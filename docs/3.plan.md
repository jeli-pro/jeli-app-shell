Yo, check it. The current app shell is a tangled mess. Every page tries to manage its own view state, and switching modes is janky as hell. Fullscreen breaks stuff, side panes are inconsistent—it's just not cutting it. We're going to gut this thing and rebuild it like VS Code. Clean, consistent, and flexible.

The plan is to create a single source of truth for view management. Pages become "dumb" content blobs that get slapped into panes by a master controller. They can *suggest* how they want to be displayed, but the shell is the boss. We'll introduce a central "view registry" so the shell knows what's available to render. This decouples everything and makes the whole system predictable. Any view, any pane, any time. It'll also set us up for slick features down the road, like drag-and-drop pane management.

No more special snowflakes. Every page plays by the same rules. The result will be a buttery-smooth UX and code that's actually maintainable. Let's do this.

```yaml
plan:
  uuid: 'f4e6a8b1-2c9d-4f7a-8b3e-0a1b9c7d5e2f'
  status: 'todo'
  title: 'Refactor App Shell for Decoupled and Consistent View Management'
  introduction: |
    Alright, listen up. The current App Shell architecture is a house of cards. View management is scattered, causing inconsistent behavior across pages—fullscreen is buggy, and state transitions are unpredictable. It's time to burn it down and rebuild it right.

    This refactor will transform our shell into a robust, VS Code-style layout manager. We'll decouple the "what" (content) from the "where" (panes). We're centralizing all layout logic into a single, URL-driven source of truth, the `useAppViewManager` hook. Pages will become simple, declarative content units that can be rendered in any pane without knowing or caring about the overall layout.

    We're introducing a `ViewRegistry` to define all renderable components, making the system predictable and extensible. The goal is a rock-solid foundation that gives users a consistent, fluid experience and paves the way for future features like multi-tabs or drag-and-drop pane management. No more spaghetti code, just clean, predictable architecture.
  parts:
    - uuid: 'a1b2c3d4-e5f6-a7b8-c9d0-e1f2a3b4c5d6'
      status: 'todo'
      name: 'Part 1: The View Registry Foundation'
      reason: |
        First things first, we need a single source of truth for all the "views" our app can display. Right now, this logic is scattered across routers and hooks. We'll create a central registry to define each view and a renderer to display it. This decouples content from the layout components.
      steps:
        - uuid: 'c7d8e9f0-a1b2-c3d4-e5f6-a7b8c9d0e1f2'
          status: 'todo'
          name: '1. Create the View Registry'
          reason: |
            To consolidate all renderable page/pane components into one place. This makes the system aware of all possible content and their metadata (title, icon, etc.).
          files:
            - 'src/views/viewRegistry.ts'
            - 'src/hooks/useRightPaneContent.hook.tsx'
          operations:
            - "Create a new file `src/views/viewRegistry.ts`."
            - "Define a `ViewRegistration` type: `{ id: string, component: React.ComponentType, title: string, icon: LucideIcon, hasOwnScrolling?: boolean }`."
            - "Create a `viewRegistry` constant that maps view IDs like `'dashboard'`, `'settings'`, `'dataDemoItemDetail'` to their registration objects."
            - "Migrate the logic from `useRightPaneContent.hook.tsx` and the router in `App.tsx` into this registry. This includes pages like `DashboardContent`, `SettingsPage`, `DataDetailContent`, etc."
        - uuid: 'd8e9f0a1-b2c3-d4e5-f6a7-b8c9d0e1f2a3'
          status: 'todo'
          name: '2. Create a Generic ViewRenderer Component'
          reason: |
            To have a single, unified way of rendering a view based on its ID. This prevents layout components like `RightPane` from needing to know about specific page components.
          files:
            - 'src/components/layout/ViewRenderer.tsx'
            - 'src/views/viewRegistry.ts'
          operations:
            - "Create a new file `src/components/layout/ViewRenderer.tsx`."
            - "The component will accept a `viewId` prop of type string."
            - "It will import the `viewRegistry`, look up the `viewId`, and render the corresponding component."
            - "It should handle cases where the view ID is not found, rendering a fallback UI."
            - "If a view has `hasOwnScrolling: true`, the renderer should render the component directly; otherwise, it should wrap it in a scrolling div."
        - uuid: 'e9f0a1b2-c3d4-e5f6-a7b8-c9d0e1f2a3b4'
          status: 'todo'
          name: '3. Refactor RightPane and MainContent'
          reason: |
            To make our layout panes "dumb" containers that just render whatever view they're told to. This completes the decoupling of layout from content.
          files:
            - 'src/components/layout/RightPane.tsx'
            - 'src/components/layout/MainContent.tsx'
            - 'src/App.tsx'
            - 'src/hooks/useRightPaneContent.hook.tsx'
          operations:
            - "In `RightPane.tsx`, remove the `useRightPaneContent` hook. It will now receive a `viewId: string | null` prop."
            - "If `viewId` exists, use the new `ViewRenderer` component to render the content."
            - "The header in `RightPane` (icon and title) will now get its data from the `viewRegistry` based on the `viewId`."
            - "In `App.tsx`, modify `ComposedApp` to determine the `mainViewId` from the router path and pass it to `MainContent`. The `<Outlet />` will be removed from `MainContent`."
            - "`MainContent.tsx` will be refactored to accept a `viewId` and use `ViewRenderer` to display the content, just like `RightPane`."
            - "Delete the now-obsolete `useRightPaneContent.hook.tsx` file."
      context_files:
        compact:
          - 'src/components/layout/RightPane.tsx'
          - 'src/App.tsx'
          - 'src/hooks/useRightPaneContent.hook.tsx'
          - 'src/views/viewRegistry.ts'
        medium:
          - 'src/components/layout/RightPane.tsx'
          - 'src/components/layout/MainContent.tsx'
          - 'src/App.tsx'
          - 'src/hooks/useRightPaneContent.hook.tsx'
          - 'src/views/viewRegistry.ts'
        extended:
          - 'src/components/layout/RightPane.tsx'
          - 'src/components/layout/MainContent.tsx'
          - 'src/components/layout/AppShell.tsx'
          - 'src/App.tsx'
          - 'src/hooks/useRightPaneContent.hook.tsx'
          - 'src/views/viewRegistry.ts'

    - uuid: 'b2c3d4e5-f6a7-b8c9-d0e1-f2a3b4c5d6e7'
      status: 'todo'
      name: 'Part 2: Centralize and Simplify State Management'
      reason: |
        The current `useAppViewManager` is doing too much, mixing layout concerns with page-specific state. We'll gut it, refocusing it entirely on layout management driven by the URL. Page-specific state will be moved into its own dedicated hooks.
      steps:
        - uuid: 'f0a1b2c3-d4e5-f6a7-b8c9-d0e1f2a3b4c5'
          status: 'todo'
          name: '1. Isolate Page-Specific URL State'
          reason: |
            To stop the global view manager from being polluted with details about one specific page (`DataDemo`). This follows the single responsibility principle.
          files:
            - 'src/hooks/useAppViewManager.hook.ts'
            - 'src/pages/DataDemo/hooks/useDataDemoParams.hook.ts'
            - 'src/pages/DataDemo/index.tsx'
          operations:
            - "Create a new hook `src/pages/DataDemo/hooks/useDataDemoParams.hook.ts`."
            - "Move all DataDemo-specific URL param logic (filters, sort, groupBy, page, calendar props, etc.) from `useAppViewManager` into this new hook."
            - "Refactor `DataDemoPage/index.tsx` to use `useDataDemoParams.hook.ts` instead of `useAppViewManager` for its state."
        - uuid: '0a1b2c3d-4e5f-6a7b-8c9d-0e1f2a3b4c5d'
          status: 'todo'
          name: '2. Refactor useAppViewManager as the Layout Controller'
          reason: |
            To create a clean, powerful API for controlling the application layout. This hook will be the single source of truth for "what goes where".
          files:
            - 'src/hooks/useAppViewManager.hook.ts'
            - 'src/store/appShell.store.ts'
            - 'src/lib/utils.ts'
          operations:
            - "Gut `useAppViewManager.hook.ts`, removing all the logic we just extracted."
            - "The hook will now read the main path (`/dashboard`), `right` param, and `view` param from the URL."
            - "It will expose a clean state object: `{ mainViewId, rightViewId, bodyState, fullscreenTarget }`."
            - "It will provide clear action functions: `navigateTo(viewId)`, `openInRightPane(viewId)`, `openInSplitView(viewId)`, `closeRightPane()`, `swapPanes()`, `toggleFullscreen(pane)`."
            - "Update `appShell.store.ts` to reflect this new state, replacing `sidePaneContent` with `rightViewId: string | null` and `bodyState` with more explicit values."
            - "In `src/lib/utils.ts`, rename `BODY_STATES` for clarity, e.g., `SIDE_PANE` becomes `RIGHT_PANE_OVERLAY` and `SPLIT_VIEW` becomes `RIGHT_PANE_SPLIT`."
        - uuid: 'a1b2c3d4-e5f6-a7b8-c9d0-e1f2a3b4c5d7'
          status: 'todo'
          name: '3. Enhance usePageViewConfig Hook'
          reason: |
            To allow pages to declaratively suggest their preferred initial layout, such as default pane widths or opening in a split view, without dictating it.
          files:
            - 'src/hooks/usePageViewConfig.hook.ts'
            - 'src/pages/Messaging/index.tsx'
          operations:
            - "Update `usePageViewConfig.hook.ts` to accept an optional `defaultState: 'split' | 'overlay'`."
            - "`useAppViewManager` will read this config on initial page load and apply it *only if* no layout state is already present in the URL."
            - "Refactor `MessagingPage/index.tsx` to use this new hook to declare its preference for a split view, removing its custom resizable pane logic which should be handled by the shell."
      context_files:
        compact:
          - 'src/hooks/useAppViewManager.hook.ts'
          - 'src/pages/DataDemo/index.tsx'
          - 'src/store/appShell.store.ts'
          - 'src/lib/utils.ts'
        medium:
          - 'src/hooks/useAppViewManager.hook.ts'
          - 'src/pages/DataDemo/index.tsx'
          - 'src/pages/DataDemo/hooks/useDataDemoParams.hook.ts'
          - 'src/store/appShell.store.ts'
          - 'src/lib/utils.ts'
          - 'src/hooks/usePageViewConfig.hook.ts'
        extended:
          - 'src/hooks/useAppViewManager.hook.ts'
          - 'src/pages/DataDemo/index.tsx'
          - 'src/pages/DataDemo/hooks/useDataDemoParams.hook.ts'
          - 'src/store/appShell.store.ts'
          - 'src/lib/utils.ts'
          - 'src/hooks/usePageViewConfig.hook.ts'
          - 'src/App.tsx'
          - 'src/components/layout/AppShell.tsx'

    - uuid: 'c3d4e5f6-a7b8-c9d0-e1f2-a3b4c5d6e7f8'
      status: 'todo'
      name: 'Part 3: Re-wire the Application and UI Components'
      reason: |
        With the new foundation and state manager in place, we need to connect everything. This involves updating the main App component, pages, and UI controls like the `ViewModeSwitcher` to use the new, simplified, and powerful system.
      steps:
        - uuid: 'b4c5d6e7-f8a9-b0c1-d2e3-f4a5b6c7d8e9'
          status: 'todo'
          name: '1. Re-wire App.tsx and AppShell.tsx'
          reason: |
            To make the main application entrypoint drive the layout using the new view manager, passing view IDs to the shell components instead of entire components.
          files:
            - 'src/App.tsx'
            - 'src/components/layout/AppShell.tsx'
            - 'src/hooks/useAppViewManager.hook.ts'
          operations:
            - "In `App.tsx`, the `ComposedApp` component will now be the master controller."
            - "It will call `useAppViewManager` to get the current layout state (`mainViewId`, `rightViewId`, `bodyState`)."
            - "It will pass `mainViewId` and `rightViewId` as props down into `AppShell` and subsequently to `MainContent` and `RightPane`."
            - "The `react-router-dom` `<Outlet/>` will be removed from `MainContent`. The router's sole job for content is to inform `useAppViewManager` of the base path, which determines the `mainViewId`."
        - uuid: 'd6e7f8a9-b0c1-d2e3-f4a5-b6c7d8e9f0a1'
          status: 'todo'
          name: '2. Update UI Controls for New Actions'
          reason: |
            Components that change the view state need to be updated to use the new, clean actions from `useAppViewManager`.
          files:
            - 'src/components/layout/ViewModeSwitcher.tsx'
            - 'src/components/layout/EnhancedSidebar.tsx'
            - 'src/components/global/CommandPalette.tsx'
          operations:
            - "In `ViewModeSwitcher.tsx`, gut the complex state logic. Each button will now make a simple call to the new `useAppViewManager` actions like `toggleFullscreen('main')`, `openInRightPane(currentPage)`, `openInSplitView()`, etc."
            - "In `EnhancedSidebar.tsx`, update the `AppMenuItem` click handlers to use `viewManager.navigateTo(page)` or `viewManager.openInRightPane(page)`."
            - "Update the drag-and-drop handlers (`onDragStart`, etc.) to store the `viewId` for dropping on a pane."
            - "Update `CommandPalette.tsx` to use the new `viewManager` actions for navigation and pane management."
        - uuid: '1b2c3d4e-5f6a-7b8c-9d0e-1f2a3b4c5d6e'
          status: 'todo'
          name: '3. Simplify Page Components'
          reason: |
            To ensure all pages are now simple content renderers, free of layout logic, and behave consistently within the new shell.
          files:
            - 'src/pages/Dashboard/index.tsx'
            - 'src/pages/Settings/index.tsx'
            - 'src/pages/Notifications/index.tsx'
            - 'src/pages/Messaging/index.tsx'
          operations:
            - "Review all page components (`DashboardContent`, `SettingsPage`, `NotificationsPage`, etc.)."
            - "Remove any remaining layout-specific logic or props. For example, `isInSidePane` checks are no longer needed as the page is agnostic to its location."
            - "Ensure pages with internal scrolling (like `MessagingPage`) correctly register `hasOwnScrolling: true` in the `viewRegistry` so the shell doesn't add a redundant scrollbar."
            - "The custom resizable pane logic in `MessagingPage` must be removed; this is now a global feature of the `RightPane` and `AppShell`."
      context_files:
        compact:
          - 'src/App.tsx'
          - 'src/components/layout/ViewModeSwitcher.tsx'
          - 'src/components/layout/EnhancedSidebar.tsx'
          - 'src/hooks/useAppViewManager.hook.ts'
        medium:
          - 'src/App.tsx'
          - 'src/components/layout/AppShell.tsx'
          - 'src/components/layout/ViewModeSwitcher.tsx'
          - 'src/components/layout/EnhancedSidebar.tsx'
          - 'src/hooks/useAppViewManager.hook.ts'
          - 'src/pages/DataDemo/index.tsx'
        extended:
          - 'src/App.tsx'
          - 'src/components/layout/AppShell.tsx'
          - 'src/components/layout/MainContent.tsx'
          - 'src/components/layout/RightPane.tsx'
          - 'src/components/layout/ViewModeSwitcher.tsx'
          - 'src/components/layout/EnhancedSidebar.tsx'
          - 'src/hooks/useAppViewManager.hook.ts'
          - 'src/pages/DataDemo/index.tsx'
          - 'src/pages/Messaging/index.tsx'
  conclusion: |
    Once this overhaul is complete, we'll have a fundamentally more robust and flexible application shell. The strict separation of concerns will make adding new pages or views trivial—just add an entry to the registry. The user experience will be vastly improved, with consistent and smooth transitions between all view states for all content.

    This new architecture kills a whole class of layout bugs and makes the codebase cleaner and easier to reason about. Most importantly, it unlocks the potential for advanced UI features like a true multi-pane, tabbed, and drag-and-drop interface, bringing our app shell to a world-class standard.
  context_files:
    compact:
      - 'src/hooks/useAppViewManager.hook.ts'
      - 'src/App.tsx'
      - 'src/components/layout/AppShell.tsx'
      - 'src/hooks/useRightPaneContent.hook.tsx'
      - 'src/pages/DataDemo/index.tsx'
    medium:
      - 'src/hooks/useAppViewManager.hook.ts'
      - 'src/App.tsx'
      - 'src/components/layout/AppShell.tsx'
      - 'src/components/layout/RightPane.tsx'
      - 'src/components/layout/MainContent.tsx'
      - 'src/components/layout/ViewModeSwitcher.tsx'
      - 'src/hooks/useRightPaneContent.hook.tsx'
      - 'src/pages/DataDemo/index.tsx'
      - 'src/store/appShell.store.ts'
    extended:
      - 'src/hooks/useAppViewManager.hook.ts'
      - 'src/App.tsx'
      - 'src/components/layout/AppShell.tsx'
      - 'src/components/layout/RightPane.tsx'
      - 'src/components/layout/MainContent.tsx'
      - 'src/components/layout/EnhancedSidebar.tsx'
      - 'src/components/layout/ViewModeSwitcher.tsx'
      - 'src/hooks/useRightPaneContent.hook.tsx'
      - 'src/hooks/usePageViewConfig.hook.ts'
      - 'src/pages/DataDemo/index.tsx'
      - 'src/pages/Messaging/index.tsx'
      - 'src/store/appShell.store.ts'
      - 'src/lib/utils.ts'

```
