uuid: d8e56149-a35c-44da-b01b-c32ab5c5fca3
projectId: jeli-app-shell
createdAt: '2025-10-12T04:37:36.365Z'
gitCommitMsg: >-
  refactor: implement immersive scrolling layout

  Refactored the AppShell layout to provide a more immersive user experience
  where content scrolls underneath the top bar.

  - Changed the TopBar to be absolutely positioned, floating it above the main
  content area. - Removed the global `padding-top` animation from the
  `MainContent` component, which was causing the content to be pushed down. -
  Added dynamic, page-level padding to the content of `Dashboard`, `Settings`,
  `Notifications`, and `ToasterDemo` pages. This padding is applied
  conditionally based on the visibility of the top bar, ensuring content is not
  obscured.
promptSummary: >-
  The user wanted a more immersive, full-height content experience, feeling that
  a container was blocking the view near the top bar.
reasoning:
  - >-
    Based on your request for a more immersive, full-height content experience,
    I've adjusted the layout so that the page content scrolls underneath the top
    bar instead of being pushed down by it.
  - 'Here''s a breakdown of the changes:'
  - >-
    1.  **Top Bar Positioning**: I've changed the `TopBar` to be absolutely
    positioned, so it "floats" above the main content area. This allows the main
    content to occupy the full height of its container.
  - >-
    2.  **Animation Hook Update**: The animation that previously added
    `padding-top` to the entire `MainContent` component has been removed. This
    was the primary cause of the "blocked" feeling you described.
  - >-
    3.  **Page-Level Padding**: To prevent page content from being hidden behind
    the now-floating top bar, I've added dynamic padding to the scrollable area
    within each page (`Dashboard`, `Settings`, `Notifications`, `ToasterDemo`).
    This padding is smoothly applied only when the top bar is visible, ensuring
    content is always accessible while maintaining the immersive feel.
  - >-
    These changes result in a more modern, "immersive" layout where the content
    area extends to the top of the viewport, with the top bar elegantly
    overlaying it.
  - '### `src/components/layout/AppShell.tsx`'
  - >-
    I've made the top bar container `absolute` and its parent `relative` to
    allow the main content area to fill the full height of the viewport.
  - '### `src/hooks/useAppShellAnimations.hook.ts`'
  - >-
    I've removed the `paddingTop` animation from `mainContentRef`, as this is
    now handled within each page for a more fine-grained and immersive layout.
  - '### `src/pages/Dashboard/index.tsx`'
  - >-
    I've updated the Dashboard page to dynamically add padding to its content,
    ensuring it doesn't get obscured by the floating top bar.
  - '### `src/pages/Notifications/index.tsx`'
  - Similarly, I've applied the dynamic padding logic to the Notifications page.
  - '### `src/pages/Settings/index.tsx`'
  - The Settings page also receives the dynamic padding update.
  - '### `src/pages/ToasterDemo/index.tsx`'
  - Finally, the Toaster Demo page is updated with the new padding logic.
operations:
  - type: write
    path: src/components/layout/AppShell.tsx
    content: |+
      --- src/components/layout/AppShell.tsx
      +++ src/components/layout/AppShell.tsx
      @@ -213,11 +213,11 @@
               )}
       
               {/* Main area wrapper */}
      -        <div className="flex-1 flex flex-col overflow-hidden">
      +        <div className="flex-1 flex flex-col overflow-hidden relative">
                 <div
                   ref={topBarContainerRef}
      -            className="relative z-30"
      +            className="absolute top-0 left-0 right-0 z-30"
                   onMouseEnter={() => { if (isSplitView) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                 >
                   {topBarWithProps}

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useAppShellAnimations.hook.ts
    content: >+
      --- src/hooks/useAppShellAnimations.hook.ts

      +++ src/hooks/useAppShellAnimations.hook.ts

      @@ -81,12 +81,6 @@
             ease,
           });
       
      -    gsap.to(mainContentRef.current, {

      -      paddingTop: isFullscreen ? '0rem' : isTopBarVisible ? '5rem' :
      '0rem', // h-20 is 5rem

      -      duration: animationDuration,

      -      ease,

      -    });

      -
           gsap.to(topBarContainerRef.current, {
             y: (isFullscreen || !isTopBarVisible) ? '-100%' : '0%',
             duration: animationDuration,

    patchStrategy: standard-diff
  - type: write
    path: src/pages/Dashboard/index.tsx
    content: >+
      --- src/pages/Dashboard/index.tsx

      +++ src/pages/Dashboard/index.tsx

      @@ -12,6 +12,7 @@
       } from 'lucide-react'
       import { cn } from '@/lib/utils'
       import { DemoContent } from './DemoContent'
      +import { useAppShell } from '@/context/AppShellContext'
       import { useDashboardAnimations } from './hooks/useDashboardAnimations.hook'
       import { useDashboardScroll } from './hooks/useDashboardScroll.hook'
       import { PageHeader } from '@/components/shared/PageHeader';
      @@ -125,6 +126,8 @@
           const contentRef = useRef<HTMLDivElement>(null)
           const cardsRef = useRef<(HTMLDivElement | null)[]>([])
           const { showScrollToBottom, handleScroll, scrollToBottom } = useDashboardScroll(contentRef, isInSidePane);
      +    const { isTopBarVisible, bodyState } = useAppShell();

      +    const isFullscreen = bodyState === 'fullscreen';
       
           useDashboardAnimations(contentRef, cardsRef);
       
      @@ -151,9 +154,13 @@
                 className={cn("h-full overflow-y-auto")}
                 onScroll={handleScroll}
               >
      -          <div className={cn("space-y-8", !isInSidePane ? "p-6 lg:px-12"
      : "p-6")}>

      +          <div className={cn(

      +            "space-y-8 transition-all duration-300",

      +            !isInSidePane ? "px-6 lg:px-12 pb-6" : "px-6 pb-6",

      +            isTopBarVisible && !isFullscreen ? "pt-24" : "pt-6"

      +          )}>
                   {/* Header */}
                   {!isInSidePane && (
                     <PageHeader

    patchStrategy: standard-diff
  - type: write
    path: src/pages/Notifications/index.tsx
    content: >+
      --- src/pages/Notifications/index.tsx

      +++ src/pages/Notifications/index.tsx

      @@ -4,6 +4,7 @@
       import { Card, CardContent, CardHeader } from "@/components/ui/card";
       import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
       import { PageHeader } from "@/components/shared/PageHeader";
      +import { useAppShell } from "@/context/AppShellContext";
       import { useToast } from "@/components/ui/toast";
       import { cn } from "@/lib/utils";
       import { 
      @@ -293,6 +294,8 @@
         const [notifications, setNotifications] = React.useState<Notification[]>(initialNotifications);
         const [activeTab, setActiveTab] = React.useState<string>("all");
         const { show: showToast } = useToast();
      +  const { isTopBarVisible, bodyState } = useAppShell();

      +  const isFullscreen = bodyState === 'fullscreen';
       
         const handleMarkAsRead = (id: number) => {
           setNotifications(prev =>
      @@ -377,8 +380,12 @@
       
         return (
           <div className={cn("overflow-y-auto h-full")}>
      -      <div className={cn("space-y-8", !isInSidePane ? "p-6 lg:px-12" :
      "p-6")}>

      +      <div className={cn(

      +        "space-y-8 transition-all duration-300", 

      +        !isInSidePane ? "px-6 lg:px-12 pb-6" : "px-6 pb-6",

      +        isTopBarVisible && !isFullscreen ? "pt-24" : "pt-6"

      +        )}>
               {!isInSidePane && (
                 <PageHeader
                   title="Notifications"

    patchStrategy: standard-diff
  - type: write
    path: src/pages/Settings/index.tsx
    content: |+
      --- src/pages/Settings/index.tsx
      +++ src/pages/Settings/index.tsx
      @@ -1,15 +1,22 @@
       import { SettingsContent } from '@/features/settings/SettingsContent';
       import { useAutoAnimateTopBar } from '@/hooks/useAutoAnimateTopBar';
       import { PageHeader } from '@/components/shared/PageHeader';
      +import { useAppShell } from '@/context/AppShellContext';
      +import { cn } from '@/lib/utils';
       
       export function SettingsPage() {
         const { onScroll } = useAutoAnimateTopBar();
      +  const { isTopBarVisible, bodyState } = useAppShell();
      +  const isFullscreen = bodyState === 'fullscreen';
       
         return (
           <div
             className="h-full overflow-y-auto"
             onScroll={onScroll}
           >
      -      <div className="p-6 lg:px-12 space-y-8">
      +      <div className={cn(
      +        "px-6 lg:px-12 pb-6 space-y-8 transition-all duration-300",
      +        isTopBarVisible && !isFullscreen ? "pt-24" : "pt-6"
      +        )}>
               {/* Header */}
               <PageHeader
                 title="Settings"

    patchStrategy: standard-diff
  - type: write
    path: src/pages/ToasterDemo/index.tsx
    content: >+
      --- src/pages/ToasterDemo/index.tsx

      +++ src/pages/ToasterDemo/index.tsx

      @@ -1,5 +1,6 @@
       import { Button } from '@/components/ui/button';
       import { useToast } from '@/components/ui/toast';
      +import { useAppShell } from '@/context/AppShellContext';
       import { PageHeader } from '@/components/shared/PageHeader';
       import { cn } from '@/lib/utils';
       
      @@ -32,6 +33,8 @@
       
       export function ToasterDemo({ isInSidePane = false }: { isInSidePane?: boolean }) {
         const toast = useToast();
      +  const { isTopBarVisible, bodyState } = useAppShell();

      +  const isFullscreen = bodyState === 'fullscreen';
       
         const showToast = (variant: Variant, position: Position = 'bottom-right') => {
           toast.show({
      @@ -82,8 +85,12 @@
       
         return (
           <div className={cn("overflow-y-auto h-full")}>
      -      <div className={cn("space-y-8", !isInSidePane ? "p-6 lg:px-12" :
      "p-6")}>

      +      <div className={cn(

      +        "space-y-8 transition-all duration-300",

      +        !isInSidePane ? "px-6 lg:px-12 pb-6" : "px-6 pb-6",

      +        isTopBarVisible && !isFullscreen ? "pt-24" : "pt-6"

      +      )}>
               {/* Header */}
               {!isInSidePane && (
                 <PageHeader

    patchStrategy: standard-diff
snapshot:
  src/components/layout/AppShell.tsx: >-
    import React, { useRef, type ReactElement, useCallback, useEffect,
    useLayoutEffect } from 'react'

    import { cn } from '@/lib/utils'

    import { gsap } from 'gsap';

    import { CommandPalette } from '@/components/global/CommandPalette';

    import { useAppStore } from '@/store/appStore';

    import { useAppShell } from '@/context/AppShellContext';

    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'

    import { useResizableSidebar, useResizableRightPane } from
    '@/hooks/useResizablePanes.hook'

    import { useSidebarAnimations, useBodyStateAnimations } from
    '@/hooks/useAppShellAnimations.hook'

    import { ViewModeSwitcher } from './ViewModeSwitcher';


    interface AppShellProps {
      sidebar: ReactElement;
      topBar: ReactElement;
      mainContent: ReactElement;
      rightPane: ReactElement;
      commandPalette?: ReactElement;
    }


    const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
    'notifications'> = {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
    };


    // Helper hook to get the previous value of a prop or state

    function usePrevious<T>(value: T): T | undefined {
      const ref = useRef<T>();
      useEffect(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }



    export function AppShell({ sidebar, topBar, mainContent, rightPane,
    commandPalette }: AppShellProps) {
      const {
        sidebarState,
        dispatch,
        autoExpandSidebar,
        toggleSidebar,
        hoveredPane,
        peekSidebar,
        draggedPage,
        dragHoverTarget,
        toggleSplitView,    bodyState,
        sidePaneContent,
        closeSidePane,
        reducedMotion,
      } = useAppShell();
      
      const { isDarkMode, toggleDarkMode, handleNavigation, activePage } = useAppStore();
      const appRef = useRef<HTMLDivElement>(null)
      const sidebarRef = useRef<HTMLDivElement>(null)
      const mainContentRef = useRef<HTMLDivElement>(null)
      const rightPaneRef = useRef<HTMLDivElement>(null)
      const resizeHandleRef = useRef<HTMLDivElement>(null)
      const topBarContainerRef = useRef<HTMLDivElement>(null)
      const mainAreaRef = useRef<HTMLDivElement>(null)

      const prevActivePage = usePrevious(activePage);
      const prevSidePaneContent = usePrevious(sidePaneContent);

      const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;

      // Custom hooks for logic
      useResizableSidebar(sidebarRef, resizeHandleRef);
      useResizableRightPane();
      useSidebarAnimations(sidebarRef, resizeHandleRef);
      useBodyStateAnimations(appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef);
      
      // Animation for pane swapping
      useLayoutEffect(() => {
        if (reducedMotion || bodyState !== BODY_STATES.SPLIT_VIEW || !prevActivePage || !prevSidePaneContent) {
          return;
        }

        const pageForPrevSidePane = Object.keys(pageToPaneMap).find(
          key => pageToPaneMap[key as keyof typeof pageToPaneMap] === prevSidePaneContent
        );

        // Check if a swap occurred by comparing current state with previous state
        if (activePage === pageForPrevSidePane && sidePaneContent === pageToPaneMap[prevActivePage as keyof typeof pageToPaneMap]) {
          const mainEl = mainAreaRef.current;
          const rightEl = rightPaneRef.current;

          if (mainEl && rightEl) {
            const mainWidth = mainEl.offsetWidth;
            const rightWidth = rightEl.offsetWidth;

            const tl = gsap.timeline();
            
            // Animate main content FROM where right pane was TO its new place
            tl.from(mainEl, {
              x: rightWidth, duration: 0.4, ease: 'power3.inOut'
            });

            // Animate right pane FROM where main content was TO its new place
            tl.from(rightEl, {
              x: -mainWidth, duration: 0.4, ease: 'power3.inOut'
            }, 0); // Start at the same time
          }
        }
      }, [activePage, sidePaneContent, bodyState, prevActivePage, prevSidePaneContent, reducedMotion]);
      
      const sidebarWithProps = React.cloneElement(sidebar, { 
        ref: sidebarRef,
        onMouseEnter: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.COLLAPSED) {
            peekSidebar()
          }
        },
        onMouseLeave: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.PEEK) {
            dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
          }
        }
      });

      const topBarWithProps = React.cloneElement(topBar, {
        onToggleSidebar: toggleSidebar,
        onToggleDarkMode: toggleDarkMode,
      });

      const mainContentWithProps = React.cloneElement(mainContent, {
        ref: mainContentRef,
      });

      const rightPaneWithProps = React.cloneElement(rightPane, { ref: rightPaneRef });

      // Drag and drop handlers for docking
      const handleDragOverLeft = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'left') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'left' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropLeft = useCallback(() => {
        if (!draggedPage) return;
        
        const originalActivePage = activePage;
        const originalActivePagePaneContent = pageToPaneMap[originalActivePage];

        // If we drop the page that's already in the side pane, just make it the main view.
        const paneContentOfDraggedPage = pageToPaneMap[draggedPage];
        if (paneContentOfDraggedPage === sidePaneContent && (bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {
          closeSidePane();
          handleNavigation(draggedPage);
        } 
        // New context-aware logic: if we are in normal view and drop a NEW page on the left
        else if (bodyState === BODY_STATES.NORMAL && draggedPage !== originalActivePage) {
            if (originalActivePagePaneContent) {
                // 1. Set the right pane content to be the original page
                dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: originalActivePagePaneContent });
                // 2. Set the main page to be the new dragged page
                handleNavigation(draggedPage);
                // 3. Switch to split view
                dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
            } else {
                // Fallback for pages that can't be in a pane
                handleNavigation(draggedPage);
            }
        } else { // Default behavior: just make the dropped page the main one
          handleNavigation(draggedPage);
        }
        
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, activePage, bodyState, sidePaneContent, handleNavigation, dispatch, closeSidePane]);

      const handleDragOverRight = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'right') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'right' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropRight = useCallback(() => {
        if (!draggedPage) return;
        const pane = pageToPaneMap[draggedPage as keyof typeof pageToPaneMap];
        if (pane) {
          // If dropping the currently active page to the right,
          // set a default page (e.g., dashboard) as the new active page.
          if (draggedPage === activePage) {
            handleNavigation('dashboard');
          }

          // Set the right pane content and ensure split view
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: pane });
          if (bodyState === BODY_STATES.NORMAL) {
            toggleSplitView(pane);
          } else if (bodyState === BODY_STATES.SIDE_PANE) {
            toggleSplitView();
          }
        }
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, toggleSplitView, dispatch, bodyState, activePage, handleNavigation]);

      return (
        <div 
          ref={appRef}
          className={cn(
            "relative h-screen w-screen overflow-hidden bg-background transition-colors duration-300",
            isDarkMode && "dark"
          )}
        >
          <div className="flex h-screen overflow-hidden">
            {/* Enhanced Sidebar */}
            {sidebarWithProps}

            {/* Resize Handle */}
            {sidebarState !== SIDEBAR_STATES.HIDDEN && (
              <div
                ref={resizeHandleRef}
                className={cn(
                  "absolute top-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
                )}
                onMouseDown={(e) => {
                  e.preventDefault()
                  dispatch({ type: 'SET_IS_RESIZING', payload: true });
                }}
              >
                <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
              </div>
            )}

            {/* Main area wrapper */}
            <div className="flex-1 flex flex-col overflow-hidden">
              <div
                ref={topBarContainerRef}
                className="relative z-30"
                onMouseEnter={() => { if (isSplitView) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
              >
                {topBarWithProps}
              </div>

              <div className="flex flex-1 min-h-0">
                <div
                  ref={mainAreaRef}
                  className="relative flex-1 overflow-hidden bg-background"
                  onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'left' }); }}
                  onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                >
                  {/* Left drop overlay */}
                  <div
                    className={cn(
                      "absolute inset-y-0 left-0 z-40 border-2 border-transparent transition-all",
                      draggedPage
                        ? cn("pointer-events-auto", isSplitView ? 'w-full' : 'w-1/2')
                        : "pointer-events-none w-0",
                      dragHoverTarget === 'left' && "bg-primary/10 border-primary"
                    )}
                    onDragOver={handleDragOverLeft}
                    onDrop={handleDropLeft}
                    onDragLeave={() => {
                      if (dragHoverTarget === 'left') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                    }}
                  >
                    {draggedPage && dragHoverTarget === 'left' && (
                      <div className="absolute inset-0 flex items-center justify-center text-sm font-medium text-primary-foreground/80 pointer-events-none">
                        <span className="px-3 py-1 rounded-md bg-primary/70">{isSplitView ? 'Drop to Replace' : 'Drop to Left'}</span>
                      </div>
                    )}
                  </div>
                  {mainContentWithProps}
                  {isSplitView && hoveredPane === 'left' && !draggedPage && (
                    <div className="absolute top-4 right-4 z-50">
                      <ViewModeSwitcher pane="main" />
                    </div>
                  )}
                  {/* Right drop overlay (over main area, ONLY when NOT in split view) */}
                  {!isSplitView && (
                    <div
                      className={cn(
                        "absolute inset-y-0 right-0 z-40 border-2 border-transparent",
                        draggedPage ? "pointer-events-auto w-1/2" : "pointer-events-none",
                        dragHoverTarget === 'right' && "bg-primary/10 border-primary"
                      )}
                      onDragOver={handleDragOverRight}
                      onDrop={handleDropRight}
                      onDragLeave={() => {
                        if (dragHoverTarget === 'right') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                      }}
                    >
                      {draggedPage && dragHoverTarget === 'right' && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                          <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">Drop to Right</span>
                        </div>
                      )}
                    </div>
                  )}
                </div>
                {isSplitView ? (
                  <div
                    className="relative"
                    onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'right' }); }}
                    onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                    onDragOver={handleDragOverRight}
                  >
                    {rightPaneWithProps}
                    {draggedPage && (
                      <div
                        className={cn(
                          'absolute inset-0 z-50 transition-all',
                          dragHoverTarget === 'right'
                            ? 'bg-primary/10 border-2 border-primary'
                            : 'pointer-events-none'
                        )}
                        onDragLeave={() => {
                          if (dragHoverTarget === 'right')
                            dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                        }}
                        onDrop={handleDropRight}
                        onDragOver={(e) => e.preventDefault()}
                      >
                        {dragHoverTarget === 'right' && (
                          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">
                              Drop to Replace
                            </span>
                          </div>
                        )}
                      </div>
                    )}
                    {hoveredPane === 'right' && !draggedPage && (
                      <div className="absolute top-4 right-4 z-[70]">
                        <ViewModeSwitcher pane="right" />
                      </div>
                    )}
                  </div>
                ) : rightPaneWithProps}
              </div>
            </div>
          </div>
          {commandPalette || <CommandPalette />}
        </div>
      )
    }
  src/pages/Dashboard/index.tsx: >-
    import { useRef } from 'react'

    import { 
      BarChart3, 
      TrendingUp, 
      Users, 
      DollarSign, 
      Activity,
      Calendar,
      Clock,
      MessageSquare,
      FileText,
      Star,
      ChevronRight,
      MoreVertical,
      ArrowDown
    } from 'lucide-react'

    import { cn } from '@/lib/utils'

    import { DemoContent } from './DemoContent'

    import { useDashboardAnimations } from './hooks/useDashboardAnimations.hook'

    import { useDashboardScroll } from './hooks/useDashboardScroll.hook'

    import { PageHeader } from '@/components/shared/PageHeader';

    import { Card } from '@/components/ui/card';


    interface StatsCard {
      title: string
      value: string
      change: string
      trend: 'up' | 'down'
      icon: React.ReactNode
    }


    interface ActivityItem {
      id: string
      type: 'comment' | 'file' | 'meeting' | 'task'
      title: string
      description: string
      time: string
      user: string
    }


    const statsCards: StatsCard[] = [
      {
        title: "Total Revenue",
        value: "$45,231.89",
        change: "+20.1%",
        trend: "up",
        icon: <DollarSign className="w-5 h-5" />
      },
      {
        title: "Active Users",
        value: "2,350",
        change: "+180.1%",
        trend: "up",
        icon: <Users className="w-5 h-5" />
      },
      {
        title: "Conversion Rate",
        value: "12.5%",
        change: "+19%",
        trend: "up",
        icon: <TrendingUp className="w-5 h-5" />
      },
      {
        title: "Performance",
        value: "573ms",
        change: "-5.3%",
        trend: "down",
        icon: <Activity className="w-5 h-5" />
      }
    ]


    const recentActivity: ActivityItem[] = [
      {
        id: "1",
        type: "comment",
        title: "New comment on Project Alpha",
        description: "Sarah Johnson added a comment to the design review",
        time: "2 minutes ago",
        user: "SJ"
      },
      {
        id: "2",
        type: "file",
        title: "Document uploaded",
        description: "quarterly-report.pdf was uploaded to Documents",
        time: "15 minutes ago",
        user: "MD"
      },
      {
        id: "3",
        type: "meeting",
        title: "Meeting scheduled",
        description: "Weekly standup meeting scheduled for tomorrow 9 AM",
        time: "1 hour ago",
        user: "RW"
      },
      {
        id: "4",
        type: "task",
        title: "Task completed",
        description: "UI wireframes for mobile app completed",
        time: "2 hours ago",
        user: "AL"
      }
    ]


    interface DashboardContentProps {
      isInSidePane?: boolean;
    }


    export function DashboardContent({ isInSidePane = false }:
    DashboardContentProps) {
        const contentRef = useRef<HTMLDivElement>(null)
        const cardsRef = useRef<(HTMLDivElement | null)[]>([])
        const { showScrollToBottom, handleScroll, scrollToBottom } = useDashboardScroll(contentRef, isInSidePane);

        useDashboardAnimations(contentRef, cardsRef);

        const getTypeIcon = (type: ActivityItem['type']) => {
          switch (type) {
            case 'comment':
              return <MessageSquare className="w-4 h-4" />
            case 'file':
              return <FileText className="w-4 h-4" />
            case 'meeting':
              return <Calendar className="w-4 h-4" />
            case 'task':
              return <Star className="w-4 h-4" />
            default:
              return <Activity className="w-4 h-4" />
          }
        }

        return (
            <div 
              ref={contentRef}
              className={cn("h-full overflow-y-auto")}
              onScroll={handleScroll}
            >
              <div className={cn("space-y-8", !isInSidePane ? "p-6 lg:px-12" : "p-6")}>
                {/* Header */}
                {!isInSidePane && (
                  <PageHeader
                    title="Dashboard"
                    description="Welcome to the Jeli App Shell demo! Explore all the features and customization options."
                  />
                )}
                  {/* Stats Cards */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                  {statsCards.map((stat, index) => (
                    <Card
                    key={stat.title}
                    ref={el => cardsRef.current[index] = el}
                    className="p-6 border-border/50 hover:border-primary/30 transition-all duration-300 group cursor-pointer"
                  >
                    <div className="flex items-center justify-between">
                      <div className="p-3 bg-primary/10 rounded-full group-hover:bg-primary/20 transition-colors">
                        {stat.icon}
                      </div>
                      <div className={cn(
                        "text-sm font-medium",
                        stat.trend === 'up' ? "text-green-600" : "text-red-600"
                      )}>
                        {stat.change}
                      </div>
                    </div>
                    <div className="mt-4">
                      <h3 className="text-2xl font-bold">{stat.value}</h3>
                      <p className="text-sm text-muted-foreground mt-1">{stat.title}</p>
                    </div>
                  </Card>
                  ))}
                </div>

                {/* Demo Content */}
                <DemoContent />

                {/* Main Content Grid */}
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                {/* Chart Area */}
                <div className="lg:col-span-2 space-y-6">
                  {/* Analytics Chart */}
                  <Card className="p-6 border-border/50">
                    <div className="flex items-center justify-between mb-6">
                      <h3 className="text-lg font-semibold">Analytics Overview</h3>
                      <button className="h-8 w-8 flex items-center justify-center hover:bg-accent rounded-full transition-colors">
                        <MoreVertical className="w-5 h-5" />
                      </button>
                    </div>
                    
                    {/* Mock Chart */}
                    <div className="h-64 bg-gradient-to-br from-primary/10 to-transparent rounded-xl flex items-center justify-center border border-border/50">
                      <div className="text-center">
                        <BarChart3 className="w-12 h-12 text-primary mx-auto mb-2" />
                        <p className="text-muted-foreground">Chart visualization would go here</p>
                      </div>
                    </div>
                  </Card>

                  {/* Recent Projects */}
                  <Card className="p-6 border-border/50">
                    <div className="flex items-center justify-between mb-6">
                      <h3 className="text-lg font-semibold">Recent Projects</h3>
                      <button className="text-primary hover:text-primary/80 text-sm font-medium flex items-center gap-1">
                        View All
                        <ChevronRight className="w-4 h-4" />
                      </button>
                    </div>
                    
                    <div className="space-y-4">
                      {[
                        { name: "E-commerce Platform", progress: 75, team: 5, deadline: "Dec 15" },
                        { name: "Mobile App Redesign", progress: 45, team: 3, deadline: "Jan 20" },
                        { name: "Marketing Website", progress: 90, team: 4, deadline: "Dec 5" }
                      ].map((project) => (
                        <div key={project.name} className="p-4 bg-accent/30 rounded-xl hover:bg-accent/50 transition-colors cursor-pointer">
                          <div className="flex items-center justify-between mb-2">
                            <h4 className="font-medium">{project.name}</h4>
                            <span className="text-sm text-muted-foreground">{project.progress}%</span>
                          </div>
                          <div className="w-full bg-muted rounded-full h-2 mb-3">
                            <div 
                              className="bg-primary h-2 rounded-full transition-all duration-500"
                              style={{ width: `${project.progress}%` }}
                            />
                          </div>
                          <div className="flex items-center justify-between text-sm text-muted-foreground">
                            <span>{project.team} team members</span>
                            <span>Due {project.deadline}</span>
                          </div>
                        </div>
                      ))}
                    </div>
                  </Card>
                </div>

                {/* Sidebar Content */}
                <div className="space-y-6">
                  {/* Quick Actions */}
                  <Card className="p-6 border-border/50">
                    <h3 className="text-lg font-semibold mb-4">Quick Actions</h3>
                    <div className="space-y-3">
                      {[
                        { icon: <FileText className="w-4 h-4" />, label: "Create Document", color: "bg-blue-500/10 text-blue-600" },
                        { icon: <Calendar className="w-4 h-4" />, label: "Schedule Meeting", color: "bg-green-500/10 text-green-600" },
                        { icon: <Users className="w-4 h-4" />, label: "Invite Team", color: "bg-purple-500/10 text-purple-600" },
                        { icon: <BarChart3 className="w-4 h-4" />, label: "View Reports", color: "bg-orange-500/10 text-orange-600" }
                      ].map((action) => (
                        <button
                          key={action.label}
                          className="w-full flex items-center gap-3 p-3 hover:bg-accent rounded-lg transition-colors text-left"
                        >
                          <div className={cn("p-2 rounded-full", action.color)}>
                            {action.icon}
                          </div>
                          <span className="font-medium">{action.label}</span>
                        </button>
                      ))}
                    </div>
                  </Card>

                  {/* Recent Activity */}
                  <Card className="p-6 border-border/50">
                    <h3 className="text-lg font-semibold mb-4">Recent Activity</h3>
                    <div className="space-y-4">
                      {recentActivity.map((activity) => (
                        <div key={activity.id} className="flex items-start gap-3 p-3 hover:bg-accent/30 rounded-xl transition-colors cursor-pointer">
                          <div className="p-2 bg-primary/10 rounded-full flex-shrink-0">
                            {getTypeIcon(activity.type)}
                          </div>
                          <div className="flex-1 min-w-0">
                            <h4 className="font-medium text-sm mb-1">{activity.title}</h4>
                            <p className="text-xs text-muted-foreground mb-2">{activity.description}</p>
                            <div className="flex items-center gap-2 text-xs text-muted-foreground">
                              <Clock className="w-3 h-3" />
                              <span>{activity.time}</span>
                              <div className="w-5 h-5 bg-primary rounded-full flex items-center justify-center text-primary-foreground text-xs font-medium">
                                {activity.user}
                              </div>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </Card>
                </div>
              </div>
              </div>
              {showScrollToBottom && (
                <button
                  onClick={scrollToBottom}
                  className="fixed bottom-8 right-8 w-12 h-12 bg-primary text-primary-foreground rounded-full flex items-center justify-center shadow-lg hover:bg-primary/90 transition-all animate-fade-in z-[51]"
                  style={{ animation: 'bounce 2s infinite' }}
                  title="Scroll to bottom"
                >
                  <ArrowDown className="w-6 h-6" />
                </button>
              )}
          </div>
        )
    }
  src/hooks/useAppShellAnimations.hook.ts: |-
    import { useEffect } from 'react';
    import { gsap } from 'gsap';
    import { useAppShell } from '@/context/AppShellContext';
    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils';

    export function useSidebarAnimations(
      sidebarRef: React.RefObject<HTMLDivElement>,
      resizeHandleRef: React.RefObject<HTMLDivElement>
    ) {
      const { sidebarState, sidebarWidth, bodyState, reducedMotion } = useAppShell();
      const animationDuration = reducedMotion ? 0.1 : 0.4;

      useEffect(() => {
        if (!sidebarRef.current || !resizeHandleRef.current) return;

        const sidebar = sidebarRef.current;
        const handle = resizeHandleRef.current;
        
        let targetWidth = 0;
        let targetOpacity = 1;

        if (bodyState === BODY_STATES.FULLSCREEN) {
          targetWidth = 0;
          targetOpacity = 0;
        } else {
          switch (sidebarState) {
            case SIDEBAR_STATES.HIDDEN:
              targetWidth = 0;
              targetOpacity = 0;
              break;
            case SIDEBAR_STATES.COLLAPSED:
              targetWidth = 64;
              targetOpacity = 1;
              break;
            case SIDEBAR_STATES.EXPANDED:
              targetWidth = sidebarWidth;
              targetOpacity = 1;
              break;
            case SIDEBAR_STATES.PEEK:
              targetWidth = sidebarWidth * 0.8;
              targetOpacity = 0.95;
              break;
          }
        }

        const tl = gsap.timeline({ ease: "power3.out" });
        
        tl.to(sidebar, {
          width: targetWidth,
          opacity: targetOpacity,
          duration: animationDuration,
        });
        tl.to(handle, {
          left: targetWidth,
          duration: animationDuration,
        }, 0);

      }, [sidebarState, sidebarWidth, bodyState, animationDuration, sidebarRef, resizeHandleRef]);
    }

    export function useBodyStateAnimations(
      appRef: React.RefObject<HTMLDivElement>,
      mainContentRef: React.RefObject<HTMLDivElement>,
      rightPaneRef: React.RefObject<HTMLDivElement>,
      topBarContainerRef: React.RefObject<HTMLDivElement>,
      mainAreaRef: React.RefObject<HTMLDivElement>
    ) {
      const { bodyState, reducedMotion, rightPaneWidth, isTopBarVisible, closeSidePane, fullscreenTarget } = useAppShell();
      const animationDuration = reducedMotion ? 0.1 : 0.4;

      useEffect(() => {
        if (!mainContentRef.current || !rightPaneRef.current || !topBarContainerRef.current || !mainAreaRef.current) return;

        const ease = "power3.out";
        const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
        const isSidePane = bodyState === BODY_STATES.SIDE_PANE;
        const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;

        // Right pane animation
        gsap.to(rightPaneRef.current, {
          width: isFullscreen 
            ? (fullscreenTarget === 'right' ? '100%' : 0) 
            : (isSidePane || isSplitView ? rightPaneWidth : 0),
          x: (isSidePane || isSplitView || (isFullscreen && fullscreenTarget === 'right')) ? 0 : rightPaneWidth + 5, // +5 to hide border
          duration: animationDuration,
          ease,
        });

        gsap.to(mainContentRef.current, {
          paddingTop: isFullscreen ? '0rem' : isTopBarVisible ? '5rem' : '0rem', // h-20 is 5rem
          duration: animationDuration,
          ease,
        });

        gsap.to(topBarContainerRef.current, {
          y: (isFullscreen || !isTopBarVisible) ? '-100%' : '0%',
          duration: animationDuration,
          ease,
        });
        
        // Add backdrop for side pane
        const backdrop = document.querySelector('.app-backdrop');
        if (isSidePane) { // This is correct because isSidePane is false when bodyState is split_view
          if (!backdrop) {
            const el = document.createElement('div');
            el.className = 'app-backdrop fixed inset-0 bg-black/30 z-[55]';
            appRef.current?.appendChild(el);
            gsap.fromTo(el, { opacity: 0 }, { opacity: 1, duration: animationDuration });
            el.onclick = () => closeSidePane();
          }
        } else {
          if (backdrop) {
            gsap.to(backdrop, { opacity: 0, duration: animationDuration, onComplete: () => backdrop.remove() });
          }
        }
      }, [bodyState, animationDuration, rightPaneWidth, closeSidePane, isTopBarVisible, appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef, fullscreenTarget]);
    }
  src/pages/Notifications/index.tsx: >-
    import React from "react";

    import { Avatar, AvatarFallback, AvatarImage } from
    "@/components/ui/avatar";

    import { Badge } from "@/components/ui/badge";

    import { Button } from "@/components/ui/button";

    import { Card, CardContent, CardHeader } from "@/components/ui/card";

    import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";

    import { PageHeader } from "@/components/shared/PageHeader";

    import { useToast } from "@/components/ui/toast";

    import { cn } from "@/lib/utils";

    import { 
      CheckCheck, 
      Download, 
      Settings, 
      Bell,
      MessageSquare,
      UserPlus,
      Mail,
      File as FileIcon,
      Heart,
      AtSign,
      ClipboardCheck,
      ShieldCheck,
    } from "lucide-react";



    type Notification = {
      id: number;
      type: string;
      user: {
        name: string;
        avatar: string;
        fallback: string;
      };
      action: string;
      target?: string;
      content?: string;
      timestamp: string;
      timeAgo: string;
      isRead: boolean;
      hasActions?: boolean;
      file?: {
        name: string;
        size: string;
        type: string;
      };
    };


    const initialNotifications: Array<Notification> = [
      {
        id: 1,
        type: "comment",
        user: { name: "Amélie", avatar: "https://api.dicebear.com/7.x/notionists/svg?seed=Amélie", fallback: "A" },
        action: "commented in",
        target: "Dashboard 2.0",
        content: "Really love this approach. I think this is the best solution for the document sync UX issue.",
        timestamp: "Friday 3:12 PM",
        timeAgo: "2 hours ago",
        isRead: false,
      },
      {
        id: 2,
        type: "follow",
        user: { name: "Sienna", avatar: "https://api.dicebear.com/7.x/notionists/svg?seed=Sienna", fallback: "S" },
        action: "followed you",
        timestamp: "Friday 3:04 PM",
        timeAgo: "2 hours ago",
        isRead: false,
      },
      {
        id: 3,
        type: "invitation",
        user: { name: "Ammar", avatar: "https://api.dicebear.com/7.x/notionists/svg?seed=Ammar", fallback: "A" },
        action: "invited you to",
        target: "Blog design",
        timestamp: "Friday 2:22 PM",
        timeAgo: "3 hours ago",
        isRead: true,
        hasActions: true,
      },
      {
        id: 4,
        type: "file_share",
        user: { name: "Mathilde", avatar: "https://api.dicebear.com/7.x/notionists/svg?seed=Mathilde", fallback: "M" },
        action: "shared a file in",
        target: "Dashboard 2.0",
        file: { name: "Prototype recording 01.mp4", size: "14 MB", type: "MP4" },
        timestamp: "Friday 1:40 PM",
        timeAgo: "4 hours ago",
        isRead: true,
      },
      {
        id: 5,
        type: "mention",
        user: { name: "James", avatar: "https://api.dicebear.com/7.x/notionists/svg?seed=James", fallback: "J" },
        action: "mentioned you in",
        target: "Project Alpha",
        content: "Hey @you, can you review the latest designs when you get a chance?",
        timestamp: "Thursday 11:30 AM",
        timeAgo: "1 day ago",
        isRead: true,
      },
      {
        id: 6,
        type: "like",
        user: { name: "Sofia", avatar: "https://api.dicebear.com/7.x/notionists/svg?seed=Sofia", fallback: "S" },
        action: "liked your comment in",
        target: "Team Meeting Notes",
        timestamp: "Thursday 9:15 AM",
        timeAgo: "1 day ago",
        isRead: true,
      },
      {
        id: 7,
        type: "task_assignment",
        user: { name: "Admin", avatar: "https://api.dicebear.com/7.x/bottts/svg?seed=Admin", fallback: "AD" },
        action: "assigned you a new task in",
        target: "Q3 Marketing",
        content: "Finalize the social media campaign assets.",
        timestamp: "Wednesday 5:00 PM",
        timeAgo: "2 days ago",
        isRead: true,
      },
      {
        id: 8,
        type: "system_update",
        user: { name: "System", avatar: "https://api.dicebear.com/7.x/shapes/svg?seed=System", fallback: "SYS" },
        action: "pushed a new update",
        content: "Version 2.1.0 is now live with improved performance and new features. Check out the release notes for more details.",
        timestamp: "Wednesday 9:00 AM",
        timeAgo: "2 days ago",
        isRead: true,
      },
      {
        id: 9,
        type: 'comment',
        user: { name: 'Elena', avatar: 'https://api.dicebear.com/7.x/notionists/svg?seed=Elena', fallback: 'E' },
        action: 'replied to your comment in',
        target: 'Dashboard 2.0',
        content: 'Thanks for the feedback! I\'ve updated the prototype.',
        timestamp: 'Tuesday 4:30 PM',
        timeAgo: '3 days ago',
        isRead: false,
      },
      {
        id: 10,
        type: 'invitation',
        user: { name: 'Carlos', avatar: 'https://api.dicebear.com/7.x/notionists/svg?seed=Carlos', fallback: 'C' },
        action: 'invited you to',
        target: 'API Integration',
        timestamp: 'Tuesday 10:00 AM',
        timeAgo: '3 days ago',
        isRead: true,
        hasActions: true,
      },
    ];


    const iconMap: { [key: string]: React.ElementType } = {
      comment: MessageSquare,
      follow: UserPlus,
      invitation: Mail,
      file_share: FileIcon,
      mention: AtSign,
      like: Heart,
      task_assignment: ClipboardCheck,
      system_update: ShieldCheck,
    };


    function NotificationItem({ notification, onMarkAsRead, isInSidePane }: {
    notification: Notification; onMarkAsRead: (id: number) => void;
    isInSidePane?: boolean; }) {
      const Icon = iconMap[notification.type];

      return (
        <div className={cn(
          "group w-full py-4 rounded-xl hover:bg-accent/50 transition-colors duration-200",
          isInSidePane ? "" : "-mx-4 px-4"
        )}>
          <div className="flex gap-3">
            <div className="relative h-10 w-10 shrink-0">
              <Avatar className="h-10 w-10">
                <AvatarImage src={notification.user.avatar} alt={`${notification.user.name}'s profile picture`} />
                <AvatarFallback>{notification.user.fallback}</AvatarFallback>
              </Avatar>
              {Icon && (
                <div className="absolute -bottom-1 -right-1 flex h-5 w-5 items-center justify-center rounded-full border-2 border-card bg-background">
                  <Icon className={cn("h-3 w-3", notification.type === 'like' ? 'text-red-500 fill-current' : 'text-muted-foreground')} />
                </div>
              )}
            </div>

            <div className="flex flex-1 flex-col space-y-2">
              <div className="flex items-start justify-between">
                <div className="text-sm">
                  <span className="font-semibold">{notification.user.name}</span>
                  <span className="text-muted-foreground"> {notification.action} </span>
                  {notification.target && <span className="font-semibold">{notification.target}</span>}
                  <div className="mt-0.5 text-xs text-muted-foreground">{notification.timeAgo}</div>
                </div>
                <button
                  onClick={() => !notification.isRead && onMarkAsRead(notification.id)}
                  title={notification.isRead ? "Read" : "Mark as read"}
                  className={cn("size-2.5 rounded-full mt-1 shrink-0 transition-all duration-300",
                    notification.isRead ? 'bg-transparent' : 'bg-primary hover:scale-125 cursor-pointer'
                  )}
                ></button>
              </div>

              {notification.content && <div className="rounded-lg border bg-muted/50 p-3 text-sm">{notification.content}</div>}

              {notification.file && (
                <div className="flex items-center gap-2 rounded-lg bg-muted/50 p-2 border border-border">
                  <div className="shrink-0 w-10 h-10 flex items-center justify-center bg-background rounded-md border border-border">
                    <FileIcon className="w-5 h-5 text-muted-foreground" />
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="text-sm font-medium truncate">{notification.file.name}</div>
                    <div className="text-xs text-muted-foreground">{notification.file.type} • {notification.file.size}</div>
                  </div>
                  <Button variant="ghost" size="icon" className="size-8 shrink-0">
                    <Download className="w-4 h-4" />
                  </Button>
                </div>
              )}

              {notification.hasActions && (
                <div className="flex gap-2">
                  <Button variant="outline" size="sm">Decline</Button>
                  <Button size="sm">Accept</Button>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }


    export function NotificationsPage({ isInSidePane = false }: { isInSidePane?:
    boolean }) {
      const [notifications, setNotifications] = React.useState<Notification[]>(initialNotifications);
      const [activeTab, setActiveTab] = React.useState<string>("all");
      const { show: showToast } = useToast();

      const handleMarkAsRead = (id: number) => {
        setNotifications(prev =>
          prev.map(n => (n.id === id ? { ...n, isRead: true } : n))
        );
      };

      const handleMarkAllAsRead = () => {
        const unreadCount = notifications.filter(n => !n.isRead).length;
        if (unreadCount === 0) {
          showToast({
            title: "Already up to date!",
            message: "You have no unread notifications.",
            variant: "default",
          });
          return;
        }
        setNotifications(prev => prev.map(n => ({ ...n, isRead: true })));
        showToast({
            title: "All Caught Up!",
            message: "All notifications have been marked as read.",
            variant: "success",
        });
      };

      const unreadCount = notifications.filter(n => !n.isRead).length;

      const verifiedNotifications = notifications.filter((n) => n.type === "follow" || n.type === "like");
      const mentionNotifications = notifications.filter((n) => n.type === "mention");

      const verifiedCount = verifiedNotifications.filter(n => !n.isRead).length;
      const mentionCount = mentionNotifications.filter(n => !n.isRead).length;

      const getFilteredNotifications = () => {
        switch (activeTab) {
          case "verified": return verifiedNotifications;
          case "mentions": return mentionNotifications;
          default: return notifications;
        }
      };

      const filteredNotifications = getFilteredNotifications();

      const content = (
        <Card className={cn("flex w-full flex-col shadow-none", isInSidePane ? "border-none" : "")}>
          <CardHeader className="p-0">
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-semibold">
                Your notifications
              </h3>
              <div className="flex items-center gap-1">
                <Button variant="ghost" size="icon" className="size-8" onClick={handleMarkAllAsRead} title="Mark all as read">
                  <CheckCheck className="size-4 text-muted-foreground" />
                </Button>
                <Button variant="ghost" size="icon" className="size-8">
                  <Settings className="size-4 text-muted-foreground" />
                </Button>
              </div>
            </div>

            <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full flex-col justify-start mt-4">
              <TabsList className="gap-1.5">
                <TabsTrigger value="all" className="gap-1.5">
                  View all {unreadCount > 0 && <Badge variant="secondary" className="rounded-full">{unreadCount}</Badge>}
                </TabsTrigger>
                <TabsTrigger value="verified" className="gap-1.5">
                  Verified {verifiedCount > 0 && <Badge variant="secondary" className="rounded-full">{verifiedCount}</Badge>}
                </TabsTrigger>
                <TabsTrigger value="mentions" className="gap-1.5">
                  Mentions {mentionCount > 0 && <Badge variant="secondary" className="rounded-full">{mentionCount}</Badge>}
                </TabsTrigger>
              </TabsList>
            </Tabs>
          </CardHeader>

          <CardContent className="h-full p-0 mt-6">
            <div className="space-y-0 divide-y divide-border">
              {filteredNotifications.length > 0 ? (
                filteredNotifications.map((notification) => (
                  <NotificationItem key={notification.id} notification={notification} onMarkAsRead={handleMarkAsRead} isInSidePane={isInSidePane} />
                ))
              ) : (
                <div className="flex flex-col items-center justify-center space-y-2.5 py-12 text-center">
                  <div className="rounded-full bg-muted p-4">
                    <Bell className="text-muted-foreground" />
                  </div>
                  <p className="text-sm font-medium text-muted-foreground">No notifications yet.</p>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      );

      return (
        <div className={cn("overflow-y-auto h-full")}>
          <div className={cn("space-y-8", !isInSidePane ? "p-6 lg:px-12" : "p-6")}>
            {!isInSidePane && (
              <PageHeader
                title="Notifications"
                description="Manage your notifications and stay up-to-date."
              />
            )}
            {content}
          </div>
        </div>
      );
    };
  src/pages/Settings/index.tsx: |-
    import { SettingsContent } from '@/features/settings/SettingsContent';
    import { useAutoAnimateTopBar } from '@/hooks/useAutoAnimateTopBar';
    import { PageHeader } from '@/components/shared/PageHeader';

    export function SettingsPage() {
      const { onScroll } = useAutoAnimateTopBar();

      return (
        <div
          className="h-full overflow-y-auto"
          onScroll={onScroll}
        >
          <div className="p-6 lg:px-12 space-y-8">
            {/* Header */}
            <PageHeader
              title="Settings"
              description="Customize your experience. Changes are saved automatically."
            />
            <SettingsContent />
          </div>
        </div>
      )
    }
  src/pages/ToasterDemo/index.tsx: >-
    import { Button } from '@/components/ui/button';

    import { useToast } from '@/components/ui/toast';

    import { PageHeader } from '@/components/shared/PageHeader';

    import { cn } from '@/lib/utils';


    type Variant = 'default' | 'success' | 'error' | 'warning';

    type Position =
      | 'top-left'
      | 'top-center'
      | 'top-right'
      | 'bottom-left'
      | 'bottom-center'
      | 'bottom-right';

    const variantColors = {
      default: 'border-border text-foreground hover:bg-muted/10 dark:hover:bg-muted/20',
      success: 'border-green-600 text-green-600 hover:bg-green-600/10 dark:hover:bg-green-400/20',
      error: 'border-destructive text-destructive hover:bg-destructive/10 dark:hover:bg-destructive/20',
      warning: 'border-amber-600 text-amber-600 hover:bg-amber-600/10 dark:hover:bg-amber-400/20',
    }


    const DemoSection: React.FC<{ title: string; children: React.ReactNode }> =
    ({
      title,
      children,
    }) => (
      <section>
        <h2 className="text-lg font-semibold mb-2">{title}</h2>
        {children}
      </section>
    );


    export function ToasterDemo({ isInSidePane = false }: { isInSidePane?:
    boolean }) {
      const toast = useToast();

      const showToast = (variant: Variant, position: Position = 'bottom-right') => {
        toast.show({
          title: `${variant.charAt(0).toUpperCase() + variant.slice(1)} Notification`,
          message: `This is a ${variant} toast notification.`,
          variant,
          position,
          duration: 3000,
          onDismiss: () =>
            console.log(`${variant} toast at ${position} dismissed`),
        });
      };

      const simulateApiCall = async () => {
        toast.show({
          title: 'Scheduling...',
          message: 'Please wait while we schedule your meeting.',
          variant: 'default',
          position: 'bottom-right',
        });

        try {
          await new Promise((resolve) => setTimeout(resolve, 2000));

          toast.show({
            title: 'Meeting Scheduled',
            message: 'Your meeting is scheduled for July 4, 2025, at 3:42 PM IST.',
            variant: 'success',
            position: 'bottom-right',
            highlightTitle: true,
            actions: {
              label: 'Undo',
              onClick: () => console.log('Undoing meeting schedule'),
              variant: 'outline',
            },
          });
        } catch (error) {
          toast.show({
            title: 'Error Scheduling Meeting',
            message: 'Failed to schedule the meeting. Please try again.',
            variant: 'error',
            position: 'bottom-right',
          });
        }
      };

      return (
        <div className={cn("overflow-y-auto h-full")}>
          <div className={cn("space-y-8", !isInSidePane ? "p-6 lg:px-12" : "p-6")}>
            {/* Header */}
            {!isInSidePane && (
              <PageHeader
                title="Toaster"
                description="A customizable toast component for notifications."
              />
            )}
            <div className="space-y-6">
              <DemoSection title="Toast Variants">
                <div className="flex flex-wrap gap-4">
                  {(['default', 'success', 'error', 'warning'] as Variant[]).map((variantKey) => (
                    <Button
                      key={variantKey}
                      variant="outline"
                      onClick={() => showToast(variantKey as Variant)}
                      className={cn(variantColors[variantKey])}
                    >
                      {variantKey.charAt(0).toUpperCase() + variantKey.slice(1)} Toast
                    </Button>
                  ))}
                </div>
              </DemoSection>

              <DemoSection title="Toast Positions">
                <div className="flex flex-wrap gap-4">
                  {[
                    'top-left',
                    'top-center',
                    'top-right',
                    'bottom-left',
                    'bottom-center',
                    'bottom-right',
                  ].map((positionKey) => (
                    <Button
                      key={positionKey}
                      variant="outline"
                      onClick={() =>
                        showToast('default', positionKey as Position)
                      }
                      className="border-border text-foreground hover:bg-muted/10 dark:hover:bg-muted/20"
                    >
                      {positionKey
                        .replace('-', ' ')
                        .replace(/\b\w/g, (char) => char.toUpperCase())}
                    </Button>
                  ))}
                </div>
              </DemoSection>

              <DemoSection title="Real-World Example">
                <Button
                  variant="outline"
                  onClick={simulateApiCall}
                  className="border-border text-foreground hover:bg-muted/10 dark:hover:bg-muted/20"
                >
                  Schedule Meeting
                </Button>
              </DemoSection>
            </div>
          </div>
        </div>
      );
    }
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 150
