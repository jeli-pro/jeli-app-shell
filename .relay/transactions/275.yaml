uuid: d5e01108-a579-4a0d-85a2-c7f8a9202511
projectId: jeli-app-shell
createdAt: '2025-10-14T03:05:17.418Z'
gitCommitMsg: >-
  refactor(state): unify layout state into appShell.store

  Migrates all state and logic from `AppShellContext` into a new, centralized
  Zustand store (`appShell.store.ts`). This is the first major step in making
  the codebase radically DRY.

  - Creates `appShell.store.ts` to manage all layout-related state, including
  sidebar, panes, and view modes. - Replaces `AppShellContext` with a
  lightweight `AppShellProvider` responsible only for initializing the store. -
  Refactors all components and hooks that previously consumed the context to use
  the new Zustand store directly. - Eliminates the `useAppShell` hook and
  replaces `dispatch` calls with direct action calls from the store. -
  Establishes a single source of truth for shell state, removing the need for
  prop drilling and context providers for layout logic.
promptSummary: Execute Part 1 of the refactor plan.
reasoning:
  - >-
    This is a radical refactor. I'm executing Part 1 to centralize all layout
    state from `AppShellContext` into a new global Zustand store,
    `appShell.store.ts`. This eliminates the context, kills prop drilling for
    layout state, and sets up a single source of truth for the entire
    application shell.
  - '### 1. Create `appShell.store.ts`'
  - >-
    First, I'll create a new Zustand store at `src/store/appShell.store.ts`.
    This file will contain all the state, types, and actions that were
    previously managed in `AppShellContext`. I'm using standard Zustand
    `set/get` instead of the Redux middleware for a more direct and ergonomic
    API.
  - '### 2. Replace `AppShellContext` with a new `AppShellProvider`'
  - >-
    The old context file will be repurposed. It will now only contain a simple
    provider component whose sole job is to initialize the Zustand store with
    top-level props.
  - '### 3. Rename and Relocate `AppShellProvider`'
  - >-
    To reflect its new role as a simple provider and to clean up the directory
    structure, I'm moving the file. The `context` directory will be removed
    later if it becomes empty.
  - '### 4. Update Consumers to Use `useAppShellStore`'
  - >-
    This is the most critical step. I will now refactor all components and hooks
    that previously used `useAppShell()` to connect to the new
    `useAppShellStore()` instead. This involves changing how state is selected
    and how actions are called.
  - YAML is required. I will add it now.
operations:
  - type: write
    path: src/store/appShell.store.ts
    content: >-
      import { create } from 'zustand';

      import { type ReactElement } from 'react';

      import { SIDEBAR_STATES, BODY_STATES, type SidebarState, type BodyState }
      from '@/lib/utils';


      // --- State and Action Types ---


      export interface AppShellState {
        sidebarState: SidebarState;
        bodyState: BodyState;
        sidePaneContent: 'details' | 'settings' | 'main' | 'toaster' | 'notifications' | 'dataDemo' | 'dataItem';
        sidebarWidth: number;
        sidePaneWidth: number;
        splitPaneWidth: number;
        previousBodyState: BodyState;
        fullscreenTarget: 'main' | 'right' | null;
        isResizing: boolean;
        isResizingRightPane: boolean;
        isTopBarVisible: boolean;
        autoExpandSidebar: boolean;
        reducedMotion: boolean;
        compactMode: boolean;
        primaryColor: string;
        appName?: string;
        appLogo?: ReactElement;
        draggedPage: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | null;
        dragHoverTarget: 'left' | 'right' | null;
        hoveredPane: 'left' | 'right' | null;
      }


      export interface AppShellActions {
          // Initialization
          init: (config: { appName?: string; appLogo?: ReactElement; defaultSplitPaneWidth?: number }) => void;
          
          // Direct state setters
          setSidebarState: (payload: SidebarState) => void;
          setBodyState: (payload: BodyState) => void;
          setSidePaneContent: (payload: AppShellState['sidePaneContent']) => void;
          setSidebarWidth: (payload: number) => void;
          setSidePaneWidth: (payload: number) => void;
          setSplitPaneWidth: (payload: number) => void;
          setIsResizing: (payload: boolean) => void;
          setFullscreenTarget: (payload: 'main' | 'right' | null) => void;
          setIsResizingRightPane: (payload: boolean) => void;
          setTopBarVisible: (payload: boolean) => void;
          setAutoExpandSidebar: (payload: boolean) => void;
          setReducedMotion: (payload: boolean) => void;
          setCompactMode: (payload: boolean) => void;
          setPrimaryColor: (payload: string) => void;
          setDraggedPage: (payload: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | null) => void;
          setDragHoverTarget: (payload: 'left' | 'right' | null) => void;
          setHoveredPane: (payload: 'left' | 'right' | null) => void;
          
          // Composite actions
          toggleSidebar: () => void;
          hideSidebar: () => void;
          showSidebar: () => void;
          peekSidebar: () => void;
          toggleFullscreen: (target?: 'main' | 'right' | null) => void;
          resetToDefaults: () => void;
      }


      const defaultState: AppShellState = {
        sidebarState: SIDEBAR_STATES.EXPANDED,
        bodyState: BODY_STATES.NORMAL,
        sidePaneContent: 'details',
        sidebarWidth: 280,
        sidePaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.6)) : 400,
        splitPaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.35)) : 400,
        previousBodyState: BODY_STATES.NORMAL,
        fullscreenTarget: null,
        isResizing: false,
        isResizingRightPane: false,
        isTopBarVisible: true,
        autoExpandSidebar: true,
        reducedMotion: false,
        compactMode: false,
        primaryColor: '220 84% 60%',
        appName: 'Jeli App',
        appLogo: undefined,
        draggedPage: null,
        dragHoverTarget: null,
        hoveredPane: null,
      };



      export const useAppShellStore = create<AppShellState &
      AppShellActions>((set, get) => ({
        ...defaultState,

        init: ({ appName, appLogo, defaultSplitPaneWidth }) => set(state => ({
          ...state,
          ...(appName && { appName }),
          ...(appLogo && { appLogo }),
          ...(defaultSplitPaneWidth && { splitPaneWidth: defaultSplitPaneWidth }),
        })),
        
        setSidebarState: (payload) => set({ sidebarState: payload }),
        setBodyState: (payload) => {
          // If we're leaving fullscreen, reset the target and previous state
          if (get().bodyState === BODY_STATES.FULLSCREEN && payload !== BODY_STATES.FULLSCREEN) {
            set({ bodyState: payload, fullscreenTarget: null, previousBodyState: BODY_STATES.NORMAL });
          } else {
            set({ bodyState: payload });
          }
        },
        setSidePaneContent: (payload) => set({ sidePaneContent: payload }),
        setSidebarWidth: (payload) => set({ sidebarWidth: Math.max(200, Math.min(500, payload)) }),
        setSidePaneWidth: (payload) => set({ sidePaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, payload)) }),
        setSplitPaneWidth: (payload) => set({ splitPaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, payload)) }),
        setIsResizing: (payload) => set({ isResizing: payload }),
        setFullscreenTarget: (payload) => set({ fullscreenTarget: payload }),
        setIsResizingRightPane: (payload) => set({ isResizingRightPane: payload }),
        setTopBarVisible: (payload) => set({ isTopBarVisible: payload }),
        setAutoExpandSidebar: (payload) => set({ autoExpandSidebar: payload }),
        setReducedMotion: (payload) => set({ reducedMotion: payload }),
        setCompactMode: (payload) => set({ compactMode: payload }),
        setPrimaryColor: (payload) => {
          if (typeof document !== 'undefined') {
              document.documentElement.style.setProperty('--primary-hsl', payload);
          }
          set({ primaryColor: payload });
        },
        setDraggedPage: (payload) => set({ draggedPage: payload }),
        setDragHoverTarget: (payload) => set({ dragHoverTarget: payload }),
        setHoveredPane: (payload) => set({ hoveredPane: payload }),
        
        toggleSidebar: () => {
          const current = get().sidebarState;
          if (current === SIDEBAR_STATES.HIDDEN) set({ sidebarState: SIDEBAR_STATES.COLLAPSED });
          else if (current === SIDEBAR_STATES.COLLAPSED) set({ sidebarState: SIDEBAR_STATES.EXPANDED });
          else if (current === SIDEBAR_STATES.EXPANDED) set({ sidebarState: SIDEBAR_STATES.COLLAPSED });
        },
        hideSidebar: () => set({ sidebarState: SIDEBAR_STATES.HIDDEN }),
        showSidebar: () => set({ sidebarState: SIDEBAR_STATES.EXPANDED }),
        peekSidebar: () => set({ sidebarState: SIDEBAR_STATES.PEEK }),
        
        toggleFullscreen: (target = null) => {
          const { bodyState, previousBodyState } = get();
          if (bodyState === BODY_STATES.FULLSCREEN) {
            set({ 
              bodyState: previousBodyState || BODY_STATES.NORMAL,
              fullscreenTarget: null,
              previousBodyState: BODY_STATES.NORMAL,
            });
          } else {
            set({ 
              previousBodyState: bodyState, 
              bodyState: BODY_STATES.FULLSCREEN, 
              fullscreenTarget: target 
            });
          }
        },
        
        resetToDefaults: () => {
          // Preserve props passed to provider
          const { appName, appLogo } = get();
          const currentPrimaryColor = defaultState.primaryColor;
          if (typeof document !== 'undefined') {
            document.documentElement.style.setProperty('--primary-hsl', currentPrimaryColor);
          }
          set({ ...defaultState, primaryColor: currentPrimaryColor, appName, appLogo });
        },
      }));


      // Add a selector for the derived rightPaneWidth

      export const useRightPaneWidth = () => useAppShellStore(state => 
          state.bodyState === BODY_STATES.SPLIT_VIEW ? state.splitPaneWidth : state.sidePaneWidth
      );
    patchStrategy: replace
  - type: write
    path: src/context/AppShellContext.tsx
    content: >-
      import { useEffect, type ReactNode, type ReactElement } from 'react';

      import { useAppShellStore } from '@/store/appShell.store';


      interface AppShellProviderProps {
        children: ReactNode;
        appName?: string;
        appLogo?: ReactElement;
        defaultSplitPaneWidth?: number;
      }


      export function AppShellProvider({ children, appName, appLogo,
      defaultSplitPaneWidth }: AppShellProviderProps) {
        const init = useAppShellStore(state => state.init);
        const setPrimaryColor = useAppShellStore(state => state.setPrimaryColor);
        const primaryColor = useAppShellStore(state => state.primaryColor);

        useEffect(() => {
          init({ appName, appLogo, defaultSplitPaneWidth });
        }, [appName, appLogo, defaultSplitPaneWidth, init]);

        // Side effect for primary color
        useEffect(() => {
          // This effect is here because the store itself can't run side-effects on init
          // before React has mounted. So we trigger it from the provider.
          setPrimaryColor(primaryColor);
        }, [primaryColor, setPrimaryColor]);

        return <>{children}</>;
      }
    patchStrategy: replace
  - type: rename
    from: src/context/AppShellContext.tsx
    to: src/providers/AppShellProvider.tsx
  - type: write
    path: src/App.tsx
    content: >+
      --- src/App.tsx

      +++ src/App.tsx

      @@ -9,8 +9,8 @@
         useLocation,
       } from "react-router-dom";
       
      -import { AppShell } from "./components/layout/AppShell";

      -import { AppShellProvider, useAppShell } from
      "./context/AppShellContext";

      +import { AppShell } from "./components/layout/AppShell";

      +import { AppShellProvider } from "./providers/AppShellProvider";

      +import { useAppShellStore } from "./store/appShell.store";
       import { useAppStore } from "./store/appStore";
       import { useAuthStore } from "./store/authStore";
       import "./index.css";
      @@ -231,14 +231,14 @@
       
       // The main App component that composes the shell
       function ComposedApp() {
      -  const { dispatch } = useAppShell();

      +  const { setBodyState, setSidePaneContent } = useAppShellStore();
         const viewManager = useAppViewManager();
       
      -  // Sync URL state with AppShellContext

      +  // Sync URL state with AppShellStore
         useEffect(() => {
      -    dispatch({ type: 'SET_BODY_STATE', payload: viewManager.bodyState });

      -    dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload:
      viewManager.sidePaneContent });

      -  }, [viewManager.bodyState, viewManager.sidePaneContent, dispatch]);

      +    setBodyState(viewManager.bodyState);

      +    setSidePaneContent(viewManager.sidePaneContent);

      +  }, [viewManager.bodyState, viewManager.sidePaneContent, setBodyState,
      setSidePaneContent]);
       
         return (
           <AppShell

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/AppShell.tsx
    content: >
      --- src/components/layout/AppShell.tsx

      +++ src/components/layout/AppShell.tsx

      @@ -3,9 +3,8 @@
       import { cn } from '@/lib/utils'
       import { gsap } from 'gsap';
       import { CommandPalette } from '@/components/global/CommandPalette';
       import { useAppStore } from '@/store/appStore'
      -import { useAppShell } from '@/context/AppShellContext';

      +import { useAppShellStore } from '@/store/appShell.store';
       import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'
       import { useResizableSidebar, useResizableRightPane } from '@/hooks/useResizablePanes.hook'
       import { useSidebarAnimations, useBodyStateAnimations } from '@/hooks/useAppShellAnimations.hook'
      @@ -35,21 +34,21 @@
       
       export function AppShell({ sidebar, topBar, mainContent, rightPane, commandPalette, onOverlayClick }: AppShellProps) {
         const {
      -    sidebarState,

      -    dispatch,

      -    autoExpandSidebar,

      -    toggleSidebar,

      -    hoveredPane,

      -    peekSidebar,

      -    draggedPage,

      -    dragHoverTarget,

      -    bodyState,

      -    sidePaneContent,

      -    reducedMotion,

      -    isTopBarVisible,

      -  } = useAppShell();

      +    sidebarState, autoExpandSidebar, hoveredPane, draggedPage,

      +    dragHoverTarget, bodyState, sidePaneContent, reducedMotion,

      +    isTopBarVisible,

      +  } = useAppShellStore(state => ({

      +    sidebarState: state.sidebarState, autoExpandSidebar:
      state.autoExpandSidebar,

      +    hoveredPane: state.hoveredPane, draggedPage: state.draggedPage,

      +    dragHoverTarget: state.dragHoverTarget, bodyState: state.bodyState,

      +    sidePaneContent: state.sidePaneContent, reducedMotion:
      state.reducedMotion,

      +    isTopBarVisible: state.isTopBarVisible,

      +  }));

      +  const { setSidebarState, toggleSidebar, peekSidebar, setDraggedPage,
      setDragHoverTarget, setHoveredPane } = useAppShellStore.getState();
         
         const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
         const isSidePaneOpen = bodyState === BODY_STATES.SIDE_PANE;
      @@ -118,11 +117,11 @@
           },
           onMouseLeave: () => {
             if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.PEEK) {
      -        dispatch({ type: 'SET_SIDEBAR_STATE', payload:
      SIDEBAR_STATES.COLLAPSED });

      +        setSidebarState(SIDEBAR_STATES.COLLAPSED);
             }
           }
         });
      @@ -140,9 +139,9 @@
           if (!draggedPage) return;
           e.preventDefault();
           if (dragHoverTarget !== 'left') {
      -      dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'left' });

      +      setDragHoverTarget('left');
           }
      -  }, [draggedPage, dragHoverTarget, dispatch]);

      +  }, [draggedPage, dragHoverTarget, setDragHoverTarget]);
       
         const handleDropLeft = useCallback(() => {
           if (!draggedPage) return;
      @@ -171,20 +170,20 @@
             navigate(`/${draggedPage}`, { replace: true });
           }
           
      -    dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });

      -    dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });

      -  }, [draggedPage, activePage, bodyState, sidePaneContent, navigate,
      dispatch, location]);

      +    setDraggedPage(null);

      +    setDragHoverTarget(null);

      +  }, [draggedPage, activePage, bodyState, sidePaneContent, navigate,
      location, setDraggedPage, setDragHoverTarget]);
       
         const handleDragOverRight = useCallback((e: React.DragEvent) => {
           if (!draggedPage) return;
           e.preventDefault();
           if (dragHoverTarget !== 'right') {
      -      dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'right' });

      +      setDragHoverTarget('right');
           }
      -  }, [draggedPage, dragHoverTarget, dispatch]);

      +  }, [draggedPage, dragHoverTarget, setDragHoverTarget]);
       
         const handleDropRight = useCallback(() => {
           if (!draggedPage) return;
           const pane = pageToPaneMap[draggedPage as keyof typeof pageToPaneMap];
           if (pane) {
      @@ -197,9 +196,9 @@
       
             navigate(`/${mainPage}?view=split&right=${pane}`, { replace: true });
           }
      -    dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });

      -    dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });

      -  }, [draggedPage, dispatch, activePage, navigate]);

      +    setDraggedPage(null);

      +    setDragHoverTarget(null);

      +  }, [draggedPage, activePage, navigate, setDraggedPage,
      setDragHoverTarget]);
       
         return (
           <div 
      @@ -220,7 +219,7 @@
                   )}
                   onMouseDown={(e) => {
                     e.preventDefault()
      -              dispatch({ type: 'SET_IS_RESIZING', payload: true });

      +              useAppShellStore.getState().setIsResizing(true);
                   }}
                 >
                   <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
      @@ -234,13 +233,13 @@
                     "absolute top-0 left-0 right-0 z-30",
                     isFullscreen && "z-0"
                   )}
      -            onMouseEnter={() => { if (isSplitView) dispatch({ type:
      'SET_HOVERED_PANE', payload: null }); }}

      +            onMouseEnter={() => { if (isSplitView) setHoveredPane(null);
      }}
                 >
                   {topBarWithProps}
                 </div>
       
                 <div className="flex flex-1 min-h-0">
                   <div
                     ref={mainAreaRef}
                     className="relative flex-1 overflow-hidden bg-background"
      -              onMouseEnter={() => { if (isSplitView && !draggedPage)
      dispatch({ type: 'SET_HOVERED_PANE', payload: 'left' }); }}

      -              onMouseLeave={() => { if (isSplitView && !draggedPage)
      dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}

      +              onMouseEnter={() => { if (isSplitView && !draggedPage)
      setHoveredPane('left'); }}

      +              onMouseLeave={() => { if (isSplitView && !draggedPage)
      setHoveredPane(null); }}
                   >
                     {/* Side Pane Overlay */}
                     <div
      @@ -264,7 +263,7 @@
                       onDragOver={handleDragOverLeft}
                       onDrop={handleDropLeft}
                       onDragLeave={() => {
      -                  if (dragHoverTarget === 'left') dispatch({ type:
      'SET_DRAG_HOVER_TARGET', payload: null });

      +                  if (dragHoverTarget === 'left')
      setDragHoverTarget(null);
                       }}
                     >
                       {draggedPage && dragHoverTarget === 'left' && (
      @@ -288,7 +287,7 @@
                         onDragOver={handleDragOverRight}
                         onDrop={handleDropRight}
                         onDragLeave={() => {
      -                    if (dragHoverTarget === 'right') dispatch({ type:
      'SET_DRAG_HOVER_TARGET', payload: null });

      +                    if (dragHoverTarget === 'right')
      setDragHoverTarget(null);
                         }}
                       >
                         {draggedPage && dragHoverTarget === 'right' && (
      @@ -302,8 +301,8 @@
                   {isSplitView ? (
                     <div
                       className="relative"
      -                onMouseEnter={() => { if (isSplitView && !draggedPage)
      dispatch({ type: 'SET_HOVERED_PANE', payload: 'right' }); }}

      -                onMouseLeave={() => { if (isSplitView && !draggedPage)
      dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}

      +                onMouseEnter={() => { if (isSplitView && !draggedPage)
      setHoveredPane('right'); }}

      +                onMouseLeave={() => { if (isSplitView && !draggedPage)
      setHoveredPane(null); }}
                       onDragOver={handleDragOverRight}
                     >
                       {rightPaneWithProps}
      @@ -316,7 +315,7 @@
                           )}
                           onDragLeave={() => {
                             if (dragHoverTarget === 'right')
      -                        dispatch({ type: 'SET_DRAG_HOVER_TARGET',
      payload: null });

      +                        setDragHoverTarget(null);
                           }}
                           onDrop={handleDropRight}
                           onDragOver={(e) => e.preventDefault()}
    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/EnhancedSidebar.tsx
    content: >
      --- src/components/layout/EnhancedSidebar.tsx

      +++ src/components/layout/EnhancedSidebar.tsx

      @@ -20,7 +20,7 @@
         Database
       } from 'lucide-react';
       import { type ActivePage } from '@/store/appStore';
      -import { useAppShell } from '@/context/AppShellContext';

      +import { useAppShellStore } from '@/store/appShell.store';
       import {
         Workspaces,
         WorkspaceTrigger,
      @@ -74,7 +74,7 @@
       
       export const EnhancedSidebar = React.forwardRef<HTMLDivElement, SidebarProps>(
         ({ onMouseEnter, onMouseLeave }, ref) => {
      -    const { sidebarWidth, compactMode, appName, appLogo } =
      useAppShell();

      +    const { sidebarWidth, compactMode, appName, appLogo } =
      useAppShellStore();
           const [selectedWorkspace, setSelectedWorkspace] = React.useState(mockWorkspaces[0]);
       
           return (
      @@ -148,7 +148,8 @@
       }
       
       const AppMenuItem: React.FC<AppMenuItemProps> = ({ icon: Icon, label, badge, hasActions, children, isSubItem = false, page, opensInSidePane = false }) => {
      -  const { compactMode, dispatch } = useAppShell()

      +  const compactMode = useAppShellStore(s => s.compactMode);

      +  const { setDraggedPage, setDragHoverTarget } =
      useAppShellStore.getState();
         const { isCollapsed } = useSidebar();
         const viewManager = useAppViewManager();
       
      @@ -174,13 +175,13 @@
                 draggable={!!page}
                 onDragStart={(_e) => {
                   if (page) {
      -              // set dragged page in AppShell context

      -              dispatch({ type: 'SET_DRAGGED_PAGE', payload: page });

      +              // set dragged page in AppShell store

      +              setDraggedPage(page);
                   }
                 }}
                 onDragEnd={() => {
      -            dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });

      -            dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });

      +            setDraggedPage(null);

      +            setDragHoverTarget(null);
                 }}
               >
                 <SidebarIcon>
    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/MainContent.tsx
    content: >
      --- src/components/layout/MainContent.tsx

      +++ src/components/layout/MainContent.tsx

      @@ -2,7 +2,7 @@
       import { X } from 'lucide-react'
       import { cn } from '@/lib/utils';
       import { BODY_STATES } from '@/lib/utils'
      -import { useAppShell } from '@/context/AppShellContext'

      +import { useAppShellStore } from '@/store/appShell.store'
       
       interface MainContentProps {
         children?: React.ReactNode;
      @@ -10,7 +10,7 @@
       
       export const MainContent = forwardRef<HTMLDivElement, MainContentProps>(
         ({ children }, ref) => {
      -    const { bodyState, fullscreenTarget, toggleFullscreen } =
      useAppShell();

      +    const { bodyState, fullscreenTarget, toggleFullscreen } =
      useAppShellStore();
           const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
       
           if (isFullscreen && fullscreenTarget === 'right') {
    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/RightPane.tsx
    content: >
      --- src/components/layout/RightPane.tsx

      +++ src/components/layout/RightPane.tsx

      @@ -8,13 +8,16 @@
         SplitSquareHorizontal,
         ChevronsLeftRight,
       } from 'lucide-react'
      -import { cn, BODY_STATES } from '@/lib/utils'

      -import { useAppShell } from '@/context/AppShellContext'

      +import { cn, BODY_STATES } from '@/lib/utils';

      +import { useAppShellStore } from '@/store/appShell.store';
       import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
       import { useRightPaneContent } from '@/hooks/useRightPaneContent.hook'
       
       export const RightPane = forwardRef<HTMLDivElement, { className?: string }>(({ className }, ref) => {
      -  const { dispatch, fullscreenTarget, toggleFullscreen, bodyState } =
      useAppShell()

      +  const fullscreenTarget = useAppShellStore(s => s.fullscreenTarget);

      +  const bodyState = useAppShellStore(s => s.bodyState);

      +  const { toggleFullscreen, setIsResizingRightPane } =
      useAppShellStore.getState();

      +
         const viewManager = useAppViewManager()
         const { sidePaneContent, closeSidePane, toggleSplitView, navigateTo } = viewManager
         
      @@ -84,7 +87,7 @@
               )}
               onMouseDown={(e) => {
                 e.preventDefault()
      -          dispatch({ type: 'SET_IS_RESIZING_RIGHT_PANE', payload: true
      });

      +          setIsResizingRightPane(true);
               }}
             >
               <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/Sidebar.tsx
    content: |
      --- src/components/layout/Sidebar.tsx
      +++ src/components/layout/Sidebar.tsx
      @@ -1,7 +1,7 @@
       import * as React from 'react';
       import { ChevronDown } from 'lucide-react';
       import { Slot } from '@radix-ui/react-slot';
      -import { useAppShell } from '@/context/AppShellContext';
      +import { useAppShellStore } from '@/store/appShell.store';
       import { SIDEBAR_STATES } from '@/lib/utils';
       import { cn } from '@/lib/utils';
       import { Button } from '@/components/ui/button';
      @@ -29,7 +29,7 @@
       
       const Sidebar = React.forwardRef<HTMLDivElement, SidebarProps>(
         ({ children, className, ...props }, ref) => {
      -    const { sidebarState, compactMode } = useAppShell();
      +    const { sidebarState, compactMode } = useAppShellStore();
           const isCollapsed = sidebarState === SIDEBAR_STATES.COLLAPSED;
           const isPeek = sidebarState === SIDEBAR_STATES.PEEK;
       
    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/TopBar.tsx
    content: |
      --- src/components/layout/TopBar.tsx
      +++ src/components/layout/TopBar.tsx
      @@ -11,7 +11,7 @@
       import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
       import { UserDropdown } from './UserDropdown'
       import { ViewModeSwitcher } from './ViewModeSwitcher'
      -import { useAppShell } from '@/context/AppShellContext'
      +import { useAppShellStore } from '@/store/appShell.store'
       
       interface TopBarProps {
         children?: React.ReactNode
      @@ -20,11 +20,8 @@
       export function TopBar({
         children,
       }: TopBarProps) {
      -  const { 
      -    bodyState,
      -    toggleSidebar,
      -  } = useAppShell()
      +  const bodyState = useAppShellStore(s => s.bodyState);
      +  const toggleSidebar = useAppShellStore(s => s.toggleSidebar);
         const viewManager = useAppViewManager();
         const { 
           setCommandPaletteOpen,
    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/ViewModeSwitcher.tsx
    content: |
      --- src/components/layout/ViewModeSwitcher.tsx
      +++ src/components/layout/ViewModeSwitcher.tsx
      @@ -1,7 +1,7 @@
       import { useState, useRef, useEffect } from 'react';
       import { gsap } from 'gsap';
       import { cn } from '@/lib/utils'
      -import { useAppShell } from '@/context/AppShellContext'
      +import { useAppShellStore } from '@/store/appShell.store'
       import { type ActivePage } from '@/store/appStore'
       import { BODY_STATES } from '@/lib/utils'
       import { type AppShellState } from '@/context/AppShellContext'
      @@ -18,11 +18,8 @@
       } from 'lucide-react'
       
       export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' | 'right', targetPage?: ActivePage }) {
      -  const {
      -    bodyState,
      -    toggleFullscreen,
      -    fullscreenTarget,
      -  } = useAppShell()
      +  const { bodyState, fullscreenTarget } = useAppShellStore();
      +  const toggleFullscreen = useAppShellStore(s => s.toggleFullscreen);
         const {
           currentActivePage,
           toggleSidePane,
    patchStrategy: standard-diff
  - type: write
    path: src/components/global/CommandPalette.tsx
    content: >
      --- src/components/global/CommandPalette.tsx

      +++ src/components/global/CommandPalette.tsx

      @@ -9,12 +9,12 @@
         CommandShortcut,
       } from '@/components/ui/command';
       import { useAppStore } from '@/store/appStore'
      -import { useAppShell } from '@/context/AppShellContext'
       import { useCommandPaletteToggle } from '@/hooks/useCommandPaletteToggle.hook'
       import { useAppViewManager } from '@/hooks/useAppViewManager.hook';
      +import { useAppShellStore } from '@/store/appShell.store';
       import { Home, Settings, Moon, Sun, Monitor, Smartphone, PanelRight, Maximize, Component, Bell } from 'lucide-react'
       
       export function CommandPalette() {
      -  const { dispatch, toggleFullscreen } = useAppShell();

      +  const { setCompactMode, toggleFullscreen } = useAppShellStore();
         const viewManager = useAppViewManager();
         const {
           isCommandPaletteOpen,
      @@ -64,12 +64,12 @@
               <CommandSeparator />
               <CommandGroup heading="Preferences">
      -          <CommandItem onSelect={() => runCommand(() => dispatch({ type:
      'SET_COMPACT_MODE', payload: true }))}>

      +          <CommandItem onSelect={() => runCommand(() =>
      setCompactMode(true))}>
                   <Smartphone className="mr-2 h-4 w-4" />
                   <span>Enable Compact Mode</span>
                   <CommandShortcut>⌘C</CommandShortcut>
                 </CommandItem>
      -          <CommandItem onSelect={() => runCommand(() => dispatch({ type:
      'SET_COMPACT_MODE', payload: false }))}>

      +          <CommandItem onSelect={() => runCommand(() =>
      setCompactMode(false))}>
                   <Monitor className="mr-2 h-4 w-4" />
                   <span>Disable Compact Mode</span>
                   <CommandShortcut>⇧⌘C</CommandShortcut>
    patchStrategy: standard-diff
  - type: write
    path: src/features/settings/SettingsContent.tsx
    content: >
      --- src/features/settings/SettingsContent.tsx

      +++ src/features/settings/SettingsContent.tsx

      @@ -12,7 +12,7 @@
         Check
       } from 'lucide-react'
       import { cn } from '@/lib/utils'
      -import { useAppShell } from '@/context/AppShellContext'

      +import { useAppShellStore } from '@/store/appShell.store'
       import { useAppStore } from '@/store/appStore'
       import { SettingsToggle } from './SettingsToggle'
       import { SettingsSection } from './SettingsSection'
      @@ -26,27 +26,27 @@
       ]
       
       export function SettingsContent() {
      -  const shell = useAppShell()

      -  const dispatch = shell.dispatch

      +  const {

      +    sidebarWidth, compactMode, primaryColor, autoExpandSidebar,
      reducedMotion,

      +    setSidebarWidth, setCompactMode, setPrimaryColor,
      setAutoExpandSidebar,

      +    setReducedMotion, resetToDefaults

      +  } = useAppShellStore();
         const { isDarkMode, toggleDarkMode } = useAppStore()
       
      -  const [tempSidebarWidth, setTempSidebarWidth] =
      useState(shell.sidebarWidth)

      +  const [tempSidebarWidth, setTempSidebarWidth] = useState(sidebarWidth)
       
         const handleSidebarWidthChange = (width: number) => {
           setTempSidebarWidth(width)
      -    dispatch({ type: 'SET_SIDEBAR_WIDTH', payload: width });

      +    setSidebarWidth(width);
         }
       
         const handleReset = () => {
      -    shell.resetToDefaults();

      +    resetToDefaults();
           setTempSidebarWidth(280); // Reset temp state as well
         }
       
      -  const setCompactMode = (payload: boolean) => dispatch({ type:
      'SET_COMPACT_MODE', payload });

      -  const setReducedMotion = (payload: boolean) => dispatch({ type:
      'SET_REDUCED_MOTION', payload });

      -  const setSidebarWidth = (payload: number) => {

      -    dispatch({ type: 'SET_SIDEBAR_WIDTH', payload });

      +  const handleSetSidebarWidth = (payload: number) => {

      +    setSidebarWidth(payload);
           setTempSidebarWidth(payload);
         };
       
      @@ -66,8 +66,8 @@
                 icon={<Minimize2 className="w-4 h-4" />}
                 title="Compact Mode"
                 description="Reduce spacing and sizes"
      -          checked={shell.compactMode}

      -          onCheckedChange={(payload) => dispatch({ type:
      'SET_COMPACT_MODE', payload })}

      +          checked={compactMode}

      +          onCheckedChange={setCompactMode}
               />
       
               {/* Accent Color */}
      @@ -81,12 +81,12 @@
                 </div>
                 <div className="grid grid-cols-6 gap-2 pt-1">
                   {colorPresets.map(color => {
      -              const isActive = color.value === shell.primaryColor

      +              const isActive = color.value === primaryColor
                     return (
                       <button
                         key={color.name}
                         title={color.name}
      -                  onClick={() => dispatch({ type: 'SET_PRIMARY_COLOR',
      payload: color.value })}

      +                  onClick={() => setPrimaryColor(color.value)}
                         className={cn(
                           "w-8 h-8 rounded-full border-2 transition-transform hover:scale-110 flex items-center justify-center",
                           isActive ? 'border-primary' : 'border-transparent'
      @@ -104,8 +104,8 @@
                 icon={<Eye className="w-4 h-4" />}
                 title="Auto Expand Sidebar"
                 description="Expand on hover when collapsed"
      -          checked={shell.autoExpandSidebar}

      -          onCheckedChange={(payload) => dispatch({ type:
      'SET_AUTO_EXPAND_SIDEBAR', payload })}

      +          checked={autoExpandSidebar}

      +          onCheckedChange={setAutoExpandSidebar}
               />
       
               {/* Sidebar Width */}
      @@ -139,8 +139,8 @@
                 icon={<Zap className="w-4 h-4" />}
                 title="Reduced Motion"
                 description="Minimize animations"
      -          checked={shell.reducedMotion}

      -          onCheckedChange={(payload) => dispatch({ type:
      'SET_REDUCED_MOTION', payload })}

      +          checked={reducedMotion}

      +          onCheckedChange={setReducedMotion}
               />
             </SettingsSection>
       
      @@ -154,7 +154,7 @@
                   onClick={() => {
                     setCompactMode(false)
                     setReducedMotion(false)
      -              setSidebarWidth(320)

      +              handleSetSidebarWidth(320)
                   }}
                   className="p-4 bg-accent/30 hover:bg-accent/50 rounded-xl transition-colors text-left"
                 >
      @@ -167,7 +167,7 @@
                   onClick={() => {
                     setCompactMode(true)
                     setReducedMotion(true)
      -              setSidebarWidth(240)

      +              handleSetSidebarWidth(240)
                   }}
                   className="p-4 bg-accent/30 hover:bg-accent/50 rounded-xl transition-colors text-left"
                 >
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useAppShellAnimations.hook.ts
    content: >
      --- src/hooks/useAppShellAnimations.hook.ts

      +++ src/hooks/useAppShellAnimations.hook.ts

      @@ -1,7 +1,7 @@
       import { useEffect, useRef } from 'react';
       import { gsap } from 'gsap';
       import { useSearchParams } from 'react-router-dom';
      -import { useAppShell } from '@/context/AppShellContext';

      +import { useAppShellStore, useRightPaneWidth } from
      '@/store/appShell.store';
       import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils';
       
       function usePrevious<T>(value: T): T | undefined {
      @@ -15,7 +15,7 @@
         sidebarRef: React.RefObject<HTMLDivElement>,
         resizeHandleRef: React.RefObject<HTMLDivElement>
       ) {
      -  const { sidebarState, sidebarWidth, bodyState, reducedMotion } =
      useAppShell();

      +  const { sidebarState, sidebarWidth, bodyState, reducedMotion } =
      useAppShellStore();
         const animationDuration = reducedMotion ? 0.1 : 0.4;
       
         useEffect(() => {
      @@ -74,7 +74,8 @@
         topBarContainerRef: React.RefObject<HTMLDivElement>,
         mainAreaRef: React.RefObject<HTMLDivElement>
       ) {
      -  const { bodyState, reducedMotion, rightPaneWidth, isTopBarVisible,
      dispatch, fullscreenTarget } = useAppShell();

      +  const { bodyState, reducedMotion, isTopBarVisible, fullscreenTarget } =
      useAppShellStore();

      +  const rightPaneWidth = useRightPaneWidth();
         const animationDuration = reducedMotion ? 0.1 : 0.4;
         const prevBodyState = usePrevious(bodyState);
         const [, setSearchParams] = useSearchParams();
      @@ -150,6 +151,6 @@
               gsap.to(backdrop, { opacity: 0, duration: animationDuration, onComplete: () => backdrop.remove() });
             }
           }
      -  }, [bodyState, prevBodyState, animationDuration, rightPaneWidth,
      isTopBarVisible, appRef, mainContentRef, rightPaneRef, topBarContainerRef,
      mainAreaRef, fullscreenTarget, dispatch, setSearchParams]);

      +  }, [bodyState, prevBodyState, animationDuration, rightPaneWidth,
      isTopBarVisible, appRef, mainContentRef, rightPaneRef, topBarContainerRef,
      mainAreaRef, fullscreenTarget, setSearchParams]);
       }
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useResizablePanes.hook.ts
    content: >
      --- src/hooks/useResizablePanes.hook.ts

      +++ src/hooks/useResizablePanes.hook.ts

      @@ -1,6 +1,6 @@
       import { useEffect } from 'react';
       import { gsap } from 'gsap';
      -import { useAppShell } from '@/context/AppShellContext';

      +import { useAppShellStore } from '@/store/appShell.store';
       import { BODY_STATES } from '@/lib/utils';
       
       export function useResizableSidebar(
         sidebarRef: React.RefObject<HTMLDivElement>,
         resizeHandleRef: React.RefObject<HTMLDivElement>
       ) {
      -  const { isResizing, dispatch } = useAppShell();

      +  const isResizing = useAppShellStore(s => s.isResizing);

      +  const { setSidebarWidth, setIsResizing } = useAppShellStore.getState();
       
         useEffect(() => {
           const handleMouseMove = (e: MouseEvent) => {
             if (!isResizing) return;
       
             const newWidth = Math.max(200, Math.min(500, e.clientX));
      -      dispatch({ type: 'SET_SIDEBAR_WIDTH', payload: newWidth });

      +      setSidebarWidth(newWidth);
       
             if (sidebarRef.current) {
               gsap.set(sidebarRef.current, { width: newWidth });
      @@ -11,7 +11,7 @@
           };
       
           const handleMouseUp = () => {
      -      dispatch({ type: 'SET_IS_RESIZING', payload: false });

      +      setIsResizing(false);
             document.body.style.cursor = '';
             document.body.style.userSelect = '';
           };
      @@ -26,29 +26,30 @@
             document.removeEventListener('mousemove', handleMouseMove);
             document.removeEventListener('mouseup', handleMouseUp);
           };
      -  }, [isResizing, dispatch, sidebarRef, resizeHandleRef]);

      +  }, [isResizing, setSidebarWidth, setIsResizing, sidebarRef,
      resizeHandleRef]);
       }
       
       export function useResizableRightPane() {
      -  const { isResizingRightPane, dispatch, bodyState } = useAppShell();

      +  const isResizingRightPane = useAppShellStore(s =>
      s.isResizingRightPane);

      +  const bodyState = useAppShellStore(s => s.bodyState);

      +  const { setSplitPaneWidth, setSidePaneWidth, setIsResizingRightPane } =
      useAppShellStore.getState();
       
         useEffect(() => {
           const handleMouseMove = (e: MouseEvent) => {
             if (!isResizingRightPane) return;
       
             const newWidth = window.innerWidth - e.clientX;
             if (bodyState === BODY_STATES.SPLIT_VIEW) {
      -        dispatch({ type: 'SET_SPLIT_PANE_WIDTH', payload: newWidth });

      +        setSplitPaneWidth(newWidth);
             } else {
      -        dispatch({ type: 'SET_SIDE_PANE_WIDTH', payload: newWidth });

      +        setSidePaneWidth(newWidth);
             }
           };
       
           const handleMouseUp = () => {
      -      dispatch({ type: 'SET_IS_RESIZING_RIGHT_PANE', payload: false });

      +      setIsResizingRightPane(false);
             document.body.style.cursor = '';
             document.body.style.userSelect = '';
           };
      @@ -64,6 +65,6 @@
             document.removeEventListener('mousemove', handleMouseMove);
             document.removeEventListener('mouseup', handleMouseUp);
             document.body.style.cursor = '';
           };
      -  }, [isResizingRightPane, dispatch, bodyState]);

      +  }, [isResizingRightPane, setSplitPaneWidth, setSidePaneWidth,
      setIsResizingRightPane, bodyState]);
       }
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useAutoAnimateTopBar.ts
    content: |
      --- src/hooks/useAutoAnimateTopBar.ts
      +++ src/hooks/useAutoAnimateTopBar.ts
      @@ -1,9 +1,10 @@
       import { useRef, useCallback, useEffect } from 'react';
      -import { useAppShell } from '@/context/AppShellContext';
      +import { useAppShellStore } from '@/store/appShell.store';
       import { BODY_STATES } from '@/lib/utils';
       
       export function useAutoAnimateTopBar(isPane = false) {
      -  const { dispatch, bodyState } = useAppShell();
      +  const bodyState = useAppShellStore(s => s.bodyState);
      +  const setTopBarVisible = useAppShellStore(s => s.setTopBarVisible);
         const lastScrollTop = useRef(0);
         const scrollTimeout = useRef<ReturnType<typeof setTimeout> | null>(null);
       
      @@ -16,9 +17,9 @@
           const { scrollTop } = event.currentTarget;
           
           if (scrollTop > lastScrollTop.current && scrollTop > 200) {
      -      dispatch({ type: 'SET_TOP_BAR_VISIBLE', payload: false });
      +      setTopBarVisible(false);
           } else if (scrollTop < lastScrollTop.current || scrollTop <= 0) {
      -      dispatch({ type: 'SET_TOP_BAR_VISIBLE', payload: true });
      +      setTopBarVisible(true);
           }
           
           lastScrollTop.current = scrollTop <= 0 ? 0 : scrollTop;
      @@ -28,10 +29,10 @@
             // Don't hide, just ensure it's visible after scrolling stops
             // and we are not at the top of the page.
             if (scrollTop > 0) {
      -        dispatch({ type: 'SET_TOP_BAR_VISIBLE', payload: true });
      +        setTopBarVisible(true);
             }
           }, 250); // Adjust timeout as needed
      -  }, [isPane, dispatch, bodyState]);
      +  }, [isPane, setTopBarVisible, bodyState]);
       
         // Cleanup on unmount
         useEffect(() => {
    patchStrategy: standard-diff
  - type: write
    path: src/pages/Dashboard/hooks/useDashboardAnimations.motion.hook.ts
    content: |
      --- src/pages/Dashboard/hooks/useDashboardAnimations.motion.hook.ts
      +++ src/pages/Dashboard/hooks/useDashboardAnimations.motion.hook.ts
      @@ -1,6 +1,6 @@
       import { useEffect } from 'react';
       import { gsap } from 'gsap';
      -import { useAppShell } from '@/context/AppShellContext';
      +import { useAppShellStore } from '@/store/appShell.store';
       import { BODY_STATES } from '@/lib/utils';
       import { useStaggeredAnimation } from '@/hooks/useStaggeredAnimation.motion.hook';
       
      @@ -9,7 +9,7 @@
         statsCardsContainerRef: React.RefObject<HTMLDivElement>,
         featureCardsContainerRef: React.RefObject<HTMLDivElement>,
       ) {
      -  const { bodyState } = useAppShell();
      +  const bodyState = useAppShellStore(s => s.bodyState);
       
         // Animate cards on mount
         useStaggeredAnimation(statsCardsContainerRef, [], { y: 20, scale: 0.95 });
    patchStrategy: standard-diff
  - type: write
    path: src/components/shared/PageLayout.tsx
    content: |
      --- src/components/shared/PageLayout.tsx
      +++ src/components/shared/PageLayout.tsx
      @@ -1,6 +1,6 @@
       import React from 'react';
       import { cn } from '@/lib/utils';
      -import { useAppShell } from '@/context/AppShellContext';
      +import { useAppShellStore } from '@/store/appShell.store';
       
       interface PageLayoutProps extends React.HTMLAttributes<HTMLDivElement> {
         children: React.ReactNode;
      @@ -10,7 +10,7 @@
       
       export const PageLayout = React.forwardRef<HTMLDivElement, PageLayoutProps>(
         ({ children, onScroll, scrollRef, className, isInSidePane = false, ...props }, ref) => {
      -    const { isTopBarVisible, bodyState } = useAppShell();
      +    const { isTopBarVisible, bodyState } = useAppShellStore();
           const isFullscreen = bodyState === 'fullscreen';
       
           return (
    patchStrategy: standard-diff
  - type: write
    path: src/index.ts
    content: >
      --- src/index.ts

      +++ src/index.ts

      @@ -1,5 +1,6 @@
       // Context
      -export { AppShellProvider, useAppShell } from
      './context/AppShellContext';

      +export { AppShellProvider } from './providers/AppShellProvider';

      +export { useAppShellStore } from './store/appShell.store';
       
       // Layout Components
       export { AppShell } from './components/layout/AppShell';
    patchStrategy: standard-diff
snapshot:
  src/store/appShell.store.ts: null
  src/providers/AppShellProvider.tsx: null
  src/context/AppShellContext.tsx: >-
    import {
      createContext,
      useContext,
      useReducer,
      useEffect,
      useMemo,
      useCallback,
      type ReactNode,
      type ReactElement,
      type Dispatch,
    } from 'react';

    import { SIDEBAR_STATES, BODY_STATES, type SidebarState, type BodyState }
    from '@/lib/utils';


    // --- State and Action Types ---


    export interface AppShellState {
      sidebarState: SidebarState;
      bodyState: BodyState;
      sidePaneContent: 'details' | 'settings' | 'main' | 'toaster' | 'notifications' | 'dataDemo' | 'dataItem';
      sidebarWidth: number;
      sidePaneWidth: number;
      splitPaneWidth: number;
      previousBodyState: BodyState;
      fullscreenTarget: 'main' | 'right' | null;
      isResizing: boolean;
      isResizingRightPane: boolean;
      isTopBarVisible: boolean;
      autoExpandSidebar: boolean;
      reducedMotion: boolean;
      compactMode: boolean;
      primaryColor: string;
      appName?: string;
      appLogo?: ReactElement;
     draggedPage: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | null;
     dragHoverTarget: 'left' | 'right' | null;
     hoveredPane: 'left' | 'right' | null;
    }


    type AppShellAction =
      | { type: 'SET_SIDEBAR_STATE'; payload: SidebarState }
      | { type: 'SET_BODY_STATE'; payload: BodyState }
      | { type: 'SET_SIDE_PANE_CONTENT'; payload: AppShellState['sidePaneContent'] }
      | { type: 'SET_SIDEBAR_WIDTH'; payload: number }
      | { type: 'SET_SIDE_PANE_WIDTH'; payload: number }
      | { type: 'SET_SPLIT_PANE_WIDTH'; payload: number }
      | { type: 'SET_IS_RESIZING'; payload: boolean }
      | { type: 'SET_PREVIOUS_BODY_STATE'; payload: BodyState }
      | { type: 'SET_FULLSCREEN_TARGET'; payload: 'main' | 'right' | null }
      | { type: 'SET_IS_RESIZING_RIGHT_PANE'; payload: boolean }
      | { type: 'SET_TOP_BAR_VISIBLE'; payload: boolean }
      | { type: 'SET_AUTO_EXPAND_SIDEBAR'; payload: boolean }
      | { type: 'SET_REDUCED_MOTION'; payload: boolean }
      | { type: 'SET_COMPACT_MODE'; payload: boolean }
      | { type: 'SET_PRIMARY_COLOR'; payload: string }
      | { type: 'SET_DRAGGED_PAGE'; payload: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | null }
      | { type: 'SET_DRAG_HOVER_TARGET'; payload: 'left' | 'right' | null }
      | { type: 'SET_HOVERED_PANE'; payload: 'left' | 'right' | null }
      | { type: 'RESET_TO_DEFAULTS' };

    // --- Reducer ---


    const defaultState: AppShellState = {
      sidebarState: SIDEBAR_STATES.EXPANDED,
      bodyState: BODY_STATES.NORMAL,
      sidePaneContent: 'details',
      sidebarWidth: 280,
      sidePaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.6)) : 400,
      splitPaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.35)) : 400,
      previousBodyState: BODY_STATES.NORMAL,
      fullscreenTarget: null,
      isResizing: false,
      isResizingRightPane: false,
      isTopBarVisible: true,
      autoExpandSidebar: true,
      reducedMotion: false,
      compactMode: false,
      primaryColor: '220 84% 60%',
      appName: 'Jeli App',
      appLogo: undefined,
      draggedPage: null,
      dragHoverTarget: null,
      hoveredPane: null,
    };


    function appShellReducer(state: AppShellState, action: AppShellAction):
    AppShellState {
      switch (action.type) {
        case 'SET_SIDEBAR_STATE': return { ...state, sidebarState: action.payload };
        case 'SET_BODY_STATE':
          // If we're leaving fullscreen, reset the target and previous state
          if (state.bodyState === BODY_STATES.FULLSCREEN && action.payload !== BODY_STATES.FULLSCREEN) {
            return { ...state, bodyState: action.payload, fullscreenTarget: null, previousBodyState: BODY_STATES.NORMAL };
          }
          return { ...state, bodyState: action.payload };
        case 'SET_SIDE_PANE_CONTENT': return { ...state, sidePaneContent: action.payload };
        case 'SET_SIDEBAR_WIDTH': return { ...state, sidebarWidth: Math.max(200, Math.min(500, action.payload)) };
        case 'SET_SIDE_PANE_WIDTH': return { ...state, sidePaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };
        case 'SET_SPLIT_PANE_WIDTH': return { ...state, splitPaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };
        case 'SET_IS_RESIZING': return { ...state, isResizing: action.payload };
        case 'SET_PREVIOUS_BODY_STATE': return { ...state, previousBodyState: action.payload };
        case 'SET_FULLSCREEN_TARGET': return { ...state, fullscreenTarget: action.payload };
        case 'SET_IS_RESIZING_RIGHT_PANE': return { ...state, isResizingRightPane: action.payload };
        case 'SET_TOP_BAR_VISIBLE': return { ...state, isTopBarVisible: action.payload };
        case 'SET_AUTO_EXPAND_SIDEBAR': return { ...state, autoExpandSidebar: action.payload };
        case 'SET_REDUCED_MOTION': return { ...state, reducedMotion: action.payload };
        case 'SET_COMPACT_MODE': return { ...state, compactMode: action.payload };
        case 'SET_PRIMARY_COLOR': return { ...state, primaryColor: action.payload };
        case 'SET_DRAGGED_PAGE': return { ...state, draggedPage: action.payload };
        case 'SET_DRAG_HOVER_TARGET': return { ...state, dragHoverTarget: action.payload };
        case 'SET_HOVERED_PANE': return { ...state, hoveredPane: action.payload };
        case 'RESET_TO_DEFAULTS':
          return {
            ...defaultState,
            appName: state.appName, // Preserve props passed to provider
            appLogo: state.appLogo,   // Preserve props passed to provider
          };
        default: return state;
      }
    }


    // --- Context and Provider ---


    interface AppShellContextValue extends AppShellState {
      dispatch: Dispatch<AppShellAction>;
      rightPaneWidth: number;
      // Composite actions for convenience
      toggleSidebar: () => void;
      hideSidebar: () => void;
      showSidebar: () => void;
      peekSidebar: () => void;
      toggleFullscreen: (target?: 'main' | 'right' | null) => void;
      resetToDefaults: () => void;
    }


    const AppShellContext = createContext<AppShellContextValue | null>(null);


    interface AppShellProviderProps {
      children: ReactNode;
      appName?: string;
      appLogo?: ReactElement;
      defaultSplitPaneWidth?: number;
    }


    export function AppShellProvider({ children, appName, appLogo,
    defaultSplitPaneWidth }: AppShellProviderProps) {
      const [state, dispatch] = useReducer(appShellReducer, {
        ...defaultState,
        ...(appName && { appName }),
        ...(appLogo && { appLogo }),
        ...(defaultSplitPaneWidth && { splitPaneWidth: defaultSplitPaneWidth }),
      });

      // Side effect for primary color
      useEffect(() => {
        document.documentElement.style.setProperty('--primary-hsl', state.primaryColor);
      }, [state.primaryColor]);

      // Memoized composite actions using useCallback for stable function identities
      const toggleSidebar = useCallback(() => {
        const current = state.sidebarState;
        if (current === SIDEBAR_STATES.HIDDEN) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
        else if (current === SIDEBAR_STATES.COLLAPSED) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.EXPANDED });
        else if (current === SIDEBAR_STATES.EXPANDED) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
      }, [state.sidebarState]);

      const hideSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.HIDDEN }), []);
      const showSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.EXPANDED }), []);
      const peekSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.PEEK }), []);
      
      const toggleFullscreen = useCallback((target: 'main' | 'right' | null = null) => {
        const current = state.bodyState;
        if (current === BODY_STATES.FULLSCREEN) {
          // Exiting fullscreen, go back to the previous state
          dispatch({ type: 'SET_BODY_STATE', payload: state.previousBodyState || BODY_STATES.NORMAL });
        } else {
          // Entering fullscreen
          dispatch({ type: 'SET_PREVIOUS_BODY_STATE', payload: current });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.FULLSCREEN });
          dispatch({ type: 'SET_FULLSCREEN_TARGET', payload: target });
        }
      }, [state.bodyState, state.previousBodyState]);

      const resetToDefaults = useCallback(() => dispatch({ type: 'RESET_TO_DEFAULTS' }), []);

      const rightPaneWidth = useMemo(() => (
        state.bodyState === BODY_STATES.SPLIT_VIEW ? state.splitPaneWidth : state.sidePaneWidth
      ), [state.bodyState, state.splitPaneWidth, state.sidePaneWidth]);

      const value = useMemo(() => ({ 
        ...state, 
        dispatch,
        rightPaneWidth,
        toggleSidebar,
        hideSidebar,
        showSidebar,
        peekSidebar,
        toggleFullscreen,
        resetToDefaults,
      }), [
        state, 
        rightPaneWidth,
        toggleSidebar,
        hideSidebar,
        showSidebar,
        peekSidebar,
        toggleFullscreen,
        resetToDefaults
      ]);

      return (
        <AppShellContext.Provider value={value}>
          {children}
        </AppShellContext.Provider>
      );
    }


    // --- Hook ---


    // eslint-disable-next-line react-refresh/only-export-components

    export function useAppShell() {
      const context = useContext(AppShellContext);
      if (!context) {
        throw new Error('useAppShell must be used within an AppShellProvider');
      }
      return context;
    }
  src/App.tsx: |-
    import React, { useEffect } from "react";
    import {
      createBrowserRouter,
      RouterProvider,
      Outlet,
      Navigate,
      useNavigate, // used in LoginPageWrapper
      useLocation,
    } from "react-router-dom";

    import { AppShell } from "./components/layout/AppShell";
    import { AppShellProvider, useAppShell } from "./context/AppShellContext";
    import { useAppStore } from "./store/appStore";
    import { useAuthStore } from "./store/authStore";
    import "./index.css";

    // Import library components
    import { EnhancedSidebar } from "./components/layout/EnhancedSidebar";
    import { MainContent } from "./components/layout/MainContent";
    import { RightPane } from "./components/layout/RightPane";
    import { TopBar } from "./components/layout/TopBar";
    import { CommandPalette } from "./components/global/CommandPalette";
    import { ToasterProvider } from "./components/ui/toast";

    // --- Page/Content Components for Pages and Panes ---
    import { DashboardContent } from "./pages/Dashboard";
    import { SettingsPage } from "./pages/Settings";
    import { ToasterDemo } from "./pages/ToasterDemo";
    import { NotificationsPage } from "./pages/Notifications";
    import DataDemoPage from "./pages/DataDemo";
    import { LoginPage } from "./components/auth/LoginPage";

    // --- Icons ---
    import {
      Search,
      Filter,
      Plus,
      ChevronRight,
      Rocket,
    } from "lucide-react";

    // --- Utils & Hooks ---
    import { cn } from "./lib/utils";
    import { useAppViewManager } from "./hooks/useAppViewManager.hook";
    import { useRightPaneContent } from "./hooks/useRightPaneContent.hook";
    import { BODY_STATES } from "./lib/utils";

    // Wrapper for LoginPage to provide auth handlers
    function LoginPageWrapper() {
      const { login, forgotPassword } = useAuthStore();
      const navigate = useNavigate();
      const location = useLocation();
      const from = location.state?.from?.pathname + location.state?.from?.search || "/";

      const handleLogin = async (email: string, password: string) => {
        try {
          await login(email, password);
          navigate(from, { replace: true });
        } catch (error) {
          console.error("Login failed:", error);
          // In a real app, you'd show an error message to the user
        }
      };

      const handleForgotPassword = async (email: string) => {
        try {
          await forgotPassword(email);
        } catch (error) {
          console.error("Forgot password failed:", error);
        }
      };

      const handleSignUp = () => {
        // In a real app, navigate to sign up page
        console.log("Navigate to sign up page");
      };

      return (
        <LoginPage
          onLogin={handleLogin}
          onForgotPassword={handleForgotPassword}
          onSignUp={handleSignUp}
        />
      );
    }

    // Checks for authentication and redirects to login if needed
    function ProtectedRoute() {
      const { isAuthenticated } = useAuthStore();
      const location = useLocation();
      if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
      }
      return <Outlet />;
    }

    // A root component to apply global styles and effects
    function Root() {
      const isDarkMode = useAppStore((state) => state.isDarkMode);

      useEffect(() => {
        document.documentElement.classList.toggle("dark", isDarkMode);
      }, [isDarkMode]);

      return <Outlet />;
    }

    // The main layout for authenticated parts of the application
    function ProtectedLayout() {

      return (
        <div className="h-screen w-screen overflow-hidden bg-background">
          <AppShellProvider
            appName="Jeli App"
            appLogo={
              <div className="p-2 bg-primary/20 rounded-lg">
                <Rocket className="w-5 h-5 text-primary" />
              </div>
            }
          >
            <ComposedApp />
          </AppShellProvider>
        </div>
      );
    }

    // Content for the Top Bar (will be fully refactored in Part 2)
    function AppTopBar() {
      const { searchTerm, setSearchTerm } = useAppStore();
      const [isSearchFocused, setIsSearchFocused] = React.useState(false);
      const location = useLocation();
      const activePage = location.pathname.split('/').filter(Boolean).pop()?.replace('-', ' ') || 'dashboard';

      return (
        <div className="flex items-center gap-3 flex-1">
          <div
            className={cn(
              "hidden md:flex items-center gap-2 text-sm transition-opacity",
              {
                "opacity-0 pointer-events-none":
                  isSearchFocused && activePage === "dashboard",
              },
            )}
          >
            <a
              href="#"
              className="text-muted-foreground hover:text-foreground transition-colors"
            >
              Home
            </a>
            <ChevronRight className="w-4 h-4 text-muted-foreground" />
            <span className="font-medium text-foreground capitalize">
              {activePage}
            </span>
          </div>

          <div className="flex-1" />

          {/* Page-specific: Dashboard search and actions */}
          {activePage === "dashboard" && (
            <div className="flex items-center gap-2 flex-1 justify-end">
              <div
                className={cn(
                  "relative transition-all duration-300 ease-in-out",
                  isSearchFocused ? "flex-1 max-w-lg" : "w-auto",
                )}
              >
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4 pointer-events-none" />
                <input
                  type="text"
                  placeholder="Search..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  onFocus={() => setIsSearchFocused(true)}
                  onBlur={() => setIsSearchFocused(false)}
                  className={cn(
                    "pl-9 pr-4 py-2 h-10 border-none rounded-lg bg-card focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all duration-300 ease-in-out w-full",
                    isSearchFocused ? "bg-background" : "w-48",
                  )}
                />
              </div>
              <button className="h-10 w-10 flex-shrink-0 flex items-center justify-center hover:bg-accent rounded-full transition-colors">
                <Filter className="w-5 h-5" />
              </button>
              <button className="bg-primary text-primary-foreground px-4 py-2 rounded-full hover:bg-primary/90 transition-colors flex items-center gap-2 h-10 flex-shrink-0">
                <Plus className="w-5 h-5" />
                <span
                  className={cn(isSearchFocused ? "hidden sm:inline" : "inline")}
                >
                  New Project
                </span>
              </button>
            </div>
          )}
        </div>
      );
    }

    // The main App component that composes the shell
    function ComposedApp() {
      const { dispatch } = useAppShell();
      const viewManager = useAppViewManager();

      // Sync URL state with AppShellContext
      useEffect(() => {
        dispatch({ type: 'SET_BODY_STATE', payload: viewManager.bodyState });
        dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: viewManager.sidePaneContent });
      }, [viewManager.bodyState, viewManager.sidePaneContent, dispatch]);

      return (
        <AppShell
          sidebar={<EnhancedSidebar />}
          onOverlayClick={viewManager.closeSidePane}
          topBar={
            <TopBar>
              <AppTopBar />
            </TopBar>
          }
          mainContent={
            <MainContent>
              <Outlet />
            </MainContent>
          }
          rightPane={<RightPane />}
          commandPalette={<CommandPalette />}
        />
      );
    }

    function App() {
      const router = createBrowserRouter([
        {
          element: <Root />,
          children: [
            {
              path: "/login",
              element: <LoginPageWrapper />,
            },
            {
              path: "/",
              element: <ProtectedRoute />,
              children: [
                {
                  path: "/",
                  element: <ProtectedLayout />,
                  children: [
                    { index: true, element: <Navigate to="/dashboard" replace /> },
                    { path: "dashboard", element: <DashboardContent /> },
                    { path: "settings", element: <SettingsPage /> },
                    { path: "toaster", element: <ToasterDemo /> },
                    { path: "notifications", element: <NotificationsPage /> },
                    { path: "data-demo", element: <DataDemoPage /> },
                    { path: "data-demo/:itemId", element: <DataDemoPage /> },
                  ],
                },
              ],
            },
          ],
        },
      ]);

      return (
        <ToasterProvider>
          <RouterProvider router={router} />
        </ToasterProvider>
      );
    }

    export default App;
  src/components/layout/AppShell.tsx: >-
    import React, { useRef, type ReactElement, useCallback, useEffect,
    useLayoutEffect } from 'react'

    import { useLocation, useNavigate } from 'react-router-dom';

    import { cn } from '@/lib/utils'

    import { gsap } from 'gsap';

    import { CommandPalette } from '@/components/global/CommandPalette';

    import { useAppStore } from '@/store/appStore'

    import { useAppShell } from '@/context/AppShellContext';

    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'

    import { useResizableSidebar, useResizableRightPane } from
    '@/hooks/useResizablePanes.hook'

    import { useSidebarAnimations, useBodyStateAnimations } from
    '@/hooks/useAppShellAnimations.hook'

    import { ViewModeSwitcher } from './ViewModeSwitcher';


    interface AppShellProps {
      sidebar: ReactElement;
      topBar: ReactElement;
      mainContent: ReactElement;
      rightPane: ReactElement;
      commandPalette?: ReactElement;
      onOverlayClick?: () => void;
    }


    const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
    'notifications' | 'dataDemo'> = {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
      'data-demo': 'dataDemo',
    };


    // Helper hook to get the previous value of a prop or state

    function usePrevious<T>(value: T): T | undefined {
      const ref = useRef<T>();
      useEffect(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }



    export function AppShell({ sidebar, topBar, mainContent, rightPane,
    commandPalette, onOverlayClick }: AppShellProps) {
      const {
        sidebarState,
        dispatch,
        autoExpandSidebar,
        toggleSidebar,
        hoveredPane,
        peekSidebar,
        draggedPage,
        dragHoverTarget,
        bodyState,
        sidePaneContent,
        reducedMotion,
        isTopBarVisible,
      } = useAppShell();
      
      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isSidePaneOpen = bodyState === BODY_STATES.SIDE_PANE;

      const { isDarkMode, toggleDarkMode } = useAppStore();
      const navigate = useNavigate();
      const location = useLocation();
      const activePage = location.pathname.split('/')[1] || 'dashboard';
      const appRef = useRef<HTMLDivElement>(null)
      const sidebarRef = useRef<HTMLDivElement>(null)
      const mainContentRef = useRef<HTMLDivElement>(null)
      const rightPaneRef = useRef<HTMLDivElement>(null)
      const resizeHandleRef = useRef<HTMLDivElement>(null)
      const topBarContainerRef = useRef<HTMLDivElement>(null)
      const mainAreaRef = useRef<HTMLDivElement>(null)

      const prevActivePage = usePrevious(activePage);
      const prevSidePaneContent = usePrevious(sidePaneContent);

      const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;

      // Custom hooks for logic
      useResizableSidebar(sidebarRef, resizeHandleRef);
      useResizableRightPane();
      useSidebarAnimations(sidebarRef, resizeHandleRef);
      useBodyStateAnimations(appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef);
      
      // Animation for pane swapping
      useLayoutEffect(() => {
        if (reducedMotion || bodyState !== BODY_STATES.SPLIT_VIEW || !prevActivePage || !prevSidePaneContent) {
          return;
        }

        const pageForPrevSidePane = Object.keys(pageToPaneMap).find(
          key => pageToPaneMap[key as keyof typeof pageToPaneMap] === prevSidePaneContent
        );

        // Check if a swap occurred by comparing current state with previous state
        if (activePage === pageForPrevSidePane && sidePaneContent === pageToPaneMap[prevActivePage as keyof typeof pageToPaneMap]) {
          const mainEl = mainAreaRef.current;
          const rightEl = rightPaneRef.current;

          if (mainEl && rightEl) {
            const mainWidth = mainEl.offsetWidth;
            const rightWidth = rightEl.offsetWidth;

            const tl = gsap.timeline();
            
            // Animate main content FROM where right pane was TO its new place
            tl.from(mainEl, {
              x: rightWidth, duration: 0.4, ease: 'power3.inOut'
            });

            // Animate right pane FROM where main content was TO its new place
            tl.from(rightEl, {
              x: -mainWidth, duration: 0.4, ease: 'power3.inOut'
            }, 0); // Start at the same time
          }
        }
      }, [activePage, sidePaneContent, bodyState, prevActivePage, prevSidePaneContent, reducedMotion]);
      
      const sidebarWithProps = React.cloneElement(sidebar, { 
        ref: sidebarRef,
        onMouseEnter: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.COLLAPSED) {
            peekSidebar()
          }
        },
        onMouseLeave: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.PEEK) {
            dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
          }
        }
      });

      const topBarWithProps = React.cloneElement(topBar, {
        onToggleSidebar: toggleSidebar,
        onToggleDarkMode: toggleDarkMode,
      });

      const mainContentWithProps = React.cloneElement(mainContent, {
        ref: mainContentRef,
      });

      const rightPaneWithProps = React.cloneElement(rightPane, { ref: rightPaneRef });

      // Drag and drop handlers for docking
      const handleDragOverLeft = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'left') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'left' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropLeft = useCallback(() => {
        if (!draggedPage) return;

        // If we drop the page that's already in the side pane, just make it the main view.
        const paneContentOfDraggedPage = pageToPaneMap[draggedPage];
        if (paneContentOfDraggedPage === sidePaneContent && (bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {
          navigate(`/${draggedPage}`, { replace: true });
        } 
        // New context-aware logic: if we are in normal view and drop a NEW page on the left
        else if (bodyState === BODY_STATES.NORMAL && draggedPage !== activePage) {
            const originalActivePagePaneContent = pageToPaneMap[activePage];
            if (originalActivePagePaneContent) {
                navigate(`/${draggedPage}?view=split&right=${originalActivePagePaneContent}`, { replace: true });
            } else {
                // Fallback for pages that can't be in a pane
                navigate(`/${draggedPage}`, { replace: true });
            }
        } else { // Default behavior: just make the dropped page the main one
          // If in split view, replace the main content and keep the right pane
          if (bodyState === BODY_STATES.SPLIT_VIEW) {
            const rightPane = location.search.split('right=')[1];
            if (rightPane) {
              navigate(`/${draggedPage}?view=split&right=${rightPane}`, { replace: true });
              return;
            }
          }
          navigate(`/${draggedPage}`, { replace: true });
        }
        
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, activePage, bodyState, sidePaneContent, navigate, dispatch, location]);

      const handleDragOverRight = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'right') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'right' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropRight = useCallback(() => {
        if (!draggedPage) return;
        const pane = pageToPaneMap[draggedPage as keyof typeof pageToPaneMap];
        if (pane) {
          let mainPage = activePage;
          // If dropping the currently active page to the right,
          // set a default page (e.g., dashboard) as the new active page.
          if (draggedPage === activePage) {
            mainPage = 'dashboard';
          }

          navigate(`/${mainPage}?view=split&right=${pane}`, { replace: true });
        }
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, dispatch, activePage, navigate]);

      return (
        <div 
          ref={appRef}
          className={cn(
            "relative h-screen w-screen overflow-hidden bg-background transition-colors duration-300",
            isDarkMode && "dark"
          )}
        >
          <div className="flex h-screen overflow-hidden">
            {/* Enhanced Sidebar */}
            {sidebarWithProps}

            {/* Resize Handle */}
            {sidebarState !== SIDEBAR_STATES.HIDDEN && (
              <div
                ref={resizeHandleRef}
                className={cn(
                  "absolute top-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
                )}
                onMouseDown={(e) => {
                  e.preventDefault()
                  dispatch({ type: 'SET_IS_RESIZING', payload: true });
                }}
              >
                <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
              </div>
            )}

            {/* Main area wrapper */}
            <div className="flex-1 flex flex-col overflow-hidden relative">
              <div
                ref={topBarContainerRef}
                className={cn(
                  "absolute top-0 left-0 right-0 z-30",
                  isFullscreen && "z-0"
                )}
                onMouseEnter={() => { if (isSplitView) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
              >
                {topBarWithProps}
              </div>

              <div className="flex flex-1 min-h-0">
                <div
                  ref={mainAreaRef}
                  className="relative flex-1 overflow-hidden bg-background"
                  onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'left' }); }}
                  onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                >
                  {/* Side Pane Overlay */}
                  <div
                    role="button"
                    aria-label="Close side pane"
                    tabIndex={isSidePaneOpen ? 0 : -1}
                    className={cn(
                      "absolute inset-0 bg-black/40 z-40 transition-opacity duration-300",
                      isSidePaneOpen
                        ? "opacity-100 pointer-events-auto"
                        : "opacity-0 pointer-events-none"
                    )}
                    onClick={onOverlayClick}
                  />
                  {/* Left drop overlay */}
                  <div
                    className={cn(
                      "absolute inset-y-0 left-0 z-40 border-2 border-transparent transition-all",
                      draggedPage
                        ? cn("pointer-events-auto", isSplitView ? 'w-full' : 'w-1/2')
                        : "pointer-events-none w-0",
                      dragHoverTarget === 'left' && "bg-primary/10 border-primary"
                    )}
                    onDragOver={handleDragOverLeft}
                    onDrop={handleDropLeft}
                    onDragLeave={() => {
                      if (dragHoverTarget === 'left') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                    }}
                  >
                    {draggedPage && dragHoverTarget === 'left' && (
                      <div className="absolute inset-0 flex items-center justify-center text-sm font-medium text-primary-foreground/80 pointer-events-none">
                        <span className="px-3 py-1 rounded-md bg-primary/70">{isSplitView ? 'Drop to Replace' : 'Drop to Left'}</span>
                      </div>
                    )}
                  </div>
                  {mainContentWithProps}
                  {isSplitView && hoveredPane === 'left' && !draggedPage && (
                    <div className={cn("absolute right-4 z-50 transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                      <ViewModeSwitcher pane="main" />
                    </div>
                  )}
                  {/* Right drop overlay (over main area, ONLY when NOT in split view) */}
                  {!isSplitView && (
                    <div
                      className={cn(
                        "absolute inset-y-0 right-0 z-40 border-2 border-transparent",
                        draggedPage ? "pointer-events-auto w-1/2" : "pointer-events-none",
                        dragHoverTarget === 'right' && "bg-primary/10 border-primary"
                      )}
                      onDragOver={handleDragOverRight}
                      onDrop={handleDropRight}
                      onDragLeave={() => {
                        if (dragHoverTarget === 'right') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                      }}
                    >
                      {draggedPage && dragHoverTarget === 'right' && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                          <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">Drop to Right</span>
                        </div>
                      )}
                    </div>
                  )}
                </div>
                {isSplitView ? (
                  <div
                    className="relative"
                    onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'right' }); }}
                    onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                    onDragOver={handleDragOverRight}
                  >
                    {rightPaneWithProps}
                    {draggedPage && (
                      <div
                        className={cn(
                          'absolute inset-0 z-50 transition-all',
                          dragHoverTarget === 'right'
                            ? 'bg-primary/10 border-2 border-primary'
                            : 'pointer-events-none'
                        )}
                        onDragLeave={() => {
                          if (dragHoverTarget === 'right')
                            dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                        }}
                        onDrop={handleDropRight}
                        onDragOver={(e) => e.preventDefault()}
                      >
                        {dragHoverTarget === 'right' && (
                          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">
                              Drop to Replace
                            </span>
                          </div>
                        )}
                      </div>
                    )}
                    {hoveredPane === 'right' && !draggedPage && (
                      <div className={cn("absolute right-4 z-[70] transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                        <ViewModeSwitcher pane="right" />
                      </div>
                    )}
                  </div>
                ) : rightPaneWithProps}
              </div>
            </div>
          </div>
          {commandPalette || <CommandPalette />}
        </div>
      )
    }
  src/components/layout/MainContent.tsx: |-
    import { forwardRef } from 'react'
    import { X } from 'lucide-react'
    import { cn } from '@/lib/utils';
    import { BODY_STATES } from '@/lib/utils'
    import { useAppShell } from '@/context/AppShellContext'

    interface MainContentProps {
      children?: React.ReactNode;
    }

    export const MainContent = forwardRef<HTMLDivElement, MainContentProps>(
      ({ children }, ref) => {
        const { bodyState, fullscreenTarget, toggleFullscreen } = useAppShell();
        const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;

        if (isFullscreen && fullscreenTarget === 'right') {
          return null;
        }

        return (
          <div
            ref={ref}
            className={cn(
            "flex flex-col h-full overflow-hidden bg-background",
            isFullscreen && "fixed inset-0 z-[60]"
            )}
          >
            {isFullscreen && (
              <button
                onClick={() => toggleFullscreen()}
                className="fixed top-6 right-6 lg:right-12 z-[100] h-12 w-12 flex items-center justify-center rounded-full bg-card/50 backdrop-blur-sm hover:bg-card/75 transition-colors group"
                title="Exit Fullscreen"
              >
                <X className="w-6 h-6 group-hover:scale-110 group-hover:rotate-90 transition-all duration-300" />
              </button>
            )}

            <div className="flex-1 min-h-0 flex flex-col">
              {children}
            </div>
          </div>
        )
      }
    )
    MainContent.displayName = 'MainContent'
  src/components/layout/EnhancedSidebar.tsx: >-
    import React from 'react';

    import {
      Home,
      Settings,
      HelpCircle,
      Component,
      Rocket,
      MoreHorizontal,
      Bell,
      Search,
      FileText,
      Star,
      Trash2,
      FolderOpen,
      Mail,
      Bookmark,
      Download,
      User,
      Plus,
      Database
    } from 'lucide-react';

    import { type ActivePage } from '@/store/appStore';

    import { useAppShell } from '@/context/AppShellContext';

    import {
      Workspaces,
      WorkspaceTrigger,
      WorkspaceContent,
      type Workspace,
    } from './WorkspaceSwitcher';

    import {
      DropdownMenu,
      DropdownMenuContent,
      DropdownMenuItem,
      DropdownMenuTrigger,
    } from '@/components/ui/dropdown-menu';

    import {
      Sidebar,
      SidebarContent,
      SidebarHeader,
      SidebarTitle,
      SidebarBody,
      SidebarFooter,
      SidebarSection,
      SidebarMenuItem,
      SidebarMenuButton,
      SidebarMenuAction,
      SidebarLabel,
      SidebarBadge,
      SidebarTooltip,
      SidebarIcon,
      useSidebar,
    } from './Sidebar';

    import { ViewModeSwitcher } from './ViewModeSwitcher';

    import { cn } from '@/lib/utils';

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook';


    interface MyWorkspace extends Workspace {
      logo: string;
      plan: string;
    }


    const mockWorkspaces: MyWorkspace[] = [
      { id: 'ws1', name: 'Acme Inc.', logo: 'https://avatar.vercel.sh/acme.png', plan: 'Pro' },
      { id: 'ws2', name: 'Monsters Inc.', logo: 'https://avatar.vercel.sh/monsters.png', plan: 'Free' },
      { id: 'ws3', name: 'Stark Industries', logo: 'https://avatar.vercel.sh/stark.png', plan: 'Enterprise' },
    ];


    const SidebarWorkspaceTrigger = () => {
      const { isCollapsed, compactMode } = useSidebar();

      return (
        <WorkspaceTrigger
          collapsed={isCollapsed}
          className={cn(
            'rounded-xl transition-colors hover:bg-accent/50 w-full',
            isCollapsed ? 'p-2' : 'p-3 bg-accent/50',
          )}
          avatarClassName={cn(compactMode ? 'h-8 w-8' : 'h-10 w-10')}
        />
      );
    };


    interface SidebarProps {
      onMouseEnter?: () => void;
      onMouseLeave?: () => void;
    }


    export const EnhancedSidebar = React.forwardRef<HTMLDivElement,
    SidebarProps>(
      ({ onMouseEnter, onMouseLeave }, ref) => {
        const { sidebarWidth, compactMode, appName, appLogo } = useAppShell();
        const [selectedWorkspace, setSelectedWorkspace] = React.useState(mockWorkspaces[0]);

        return (
          <Sidebar
            ref={ref}
            style={{ width: sidebarWidth }}
            onMouseEnter={onMouseEnter}
            onMouseLeave={onMouseLeave}
          >
            <SidebarContent>
              <SidebarHeader>
                {appLogo || (
                  <div className="p-2 bg-primary/20 rounded-lg">
                    <Rocket className="w-5 h-5 text-primary" />
                  </div>
                )}
                <SidebarTitle>{appName}</SidebarTitle>
              </SidebarHeader>

              <SidebarBody>
                <SidebarSection title="Main">
                  <AppMenuItem icon={Home} label="Dashboard" page="dashboard" />
                  <AppMenuItem icon={Database} label="Data Demo" page="data-demo" />
                  <AppMenuItem icon={Search} label="Search" />
                  <AppMenuItem icon={Bell} label="Notifications" badge={3} page="notifications" opensInSidePane />
                </SidebarSection>
                
                <SidebarSection title="Workspace" collapsible defaultExpanded>
                  <AppMenuItem icon={FileText} label="Documents" hasActions>
                    <AppMenuItem icon={FileText} label="Recent" isSubItem />
                    <AppMenuItem icon={Star} label="Starred" isSubItem />
                    <AppMenuItem icon={Trash2} label="Trash" isSubItem />
                  </AppMenuItem>
                  <AppMenuItem icon={FolderOpen} label="Projects" hasActions />
                  <AppMenuItem icon={Mail} label="Messages" badge={12} />
                </SidebarSection>
                
                <SidebarSection title="Personal" collapsible>
                  <AppMenuItem icon={Bookmark} label="Bookmarks" />
                  <AppMenuItem icon={Star} label="Favorites" />
                  <AppMenuItem icon={Download} label="Downloads" />
                </SidebarSection>

                <SidebarSection title="Components" collapsible defaultExpanded>
                  <AppMenuItem icon={Component} label="Toaster" page="toaster" />
                </SidebarSection>
              </SidebarBody>

              <SidebarFooter>
                <SidebarSection>
                  <AppMenuItem icon={User} label="Profile" />
                  <AppMenuItem icon={Settings} label="Settings" page="settings" />
                  <AppMenuItem icon={HelpCircle} label="Help" />
                </SidebarSection>

                <div className={cn(compactMode ? 'mt-4' : 'mt-6')}>
                  <Workspaces
                    workspaces={mockWorkspaces}
                    selectedWorkspaceId={selectedWorkspace.id}
                    onWorkspaceChange={setSelectedWorkspace}
                  >
                    <SidebarWorkspaceTrigger />
                    <WorkspaceContent>
                      <button className="flex w-full items-center gap-2 rounded-sm px-2 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground focus:outline-none">
                        <Plus className="h-4 w-4" />
                        <span>Create Workspace</span>
                      </button>
                    </WorkspaceContent>
                  </Workspaces>
                </div>
              </SidebarFooter>
            </SidebarContent>
          </Sidebar>
        );
      },
    );

    EnhancedSidebar.displayName = 'EnhancedSidebar';



    // Example of a reusable menu item component built with the new Sidebar
    primitives

    interface AppMenuItemProps {
      icon: React.ElementType;
      label: string;
      badge?: number;
      hasActions?: boolean;
      children?: React.ReactNode;
      isSubItem?: boolean;
      page?: ActivePage;
      opensInSidePane?: boolean;
    }


    const AppMenuItem: React.FC<AppMenuItemProps> = ({ icon: Icon, label, badge,
    hasActions, children, isSubItem = false, page, opensInSidePane = false }) =>
    {
      const { compactMode, dispatch } = useAppShell()
      const { isCollapsed } = useSidebar();
      const viewManager = useAppViewManager();

      const isActive = (
        (!opensInSidePane && page && viewManager.currentActivePage === page)
      ) || (
        opensInSidePane && page === 'notifications' && viewManager.sidePaneContent === 'notifications'
      );

      const handleClick = () => {
        if (page) {
          if (opensInSidePane) {
            // The only item using this is Notifications
            viewManager.toggleSidePane('notifications');
          } else {
            viewManager.navigateTo(page);
          }
        }
      };

      return (
        <div className={isSubItem ? (compactMode ? 'ml-4' : 'ml-6') : ''}>
          <SidebarMenuItem>
            <SidebarMenuButton
              onClick={handleClick}
              isActive={isActive}
              draggable={!!page}
              onDragStart={(_e) => {
                if (page) {
                  // set dragged page in AppShell context
                  dispatch({ type: 'SET_DRAGGED_PAGE', payload: page });
                }
              }}
              onDragEnd={() => {
                dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
                dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
              }}
            >
              <SidebarIcon>
                <Icon className={isSubItem ? "w-3 h-3" : "w-4 h-4"}/>
              </SidebarIcon>
              <SidebarLabel>{label}</SidebarLabel>
              {badge && <SidebarBadge>{badge}</SidebarBadge>}
              <SidebarTooltip label={label} badge={badge} />
            </SidebarMenuButton>

            {page && !isCollapsed && ( // Always render switcher if there's a page
              <div className={cn(
                "absolute top-1/2 -translate-y-1/2 z-10",
                "opacity-0 group-hover/item:opacity-100 group-focus-within/item:opacity-100",
                "transition-opacity pointer-events-none group-hover/item:pointer-events-auto",
                // If there are actions, move left to make space for the action button
                hasActions ? "right-10" : "right-2"
              )}>
                <ViewModeSwitcher targetPage={page} />
              </div>
            )}

            {hasActions && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <SidebarMenuAction>
                    <MoreHorizontal className="h-4 w-4" />
                  </SidebarMenuAction>
                </DropdownMenuTrigger>
                <DropdownMenuContent side="right" align="start">
                  <DropdownMenuItem>
                    <span>Edit {label}</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem>
                    <span>Delete {label}</span>
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </SidebarMenuItem>
          {!isCollapsed && children && (
            <div className="space-y-1 mt-1">{children}</div>
          )}
        </div>
      );
    };
  src/components/layout/RightPane.tsx: >-
    import { forwardRef, useMemo, useCallback, createElement } from 'react'

    import {
      ChevronRight,
      X,
      Layers,
      SplitSquareHorizontal,
      ChevronsLeftRight,
    } from 'lucide-react'

    import { cn, BODY_STATES } from '@/lib/utils'

    import { useAppShell } from '@/context/AppShellContext'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { useRightPaneContent } from '@/hooks/useRightPaneContent.hook'


    export const RightPane = forwardRef<HTMLDivElement, { className?: string
    }>(({ className }, ref) => {
      const { dispatch, fullscreenTarget, toggleFullscreen, bodyState } = useAppShell()
      const viewManager = useAppViewManager()
      const { sidePaneContent, closeSidePane, toggleSplitView, navigateTo } = viewManager
      
      const { meta, content: children } = useRightPaneContent(sidePaneContent)
      
      const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;
      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;

      const handleMaximize = useCallback(() => {
        if ("page" in meta && meta.page) {
          navigateTo(meta.page);
        }
      }, [meta, navigateTo]);

      const header = useMemo(() => (
        <div className="flex items-center justify-between p-4 border-b border-border h-20 flex-shrink-0 pl-6">
          {bodyState !== BODY_STATES.SPLIT_VIEW && 'icon' in meta ? (
            <div className="flex items-center gap-2">
              {meta.icon && createElement(meta.icon, { className: "w-5 h-5" })}
              <h2 className="text-lg font-semibold whitespace-nowrap">{meta.title}</h2>
            </div>
          ) : <div />}
          <div className="flex items-center">
            {(bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW) && (
              <button onClick={toggleSplitView} className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors" title={bodyState === BODY_STATES.SIDE_PANE ? "Switch to Split View" : "Switch to Overlay View"}>
                {bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-5 h-5" /> : <SplitSquareHorizontal className="w-5 h-5" />}
              </button>
            )}
            {bodyState !== BODY_STATES.SPLIT_VIEW && "page" in meta && meta.page && (
              <button onClick={handleMaximize} className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors mr-2" title="Move to Main View">
                <ChevronsLeftRight className="w-5 h-5" />
              </button>
            )}
          </div>
        </div>
      ), [bodyState, meta, handleMaximize, toggleSplitView]);

      if (isFullscreen && fullscreenTarget !== 'right') {
        return null;
      }

      return (
        <aside
          ref={ref}
          className={cn(
            "border-l border-border flex flex-col h-full overflow-hidden",
            isSplitView && "relative bg-background",
            !isSplitView && !isFullscreen && "fixed top-0 right-0 z-[60] bg-card", // side pane overlay
            isFullscreen && fullscreenTarget === 'right' && "fixed inset-0 z-[60] bg-card", // fullscreen
            className,
          )}
        >
          {isFullscreen && fullscreenTarget === 'right' && (
            <button
              onClick={() => toggleFullscreen()}
              className="fixed top-6 right-6 lg:right-12 z-[100] h-12 w-12 flex items-center justify-center rounded-full bg-card/50 backdrop-blur-sm hover:bg-card/75 transition-colors group"
              title="Exit Fullscreen"
            >
              <X className="w-6 h-6 group-hover:scale-110 group-hover:rotate-90 transition-all duration-300" />
            </button>
          )}
          {bodyState !== BODY_STATES.SPLIT_VIEW && !isFullscreen && (
            <button
              onClick={closeSidePane}
              className="absolute top-1/2 -left-px -translate-y-1/2 -translate-x-full w-8 h-16 bg-card border border-r-0 border-border rounded-l-lg flex items-center justify-center hover:bg-accent transition-colors group z-10"
              title="Close pane"
            >
              <ChevronRight className="w-5 h-5 text-muted-foreground group-hover:text-foreground transition-colors" />
            </button>
          )}
          <div 
            className={cn(
              "absolute top-0 left-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
            )}
            onMouseDown={(e) => {
              e.preventDefault()
              dispatch({ type: 'SET_IS_RESIZING_RIGHT_PANE', payload: true });
            }}
          >
            <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
          </div>
          {header}
          <div className={cn("flex-1 overflow-y-auto")}>
            {children}
          </div>
        </aside>
      )
    })

    RightPane.displayName = "RightPane"
  src/components/layout/Sidebar.tsx: >-
    import * as React from 'react';

    import { ChevronDown } from 'lucide-react';

    import { Slot } from '@radix-ui/react-slot';

    import { useAppShell } from '@/context/AppShellContext';

    import { SIDEBAR_STATES } from '@/lib/utils';

    import { cn } from '@/lib/utils';

    import { Button } from '@/components/ui/button';


    // --- Context ---

    interface SidebarContextValue {
      isCollapsed: boolean;
      isPeek: boolean;
      compactMode: boolean;
    }


    const SidebarContext = React.createContext<SidebarContextValue |
    null>(null);


    // eslint-disable-next-line react-refresh/only-export-components

    export const useSidebar = () => {
      const context = React.useContext(SidebarContext);
      if (!context) {
        throw new Error('useSidebar must be used within a Sidebar component');
      }
      return context;
    };


    // --- Main Sidebar Component ---

    interface SidebarProps extends React.HTMLAttributes<HTMLDivElement> {
      children: React.ReactNode;
    }


    const Sidebar = React.forwardRef<HTMLDivElement, SidebarProps>(
      ({ children, className, ...props }, ref) => {
        const { sidebarState, compactMode } = useAppShell();
        const isCollapsed = sidebarState === SIDEBAR_STATES.COLLAPSED;
        const isPeek = sidebarState === SIDEBAR_STATES.PEEK;

        return (
          <SidebarContext.Provider value={{ isCollapsed, isPeek, compactMode }}>
            <div
              ref={ref}
              className={cn(
                'relative bg-card flex-shrink-0',
                'h-full',
                isPeek && 'shadow-xl z-40',
                compactMode && 'text-sm',
                className,
              )}
              {...props}
            >
              {isPeek && <div className="absolute inset-0 bg-background/80 backdrop-blur-sm" />}
              {children}
            </div>
          </SidebarContext.Provider>
        );
      },
    );

    Sidebar.displayName = 'Sidebar';


    // --- Sidebar Content Wrapper ---

    const SidebarContent = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => {
      const { compactMode } = useSidebar();
      return (
        <div
          ref={ref}
          className={cn(
            'relative z-10 h-full flex flex-col',
            compactMode ? 'p-3' : 'p-4',
            className,
          )}
          {...props}
        />
      );
    });

    SidebarContent.displayName = 'SidebarContent';


    // --- Sidebar Header ---

    const SidebarHeader = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      return (
        <div
          ref={ref}
          className={cn(
            'flex items-center gap-3',
            isCollapsed ? 'justify-center' : 'px-3',
            'h-16',
            className,
          )}
          {...props}
        />
      );
    });

    SidebarHeader.displayName = 'SidebarHeader';


    const SidebarTitle = React.forwardRef<
      HTMLParagraphElement,
      React.HTMLAttributes<HTMLParagraphElement>
    >(({ className, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      if (isCollapsed) return null;
      return (
        <h1
          ref={ref}
          className={cn('text-lg font-bold nav-label', className)}
          {...props}
        />
      );
    });

    SidebarTitle.displayName = 'SidebarTitle';


    // --- Sidebar Body ---

    const SidebarBody = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => (
      <div
        ref={ref}
        className={cn(
          'flex-1 overflow-y-auto space-y-6 pt-4',
          className,
        )}
        {...props}
      />
    ));

    SidebarBody.displayName = 'SidebarBody';


    // --- Sidebar Footer ---

    const SidebarFooter = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => {
      const { compactMode } = useSidebar();
      return (
        <div
          ref={ref}
          className={cn('pt-4 border-t border-border', compactMode && 'pt-3', className)}
          {...props}
        />
      );
    });

    SidebarFooter.displayName = 'SidebarFooter';


    // --- Sidebar Section ---

    const SidebarSection = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement> & {
        title?: string;
        collapsible?: boolean;
        defaultExpanded?: boolean;
      }
    >(({ title, collapsible = false, defaultExpanded = true, children, ...props
    }, ref) => {
      const { isCollapsed } = useSidebar();
      const [isExpanded, setIsExpanded] = React.useState(defaultExpanded);

      const handleToggle = () => {
        if (collapsible) {
          setIsExpanded(!isExpanded);
        }
      };

      return (
        <div ref={ref} className="space-y-1" {...props}>
          {!isCollapsed && title && (
            <div
              className={cn(
                'flex items-center justify-between px-3 text-xs font-medium text-muted-foreground uppercase tracking-wider',
                collapsible && 'cursor-pointer hover:text-foreground transition-colors',
              )}
              onClick={handleToggle}
            >
              <span className="section-title">{title}</span>
              {collapsible && (
                <ChevronDown
                  className={cn(
                    'section-chevron w-3 h-3 transition-transform',
                    isExpanded ? 'rotate-0' : '-rotate-90',
                  )}
                />
              )}
            </div>
          )}
          {(!collapsible || isExpanded || isCollapsed) && (
            <nav className="space-y-1">{children}</nav>
          )}
        </div>
      );
    });

    SidebarSection.displayName = 'SidebarSection';


    // --- Sidebar Menu Item ---

    const SidebarMenuItem = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => {
      return <div ref={ref} className={cn('group/item relative flex items-stretch', className)} {...props} />;
    });

    SidebarMenuItem.displayName = 'SidebarMenuItem';



    // --- Sidebar Menu Button ---

    interface SidebarMenuButtonProps extends
    React.ButtonHTMLAttributes<HTMLButtonElement> {
      asChild?: boolean;
      isActive?: boolean;
    }

    const SidebarMenuButton = React.forwardRef<HTMLButtonElement,
    SidebarMenuButtonProps>(
      ({ className, asChild = false, isActive, ...props }, ref) => {
        const { isCollapsed, compactMode } = useSidebar();
        const Comp = asChild ? Slot : 'button';

        return (
          <Comp
            ref={ref}
            className={cn(
              'group flex items-center gap-3 rounded-lg cursor-pointer transition-all duration-200 w-full text-left flex-1',
              compactMode ? 'px-2 py-1.5' : 'px-4 py-2.5',
              'hover:bg-accent',
              isActive && 'bg-primary text-primary-foreground hover:bg-primary/90',
              isCollapsed && 'justify-center',
              className
            )}
            {...props}
          />
        );
      }
    );

    SidebarMenuButton.displayName = 'SidebarMenuButton';


    // --- Sidebar Menu Action ---

    const SidebarMenuAction = React.forwardRef<
      HTMLButtonElement,
      React.ButtonHTMLAttributes<HTMLButtonElement>
    >(({ className, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      if (isCollapsed) return null;
      return (
        <Button
          ref={ref}
          variant="ghost"
          size="icon"
          className={cn(
            'absolute right-1 top-1/2 -translate-y-1/2 h-8 w-8 rounded-md opacity-0 group-hover/item:opacity-100 transition-opacity',
            'focus:opacity-100', // show on focus for accessibility
            className
          )}
          {...props}
        />
      );
    });

    SidebarMenuAction.displayName = 'SidebarMenuAction';


    // --- Sidebar Menu Label ---

    const SidebarLabel = React.forwardRef<
      HTMLSpanElement,
      React.HTMLAttributes<HTMLSpanElement>
    >(({ className, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      if (isCollapsed) return null;
      return (
        <span
          ref={ref}
          className={cn('nav-label flex-1 font-medium truncate', className)}
          {...props}
        />
      );
    });

    SidebarLabel.displayName = 'SidebarLabel';



    // --- Sidebar Menu Badge ---

    const SidebarBadge = React.forwardRef<
      HTMLSpanElement,
      React.HTMLAttributes<HTMLSpanElement>
    >(({ className, children, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      if (isCollapsed) return null;
      const badgeContent = typeof children === 'number' && children > 99 ? '99+' : children;
      return (
        <span
          ref={ref}
          className={cn(
            'nav-badge bg-destructive text-destructive-foreground text-xs px-1.5 py-0.5 rounded-full min-w-[1.25rem] text-center',
            className
          )}
          {...props}
        >
          {badgeContent}
        </span>
      );
    });

    SidebarBadge.displayName = 'SidebarBadge';



    // --- Sidebar Tooltip ---

    interface SidebarTooltipProps extends React.HTMLAttributes<HTMLDivElement> {
      label: string;
      badge?: number | string;
    }

    const SidebarTooltip = ({ label, badge, className, ...props }:
    SidebarTooltipProps) => {
      const { isCollapsed } = useSidebar();
      if (!isCollapsed) return null;
      return (
        <div
          className={cn(
            'absolute left-full ml-2 px-2 py-1 bg-popover text-popover-foreground text-sm rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-50',
            className
          )}
          {...props}
        >
          {label}
          {badge && (
            <span className="ml-2 bg-destructive text-destructive-foreground text-xs px-1.5 py-0.5 rounded-full">
              {typeof badge === 'number' && badge > 99 ? '99+' : badge}
            </span>
          )}
        </div>
      );
    };

    SidebarTooltip.displayName = 'SidebarTooltip';



    // --- Icon Wrapper for consistent sizing ---

    const SidebarIcon = ({ children, className }: { children: React.ReactNode,
    className?: string }) => {
      return (
        <div className={cn("flex-shrink-0 w-4 h-4", className)}>
          {children}
        </div>
      )
    }


    export {
      Sidebar,
      SidebarContent,
      SidebarHeader,
      SidebarTitle,
      SidebarBody,
      SidebarFooter,
      SidebarSection,
      SidebarMenuItem,
      SidebarMenuButton,
      SidebarMenuAction,
      SidebarLabel,
      SidebarBadge,
      SidebarTooltip,
      SidebarIcon
    };
  src/components/layout/TopBar.tsx: |-
    import {
      Menu, 
      Moon, 
      Sun,
      Settings,
      Command,
      Zap,
    } from 'lucide-react'
    import { cn } from '@/lib/utils'
    import { BODY_STATES } from '@/lib/utils'
    import { useAppStore } from '@/store/appStore'
    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
    import { UserDropdown } from './UserDropdown'
    import { ViewModeSwitcher } from './ViewModeSwitcher'
    import { useAppShell } from '@/context/AppShellContext'

    interface TopBarProps {
      children?: React.ReactNode
    }

    export function TopBar({
      children,
    }: TopBarProps) {
      const { 
        bodyState,
        toggleSidebar,
      } = useAppShell()
      const viewManager = useAppViewManager();
      const { 
        setCommandPaletteOpen,
        isDarkMode,
        toggleDarkMode,
      } = useAppStore()

      return (
        <div className={cn(
          "h-20 bg-background border-b border-border flex items-center justify-between px-6 z-50 gap-4"
        )}>
          {/* Left Section - Sidebar Controls & Breadcrumbs */}
          <div className="flex items-center gap-4">
            {/* Sidebar Controls */}
            <button
              onClick={toggleSidebar}
              className={cn(
                "h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors"
              )}
              title="Toggle Sidebar"
            >
              <Menu className="w-5 h-5" />
            </button>

          </div>

          {/* Right Section - page controls, and global controls */}
          <div className="flex items-center gap-3">
            {children}

            {/* Separator */}
            <div className="w-px h-6 bg-border mx-2" />

            {/* Quick Actions */}
            <div className="flex items-center gap-3">

              <button
                onClick={() => setCommandPaletteOpen(true)}
                className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
                title="Command Palette (Ctrl+K)"
              >
                <Command className="w-5 h-5 group-hover:scale-110 transition-transform" />
              </button>

            <button
              className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
              title="Quick Actions"
            >
              <Zap className="w-5 h-5 group-hover:scale-110 transition-transform" />
            </button>

            {bodyState !== BODY_STATES.SPLIT_VIEW && <ViewModeSwitcher />}

            <div className="w-px h-6 bg-border mx-2" />

            {/* Theme and Settings */}
            <button
              onClick={toggleDarkMode}
              className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
              title="Toggle Dark Mode"
            >
              {isDarkMode ? (
                <Sun className="w-5 h-5 group-hover:scale-110 transition-transform" />
              ) : (
                <Moon className="w-5 h-5 group-hover:scale-110 transition-transform" />
              )}
            </button>

            <button
              onClick={() => viewManager.toggleSidePane('settings')}
              className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
              title="Settings"
            >
              <Settings className="w-5 h-5 group-hover:rotate-90 transition-transform duration-300" />
            </button>
            <UserDropdown />
            </div>
          </div>
        </div>
      )
    }
  src/components/global/CommandPalette.tsx: >-
    import {
      CommandDialog,
      CommandEmpty,
      CommandGroup,
      CommandInput,
      CommandItem,
      CommandList,
      CommandSeparator,
      CommandShortcut,
    } from '@/components/ui/command';

    import { useAppStore } from '@/store/appStore'

    import { useAppShell } from '@/context/AppShellContext'

    import { useCommandPaletteToggle } from
    '@/hooks/useCommandPaletteToggle.hook'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook';

    import { Home, Settings, Moon, Sun, Monitor, Smartphone, PanelRight,
    Maximize, Component, Bell } from 'lucide-react'


    export function CommandPalette() {
      const { dispatch, toggleFullscreen } = useAppShell();
      const viewManager = useAppViewManager();
      const {
        isCommandPaletteOpen,
        setCommandPaletteOpen,
        isDarkMode,
        toggleDarkMode,
      } = useAppStore()
      useCommandPaletteToggle()
      
      const runCommand = (command: () => void) => {
        setCommandPaletteOpen(false)
        command()
      }

      return (
        <CommandDialog open={isCommandPaletteOpen} onOpenChange={setCommandPaletteOpen}>
          <CommandInput placeholder="Type a command or search..." />
          <CommandList>
            <CommandEmpty>No results found.</CommandEmpty>
            <CommandGroup heading="Navigation">
              <CommandItem onSelect={() => runCommand(() => viewManager.navigateTo('dashboard'))}>
                <Home className="mr-2 h-4 w-4" />
                <span>Go to Dashboard</span>
                <CommandShortcut>G D</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => viewManager.navigateTo('settings'))}>
                <Settings className="mr-2 h-4 w-4" />
                <span>Go to Settings</span>
                <CommandShortcut>G S</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => viewManager.navigateTo('toaster'))}>
                <Component className="mr-2 h-4 w-4" />
                <span>Go to Toaster Demo</span>
                <CommandShortcut>G T</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => viewManager.navigateTo('notifications'))}>
                <Bell className="mr-2 h-4 w-4" />
                <span>Go to Notifications</span>
                <CommandShortcut>G N</CommandShortcut>
              </CommandItem>
            </CommandGroup>
            <CommandSeparator />
            <CommandGroup heading="Actions">
              <CommandItem onSelect={() => runCommand(toggleDarkMode)}>
                {isDarkMode ? <Sun className="mr-2 h-4 w-4" /> : <Moon className="mr-2 h-4 w-4" />}
                <span>Toggle Theme</span>
                <CommandShortcut>⌘T</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(toggleFullscreen)}>
                <Maximize className="mr-2 h-4 w-4" />
                <span>Toggle Fullscreen</span>
                <CommandShortcut>⌘F</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => viewManager.openSidePane('settings'))}>
                <PanelRight className="mr-2 h-4 w-4" />
                <span>Open Settings in Side Pane</span>
                <CommandShortcut>⌥S</CommandShortcut>
              </CommandItem>
            </CommandGroup>
            <CommandSeparator />
            <CommandGroup heading="Preferences">
              <CommandItem onSelect={() => runCommand(() => dispatch({ type: 'SET_COMPACT_MODE', payload: true }))}>
                <Smartphone className="mr-2 h-4 w-4" />
                <span>Enable Compact Mode</span>
                <CommandShortcut>⌘C</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => dispatch({ type: 'SET_COMPACT_MODE', payload: false }))}>
                <Monitor className="mr-2 h-4 w-4" />
                <span>Disable Compact Mode</span>
                <CommandShortcut>⇧⌘C</CommandShortcut>
              </CommandItem>
            </CommandGroup>
          </CommandList>
        </CommandDialog>
      )
    }
  src/components/layout/ViewModeSwitcher.tsx: >-
    import { useState, useRef, useEffect } from 'react';

    import { gsap } from 'gsap';

    import { cn } from '@/lib/utils'

    import { useAppShell } from '@/context/AppShellContext'

    import { type ActivePage } from '@/store/appStore'

    import { BODY_STATES } from '@/lib/utils'

    import { type AppShellState } from '@/context/AppShellContext'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import {
      Columns,
      PanelRightOpen,
      SplitSquareHorizontal,
      Maximize,
      Minimize,
      Layers,
      X,
      ArrowLeftRight
    } from 'lucide-react'


    export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
    'right', targetPage?: ActivePage }) {
      const {
        bodyState,
        toggleFullscreen,
        fullscreenTarget,
      } = useAppShell()
      const {
        currentActivePage,
        toggleSidePane,
        toggleSplitView,
        setNormalView,
        navigateTo,
        switchSplitPanes,
        closeSplitPane,
      } = useAppViewManager();

      const activePage = targetPage || currentActivePage;
      const [isExpanded, setIsExpanded] = useState(false);
      const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isThisPaneFullscreen = isFullscreen && (
        (pane === 'main' && fullscreenTarget !== 'right') ||
        (pane === 'right' && fullscreenTarget === 'right') ||
        (!pane && !fullscreenTarget) // Global switcher, global fullscreen
      );

      useEffect(() => {
        const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
        if (buttonsToAnimate.length === 0) return;

        gsap.killTweensOf(buttonsToAnimate);

        if (isExpanded) {
            gsap.to(buttonsToAnimate, {
                width: 32, // h-8 w-8
                opacity: 1,
                pointerEvents: 'auto',
                marginLeft: 4, // from gap-1 in original
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'start'
                },
                ease: 'power2.out'
            });
        } else {
            gsap.to(buttonsToAnimate, {
                width: 0,
                opacity: 0,
                pointerEvents: 'none',
                marginLeft: 0,
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'end'
                },
                ease: 'power2.in'
            });
        }
      }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

      const handlePaneClick = (type: 'side-pane' | 'split-view') => {
        const pageToPaneMap: Record<ActivePage, AppShellState['sidePaneContent']> = {
          dashboard: 'main', settings: 'settings', toaster: 'toaster', notifications: 'notifications', 'data-demo': 'dataDemo',
        };
        const paneContent = pageToPaneMap[activePage];
        if (type === 'side-pane') toggleSidePane(paneContent);
        else toggleSplitView();
      }

      const handleNormalViewClick = () => {
        if (isFullscreen) {
          toggleFullscreen();
        }
        if (targetPage && targetPage !== currentActivePage) {
          navigateTo(targetPage);
        } else {
          setNormalView();
        }
      }

      const buttons = [
        {
          id: 'normal',
          onClick: handleNormalViewClick,
          active: bodyState === BODY_STATES.NORMAL,
          title: "Normal View",
          icon: <Columns className="w-4 h-4" />
        },
        {
          id: 'side-pane',
          onClick: () => handlePaneClick('side-pane'),
          active: bodyState === BODY_STATES.SIDE_PANE,
          title: "Side Pane View",
          icon: <PanelRightOpen className="w-4 h-4" />
        },
        {
          id: 'split-view',
          onClick: () => handlePaneClick('split-view'),
          active: bodyState === BODY_STATES.SPLIT_VIEW,
          title: bodyState === BODY_STATES.SPLIT_VIEW ? 'Switch to Overlay View' : 'Switch to Split View',
          icon: bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-4 h-4" /> : <SplitSquareHorizontal className="w-4 h-4" />
        },
        {
          id: 'fullscreen',
          onClick: () => {
            if (targetPage && targetPage !== currentActivePage ) {
              navigateTo(targetPage);
              setTimeout(() => toggleFullscreen(pane), 50);
            } else {
              toggleFullscreen(pane);
            }
          },
          active: isThisPaneFullscreen,
          title: "Toggle Fullscreen",
          icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
        }
      ];

      if (bodyState === BODY_STATES.SPLIT_VIEW) {
        buttons.push({
          id: 'switch',
          onClick: switchSplitPanes,
          active: false,
          title: "Switch Panes",
          icon: <ArrowLeftRight className="w-4 h-4" />
        });
        buttons.push({
          id: 'close',
          onClick: () => closeSplitPane(pane || 'right'),
          active: false,
          title: "Close Pane",
          icon: <X className="w-4 h-4 text-muted-foreground group-hover:text-destructive" />
        });
      }

      return (
        <div
          onMouseEnter={() => setIsExpanded(true)}
          onMouseLeave={() => setIsExpanded(false)}
          className="flex items-center gap-0 p-1 bg-card rounded-full border border-border"
        >
            <button
                className='h-8 w-8 flex-shrink-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors'
                title="View Modes"
                onClick={() => setIsExpanded(!isExpanded)}
            >
                <Layers className="w-4 h-4" />
            </button>
          
          {buttons.map((btn, index) => (
            <button
              key={btn.id}
              ref={el => buttonRefs.current[index] = el}
              onClick={btn.onClick}
              className={cn(
                'h-8 w-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors group opacity-0',
                btn.active && 'bg-accent text-accent-foreground',
                btn.id === 'close' && 'hover:bg-destructive/20'
              )}
              style={{ pointerEvents: 'none', marginLeft: 0, overflow: 'hidden' }}
              title={btn.title}
            >
              {btn.icon}
            </button>
          ))}
        </div>
      )
    }
  src/features/settings/SettingsContent.tsx: |-
    import { useState } from 'react'
    import { 
      Moon, 
      Sun, 
      Zap, 
      Eye, 
      Minimize2, 
      RotateCcw,
      Monitor,
      Smartphone,
      Palette,
      Accessibility,
      Check
    } from 'lucide-react'
    import { cn } from '@/lib/utils'
    import { useAppShell } from '@/context/AppShellContext'
    import { useAppStore } from '@/store/appStore'
    import { SettingsToggle } from './SettingsToggle'
    import { SettingsSection } from './SettingsSection'

    const colorPresets = [
      { name: 'Default Blue', value: '220 84% 60%' },
      { name: 'Rose', value: '346.8 77.2% 49.8%' },
      { name: 'Green', value: '142.1 76.2% 36.3%' },
      { name: 'Orange', value: '24.6 95% 53.1%' },
      { name: 'Violet', value: '262.1 83.3% 57.8%' },
      { name: 'Slate', value: '215.3 20.3% 65.1%' }
    ]

    export function SettingsContent() {
      const shell = useAppShell()
      const dispatch = shell.dispatch
      const { isDarkMode, toggleDarkMode } = useAppStore()

      const [tempSidebarWidth, setTempSidebarWidth] = useState(shell.sidebarWidth)

      const handleSidebarWidthChange = (width: number) => {
        setTempSidebarWidth(width)
        dispatch({ type: 'SET_SIDEBAR_WIDTH', payload: width });
      }

      const handleReset = () => {
        shell.resetToDefaults();
        setTempSidebarWidth(280); // Reset temp state as well
      }

      const setCompactMode = (payload: boolean) => dispatch({ type: 'SET_COMPACT_MODE', payload });
      const setReducedMotion = (payload: boolean) => dispatch({ type: 'SET_REDUCED_MOTION', payload });
      const setSidebarWidth = (payload: number) => {
        dispatch({ type: 'SET_SIDEBAR_WIDTH', payload });
        setTempSidebarWidth(payload);
      };

      return (
        <div className="space-y-10">
          {/* Appearance */}
          <SettingsSection icon={<Palette />} title="Appearance">
            {/* Dark Mode */}
            <SettingsToggle
              icon={isDarkMode ? <Moon className="w-4 h-4" /> : <Sun className="w-4 h-4" />}
              title="Dark Mode"
              description="Toggle dark theme"
              checked={isDarkMode}
              onCheckedChange={toggleDarkMode}
            />

            {/* Compact Mode */}
            <SettingsToggle
              icon={<Minimize2 className="w-4 h-4" />}
              title="Compact Mode"
              description="Reduce spacing and sizes"
              checked={shell.compactMode}
              onCheckedChange={(payload) => dispatch({ type: 'SET_COMPACT_MODE', payload })}
            />

            {/* Accent Color */}
            <div className="space-y-3">
              <div className="flex items-center gap-3">
                <Palette className="w-4 h-4" />
                <div>
                  <p className="font-medium">Accent Color</p>
                  <p className="text-sm text-muted-foreground">Customize the main theme color</p>
                </div>
              </div>
              <div className="grid grid-cols-6 gap-2 pt-1">
                {colorPresets.map(color => {
                  const isActive = color.value === shell.primaryColor
                  return (
                    <button
                      key={color.name}
                      title={color.name}
                      onClick={() => dispatch({ type: 'SET_PRIMARY_COLOR', payload: color.value })}
                      className={cn(
                        "w-8 h-8 rounded-full border-2 transition-transform hover:scale-110 flex items-center justify-center",
                        isActive ? 'border-primary' : 'border-transparent'
                      )}
                      style={{ backgroundColor: `hsl(${color.value})` }}
                    >{isActive && <Check className="w-5 h-5 text-primary-foreground" />}</button>
                  )
                })}
              </div>
            </div>
          </SettingsSection>

          {/* Behavior */}
          <SettingsSection icon={<Zap />} title="Behavior">
            {/* Auto Expand Sidebar */}
            <SettingsToggle
              icon={<Eye className="w-4 h-4" />}
              title="Auto Expand Sidebar"
              description="Expand on hover when collapsed"
              checked={shell.autoExpandSidebar}
              onCheckedChange={(payload) => dispatch({ type: 'SET_AUTO_EXPAND_SIDEBAR', payload })}
            />

            {/* Sidebar Width */}
            <div className="space-y-3">
              <div className="flex items-center gap-3">
                <Monitor className="w-4 h-4" />
                <div>
                  <p className="font-medium">Sidebar Width</p>
                  <p className="text-sm text-muted-foreground">{tempSidebarWidth}px</p>
                </div>
              </div>
              <div className="space-y-2">
                <input
                  type="range"
                  min="200"
                  max="500"
                  step="10"
                  value={tempSidebarWidth}
                  onChange={(e) => handleSidebarWidthChange(Number(e.target.value))}
                  className="w-full h-1.5 bg-muted rounded-lg appearance-none cursor-pointer slider"
                />
                <div className="flex justify-between text-xs text-muted-foreground">
                  <span>200px</span>
                  <span>350px</span>
                  <span>500px</span>
                </div>
              </div>
            </div>
          </SettingsSection>

          {/* Accessibility */}
          <SettingsSection icon={<Accessibility />} title="Accessibility">
            {/* Reduced Motion */}
            <SettingsToggle
              icon={<Zap className="w-4 h-4" />}
              title="Reduced Motion"
              description="Minimize animations"
              checked={shell.reducedMotion}
              onCheckedChange={(payload) => dispatch({ type: 'SET_REDUCED_MOTION', payload })}
            />
          </SettingsSection>

          {/* Presets */}
          <div className="space-y-4">
            <h3 className="text-sm font-semibold text-muted-foreground uppercase tracking-wider">
              Quick Presets
            </h3>
            
            <div className="grid grid-cols-2 gap-3">
              <button 
                onClick={() => {
                  setCompactMode(false)
                  setReducedMotion(false)
                  setSidebarWidth(320)
                }}
                className="p-4 bg-accent/30 hover:bg-accent/50 rounded-xl transition-colors text-left"
              >
                <Monitor className="w-4 h-4 mb-2" />
                <p className="font-medium text-sm">Desktop</p>
                <p className="text-xs text-muted-foreground">Spacious layout</p>
              </button>
              
              <button 
                onClick={() => {
                  setCompactMode(true)
                  setReducedMotion(true)
                  setSidebarWidth(240)
                }}
                className="p-4 bg-accent/30 hover:bg-accent/50 rounded-xl transition-colors text-left"
              >
                <Smartphone className="w-4 h-4 mb-2" />
                <p className="font-medium text-sm">Mobile</p>
                <p className="text-xs text-muted-foreground">Compact layout</p>
              </button>
            </div>
          </div>
          <div className="pt-6 border-t border-border">
            <button
              onClick={handleReset}
              className="w-full flex items-center justify-center gap-2 px-4 py-2.5 bg-destructive/10 text-destructive hover:bg-destructive/20 rounded-lg transition-colors"
            >
              <RotateCcw className="w-4 h-4" />
              Reset to Defaults
            </button>
          </div>
        </div>
      )
    }

    // Custom slider styles
    const sliderStyles = `
    .slider::-webkit-slider-thumb {
      appearance: none;
      height: 18px;
      width: 18px;
      border-radius: 50%;
      background: hsl(var(--primary));
      cursor: pointer;
      border: 3px solid hsl(var(--background));
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-top: -7px;
    }

    .slider::-moz-range-thumb {
      height: 18px;
      width: 18px;
      border-radius: 50%;
      background: hsl(var(--primary));
      cursor: pointer;
      border: 3px solid hsl(var(--background));
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    `

    // Inject styles
    if (typeof document !== 'undefined') {
      const styleSheet = document.createElement('style')
      styleSheet.textContent = sliderStyles
      document.head.appendChild(styleSheet)
    }
  src/hooks/useAppShellAnimations.hook.ts: |-
    import { useEffect, useRef } from 'react';
    import { gsap } from 'gsap';
    import { useSearchParams } from 'react-router-dom';
    import { useAppShell } from '@/context/AppShellContext';
    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils';

    function usePrevious<T>(value: T): T | undefined {
      const ref = useRef<T>();
      useEffect(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }

    export function useSidebarAnimations(
      sidebarRef: React.RefObject<HTMLDivElement>,
      resizeHandleRef: React.RefObject<HTMLDivElement>
    ) {
      const { sidebarState, sidebarWidth, bodyState, reducedMotion } = useAppShell();
      const animationDuration = reducedMotion ? 0.1 : 0.4;

      useEffect(() => {
        if (!sidebarRef.current || !resizeHandleRef.current) return;

        const sidebar = sidebarRef.current;
        const handle = resizeHandleRef.current;
        
        let targetWidth = 0;
        let targetOpacity = 1;

        if (bodyState === BODY_STATES.FULLSCREEN) {
          targetWidth = 0;
          targetOpacity = 0;
        } else {
          switch (sidebarState) {
            case SIDEBAR_STATES.HIDDEN:
              targetWidth = 0;
              targetOpacity = 0;
              break;
            case SIDEBAR_STATES.COLLAPSED:
              targetWidth = 64;
              targetOpacity = 1;
              break;
            case SIDEBAR_STATES.EXPANDED:
              targetWidth = sidebarWidth;
              targetOpacity = 1;
              break;
            case SIDEBAR_STATES.PEEK:
              targetWidth = sidebarWidth * 0.8;
              targetOpacity = 0.95;
              break;
          }
        }

        const tl = gsap.timeline({ ease: "power3.out" });
        
        tl.to(sidebar, {
          width: targetWidth,
          opacity: targetOpacity,
          duration: animationDuration,
        });
        tl.to(handle, {
          left: targetWidth,
          duration: animationDuration,
        }, 0);

      }, [sidebarState, sidebarWidth, bodyState, animationDuration, sidebarRef, resizeHandleRef]);
    }

    export function useBodyStateAnimations(
      appRef: React.RefObject<HTMLDivElement>,
      mainContentRef: React.RefObject<HTMLDivElement>,
      rightPaneRef: React.RefObject<HTMLDivElement>,
      topBarContainerRef: React.RefObject<HTMLDivElement>,
      mainAreaRef: React.RefObject<HTMLDivElement>
    ) {
      const { bodyState, reducedMotion, rightPaneWidth, isTopBarVisible, dispatch, fullscreenTarget } = useAppShell();
      const animationDuration = reducedMotion ? 0.1 : 0.4;
      const prevBodyState = usePrevious(bodyState);
      const [, setSearchParams] = useSearchParams();

      useEffect(() => {
        if (!mainContentRef.current || !rightPaneRef.current || !topBarContainerRef.current || !mainAreaRef.current) return;

        const ease = "power3.out";
        const isSidePane = bodyState === BODY_STATES.SIDE_PANE;
        const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;

        // Kill any existing animations on the right pane to prevent conflicts
        gsap.killTweensOf(rightPaneRef.current);

        // Right pane animation
        if (isSidePane) {
          // SHOW AS OVERLAY: Set width immediately, animate transform for performance.
          gsap.set(rightPaneRef.current, { width: rightPaneWidth, x: '0%' });
          gsap.fromTo(rightPaneRef.current, { x: '100%' }, {
              x: '0%',
              duration: animationDuration,
              ease,
          });
        } else if (isSplitView) {
            // SHOW AS SPLIT: Set transform immediately, animate width.
            gsap.set(rightPaneRef.current, { x: '0%' });
            gsap.to(rightPaneRef.current, {
                width: rightPaneWidth,
                duration: animationDuration,
                ease,
            });
        } else {
            // HIDE PANE: Determine how to hide based on the state we are coming FROM.
            if (prevBodyState === BODY_STATES.SIDE_PANE) {
                // It was an overlay, so slide it out.
                gsap.to(rightPaneRef.current, {
              x: '100%',
              duration: animationDuration,
              ease,
                });
            } else { // Covers coming from SPLIT_VIEW, FULLSCREEN, or NORMAL
                // It was docked or fullscreen, so shrink its width.
                gsap.to(rightPaneRef.current, { width: 0, duration: animationDuration, ease });
            }
        }

        // Determine top bar position based on state
        let topBarY = '0%';
        if (bodyState === BODY_STATES.FULLSCREEN) {
          topBarY = '-100%'; // Always hide in fullscreen
        } else if (bodyState === BODY_STATES.NORMAL && !isTopBarVisible) {
          topBarY = '-100%'; // Hide only in normal mode when scrolled
        }

        gsap.to(topBarContainerRef.current, {
          y: topBarY,
          duration: animationDuration,
          ease,
        });
        
        // Add backdrop for side pane
        const backdrop = document.querySelector('.app-backdrop');
        if (isSidePane) { // This is correct because isSidePane is false when bodyState is split_view
          if (!backdrop) {
            const el = document.createElement('div');
            el.className = 'app-backdrop fixed inset-0 bg-black/30 z-[55]';
            appRef.current?.appendChild(el);
            gsap.fromTo(el, { opacity: 0 }, { opacity: 1, duration: animationDuration });
            el.onclick = () => {
              setSearchParams(prev => {
                const newParams = new URLSearchParams(prev);
                newParams.delete('sidePane');
                return newParams;
              }, { replace: true });
            };
          }
        } else {
          if (backdrop) {
            gsap.to(backdrop, { opacity: 0, duration: animationDuration, onComplete: () => backdrop.remove() });
          }
        }
      }, [bodyState, prevBodyState, animationDuration, rightPaneWidth, isTopBarVisible, appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef, fullscreenTarget, dispatch, setSearchParams]);
    }
  src/hooks/useResizablePanes.hook.ts: |-
    import { useEffect } from 'react';
    import { gsap } from 'gsap';
    import { useAppShell } from '@/context/AppShellContext';
    import { BODY_STATES } from '@/lib/utils';

    export function useResizableSidebar(
      sidebarRef: React.RefObject<HTMLDivElement>,
      resizeHandleRef: React.RefObject<HTMLDivElement>
    ) {
      const { isResizing, dispatch } = useAppShell();

      useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
          if (!isResizing) return;

          const newWidth = Math.max(200, Math.min(500, e.clientX));
          dispatch({ type: 'SET_SIDEBAR_WIDTH', payload: newWidth });

          if (sidebarRef.current) {
            gsap.set(sidebarRef.current, { width: newWidth });
          }
          if (resizeHandleRef.current) {
            gsap.set(resizeHandleRef.current, { left: newWidth });
          }
        };

        const handleMouseUp = () => {
          dispatch({ type: 'SET_IS_RESIZING', payload: false });
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        };

        if (isResizing) {
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };
      }, [isResizing, dispatch, sidebarRef, resizeHandleRef]);
    }

    export function useResizableRightPane() {
      const { isResizingRightPane, dispatch, bodyState } = useAppShell();

      useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
          if (!isResizingRightPane) return;

          const newWidth = window.innerWidth - e.clientX;
          if (bodyState === BODY_STATES.SPLIT_VIEW) {
            dispatch({ type: 'SET_SPLIT_PANE_WIDTH', payload: newWidth });
          } else {
            dispatch({ type: 'SET_SIDE_PANE_WIDTH', payload: newWidth });
          }
        };

        const handleMouseUp = () => {
          dispatch({ type: 'SET_IS_RESIZING_RIGHT_PANE', payload: false });
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        };

        if (isResizingRightPane) {
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          document.body.style.cursor = '';
        };
      }, [isResizingRightPane, dispatch, bodyState]);
    }
  src/hooks/useAutoAnimateTopBar.ts: |-
    import { useRef, useCallback, useEffect } from 'react';
    import { useAppShell } from '@/context/AppShellContext';
    import { BODY_STATES } from '@/lib/utils';

    export function useAutoAnimateTopBar(isPane = false) {
      const { dispatch, bodyState } = useAppShell();
      const lastScrollTop = useRef(0);
      const scrollTimeout = useRef<ReturnType<typeof setTimeout> | null>(null);

      const onScroll = useCallback((event: React.UIEvent<HTMLDivElement>) => {
        if (isPane || bodyState === BODY_STATES.SPLIT_VIEW || bodyState === BODY_STATES.FULLSCREEN) return;

        // Clear previous timeout
        if (scrollTimeout.current) {
          clearTimeout(scrollTimeout.current);
        }

        const { scrollTop } = event.currentTarget;
        
        if (scrollTop > lastScrollTop.current && scrollTop > 200) {
          dispatch({ type: 'SET_TOP_BAR_VISIBLE', payload: false });
        } else if (scrollTop < lastScrollTop.current || scrollTop <= 0) {
          dispatch({ type: 'SET_TOP_BAR_VISIBLE', payload: true });
        }
        
        lastScrollTop.current = scrollTop <= 0 ? 0 : scrollTop;

        // Set new timeout to show top bar when scrolling stops
        scrollTimeout.current = setTimeout(() => {
          // Don't hide, just ensure it's visible after scrolling stops
          // and we are not at the top of the page.
          if (scrollTop > 0) {
            dispatch({ type: 'SET_TOP_BAR_VISIBLE', payload: true });
          }
        }, 250); // Adjust timeout as needed
      }, [isPane, dispatch, bodyState]);

      // Cleanup on unmount
      useEffect(() => {
        return () => {
          if (scrollTimeout.current) {
            clearTimeout(scrollTimeout.current);
          }
        };
      }, []);

      return { onScroll };
    }
  src/pages/Dashboard/hooks/useDashboardAnimations.motion.hook.ts: >-
    import { useEffect } from 'react';

    import { gsap } from 'gsap';

    import { useAppShell } from '@/context/AppShellContext';

    import { BODY_STATES } from '@/lib/utils';

    import { useStaggeredAnimation } from
    '@/hooks/useStaggeredAnimation.motion.hook';


    export function useDashboardAnimations(
      contentRef: React.RefObject<HTMLDivElement>,
      statsCardsContainerRef: React.RefObject<HTMLDivElement>,
      featureCardsContainerRef: React.RefObject<HTMLDivElement>,
    ) {
      const { bodyState } = useAppShell();

      // Animate cards on mount
      useStaggeredAnimation(statsCardsContainerRef, [], { y: 20, scale: 0.95 });
      useStaggeredAnimation(featureCardsContainerRef, [], { y: 30, scale: 0.95, stagger: 0.05 });

      useEffect(() => {
        if (!contentRef.current) return;

        const content = contentRef.current;

        switch (bodyState) {
          case BODY_STATES.FULLSCREEN:
            gsap.to(content, { scale: 1.02, duration: 0.4, ease: 'power3.out' });
            break;
          default:
            gsap.to(content, { scale: 1, duration: 0.4, ease: 'power3.out' });
            break;
        }
      }, [bodyState, contentRef]);
    }
  src/components/shared/PageLayout.tsx: |-
    import React from 'react';
    import { cn } from '@/lib/utils';
    import { useAppShell } from '@/context/AppShellContext';

    interface PageLayoutProps extends React.HTMLAttributes<HTMLDivElement> {
      children: React.ReactNode;
      scrollRef?: React.RefObject<HTMLDivElement>;
      isInSidePane?: boolean;
    }

    export const PageLayout = React.forwardRef<HTMLDivElement, PageLayoutProps>(
      ({ children, onScroll, scrollRef, className, isInSidePane = false, ...props }, ref) => {
        const { isTopBarVisible, bodyState } = useAppShell();
        const isFullscreen = bodyState === 'fullscreen';

        return (
          <div
            ref={scrollRef}
            className={cn("h-full overflow-y-auto", className)}
            onScroll={onScroll}
          >
            <div ref={ref} className={cn(
              "space-y-8 transition-all duration-300",
              !isInSidePane ? "px-6 lg:px-12 pb-6" : "px-6 pb-6",
              isTopBarVisible && !isFullscreen ? "pt-24" : "pt-6"
            )}
            {...props}
            >
              {children}
            </div>
          </div>
        );
      }
    );

    PageLayout.displayName = 'PageLayout';
  src/index.ts: >-
    // Context

    export { AppShellProvider, useAppShell } from './context/AppShellContext';


    // Layout Components

    export { AppShell } from './components/layout/AppShell';

    export { MainContent } from './components/layout/MainContent';

    export { ViewModeSwitcher } from './components/layout/ViewModeSwitcher';

    export { RightPane } from './components/layout/RightPane';

    export { TopBar } from './components/layout/TopBar';

    export { UserDropdown } from './components/layout/UserDropdown';

    export { Workspaces as WorkspaceProvider, WorkspaceTrigger, WorkspaceContent
    } from './components/layout/WorkspaceSwitcher';


    // Sidebar Primitives

    export {
      Sidebar,
      SidebarBody,
      SidebarContent,
      SidebarFooter,
      SidebarHeader,
      SidebarSection,
      SidebarTitle,
      SidebarMenuItem,
      SidebarMenuButton,
      SidebarMenuAction,
      SidebarLabel,
      SidebarBadge,
      SidebarTooltip,
      SidebarIcon,
      useSidebar,
    } from './components/layout/Sidebar';


    // Shared Components

    export { ContentInSidePanePlaceholder } from
    './components/shared/ContentInSidePanePlaceholder';

    export { PageHeader } from './components/shared/PageHeader';

    export { PageLayout } from './components/shared/PageLayout';


    // Feature Components

    export { SettingsContent } from './features/settings/SettingsContent';

    export { SettingsSection } from './features/settings/SettingsSection';

    export { SettingsToggle } from './features/settings/SettingsToggle';

    export { LoginPage } from './components/auth/LoginPage';


    // UI Components

    export * from './components/ui/avatar';

    export * from './components/ui/badge';

    export * from './components/ui/button';

    export * from './components/ui/card';

    export * from './components/ui/command';

    export * from './components/ui/dialog';

    export * from './components/ui/dropdown-menu';

    export * from './components/ui/input';

    export * from './components/ui/label';

    export * from './components/ui/popover';

    export * from './components/ui/tabs';

    export * from './components/ui/toast';

    export { AnimatedTabs } from './components/ui/animated-tabs';


    // Effects Components

    export { AnimatedInput } from './components/effects/AnimatedInput';

    export { BottomGradient } from './components/effects/BottomGradient';

    export { BoxReveal } from './components/effects/BoxReveal';

    export { OrbitingCircles, TechOrbitDisplay } from
    './components/effects/OrbitingCircles';

    export { Ripple } from './components/effects/Ripple';



    // Global Components

    export { CommandPalette } from './components/global/CommandPalette';


    // Hooks

    export { useAutoAnimateTopBar } from './hooks/useAutoAnimateTopBar';

    export { useCommandPaletteToggle } from
    './hooks/useCommandPaletteToggle.hook';


    // Lib

    export * from './lib/utils';


    // Store

    export { useAppStore, type ActivePage } from './store/appStore';

    export { useAuthStore } from './store/authStore';
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-10-14T03:21:24.626Z'
status: committed
id: 275
