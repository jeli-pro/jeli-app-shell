uuid: 1d63897b-944e-4f32-8dfc-3331cf11d316
projectId: jeli-app-shell
createdAt: '2025-10-21T13:55:31.675Z'
gitCommitMsg: >-
  feat(detail-panel): implement inline editing and draggable sections

  Overhauls the `DetailPanel` to introduce a Notion-like user experience. Fields
  are now editable inline, with appropriate controls for different data types
  (text, badges, progress, etc.), powered by a new reusable `EditableField`
  component.

  This change also introduces drag-and-drop functionality using `@dnd-kit`,
  allowing users to reorder the sections within the detail panel to customize
  their layout. All data modifications are propagated through the existing
  `onItemUpdate` callback to the Zustand store, ensuring a consistent and
  reactive state management flow.
promptSummary: Implement a Notion-style editable and reorderable detail panel.
reasoning:
  - >-
    Of course. My apologies for the failed patch. The context matching was too
    fragile. I've corrected the diff for `src/pages/DataDemo/index.tsx` to be
    more robust and will now re-apply the full set of changes.
  - >-
    First, I'll add the necessary dependencies for drag-and-drop and the slider
    component.
  - >-
    Next, I'll create the `DraggableSection` component to enable reordering
    within the detail panel.
  - >-
    Now, I'll create the new `EditableField` component. This is the core of the
    inline-editing feature, handling the display-to-edit state transition and
    providing appropriate inputs for different data types.
  - >-
    Next, I'll update the `DetailPanel` to use the new `EditableField` and
    `DraggableSection` components, making it fully interactive.
  - >-
    Finally, I will correctly wire up the `updateItem` function from the data
    store to the `DynamicView` component. This connects our new editable fields
    to the application's state.
operations:
  - type: write
    path: package.json
    content: |
      <<<<<<< SEARCH
        "dependencies": {
          "@faker-js/faker": "^10.1.0",
          "@radix-ui/react-checkbox": "^1.3.3",
          "@radix-ui/react-radio-group": "^1.3.8",
          "@radix-ui/react-separator": "^1.1.7",
          "@radix-ui/react-switch": "^1.2.6",
          "@radix-ui/react-tooltip": "^1.2.8"
        }
      =======
        "dependencies": {
          "@dnd-kit/core": "^6.1.0",
          "@dnd-kit/sortable": "^8.0.0",
          "@faker-js/faker": "^10.1.0",
          "@radix-ui/react-checkbox": "^1.3.3",
          "@radix-ui/react-radio-group": "^1.3.8",
          "@radix-ui/react-separator": "^1.1.7",
          "@radix-ui/react-slider": "^1.2.0",
          "@radix-ui/react-switch": "^1.2.6",
          "@radix-ui/react-tooltip": "^1.2.8"
        }
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/features/dynamic-view/components/shared/DraggableSection.tsx
    content: >-
      import { useSortable } from '@dnd-kit/sortable';

      import { CSS } from '@dnd-kit/utilities';

      import { GripVertical } from 'lucide-react';

      import { cn } from '@/lib/utils';

      import React from 'react';


      interface DraggableSectionProps {
        id: string;
        children: React.ReactNode;
      }


      export function DraggableSection({ id, children }: DraggableSectionProps)
      {
        const {
          attributes,
          listeners,
          setNodeRef,
          transform,
          transition,
          isDragging,
        } = useSortable({ id });

        const style = {
          transform: CSS.Transform.toString(transform),
          transition,
        };

        return (
          <div ref={setNodeRef} style={style} className={cn(isDragging && 'opacity-50 z-50')}>
            <div className="bg-card/30 rounded-2xl border border-border/30 relative group">
              <button
                {...attributes}
                {...listeners}
                className="absolute top-3 -left-7 p-1 text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity cursor-grab active:cursor-grabbing"
              >
                <GripVertical className="w-5 h-5" />
              </button>
              {children}
            </div>
          </div>
        );
      }
    patchStrategy: replace
  - type: write
    path: src/features/dynamic-view/components/shared/EditableField.tsx
    content: >-
      import React, { useState, useRef, useEffect } from 'react';

      import { useDynamicView } from '../../DynamicViewContext';

      import type { GenericItem, ControlOption } from '../../types';

      import { FieldRenderer } from './FieldRenderer';

      import { Input } from '@/components/ui/input';

      import { Textarea } from '@/components/ui/textarea';

      import { Popover, PopoverContent, PopoverTrigger } from
      '@/components/ui/popover';

      import { Command, CommandGroup, CommandItem, CommandList } from
      '@/components/ui/command';

      import { Slider } from '@/components/ui/slider';

      import { cn, getNestedValue } from '@/lib/utils';

      import { mockDataItems } from '@/pages/DataDemo/data/mockData';


      interface EditableFieldProps<TFieldId extends string, TItem extends
      GenericItem> {
        item: TItem;
        fieldId: TFieldId;
        className?: string;
        options?: Record<string, any>;
      }


      // Mock user list for assignee field

      const userList = Array.from(new Set(mockDataItems.map(i =>
      i.assignee.email)))
        .map(email => mockDataItems.find(i => i.assignee.email === email)?.assignee)
        .filter(Boolean) as { name: string; email: string; avatar: string }[];


      export function EditableField<TFieldId extends string, TItem extends
      GenericItem>({
        item,
        fieldId,
        className,
        options,
      }: EditableFieldProps<TFieldId, TItem>) {
        const { config, getFieldDef, onItemUpdate } = useDynamicView<TFieldId, TItem>();
        const [isEditing, setIsEditing] = useState(false);
        const fieldDef = getFieldDef(fieldId);
        const value = getNestedValue(item, fieldId);
        const inputRef = useRef<HTMLInputElement | HTMLTextAreaElement>(null);

        useEffect(() => {
          if (isEditing && (fieldDef?.type === 'string' || fieldDef?.type === 'longtext' || fieldDef?.type === 'thumbnail')) {
            inputRef.current?.focus();
            inputRef.current?.select();
          }
        }, [isEditing, fieldDef]);

        if (!fieldDef || !onItemUpdate) {
          return <FieldRenderer item={item} fieldId={fieldId} className={className} options={options} />;
        }

        const handleUpdate = (newValue: any) => {
          if (value !== newValue) {
            onItemUpdate(item.id, { [fieldId]: newValue } as Partial<TItem>);
          }
          setIsEditing(false);
        };

        const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement | HTMLTextAreaElement>) => {
          if (e.key === 'Enter' && !(e.currentTarget instanceof HTMLTextAreaElement)) {
            handleUpdate(e.currentTarget.value);
          }
          if (e.key === 'Escape') {
            setIsEditing(false);
          }
        };

        const renderEditComponent = () => {
          switch (fieldDef.type) {
            case 'string':
            case 'thumbnail': // For emoji
              return (
                <Input
                  ref={inputRef as React.Ref<HTMLInputElement>}
                  type="text"
                  defaultValue={value}
                  onBlur={(e) => handleUpdate(e.target.value)}
                  onKeyDown={handleKeyDown}
                  className="w-full h-auto p-0 bg-transparent border-none focus-visible:ring-0 focus-visible:ring-offset-0"
                />
              );
            case 'longtext':
              return (
                <Textarea
                  ref={inputRef as React.Ref<HTMLTextAreaElement>}
                  defaultValue={value}
                  onBlur={(e) => handleUpdate(e.target.value)}
                  onKeyDown={handleKeyDown}
                  className="text-sm w-full p-0 bg-transparent border-none focus-visible:ring-0 focus-visible:ring-offset-0"
                />
              );
            case 'badge': {
              const filterableField = config.filterableFields.find((f) => f.id === fieldId);
              const badgeOptions: readonly ControlOption<string>[] = filterableField?.options || [];

              return (
                <Popover open={isEditing} onOpenChange={setIsEditing}>
                  <PopoverTrigger asChild>
                    <button className="w-full text-left" onClick={() => setIsEditing(true)}>
                      <FieldRenderer item={item} fieldId={fieldId} className={className} options={options} />
                    </button>
                  </PopoverTrigger>
                  <PopoverContent className="p-0 w-[200px]" align="start">
                    <Command>
                      <CommandList>
                        <CommandGroup>
                          {badgeOptions.map((option) => (
                            <CommandItem
                              key={option.id}
                              onSelect={() => handleUpdate(option.id)}
                            >
                              {option.label}
                            </CommandItem>
                          ))}
                        </CommandGroup>
                      </CommandList>
                    </Command>
                  </PopoverContent>
                </Popover>
              );
            }
            case 'progress': {
              const progressValue = typeof value === 'number' ? value : 0;
              return (
                 <div className="flex items-center gap-3 py-2 w-full">
                  <Slider
                    value={[progressValue]}
                    max={100}
                    step={1}
                    onValueCommit={(val) => handleUpdate(val[0])}
                    className="flex-1"
                  />
                  <span className="text-sm font-medium text-muted-foreground w-10 text-right">{progressValue}%</span>
                 </div>
              );
            }
            case 'avatar': {
              return (
                <Popover open={isEditing} onOpenChange={setIsEditing}>
                  <PopoverTrigger asChild>
                    <button className="w-full text-left" onClick={() => setIsEditing(true)}>
                      <FieldRenderer item={item} fieldId={fieldId} className={className} options={options} />
                    </button>
                  </PopoverTrigger>
                  <PopoverContent className="p-0 w-[250px]" align="start">
                    <Command>
                      <CommandList>
                        <CommandGroup>
                          {userList.map((user) => (
                            <CommandItem key={user.email} onSelect={() => handleUpdate(user)}>
                                <FieldRenderer item={{ assignee: user } as TItem} fieldId={'assignee' as TFieldId} />
                            </CommandItem>
                          ))}
                        </CommandGroup>
                      </CommandList>
                    </Command>
                  </PopoverContent>
                </Popover>
              );
            }
            case 'date': {
              return (
                <Input
                  type="date"
                  defaultValue={value ? new Date(value).toISOString().split('T')[0] : ''}
                  onChange={(e) => {
                    const date = e.target.valueAsDate;
                    if (date) {
                      // preserve time if exists
                      const originalDate = value ? new Date(value) : new Date();
                      date.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds());
                      handleUpdate(date.toISOString());
                    }
                  }}
                  className="h-8"
                />
              )
            }
            // TODO: Add tags editor
            default:
              return <FieldRenderer item={item} fieldId={fieldId} className={className} options={options} />;
          }
        };

        if (['badge', 'avatar'].includes(fieldDef.type)) {
          return renderEditComponent();
        }

        if (fieldDef.type === 'progress') {
            return renderEditComponent();
        }

        return (
          <div className={cn("w-full group", className)} onClick={() => !isEditing && setIsEditing(true)}>
            {isEditing ? (
              renderEditComponent()
            ) : (
              <div className={cn(
                "hover:bg-accent/50 rounded-md transition-colors cursor-text min-h-[32px] w-full",
                 fieldDef.type === 'longtext' ? 'py-1 flex items-start' : 'flex items-center'
              )}>
                  <FieldRenderer item={item} fieldId={fieldId} options={options} />
              </div>
            )}
          </div>
        );
      }
    patchStrategy: replace
  - type: write
    path: src/features/dynamic-view/components/shared/DetailPanel.tsx
    content: >
      --- src/features/dynamic-view/components/shared/DetailPanel.tsx

      +++ src/features/dynamic-view/components/shared/DetailPanel.tsx

      @@ -1,15 +1,28 @@

      -import React, { useRef } from 'react'

      +import React, { useRef, useState, useMemo } from 'react'

      +import {

      +  DndContext,

      +  closestCenter,

      +  type DragEndEvent,

      +} from '@dnd-kit/core';

      +import {

      +  arrayMove,

      +  SortableContext,

      +  verticalListSortingStrategy,

      +} from '@dnd-kit/sortable';
       import {
         Clock, 
         Tag,
         User,
         BarChart3,
       } from 'lucide-react'
      -import type { GenericItem, DetailViewConfig } from '../../types'

      +import type { GenericItem, DetailViewConfig, DetailViewSection } from
      '../../types'
       import { useStaggeredAnimation } from '@/hooks/useStaggeredAnimation.motion.hook';
      -import { FieldRenderer } from
      '@/features/dynamic-view/components/shared/FieldRenderer'

      +import { EditableField } from './EditableField'

      +import { DraggableSection } from './DraggableSection'
       import { getNestedValue } from '@/lib/utils'
      +import { useDynamicView } from '../../DynamicViewContext'
       
       interface DetailPanelProps<TFieldId extends string, TItem extends GenericItem> {
         item: TItem;
      @@ -25,59 +38,81 @@
       export function DetailPanel<TFieldId extends string, TItem extends GenericItem>({ item, config }: DetailPanelProps<TFieldId, TItem>) {
         const contentRef = useRef<HTMLDivElement>(null)
         useStaggeredAnimation(contentRef, [item]);
      +  

      +  const { header, body } = config;

      +  const [sections, setSections] = useState(body.sections);

      +

      +  const sectionIds = useMemo(() => sections.map(s => s.title),
      [sections]);

      +

      +  const handleDragEnd = (event: DragEndEvent) => {

      +    const { active, over } = event;

      +    if (active.id !== over?.id) {

      +      setSections((currentSections) => {

      +        const oldIndex = sectionIds.indexOf(active.id as string);

      +        const newIndex = sectionIds.indexOf(over!.id as string);

      +        return arrayMove(currentSections, oldIndex, newIndex);

      +      });

      +    }

      +  };
       
         if (!item) {
           return null
         }
         
      -  const { header, body } = config;

      -
         return (
           <div ref={contentRef} className="h-full flex flex-col">
             {/* Header */}
             <div className="p-6 border-b border-border/50 bg-gradient-to-r from-card/50 to-card/30 backdrop-blur-sm">
               <div className="flex items-start gap-4 mb-4">
      -          <div className="w-16 h-16 bg-gradient-to-br from-primary/20
      to-primary/10 rounded-2xl flex items-center justify-center text-3xl
      flex-shrink-0">

      -            <FieldRenderer item={item} fieldId={header.thumbnailField} />

      +          <div className="w-16 h-16 rounded-2xl flex items-center
      justify-center text-3xl flex-shrink-0">

      +             <EditableField item={item} fieldId={header.thumbnailField}
      />
                 </div>
                 <div className="flex-1 min-w-0">
      -            <h1 className="text-2xl font-bold mb-2 leading-tight">

      -              <FieldRenderer item={item} fieldId={header.titleField} />

      +            <h1 className="text-2xl font-bold mb-1 leading-tight">

      +              <EditableField item={item} fieldId={header.titleField} />
                   </h1>
                   <p className="text-muted-foreground">
      -              <FieldRenderer item={item}
      fieldId={header.descriptionField} />

      +              <EditableField item={item}
      fieldId={header.descriptionField} />
                   </p>
                 </div>
               </div>
       
               {/* Status badges */}
               <div className="flex items-center gap-2 flex-wrap mb-4">
                 {header.badgeFields.map((fieldId: TFieldId) => (
      -            <FieldRenderer key={fieldId} item={item} fieldId={fieldId} />

      +            <EditableField key={fieldId} item={item} fieldId={fieldId} />
                 ))}
               </div>
       
               {/* Progress */}
      -        <FieldRenderer item={item} fieldId={header.progressField}
      options={{ showPercentage: true }} />

      +        <EditableField item={item} fieldId={header.progressField}
      options={{ showPercentage: true }} />
             </div>
       
             {/* Content */}
             <div className="flex-1 overflow-y-auto">
               <div className="p-6 space-y-6">
      -          {body.sections.map((section) => {

      -            const IconComponent = SECTION_ICONS[section.title];

      -            // Render section only if at least one of its fields has a
      value

      -            const hasContent = section.fields.some((fieldId: TFieldId) =>
      {

      -              const value = getNestedValue(item, fieldId as string);

      -              return value !== null && typeof value !== 'undefined';

      -            });

      +          <DndContext

      +            collisionDetection={closestCenter}

      +            onDragEnd={handleDragEnd}

      +          >

      +            <SortableContext

      +              items={sectionIds}

      +              strategy={verticalListSortingStrategy}

      +            >

      +              {sections.map((section) => {

      +                const IconComponent = SECTION_ICONS[section.title];

      +                const hasContent = section.fields.some((fieldId:
      TFieldId) => {

      +                  const value = getNestedValue(item, fieldId as string);

      +                  return value !== null && typeof value !== 'undefined';

      +                });
       
      -            if (!hasContent) return null;

      +                if (!hasContent) return null;
       
      -            return (

      -              <div key={section.title} className="bg-card/30 rounded-2xl
      p-4 border border-border/30">

      -                <div className="flex items-center gap-1 mb-3">

      -                  {IconComponent && <IconComponent className="w-4 h-4
      text-muted-foreground" />}

      -                  <h3 className="font-semibold
      text-sm">{section.title}</h3>

      -                </div>

      -                <div className="space-y-3">

      -                  {section.fields.map((fieldId: TFieldId) => (

      -                    <FieldRenderer key={fieldId} item={item}
      fieldId={fieldId} options={{ avatarClassName: "w-12 h-12" }} />

      -                  ))}

      +                return (

      +                  <DraggableSection key={section.title}
      id={section.title}>

      +                    <div className="p-4">

      +                      <div className="flex items-center gap-1 mb-3">

      +                        {IconComponent && <IconComponent className="w-4
      h-4 text-muted-foreground" />}

      +                        <h3 className="font-semibold
      text-sm">{section.title}</h3>

      +                      </div>

      +                      <div className="space-y-3">

      +                        {section.fields.map((fieldId: TFieldId) => (

      +                          <EditableField key={fieldId} item={item}
      fieldId={fieldId} options={{ avatarClassName: "w-12 h-12" }} />

      +                        ))}

      +                      </div>

      +                    </div>

      +                  </DraggableSection>

      +                );

      +              })}

      +            </SortableContext>

      +          </DndContext>

      -                </div>

      -              </div>

      -            );

      -          })}
               </div>
             </div>
           </div>
         )
       }
    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: |
      --- src/pages/DataDemo/index.tsx
      +++ src/pages/DataDemo/index.tsx
      @@ -10,7 +10,6 @@
       import { useScrollToBottom } from "@/hooks/useScrollToBottom.hook";
       import { ScrollToBottomButton } from "@/components/shared/ScrollToBottomButton";
       import { mockDataItems } from "./data/mockData";
       import { useAppViewManager } from "@/hooks/useAppViewManager.hook";
       import { useDataDemoStore } from "./store/dataDemo.store";
      -import {} from "./store/dataDemo.store";
       import { AddDataItemCta } from "@/features/dynamic-view/components/shared/AddDataItemCta";
       
       import { dataDemoViewConfig } from "./DataDemo.config";
      @@ -35,6 +34,7 @@
           isInitialLoading,
           totalItemCount,
           loadData,
      +    updateItem,
         } = useDataDemoStore((state) => ({
           items: state.items,
           hasMore: state.hasMore,
      @@ -42,6 +42,7 @@
           isInitialLoading: state.isInitialLoading,
           totalItemCount: state.totalItemCount,
           loadData: state.loadData,
      +    updateItem: state.updateItem,
         }));
       
         const scrollRef = useRef<HTMLDivElement>(null);
      @@ -155,6 +156,7 @@
               onGroupByChange={setGroupBy}
               onActiveGroupTabChange={setActiveGroupTab}
               onPageChange={setPage}
      +        onItemUpdate={updateItem}
               onItemSelect={onItemSelect}
               loaderRef={loaderRef}
               scrollContainerRef={scrollRef}
    patchStrategy: standard-diff
snapshot:
  src/features/dynamic-view/components/shared/DraggableSection.tsx: null
  src/features/dynamic-view/components/shared/EditableField.tsx: null
  package.json: |
    {
      "name": "jeli-app-shell",
      "private": false,
      "version": "1.0.1",
      "type": "module",
      "files": [
        "dist"
      ],
      "main": "./dist/jeli-app-shell.umd.js",
      "module": "./dist/jeli-app-shell.es.js",
      "types": "./dist/index.d.ts",
      "exports": {
        ".": {
          "import": "./dist/jeli-app-shell.es.js",
          "require": "./dist/jeli-app-shell.umd.js"
        },
        "./dist/style.css": "./dist/style.css"
      },
      "sideEffects": [
        "**/*.css"
      ],
      "scripts": {
        "dev": "vite",
        "build": "tsc && vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview"
      },
      "peerDependencies": {
        "@iconify/react": "^4.1.1",
        "@radix-ui/react-avatar": "^1.0.4",
        "@radix-ui/react-dialog": "^1.0.5",
        "@radix-ui/react-dropdown-menu": "^2.0.6",
        "@radix-ui/react-label": "^2.1.7",
        "@radix-ui/react-popover": "^1.0.7",
        "@radix-ui/react-scroll-area": "^1.2.10",
        "@radix-ui/react-slot": "^1.0.2",
        "@radix-ui/react-tabs": "^1.0.4",
        "class-variance-authority": "^0.7.0",
        "clsx": "^2.0.0",
        "cmdk": "^0.2.0",
        "date-fns": "^3.6.0",
        "gsap": "^3.13.0",
        "lucide-react": "^0.294.0",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.22.3",
        "sonner": "^1.2.4",
        "tailwind-merge": "^2.0.0",
        "tailwindcss": "^3.3.5",
        "zustand": "^4.5.7"
      },
      "devDependencies": {
        "@types/node": "^20.10.0",
        "@types/react": "^18.2.37",
        "@types/react-dom": "^18.2.15",
        "@typescript-eslint/eslint-plugin": "^6.10.0",
        "@typescript-eslint/parser": "^6.10.0",
        "@vitejs/plugin-react": "^4.1.1",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.53.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.4",
        "postcss": "^8.4.31",
        "tailwindcss": "^3.3.5",
        "tailwindcss-animate": "^1.0.7",
        "typescript": "^5.2.2",
        "vite": "^4.5.0"
      },
      "dependencies": {
        "@faker-js/faker": "^10.1.0",
        "@radix-ui/react-checkbox": "^1.3.3",
        "@radix-ui/react-radio-group": "^1.3.8",
        "@radix-ui/react-separator": "^1.1.7",
        "@radix-ui/react-switch": "^1.2.6",
        "@radix-ui/react-tooltip": "^1.2.8"
      }
    }
  src/features/dynamic-view/components/shared/DetailPanel.tsx: >-
    import React, { useRef } from 'react'

    import {
      Clock, 
      Tag,
      User,
      BarChart3,
    } from 'lucide-react'

    import type { GenericItem, DetailViewConfig } from '../../types'

    import { useStaggeredAnimation } from
    '@/hooks/useStaggeredAnimation.motion.hook';

    import { FieldRenderer } from
    '@/features/dynamic-view/components/shared/FieldRenderer'

    import { getNestedValue } from '@/lib/utils'


    interface DetailPanelProps<TFieldId extends string, TItem extends
    GenericItem> {
      item: TItem;
      config: DetailViewConfig<TFieldId>;
    }


    const SECTION_ICONS: Record<string, React.ElementType> = {
      "Assigned to": User,
      "Engagement Metrics": BarChart3,
      "Tags": Tag,
      "Timeline": Clock,
    };


    export function DetailPanel<TFieldId extends string, TItem extends
    GenericItem>({ item, config }: DetailPanelProps<TFieldId, TItem>) {
      const contentRef = useRef<HTMLDivElement>(null)
      useStaggeredAnimation(contentRef, [item]);

      if (!item) {
        return null
      }
      
      const { header, body } = config;

      return (
        <div ref={contentRef} className="h-full flex flex-col">
          {/* Header */}
          <div className="p-6 border-b border-border/50 bg-gradient-to-r from-card/50 to-card/30 backdrop-blur-sm">
            <div className="flex items-start gap-4 mb-4">
              <div className="w-16 h-16 bg-gradient-to-br from-primary/20 to-primary/10 rounded-2xl flex items-center justify-center text-3xl flex-shrink-0">
                <FieldRenderer item={item} fieldId={header.thumbnailField} />
              </div>
              <div className="flex-1 min-w-0">
                <h1 className="text-2xl font-bold mb-2 leading-tight">
                  <FieldRenderer item={item} fieldId={header.titleField} />
                </h1>
                <p className="text-muted-foreground">
                  <FieldRenderer item={item} fieldId={header.descriptionField} />
                </p>
              </div>
            </div>

            {/* Status badges */}
            <div className="flex items-center gap-2 flex-wrap mb-4">
              {header.badgeFields.map((fieldId: TFieldId) => (
                <FieldRenderer key={fieldId} item={item} fieldId={fieldId} />
              ))}
            </div>

            {/* Progress */}
            <FieldRenderer item={item} fieldId={header.progressField} options={{ showPercentage: true }} />
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto">
            <div className="p-6 space-y-6">
              {body.sections.map((section) => {
                const IconComponent = SECTION_ICONS[section.title];
                // Render section only if at least one of its fields has a value
                const hasContent = section.fields.some((fieldId: TFieldId) => {
                  const value = getNestedValue(item, fieldId as string);
                  return value !== null && typeof value !== 'undefined';
                });

                if (!hasContent) return null;

                return (
                  <div key={section.title} className="bg-card/30 rounded-2xl p-4 border border-border/30">
                    <div className="flex items-center gap-1 mb-3">
                      {IconComponent && <IconComponent className="w-4 h-4 text-muted-foreground" />}
                      <h3 className="font-semibold text-sm">{section.title}</h3>
                    </div>
                    <div className="space-y-3">
                      {section.fields.map((fieldId: TFieldId) => (
                        <FieldRenderer key={fieldId} item={item} fieldId={fieldId} options={{ avatarClassName: "w-12 h-12" }} />
                      ))}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      )
    }
  src/pages/DataDemo/index.tsx: >
    import { useRef, useEffect, useCallback } from "react";

    import {
      Layers,
      AlertTriangle,
      PlayCircle,
      TrendingUp,
      CheckCircle,
      Clock,
      Archive,
      PlusCircle,
    } from "lucide-react";

    import { DynamicView } from "@/features/dynamic-view/DynamicView";

    import { PageLayout } from "@/components/shared/PageLayout";

    import { useScrollToBottom } from "@/hooks/useScrollToBottom.hook";

    import { ScrollToBottomButton } from
    "@/components/shared/ScrollToBottomButton";

    import { mockDataItems } from "./data/mockData";

    import { useAppViewManager } from "@/hooks/useAppViewManager.hook";

    import { useDataDemoStore } from "./store/dataDemo.store";

    import {} from "./store/dataDemo.store";

    import { AddDataItemCta } from
    "@/features/dynamic-view/components/shared/AddDataItemCta";


    import { dataDemoViewConfig } from "./DataDemo.config";

    import type { StatItem } from "@/features/dynamic-view/types";


    export default function DataDemoPage() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
        setFilters,
        setViewMode,
        onItemSelect,
      } = useAppViewManager();

      const {
        items: allItems,
        hasMore,
        isLoading,
        isInitialLoading,
        totalItemCount,
        loadData,
      } = useDataDemoStore((state) => ({
        items: state.items,
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
      }));

      const scrollRef = useRef<HTMLDivElement>(null);

      // Note: The `DynamicViewProvider` needs `GenericItem[]`.
      // Our store uses `GenericItem` so no cast is needed.

      // Calculate stats from data
      const totalItems = mockDataItems.length;
      const { showScrollToBottom, scrollToBottom, handleScroll } =
        useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(
        (item) => item.status === "active",
      ).length;
      const highPriorityItems = mockDataItems.filter(
        (item) => item.priority === "high" || item.priority === "critical",
      ).length;
      const avgCompletion =
        totalItems > 0
          ? Math.round(
              mockDataItems.reduce(
                (acc, item) => acc + item.metrics.completion,
                0,
              ) / totalItems,
            )
          : 0;

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          chartData: [120, 125, 122, 130, 135, 138, 142],
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week",
          trend: "up" as const,
          chartData: [45, 50, 48, 55, 53, 60, 58],
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          chartData: [25, 26, 28, 27, 26, 24, 23],
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          chartData: [65, 68, 70, 69, 72, 75, 78],
        },
        {
          title: "Completion Rate",
          value: "88%",
          icon: <CheckCircle className="w-5 h-5" />,
          change: "+1.5% this month",
          trend: "up" as const,
          chartData: [80, 82, 81, 84, 85, 87, 88],
        },
        {
          title: "Overdue Items",
          value: "8",
          icon: <Clock className="w-5 h-5" />,
          change: "-3 this week",
          trend: "down" as const,
        },
        {
          title: "New This Week",
          value: "12",
          icon: <PlusCircle className="w-5 h-5" />,
          change: "+2 from last week",
          trend: "up" as const,
        },
        {
          title: "Archived Projects",
          value: "153",
          icon: <Archive className="w-5 h-5" />,
          change: "+20 this month",
          trend: "up" as const,
        },
      ];

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === "calendar" || viewMode === "kanban",
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );

      useEffect(() => {
        // Auto-group by status when switching to kanban view for the first time
        if (viewMode === "kanban" && groupBy === "none") {
          setGroupBy("status");
          setSort(null); // Kanban is manually sorted, so disable programmatic sort
        }
        // For calendar view, we don't want grouping.
        else if (viewMode === "calendar" && groupBy !== "none") {
          setGroupBy("none");
        }
      }, [viewMode, groupBy, setGroupBy, setSort]);

      return (
        <PageLayout scrollRef={scrollRef} onScroll={handleScroll}>
          <DynamicView
            viewConfig={dataDemoViewConfig}
            items={allItems}
            isLoading={isLoading}
            isInitialLoading={isInitialLoading}
            totalItemCount={totalItemCount}
            hasMore={hasMore}
            // Controlled state
            viewMode={viewMode}
            filters={filters}
            sortConfig={sortConfig}
            groupBy={groupBy}
            activeGroupTab={activeGroupTab}
            page={page}
            // Callbacks
            onViewModeChange={setViewMode}
            onFiltersChange={setFilters}
            onSortChange={setSort}
            onGroupByChange={setGroupBy}
            onActiveGroupTabChange={setActiveGroupTab}
            onPageChange={setPage}
            onItemSelect={onItemSelect}
            loaderRef={loaderRef}
            scrollContainerRef={scrollRef}
            statsData={stats}
            // Custom Renderers
            renderCta={(viewMode, ctaProps) => (
              <AddDataItemCta viewMode={viewMode} colSpan={ctaProps.colSpan} />
            )}
          />

          <ScrollToBottomButton
            isVisible={showScrollToBottom}
            onClick={scrollToBottom}
          />
        </PageLayout>
      );
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 552
