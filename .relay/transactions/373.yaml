uuid: d166e5a0-b54c-471a-8b1b-4f968c92817d
projectId: jeli-app-shell
createdAt: '2025-10-16T23:04:03.916Z'
gitCommitMsg: >-
  feat(layout): replace right pane controls with ViewModeSwitcher

  Replaces the existing view mode buttons in the RightPane header with the more
  comprehensive ViewModeSwitcher component.

  - The ViewModeSwitcher is updated to accept string `targetPage` props,
  enabling it to work with dynamic routes found in detail views. - The RightPane
  now conditionally renders the ViewModeSwitcher in its header when it's in
  overlay mode (`SIDE_PANE`) or when its content is fullscreen, ensuring a
  consistent UX and providing a way to exit fullscreen. - The RightPane
  container is made a positioned parent to correctly anchor the absolutely
  positioned switcher during fullscreen mode.
promptSummary: >-
  The user wants to replace the current view mode controls in the RightPane's
  overlay header with the `ViewModeSwitcher` component. This requires updating
  the switcher to handle dynamic routes and ensuring it functions correctly for
  all view modes, especially normal and fullscreen, when initiated from the side
  pane.
reasoning:
  - >-
    I will refactor the right-side pane to enhance user experience by replacing
    the basic view control buttons with the more comprehensive
    `ViewModeSwitcher` component. This change will apply when the `RightPane` is
    in its overlay mode and also ensures functionality during fullscreen mode.
  - >-
    First, I'll update the `ViewModeSwitcher` component to accept dynamic URL
    paths (as strings) instead of a static `ActivePage` type. This allows it to
    work correctly with detail views commonly displayed in the `RightPane`.
  - >-
    Next, I'll integrate this enhanced `ViewModeSwitcher` into the `RightPane`
    header. It will replace the old buttons for switching to split-view or
    fullscreen, and it will be conditionally rendered. The rendering logic will
    ensure it appears both when the pane is an overlay and when its content is
    in fullscreen mode, allowing users to exit fullscreen. I'll also make a
    small adjustment to the `RightPane`'s container to correctly position the
    switcher in fullscreen mode.
  - '### Part 1: Enhance ViewModeSwitcher Flexibility'
  - >-
    I'll modify `ViewModeSwitcher.tsx` to handle string paths for its
    `targetPage` prop, making it compatible with dynamic routes.
  - '### Part 2: Integrate ViewModeSwitcher into RightPane'
  - >-
    Now I'll replace the old header controls in `RightPane.tsx` with the new,
    more powerful `ViewModeSwitcher`. The logic will ensure it's displayed
    correctly in both overlay and fullscreen modes.
operations:
  - type: write
    path: src/components/layout/ViewModeSwitcher.tsx
    content: >+
      --- src/components/layout/ViewModeSwitcher.tsx

      +++ src/components/layout/ViewModeSwitcher.tsx

      @@ -14,28 +14,27 @@
         SplitSquareHorizontal,
       } from 'lucide-react';
       import { useLocation } from 'react-router-dom';
      -import { ActivePage } from '..';
       import {
         Tooltip,
         TooltipContent,
         TooltipProvider,
         TooltipTrigger,
       } from '../ui/tooltip';
       
       interface ViewModeSwitcherProps {
         pane: PaneName;
      -  targetPage?: ActivePage;

      +  targetPage?: string;
       }
       
       const ViewModeSwitcher = ({ pane, targetPage }: ViewModeSwitcherProps) => {
         const { handlePaneClick } = useAppViewManager();
         const location = useLocation();
      -  const activePage = targetPage || (location.pathname.substring(1) as
      ActivePage);

      +  const activePage = targetPage || location.pathname.substring(1);
       
         const bodyState = useAppShell((state) => state.bodyState);
         const leftPaneState = useAppShell((state) => state.leftPaneState);
         const rightPaneState = useAppShell((state) => state.rightPaneState);
       
         const paneState = pane === 'left' ? leftPaneState : rightPaneState;
       
      -  const paneContent = pageToPaneMap[activePage];

      +  const basePage = activePage.split('/')[0];

      +  const paneContent = pageToPaneMap[basePage as keyof typeof
      pageToPaneMap];
       
         const isFullscreen =
           paneState === PANE_STATES.PANE_CONTENT_FULLSCREEN &&

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/RightPane.tsx
    content: >+
      --- src/components/layout/RightPane.tsx

      +++ src/components/layout/RightPane.tsx

      @@ -1,69 +1,48 @@
       import { useAppShell } from '@/hooks/useAppShell.hook';
       import { useRightPaneContent } from '@/hooks/useRightPaneContent.hook';
       import { cn } from '@/lib/utils';
      -import { BODY_STATES } from '@/store/appShell.store';

      -import {

      -  ChevronsLeftRight,

      -  ChevronsRightLeft,

      -  Layers,

      -  SplitSquareHorizontal,

      -  X,

      -} from 'lucide-react';

      +import { BODY_STATES, PANE_STATES } from '@/store/appShell.store';

      +import { ChevronsRightLeft, X } from 'lucide-react';
       import { useMemo } from 'react';
      +import ViewModeSwitcher from './ViewModeSwitcher';
       
       const RightPane = () => {
         const { Component, meta } = useRightPaneContent();
         const bodyState = useAppShell((state) => state.bodyState);
      -  const { toggleRightPane, setBodyState, setRightPaneState } =
      useAppShell(

      -    (state) => ({

      -      toggleRightPane: state.toggleRightPane,

      -      setBodyState: state.setBodyState,

      -      setRightPaneState: state.setRightPaneState,

      -    }),

      -  );

      +  const { toggleRightPane, rightPaneState } = useAppShell((state) => ({

      +    toggleRightPane: state.toggleRightPane,

      +    rightPaneState: state.rightPaneState,

      +  }));
       
         const header = useMemo(() => {
           if (!meta || !('title' in meta)) return null;
           return (
             <div className="flex items-center justify-between p-2 border-b">
               <div className="font-semibold">{meta.title}</div>
               <div className="flex items-center gap-1">
      -          {bodyState === BODY_STATES.SIDE_PANE && 'page' in meta &&
      meta.page && (

      -            <>

      -              <button

      -                className="p-1.5 rounded hover:bg-accent"

      -                onClick={() => {

      -                  setBodyState(BODY_STATES.SPLIT);

      -                  if (meta.page) {

      -                    setRightPaneState({

      -                      isOpen: true,

      -                      content: meta.page,

      -                    });

      -                  }

      -                }}

      -              >

      -                <SplitSquareHorizontal size={16} />

      -              </button>

      -              <button

      -                className="p-1.5 rounded hover:bg-accent"

      -                onClick={() => {

      -                  setBodyState(BODY_STATES.FULL);

      -                  if (meta.page) {

      -                    setRightPaneState({

      -                      isOpen: true,

      -                      content: meta.page,

      -                    });

      -                  }

      -                }}

      -              >

      -                <ChevronsLeftRight size={16} />

      -              </button>

      -            </>

      +          {'page' in meta &&

      +            meta.page &&

      +            (bodyState === BODY_STATES.SIDE_PANE ||

      +              rightPaneState.state ===
      PANE_STATES.PANE_CONTENT_FULLSCREEN) && (

      +              <ViewModeSwitcher pane="right" targetPage={meta.page} />

      +            )}

      +

      +          <button

      +            className="p-1.5 rounded hover:bg-accent"

      +            onClick={() => toggleRightPane(false)}

      +          >

      +            {bodyState === BODY_STATES.SIDE_PANE ? (

      +              <X size={16} />

      +            ) : (

      +              <ChevronsRightLeft size={16} />

      +            )}

      +          </button>

      +        </div>

      +      </div>

      +    );

      +  }, [meta, bodyState, toggleRightPane, rightPaneState]);
       
      -          <button className="p-1.5 rounded hover:bg-accent">

      -            <Layers size={16} />

      -          </button>

      -          <button

      -            className="p-1.5 rounded hover:bg-accent"

      -            onClick={() => toggleRightPane(false)}

      -          >

      -            {bodyState === BODY_STATES.SIDE_PANE ? (

      -              <X size={16} />

      -            ) : (

      -              <ChevronsRightLeft size={16} />

      -            )}

      -          </button>

      -        </div>

      -      </div>

      -    );

      -  }, [meta, bodyState, setBodyState, setRightPaneState,
      toggleRightPane]);

      -
         if (!Component) return null;
       
         return (
           <div
             className={cn(
      -        'h-full flex flex-col',

      +        'h-full flex flex-col relative',
               bodyState === BODY_STATES.SIDE_PANE &&
                 'absolute top-0 right-0 h-full w-[400px] bg-background border-l shadow-lg z-20',
             )}

    patchStrategy: standard-diff
snapshot:
  src/components/layout/RightPane.tsx: >-
    import { forwardRef, useMemo, useCallback, createElement, memo } from
    'react'

    import {
      ChevronRight,
      X,
      Layers,
      SplitSquareHorizontal,
      ChevronsLeftRight,
    } from 'lucide-react'

    import { cn, BODY_STATES } from '@/lib/utils';

    import { useAppShellStore } from '@/store/appShell.store';

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { useRightPaneContent } from '@/hooks/useRightPaneContent.hook'


    export const RightPane = memo(forwardRef<HTMLDivElement, { className?:
    string }>(({ className }, ref) => {
      const fullscreenTarget = useAppShellStore(s => s.fullscreenTarget)
      const bodyState = useAppShellStore(s => s.bodyState)
      const { toggleFullscreen, setIsResizingRightPane } =
        useAppShellStore.getState()

      const viewManager = useAppViewManager()
      const { sidePaneContent, closeSidePane, toggleSplitView, navigateTo } = viewManager
      
      const { meta, content: children } = useRightPaneContent(sidePaneContent)
      
      const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;
      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;

      const handleMaximize = useCallback(() => {
        if ("page" in meta && meta.page) {
          navigateTo(meta.page);
        }
      }, [meta, navigateTo]);

      const header = useMemo(() => (
        <div className="flex items-center justify-between p-4 border-b border-border h-20 flex-shrink-0 pl-6">
          {bodyState !== BODY_STATES.SPLIT_VIEW && 'icon' in meta ? (
            <div className="flex items-center gap-2">
              {meta.icon && createElement(meta.icon, { className: "w-5 h-5" })}
              <h2 className="text-lg font-semibold whitespace-nowrap">{meta.title}</h2>
            </div>
          ) : <div />}
          <div className="flex items-center">
            {(bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW) && (
              <button onClick={toggleSplitView} className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors" title={bodyState === BODY_STATES.SIDE_PANE ? "Switch to Split View" : "Switch to Overlay View"}>
                {bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-5 h-5" /> : <SplitSquareHorizontal className="w-5 h-5" />}
              </button>
            )}
            {bodyState !== BODY_STATES.SPLIT_VIEW && "page" in meta && meta.page && (
              <button onClick={handleMaximize} className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors mr-2" title="Move to Main View">
                <ChevronsLeftRight className="w-5 h-5" />
              </button>
            )}
          </div>
        </div>
      ), [bodyState, meta, handleMaximize, toggleSplitView]);

      if (isFullscreen && fullscreenTarget !== 'right') {
        return null;
      }

      return (
        <aside
          ref={ref}
          className={cn(
            "border-l border-border flex flex-col h-full overflow-hidden",
            isSplitView && "relative bg-background",
            !isSplitView && !isFullscreen && "fixed top-0 right-0 z-[60] bg-card", // side pane overlay
            isFullscreen && fullscreenTarget === 'right' && "fixed inset-0 z-[60] bg-card", // fullscreen
            className,
          )}
        >
          {isFullscreen && fullscreenTarget === 'right' && (
            <button
              onClick={() => toggleFullscreen()}
              className="fixed top-6 right-6 lg:right-12 z-[100] h-12 w-12 flex items-center justify-center rounded-full bg-card/50 backdrop-blur-sm hover:bg-card/75 transition-colors group"
              title="Exit Fullscreen"
            >
              <X className="w-6 h-6 group-hover:scale-110 group-hover:rotate-90 transition-all duration-300" />
            </button>
          )}
          {bodyState !== BODY_STATES.SPLIT_VIEW && !isFullscreen && (
            <button
              onClick={closeSidePane}
              className="absolute top-1/2 -left-px -translate-y-1/2 -translate-x-full w-8 h-16 bg-card border border-r-0 border-border rounded-l-lg flex items-center justify-center hover:bg-accent transition-colors group z-10"
              title="Close pane"
            >
              <ChevronRight className="w-5 h-5 text-muted-foreground group-hover:text-foreground transition-colors" />
            </button>
          )}
          <div 
            className={cn(
              "absolute top-0 left-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
            )}
            onMouseDown={(e) => {
              e.preventDefault()
              setIsResizingRightPane(true);
            }}
          >
            <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
          </div>
          {!isSplitView && !isFullscreen && header}
          <div className={cn("flex-1 overflow-y-auto")}>
            {children}
          </div>
        </aside>
      )
    }));

    RightPane.displayName = "RightPane"
  src/components/layout/ViewModeSwitcher.tsx: >-
    import { useState, useRef, useEffect } from 'react';

    import { gsap } from 'gsap';

    import { cn } from '@/lib/utils'

    import { useAppShellStore, type AppShellState, type ActivePage } from
    '@/store/appShell.store'

    import { BODY_STATES } from '@/lib/utils'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import {
      Columns,
      PanelRightOpen,
      SplitSquareHorizontal,
      Maximize,
      Minimize,
      Layers,
      X,
      ArrowLeftRight
    } from 'lucide-react'


    export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
    'right', targetPage?: ActivePage }) {
      const bodyState = useAppShellStore(s => s.bodyState);
      const fullscreenTarget = useAppShellStore(s => s.fullscreenTarget);
      const { toggleFullscreen } = useAppShellStore.getState();
      const {
        currentActivePage,
        toggleSidePane,
        toggleSplitView,
        setNormalView,
        navigateTo,
        switchSplitPanes,
        closeSplitPane,
      } = useAppViewManager();

      const activePage = targetPage || currentActivePage;
      const [isExpanded, setIsExpanded] = useState(false);
      const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isThisPaneFullscreen = isFullscreen && (
        (pane === 'main' && fullscreenTarget !== 'right') ||
        (pane === 'right' && fullscreenTarget === 'right') ||
        (!pane && !fullscreenTarget) // Global switcher, global fullscreen
      );

      useEffect(() => {
        const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
        if (buttonsToAnimate.length === 0) return;

        gsap.killTweensOf(buttonsToAnimate);

        if (isExpanded) {
            gsap.to(buttonsToAnimate, {
                width: 32, // h-8 w-8
                opacity: 1,
                pointerEvents: 'auto',
                marginLeft: 4, // from gap-1 in original
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'start'
                },
                ease: 'power2.out'
            });
        } else {
            gsap.to(buttonsToAnimate, {
                width: 0,
                opacity: 0,
                pointerEvents: 'none',
                marginLeft: 0,
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'end'
                },
                ease: 'power2.in'
            });
        }
      }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

      const handlePaneClick = (type: 'side-pane' | 'split-view') => {
        const pageToPaneMap: Record<ActivePage, AppShellState['sidePaneContent']> = { // This type is now stricter because ActivePage includes messaging
          dashboard: 'main', settings: 'settings', toaster: 'toaster', notifications: 'notifications', 'data-demo': 'dataDemo',
          messaging: 'messaging',
        };
        const paneContent = pageToPaneMap[activePage];
        if (type === 'side-pane') toggleSidePane(paneContent);
        else toggleSplitView();
      }

      const handleNormalViewClick = () => {
        if (isFullscreen) {
          toggleFullscreen();
        }
        if (targetPage && targetPage !== currentActivePage) {
          navigateTo(targetPage);
        } else {
          setNormalView();
        }
      }

      const buttons = [
        {
          id: 'normal',
          onClick: handleNormalViewClick,
          active: bodyState === BODY_STATES.NORMAL,
          title: "Normal View",
          icon: <Columns className="w-4 h-4" />
        },
        {
          id: 'side-pane',
          onClick: () => handlePaneClick('side-pane'),
          active: bodyState === BODY_STATES.SIDE_PANE,
          title: "Side Pane View",
          icon: <PanelRightOpen className="w-4 h-4" />
        },
        {
          id: 'split-view',
          onClick: () => handlePaneClick('split-view'),
          active: bodyState === BODY_STATES.SPLIT_VIEW,
          title: bodyState === BODY_STATES.SPLIT_VIEW ? 'Switch to Overlay View' : 'Switch to Split View',
          icon: bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-4 h-4" /> : <SplitSquareHorizontal className="w-4 h-4" />
        },
        {
          id: 'fullscreen',
          onClick: () => {
            if (targetPage && targetPage !== currentActivePage ) {
              navigateTo(targetPage);
              setTimeout(() => toggleFullscreen(pane), 50);
            } else {
              toggleFullscreen(pane);
            }
          },
          active: isThisPaneFullscreen,
          title: "Toggle Fullscreen",
          icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
        }
      ];

      if (bodyState === BODY_STATES.SPLIT_VIEW) {
        buttons.push({
          id: 'switch',
          onClick: switchSplitPanes,
          active: false,
          title: "Switch Panes",
          icon: <ArrowLeftRight className="w-4 h-4" />
        });
        buttons.push({
          id: 'close',
          onClick: () => closeSplitPane(pane || 'right'),
          active: false,
          title: "Close Pane",
          icon: <X className="w-4 h-4 text-muted-foreground group-hover:text-destructive" />
        });
      }

      return (
        <div
          onMouseEnter={() => setIsExpanded(true)}
          onMouseLeave={() => setIsExpanded(false)}
          className="flex items-center gap-0 p-1 bg-card rounded-full border border-border"
        >
            <button
                className='h-8 w-8 flex-shrink-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors'
                title="View Modes"
                onClick={() => setIsExpanded(!isExpanded)}
            >
                <Layers className="w-4 h-4" />
            </button>
          
          {buttons.map((btn, index) => (
            <button
              key={btn.id}
              ref={el => buttonRefs.current[index] = el}
              onClick={btn.onClick}
              className={cn(
                'h-8 w-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors group opacity-0',
                btn.active && 'bg-accent text-accent-foreground',
                btn.id === 'close' && 'hover:bg-destructive/20'
              )}
              style={{ pointerEvents: 'none', marginLeft: 0, overflow: 'hidden' }}
              title={btn.title}
            >
              {btn.icon}
            </button>
          ))}
        </div>
      )
    }
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 373
