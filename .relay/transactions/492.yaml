uuid: c25700a0-090c-4034-8c83-f5791c89f58e
projectId: jeli-app-shell
createdAt: '2025-10-20T02:24:06.244Z'
gitCommitMsg: >-
  refactor(data-model): Unify DataDemo and Messaging data models

  - Centralized Task, Contact, and Assignee types and mock data into a
    shared `src/data` directory.
  - Deprecated and removed the standalone `DataItem` model from `DataDemo`. -
  Enhanced the `Task` model with `description`, `category`, and
    `completion` properties to support DataDemo's UI requirements.
  - Completely refactored the `dataDemo` Zustand store to consume and manage
    the new `EnrichedTask` data model.
  - Updated key hooks (`useAppViewManager`, `useRightPaneContent`) to use
    the unified types and data, ensuring routing and side panel logic
    remain functional.
promptSummary: >-
  The user wants to refactor the DataDemo page to use the Messaging page's data
  model. This involves unifying types and data, and then refactoring the
  DataDemo store to work with the new unified model. This is part 1 and 2 of a
  larger refactoring plan.
reasoning:
  - >-
    I will now execute the first two parts of our refactoring plan. This is a
    significant architectural change, so I'll be moving files, deleting old
    models, enhancing our new unified data model, and completely overhauling the
    state management for the `DataDemo` feature.
  - '### Part 1: Centralize and Enhance the Data Model'
  - >-
    First, I'll consolidate our data models and mock data into a single
    `src/data` directory. This eliminates duplication and creates a single
    source of truth. I'll also enhance the `Task` model with new properties
    required by the `DataDemo` views.
  - I am moving `src/pages/Messaging/types.ts` to `src/data/types.ts`.
  - And moving `src/pages/Messaging/data/mockData.ts` to `src/data/mockData.ts`.
  - >-
    Now, I'll enhance the newly created `src/data/types.ts` by adding properties
    to the `Task` interface that were previously part of `DataItem`. This will
    allow our `DataDemo` views to function with the new model.
  - >-
    Next, I'll update our mock data generation in `src/data/mockData.ts` to
    populate these new fields and fix its internal import path.
  - >-
    With the new shared data location, I need to update the import paths in the
    `Messaging` feature.
  - >-
    The old `DataItem` model is now obsolete. I am deleting the file. The
    components that depend on it will be fixed in subsequent steps.
  - >-
    To prevent the application from breaking due to the deleted types file, I'll
    update two key hooks that were using it. First,
    `useRightPaneContent.hook.tsx` needs to be updated to find and enrich a
    `Task` instead of a `DataItem`.
  - >-
    Similarly, `useAppViewManager.hook.ts` must be updated. I will redefine the
    necessary view-related types directly within this hook, now based on the
    `Task` model, to ensure other parts of the app continue to function.
  - '### Part 2: Adapt DataDemo State Management'
  - >-
    With the data model unified, I'll now completely refactor the `DataDemo`
    Zustand store. It will no longer use its own mock data but will instead
    source `Tasks`, `Contacts`, and `Assignees` from our new shared data files,
    enriching them into a format the UI can consume. All its actions and
    selectors will be updated to work with this new `EnrichedTask` data
    structure.
  - >-
    This completes the foundational data layer refactoring. The next steps will
    involve updating the UI components to consume this new, unified data
    structure.
operations:
  - type: rename
    from: src/pages/Messaging/types.ts
    to: src/data/types.ts
  - type: rename
    from: src/pages/Messaging/data/mockData.ts
    to: src/data/mockData.ts
  - type: write
    path: src/data/types.ts
    content: |+
      --- src/data/types.ts
      +++ src/data/types.ts
      @@ -62,6 +62,9 @@
       export interface Task {
         id: string;
         title: string;
      +  description: string;
      +  category: string;
      +  completion: number;
         contactId: string;
         channel: Channel;
         unreadCount: number;

    patchStrategy: standard-diff
  - type: write
    path: src/data/mockData.ts
    content: >+
      --- src/data/mockData.ts

      +++ src/data/mockData.ts

      @@ -1,4 +1,4 @@

      -import type { Contact, Task, Message, ActivityEvent, Note, Assignee,
      TaskStatus, TaskPriority, Channel, JourneyPointType } from '../types';

      +import type { Contact, Task, Message, ActivityEvent, Note, Assignee,
      TaskStatus, TaskPriority, Channel, JourneyPointType } from './types';
       import { faker } from '@faker-js/faker';
       
       // --- ASSIGNEES ---
      @@ -137,6 +137,9 @@
       
               const task: Task = {
                   id: `task-${i + 1}`,
      +            description: faker.lorem.paragraph(),

      +            category: faker.commerce.department(),

      +            completion: faker.number.int({ min: 0, max: 100 }),
                   title: faker.lorem.sentence({ min: 3, max: 7 }),
                   contactId: contact.id,
                   channel: faker.helpers.arrayElement(channels),

    patchStrategy: standard-diff
  - type: write
    path: src/pages/Messaging/store/messaging.store.ts
    content: >
      <<<<<<< SEARCH

      import { mockTasks, mockContacts, mockAssignees } from '../data/mockData';

      import type { Task, Contact, Channel, Assignee, TaskStatus, TaskPriority,
      TaskView, Message, JourneyPointType } from '../types';

      =======

      import { mockTasks, mockContacts, mockAssignees } from '@/data/mockData';

      import type { Task, Contact, Channel, Assignee, TaskStatus, TaskPriority,
      TaskView } from '@/data/types';

      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/pages/Messaging/components/TaskHeader.tsx
    content: >
      <<<<<<< SEARCH

      import { useMessagingStore } from '../store/messaging.store';

      import type { Task, TaskStatus, TaskPriority, Assignee, Contact } from
      '../types';

      =======

      import { useMessagingStore } from '../store/messaging.store';

      import type { Task, TaskStatus, TaskPriority, Assignee, Contact } from
      '@/data/types';

      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: delete
    path: src/pages/DataDemo/types.ts
  - type: write
    path: src/hooks/useRightPaneContent.hook.tsx
    content: >+
      --- src/hooks/useRightPaneContent.hook.tsx

      +++ src/hooks/useRightPaneContent.hook.tsx

      @@ -12,7 +12,7 @@
       import { SettingsContent } from "@/features/settings/SettingsContent";
       import { ToasterDemo } from "@/pages/ToasterDemo";
       import { NotificationsPage } from "@/pages/Notifications";
       import DataDemoPage from "@/pages/DataDemo";
       import { DataDetailPanel } from "@/pages/DataDemo/components/DataDetailPanel";
      -import { mockDataItems } from "@/pages/DataDemo/data/mockData";

      +import { mockTasks, mockContacts, mockAssignees } from "@/data/mockData";
       import { MessagingContent } from "@/pages/Messaging/components/MessagingContent";
       import type { AppShellState } from '@/store/appShell.store';
       
      @@ -62,16 +62,23 @@
       
         const selectedItem = useMemo(() => {
           if (!itemId) return null;
      -    return mockDataItems.find(item => item.id === itemId) ?? null;

      +    const task = mockTasks.find(t => t.id === itemId);

      +    if (!task) return null;

      +

      +    const contact = mockContacts.find(c => c.id === task.contactId);

      +    if (!contact) return null; // Or handle as an error

      +

      +    const assignee = mockAssignees.find(a => a.id === task.assigneeId) ||
      null;

      +    return { ...task, contact, assignee };
         }, [itemId]);
       
         const { meta, content } = useMemo(() => {
           if (sidePaneContent === 'dataItem' && selectedItem) {
             return {
      -        meta: { title: "Item Details", icon: Database, page:
      `data-demo/${itemId}` },

      +        meta: { title: "Task Details", icon: Database, page:
      `data-demo/${itemId}` },
               content: <DataDetailPanel item={selectedItem} />,
             };
           }

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: "--- src/hooks/useAppViewManager.hook.ts\n+++ src/hooks/useAppViewManager.hook.ts\n@@ -2,14 +2,29 @@\n import { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\n import { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\n-import type { DataItem, ViewMode, SortConfig, SortableField, GroupableField, Status, Priority, CalendarDateProp, CalendarDisplayProp, CalendarColorProp } from '@/pages/DataDemo/types';\n-import type { FilterConfig } from '@/pages/DataDemo/types';\n-import type { TaskView } from '@/pages/Messaging/types';\n+import type { Task, TaskView, TaskStatus, TaskPriority } from '@/data/types';\n import { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n \n+export type ViewMode = 'list' | 'cards' | 'grid' | 'table' | 'kanban' | 'calendar';\n+export type GroupableField = 'status' | 'priority' | 'category';\n+export type SortableField =\n+  | 'title'\n+  | 'status'\n+  | 'priority'\n+  | 'completion'\n+  | 'contact.name'\n+  | 'lastActivity.timestamp'\n+  | 'createdAt'\n+  | 'dueDate';\n+export type SortDirection = 'asc' | 'desc';\n+export interface SortConfig {\n+  key: SortableField;\n+  direction: SortDirection;\n+}\n+export type CalendarDateProp = 'dueDate' | 'createdAt' | 'lastActivity.timestamp';\n+export type CalendarDisplayProp = 'priority' | 'assignee' | 'tags';\n+export type CalendarColorProp = 'none' | 'priority' | 'status' | 'category';\n+export interface FilterConfig {\n+  searchTerm: string;\n+  status: TaskStatus[];\n+  priority: TaskPriority[];\n+}\n+\n const pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n   dashboard: 'main',\n   settings: 'settings',\n@@ -99,8 +114,8 @@\n \tconst filters = useMemo<FilterConfig>(\n \t\t() => ({\n \t\t\tsearchTerm: q || '',\n-\t\t\tstatus: (status?.split(',') || []).filter(Boolean) as Status[],\n-\t\t\tpriority: (priority?.split(',') || []).filter(Boolean) as Priority[],\n+\t\t\tstatus: (status?.split(',') || []).filter(Boolean) as TaskStatus[],\n+\t\t\tpriority: (priority?.split(',') || []).filter(Boolean) as TaskPriority[],\n \t\t}),\n \t\t[q, status, priority],\n \t);\n@@ -282,8 +297,8 @@\n   const setCalendarColorProp = (prop: CalendarColorProp) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n \n   const onItemSelect = useCallback((item: Task) => {\n-\t\tnavigate(`/data-demo/${item.id}${location.search}`);\n-\t}, [navigate, location.search]);\n+\t\tnavigate(`/data-demo/${item.id}${location.search}`, { replace: true });\n+\t}, [navigate, location.search]);\n \n   const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n \n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/store/dataDemo.store.tsx
    content: >-
      import { create } from 'zustand';

      import { type ReactNode } from 'react';

      import { capitalize, cn } from '@/lib/utils';

      import { Badge } from '@/components/ui/badge';

      import { mockTasks, mockContacts, mockAssignees } from '@/data/mockData';

      import type { Task, Contact, Assignee, TaskStatus, TaskPriority } from
      '@/data/types';


      // --- Types ---

      export type EnrichedTask = Task & { contact: Contact; assignee: Assignee |
      null };

      export type GroupableField = 'status' | 'priority' | 'category';

      export type SortableField =
        | 'title'
        | 'status'
        | 'priority'
        | 'completion'
        | 'contact.name'
        | 'lastActivity.timestamp'
        | 'createdAt'
        | 'dueDate';
      export type SortDirection = 'asc' | 'desc';

      export interface SortConfig {
        key: SortableField;
        direction: SortDirection;
      }

      export interface FilterConfig {
        searchTerm: string;
        status: TaskStatus[];
        priority: TaskPriority[];
      }


      // --- State and Actions ---

      interface DataDemoState {
          items: EnrichedTask[];
          hasMore: boolean;
          isLoading: boolean;
          isInitialLoading: boolean;
          totalItemCount: number;
      }


      interface DataDemoActions {
          loadData: (params: {
              page: number;
              groupBy: GroupableField | 'none';
              filters: FilterConfig;
              sortConfig: SortConfig | null;
              isFullLoad?: boolean;
          }) => void;
          updateItem: (taskId: string, updates: Partial<Task>) => void;
      }


      const defaultState: DataDemoState = {
          items: [],
          hasMore: true,
          isLoading: true,
          isInitialLoading: true,
          totalItemCount: 0,
      };


      // --- Store Implementation ---

      const allEnrichedTasks = mockTasks.map(task => {
          const contact = mockContacts.find(c => c.id === task.contactId);
          if (!contact) throw new Error(`Contact not found for task ${task.id}`);
          const assignee = mockAssignees.find(a => a.id === task.assigneeId) || null;
          return { ...task, contact, assignee };
      });


      export const useDataDemoStore = create<DataDemoState &
      DataDemoActions>((set, get) => ({
          ...defaultState,

          loadData: ({ page, groupBy, filters, sortConfig, isFullLoad }) => {
              set({ isLoading: true, ...(page === 1 && { isInitialLoading: true }) });
              const isFirstPage = page === 1;

              const filteredAndSortedData = (() => {
                  const lowercasedSearch = filters.searchTerm.toLowerCase();
                  const filteredItems = allEnrichedTasks.filter((item) => {
                      const searchTermMatch =
                          item.title.toLowerCase().includes(lowercasedSearch) ||
                          item.description.toLowerCase().includes(lowercasedSearch) ||
                          item.contact.name.toLowerCase().includes(lowercasedSearch);
                      const statusMatch = filters.status.length === 0 || filters.status.includes(item.status);
                      const priorityMatch = filters.priority.length === 0 || filters.priority.includes(item.priority);
                      return searchTermMatch && statusMatch && priorityMatch;
                  });

                  if (sortConfig) {
                      filteredItems.sort((a, b) => {
                          // eslint-disable-next-line @typescript-eslint/no-explicit-any
                          const getNestedValue = (obj: EnrichedTask, path: string): any =>
                              path.split('.').reduce((o: any, k) => (o || {})[k], obj);

                          const aValue = getNestedValue(a, sortConfig.key);
                          const bValue = getNestedValue(b, sortConfig.key);

                          if (aValue === undefined || bValue === undefined) return 0;
                          if (typeof aValue === 'string' && typeof bValue === 'string') {
                              return sortConfig.direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                          }
                          if (typeof aValue === 'number' && typeof bValue === 'number') {
                              return sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue;
                          }
                          if (['createdAt', 'dueDate', 'lastActivity.timestamp'].includes(sortConfig.key)) {
                              if (typeof aValue === 'string' && typeof bValue === 'string') {
                                  const dateA = aValue ? new Date(aValue).getTime() : 0;
                                  const dateB = bValue ? new Date(bValue).getTime() : 0;
                                  return sortConfig.direction === 'asc' ? dateA - dateB : dateB - aA;
                              }
                          }
                          return 0;
                      });
                  }
                  return filteredItems;
              })();
              
              const totalItemCount = filteredAndSortedData.length;
              
              // Short delay to simulate network latency, even with local data
              setTimeout(() => {
                  if (groupBy !== 'none' || isFullLoad) {
                      set({
                          items: filteredAndSortedData,
                          hasMore: false,
                          isLoading: false,
                          isInitialLoading: false,
                          totalItemCount,
                      });
                      return;
                  }

                  const pageSize = 12;
                  const newItems = filteredAndSortedData.slice((page - 1) * pageSize, page * pageSize);
                  
                  set(state => ({
                      items: isFirstPage ? newItems : [...state.items, ...newItems],
                      hasMore: totalItemCount > page * pageSize,
                      isLoading: false,
                      isInitialLoading: false,
                      totalItemCount,
                  }));

              }, isFirstPage ? 500 : 300);
          },

          updateItem: (taskId, updates) => {
              // In a real app, this would be an API call. Here we update the mock source.
              const taskIndex = mockTasks.findIndex(i => i.id === taskId);
              if (taskIndex > -1) {
                  mockTasks[taskIndex] = { ...mockTasks[taskIndex], ...updates };
              }

              // Also update the currently loaded items in the store's state for UI consistency
              set(state => ({
                  items: state.items.map(item => {
                      if (item.id === taskId) {
                          const updatedTask = { ...item, ...updates };
                          // If assigneeId changed, we need to re-fetch the assignee object
                          if ('assigneeId' in updates) {
                              updatedTask.assignee = mockAssignees.find(a => a.id === updatedTask.assigneeId) || null;
                          }
                          return updatedTask;
                      }
                      return item;
                  }),
              }));
          },
      }));


      // --- Selectors ---

      export const useGroupTabs = (
          groupBy: GroupableField | 'none',
          activeGroupTab: string,
      ) => useDataDemoStore(state => {
          const items = state.items;
          if (groupBy === 'none' || !items.length) return [];
          
          const groupCounts = items.reduce((acc, item) => {
              const groupKey = String(item[groupBy as GroupableField]);
              acc[groupKey] = (acc[groupKey] || 0) + 1;
              return acc;
          }, {} as Record<string, number>);

          const sortedGroups = Object.keys(groupCounts).sort((a, b) => a.localeCompare(b));

          const createLabel = (text: string, count: number, isActive: boolean): ReactNode => (
              <>
                  {text}
                  <Badge variant={isActive ? 'default' : 'secondary'} className={cn('transition-colors duration-300 text-xs font-semibold', !isActive && 'group-hover:bg-accent group-hover:text-accent-foreground')}>
                      {count}
                  </Badge>
              </>
          );
          
          const totalCount = items.length;

          return [
              { id: 'all', label: createLabel('All', totalCount, activeGroupTab === 'all') },
              ...sortedGroups.map((g) => ({
                  id: g,
                  label: createLabel(capitalize(g), groupCounts[g], activeGroupTab === g),
              })),
          ];
      });


      export const useDataToRender = (
          groupBy: GroupableField | 'none',
          activeGroupTab: string,
      ) => useDataDemoStore(state => {
          const items = state.items;
          if (groupBy === 'none') {
              return items;
          }
          if (activeGroupTab === 'all') {
              return items;
          }
          return items.filter((item) => String(item[groupBy as GroupableField]) === activeGroupTab);
      });


      export const useSelectedItem = (taskId?: string): EnrichedTask | null => {
          if (!taskId) return null;
          const task = mockTasks.find(item => item.id === taskId);
          if (!task) return null;

          const contact = mockContacts.find(c => c.id === task.contactId);
          if (!contact) return null;

          const assignee = mockAssignees.find(a => a.id === task.assigneeId) || null;
          return { ...task, contact, assignee };
      };
    patchStrategy: replace
snapshot:
  src/data/types.ts: null
  src/data/mockData.ts: null
  src/pages/Messaging/types.ts: >-
    import type { LucideIcon } from "lucide-react";


    export type Channel = 'whatsapp' | 'instagram' | 'facebook' | 'email';


    export interface ChannelIcon {
      Icon: LucideIcon;
      color: string;
    }


    export interface Contact {
      id: string;
      name:string;
      avatar: string;
      online: boolean;
      tags: string[];
      email: string;
      phone: string;
      lastSeen: string;
      company: string;
      role: string;
      activity: ActivityEvent[];
      notes: Note[];
    }


    export interface Assignee {
      id: string;
      name: string;
      avatar: string;
      type: 'human' | 'ai';
    }


    export type ActivityEventType = 'note' | 'call' | 'email' | 'meeting';


    export interface ActivityEvent {
      id: string;
      type: ActivityEventType;
      content: string;
      timestamp: string;
    }

    export interface Note {
      id: string;
      content: string;
      createdAt: string;
    }


    export type JourneyPointType = 'Inquiry' | 'Consult' | 'Quote' | 'Order' |
    'Payment' | 'Shipped' | 'Delivered' | 'Canceled' | 'Refund' | 'Complain' |
    'Reorder' | 'Follow-up' | 'Review';


    export interface Message {
      id: string;
      text: string;
      timestamp: string;
      sender: 'user' | 'contact' | 'system';
      type: 'comment' | 'note' | 'system';
      read: boolean;
      userId?: string; // for notes or system messages from users
      journeyPoint?: JourneyPointType;
    }


    export interface AISummary {
      sentiment: 'positive' | 'negative' | 'neutral';
      summaryPoints: string[];
      suggestedReplies: string[];
    }


    export type TaskStatus = 'open' | 'in-progress' | 'done' | 'snoozed';

    export type TaskPriority = 'none' | 'low' | 'medium' | 'high';


    export interface Task {
      id: string;
      title: string;
      contactId: string;
      channel: Channel;
      unreadCount: number;
      lastActivity: Message;
      messages: Message[];
      status: TaskStatus;
      assigneeId: string | null;
      dueDate: string | null;
      priority: TaskPriority;
      tags: string[];
      aiSummary: AISummary;
      activeHandlerId: string | null;
      takeoverRequested?: boolean;
    }


    export type TaskView = 'all_open' | 'unassigned' | 'me' | 'done';
  src/hooks/useRightPaneContent.hook.tsx: >-
    import { useMemo, useCallback } from 'react';

    import { useNavigate, useParams } from 'react-router-dom';

    import {
      LayoutDashboard,
      Settings,
      Component,
      Bell,
      SlidersHorizontal,
      Database,
      MessageSquare,
    } from 'lucide-react';


    import { DashboardContent } from "@/pages/Dashboard";

    import { SettingsContent } from "@/features/settings/SettingsContent";

    import { ToasterDemo } from "@/pages/ToasterDemo";

    import { NotificationsPage } from "@/pages/Notifications";

    import DataDemoPage from "@/pages/DataDemo";

    import { DataDetailPanel } from
    "@/pages/DataDemo/components/DataDetailPanel";

    import { mockDataItems } from "@/pages/DataDemo/data/mockData";

    import { MessagingContent } from
    "@/pages/Messaging/components/MessagingContent";

    import type { AppShellState } from '@/store/appShell.store';


    export function useRightPaneContent(sidePaneContent:
    AppShellState['sidePaneContent']) {
      const navigate = useNavigate();
      const { itemId, conversationId } = useParams<{ itemId: string; conversationId: string }>();

      const staticContentMap = useMemo(() => ({
        main: {
          title: "Dashboard",
          icon: LayoutDashboard,
          page: "dashboard",
          content: <DashboardContent />,
        },
        settings: {
          title: "Settings",
          icon: Settings,
          page: "settings",
          content: <div className="p-6"><SettingsContent /></div>,
        },
        toaster: {
          title: "Toaster Demo",
          icon: Component,
          page: "toaster",
          content: <ToasterDemo />,
        },
        notifications: {
          title: "Notifications",
          icon: Bell,
          page: "notifications",
          content: <NotificationsPage />,
        },
        dataDemo: {
          title: "Data Showcase",
          icon: Database,
          page: "data-demo",
          content: <DataDemoPage />,
        },
        details: {
          title: "Details Panel",
          icon: SlidersHorizontal,
          content: (
            <div className="p-6">
              <p className="text-muted-foreground">
                This is the side pane. It can be used to display contextual
                information, forms, or actions related to the main content.
              </p>
            </div>
          ),
        },
      }), []);

      const contentMap = useMemo(() => ({
        ...staticContentMap,
        messaging: {
          title: "Conversation",
          icon: MessageSquare,
          page: "messaging",
          content: <MessagingContent conversationId={conversationId} />,
        },
      }), [conversationId, staticContentMap]);

      const selectedItem = useMemo(() => {
        if (!itemId) return null;
        return mockDataItems.find(item => item.id === itemId) ?? null;
      }, [itemId]);

      const { meta, content } = useMemo(() => {
        if (sidePaneContent === 'dataItem' && selectedItem) {
          return {
            meta: { title: "Item Details", icon: Database, page: `data-demo/${itemId}` },
            content: <DataDetailPanel item={selectedItem} />,
          };
        }
        const mappedContent = contentMap[sidePaneContent as keyof typeof contentMap] || contentMap.details;
        return {
          meta: mappedContent,
          content: mappedContent.content,
        };
      }, [sidePaneContent, selectedItem, contentMap, itemId]);

      return { meta, content };
    }
  src/pages/Messaging/store/messaging.store.ts: >-
    import { useState, useEffect } from 'react';

    import { create } from 'zustand';

    import { mockTasks, mockContacts, mockAssignees } from '../data/mockData';

    import type { Task, Contact, Channel, Assignee, TaskStatus, TaskPriority,
    TaskView, Message, JourneyPointType } from '../types';


    const currentUserId = 'user-1'; // Mock current user


    interface MessagingState {
      tasks: Task[];
      contacts: Contact[];
      assignees: Assignee[];
      searchTerm: string;
      activeFilters: {
        channels: Channel[];
        tags: string[];
        status: TaskStatus[];
        priority: TaskPriority[];
        assigneeId: string[];
      };
      activeTaskView: TaskView;
    }


    interface MessagingActions {
      getTaskById: (id: string) => (Task & { contact: Contact, assignee: Assignee | null, activeHandler: Assignee | null }) | undefined;
      getFilteredTasks: () => (Task & { contact: Contact, assignee: Assignee | null })[];
      setSearchTerm: (term: string) => void;
      setActiveTaskView: (view: TaskView) => void;
      setFilters: (filters: Partial<MessagingState['activeFilters']>) => void;
      updateTask: (taskId: string, updates: Partial<Omit<Task, 'id'>>) => void;
      takeOverTask: (taskId: string, userId: string) => void;
      requestAndSimulateTakeover: (taskId: string, requestedByUserId: string) => void;
      getAssigneeById: (assigneeId: string) => Assignee | undefined;
      getContactsByCompany: (companyName: string, currentContactId: string) => Contact[];
      getAvailableTags: () => string[];
    }


    export const useMessagingStore = create<MessagingState &
    MessagingActions>((set, get) => ({
      tasks: mockTasks,
      contacts: mockContacts,
      assignees: mockAssignees,
      searchTerm: '',
      activeFilters: {
        channels: [],
        tags: [],
        status: [],
        priority: [],
        assigneeId: [],
      },
      activeTaskView: 'all_open',

      getTaskById: (id) => {
        const task = get().tasks.find(t => t.id === id);
        if (!task) return undefined;

        const contact = get().contacts.find(c => c.id === task.contactId);
        if (!contact) return undefined;

        const assignee = get().assignees.find(a => a.id === task.assigneeId) || null;
        const activeHandler = get().assignees.find(a => a.id === task.activeHandlerId) || null;

        return { ...task, contact, assignee, activeHandler };
      },

      getFilteredTasks: () => {
        const { tasks, contacts, assignees, searchTerm, activeFilters, activeTaskView } = get();
        const lowercasedSearch = searchTerm.toLowerCase();

        const viewFilteredTasks = tasks.filter(task => {
          switch (activeTaskView) {
            case 'all_open':
              return task.status === 'open' || task.status === 'in-progress';
            case 'unassigned':
              return !task.assigneeId && (task.status === 'open' || task.status === 'in-progress');
            case 'me':
              return task.assigneeId === currentUserId && (task.status === 'open' || task.status === 'in-progress');
            case 'done':
              return task.status === 'done';
            default:
              return true;
          }
        });
        const mapped = viewFilteredTasks.map(task => {
          const contact = contacts.find(c => c.id === task.contactId) as Contact;
          const assignee = assignees.find(a => a.id === task.assigneeId) || null;
          return { ...task, contact, assignee };
        });

        const filtered = mapped.filter(task => {
          const searchMatch = task.title.toLowerCase().includes(lowercasedSearch) || task.contact.name.toLowerCase().includes(lowercasedSearch);
          const channelMatch = activeFilters.channels.length === 0 || activeFilters.channels.includes(task.channel);
          const tagMatch = activeFilters.tags.length === 0 || activeFilters.tags.some(tag => task.tags.includes(tag));
          const statusMatch = activeFilters.status.length === 0 || activeFilters.status.includes(task.status);
          const priorityMatch = activeFilters.priority.length === 0 || activeFilters.priority.includes(task.priority);
          const assigneeMatch = activeFilters.assigneeId.length === 0 || (task.assigneeId && activeFilters.assigneeId.includes(task.assigneeId));
          
          return searchMatch && channelMatch && tagMatch && statusMatch && priorityMatch && assigneeMatch;
        });

        return filtered.sort((a, b) => new Date(b.lastActivity.timestamp).getTime() - new Date(a.lastActivity.timestamp).getTime());
      },

      setSearchTerm: (term) => set({ searchTerm: term }),
      
      setActiveTaskView: (view) => set({ activeTaskView: view }),

      setFilters: (newFilters) => set(state => ({
        activeFilters: { ...state.activeFilters, ...newFilters }
      })),

      updateTask: (taskId, updates) => set(state => ({
        tasks: state.tasks.map(task => 
          task.id === taskId 
            ? { ...task, ...updates, lastActivity: { ...task.lastActivity, timestamp: new Date().toISOString() } } 
            : task
        )
      })),

      takeOverTask: (taskId, userId) => set(state => ({
        tasks: state.tasks.map(task => 
          task.id === taskId 
            ? { ...task, activeHandlerId: userId, takeoverRequested: false } 
            : task
        )
      })),

      requestAndSimulateTakeover: (taskId, requestedByUserId) => {
        set(state => ({
          tasks: state.tasks.map(task => 
            task.id === taskId ? { ...task, takeoverRequested: true } : task
          )
        }));
        // Simulate a 2-second delay for the other user to "approve"
        setTimeout(() => get().takeOverTask(taskId, requestedByUserId), 2000);
      },

      getAssigneeById: (assigneeId: string) => {
        return get().assignees.find(a => a.id === assigneeId);
      },

      getContactsByCompany: (companyName, currentContactId) => {
        return get().contacts.filter(
          c => c.company === companyName && c.id !== currentContactId
        );
      },

      getAvailableTags: () => {
        const contactTags = get().contacts.flatMap(c => c.tags);
        const taskTags = get().tasks.flatMap(t => t.tags);
        const allTags = new Set([...contactTags, ...taskTags]);
        return Array.from(allTags);
      }
    }));


    export const useMessagingTaskCounts = () => {
      const tasks = useMessagingStore(s => s.tasks);
      const [counts, setCounts] = useState<Record<TaskView, number>>({
        all_open: 0,
        unassigned: 0,
        me: 0,
        done: 0,
      });

      useEffect(() => {
        // Deferring the count calculation until after the first paint.
        // This frees up the main thread for initial animations to run smoothly.
        const animationFrameId = requestAnimationFrame(() => {
            const newCounts: Record<TaskView, number> = {
                all_open: 0,
                unassigned: 0,
                me: 0,
                done: 0,
            };

            for (const task of tasks) {
                const isOpenOrInProgress = task.status === 'open' || task.status === 'in-progress';

                if (isOpenOrInProgress) {
                    newCounts.all_open++;
                    if (!task.assigneeId) newCounts.unassigned++;
                    if (task.assigneeId === currentUserId) newCounts.me++;
                } else if (task.status === 'done') {
                    newCounts.done++;
                }
            }
            setCounts(newCounts);
        });

        return () => cancelAnimationFrame(animationFrameId);
      }, [tasks]);

      return counts;
    };
  src/pages/Messaging/data/mockData.ts: >-
    import type { Contact, Task, Message, ActivityEvent, Note, Assignee,
    TaskStatus, TaskPriority, Channel, JourneyPointType } from '../types';

    import { faker } from '@faker-js/faker';


    // --- ASSIGNEES ---

    export const mockAssignees: Assignee[] = [
      { id: 'user-1', name: 'You', avatar: `https://avatar.vercel.sh/you.png`, type: 'human' },
      { id: 'user-2', name: 'Alex Johnson', avatar: `https://avatar.vercel.sh/alex.png`, type: 'human' },
      { id: 'user-3', name: 'Samira Kumar', avatar: `https://avatar.vercel.sh/samira.png`, type: 'human' },
      { id: 'user-4', name: 'Casey Lee', avatar: `https://avatar.vercel.sh/casey.png`, type: 'human' },
      { id: 'user-5', name: 'Jordan Rivera', avatar: `https://avatar.vercel.sh/jordan.png`, type: 'human' },
      { id: 'user-ai-1', name: 'AI Assistant', avatar: `https://avatar.vercel.sh/ai.png`, type: 'ai' },
    ];


    // --- HELPERS ---

    const generateNotes = (contactName: string): Note[] => [
      { id: `note-${faker.string.uuid()}`, content: `Initial discovery call with ${contactName}. Seemed very interested in our enterprise package.`, createdAt: faker.date.past().toISOString() },
      { id: `note-${faker.string.uuid()}`, content: `Followed up via email with pricing details.`, createdAt: faker.date.recent().toISOString() },
    ];


    const generateActivity = (contactName: string): ActivityEvent[] => [
      { id: `act-${faker.string.uuid()}`, type: 'email', content: `Sent follow-up email regarding pricing.`, timestamp: faker.date.past().toISOString() },
      { id: `act-${faker.string.uuid()}`, type: 'call', content: `Had a 30-minute discovery call with ${contactName}.`, timestamp: faker.date.recent().toISOString() },
      { id: `act-${faker.string.uuid()}`, type: 'meeting', content: `Scheduled a demo for next week.`, timestamp: faker.date.soon().toISOString() },
    ];


    // --- COMPANIES ---

    const mockCompanies = Array.from({ length: 25 }, () =>
    faker.company.name());


    // --- CONTACTS ---

    export const mockContacts: Contact[] = Array.from({ length: 80 }, (_, i) =>
    {
        const firstName = faker.person.firstName();
        const lastName = faker.person.lastName();
        const name = `${firstName} ${lastName}`;
        const company = faker.helpers.arrayElement(mockCompanies);
        return {
            id: `contact-${i + 1}`,
            name,
            avatar: `https://avatar.vercel.sh/${firstName.toLowerCase()}${lastName.toLowerCase()}.png`,
            online: faker.datatype.boolean(),
            tags: faker.helpers.arrayElements(['VIP', 'New Lead', 'Returning Customer', 'Support Request', 'High Value'], { min: 1, max: 3 }),
            email: faker.internet.email({ firstName, lastName }),
            phone: faker.phone.number(),
            lastSeen: faker.datatype.boolean() ? 'online' : `${faker.number.int({ min: 2, max: 59 })} minutes ago`,
            company,
            role: faker.person.jobTitle(),
            activity: generateActivity(name),
            notes: generateNotes(name),
        };
    });


    // --- MESSAGE GENERATOR ---

    const generateMessages = (messageCount: number, contactName: string,
    journeyPath: JourneyPointType[]): Message[] => {
      const messages: Message[] = [];
      const now = new Date();
      
      const journeyPointsWithIndices = journeyPath.map((point, index) => ({
          point,
          index: Math.floor((messageCount / journeyPath.length) * (index + Math.random() * 0.8))
      }));

      for (let i = 0; i < messageCount; i++) {
        const random = Math.random();
        let sender: Message['sender'] = 'contact';
        let type: Message['type'] = 'comment';
        let text = faker.lorem.sentence();
        let userId: string | undefined = undefined;

        if (random > 0.85) { // Internal Note
          sender = 'user';
          type = 'note';
          const user = faker.helpers.arrayElement(mockAssignees.filter(u => u.type === 'human'));
          userId = user.id;
          text = `Internal note from ${user.name}: ${faker.lorem.sentence()}`;
        } else if (random > 0.7) { // System message
          sender = 'system';
          type = 'system';
          text = faker.helpers.arrayElement(['Task status changed to "in-progress"', 'Task assigned to Alex Johnson', 'User joined the conversation']);
        } else if (random > 0.35) { // User comment
          sender = 'user';
          type = 'comment';
          userId = 'user-1'; // "You"
          text = faker.lorem.sentence();
        }
        
        const journeyPointInfo = journeyPointsWithIndices.find(jp => jp.index === i);

        messages.push({
          id: `msg-${faker.string.uuid()}`,
          text,
          timestamp: new Date(now.getTime() - (messageCount - i) * 60 * 60 * 100).toISOString(),
          sender,
          type,
          read: i < messageCount - faker.number.int({min: 0, max: 5}),
          userId,
          journeyPoint: journeyPointInfo?.point
        });
      }
      
      // Ensure the last message is from the contact for preview purposes
      messages[messages.length - 1] = {
        ...messages[messages.length-1],
        sender: 'contact',
        type: 'comment',
        text: `Hey! This is the latest message from ${contactName}. ${faker.lorem.sentence()}`,
        userId: undefined
      };
      return messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
    };


    // --- TASK GENERATOR ---

    const generateTasks = (count: number): Task[] => {
        const tasks: Task[] = [];
        const statuses: TaskStatus[] = ['open', 'in-progress', 'done', 'snoozed'];
        const priorities: TaskPriority[] = ['none', 'low', 'medium', 'high'];
        const channels: Channel[] = ['whatsapp', 'instagram', 'facebook', 'email'];
        const possibleJourneys: JourneyPointType[][] = [
            ['Inquiry', 'Consult', 'Quote', 'Order', 'Payment', 'Shipped', 'Delivered', 'Review'],
            ['Inquiry', 'Consult', 'Quote', 'Order', 'Payment', 'Shipped', 'Delivered', 'Follow-up'],
            ['Inquiry', 'Consult', 'Follow-up'],
            ['Inquiry', 'Consult', 'Quote', 'Order', 'Canceled'],
            ['Consult', 'Order', 'Payment', 'Shipped', 'Delivered', 'Complain', 'Refund'],
            ['Consult', 'Order', 'Payment', 'Shipped', 'Complain', 'Follow-up'],
            ['Order', 'Delivered', 'Review', 'Reorder', 'Delivered'],
            ['Complain', 'Follow-up', 'Refund'],
            ['Quote', 'Follow-up', 'Order', 'Payment', 'Shipped', 'Delivered'],
            ['Inquiry', 'Quote', 'Order', 'Payment', 'Shipped', 'Canceled', 'Refund'],
            ['Consult', 'Follow-up'],
            ['Complain'],
            ['Order', 'Delivered'],
        ];

        for (let i = 0; i < count; i++) {
            const contact = faker.helpers.arrayElement(mockContacts);
            const status = faker.helpers.arrayElement(statuses);
            const unreadCount = status === 'open' || status === 'in-progress' ? faker.number.int({ min: 0, max: 8 }) : 0;
            const messageCount = faker.number.int({ min: 10, max: 150 });
            const journey = faker.helpers.arrayElement(possibleJourneys);
            const messages = generateMessages(messageCount, contact.name, journey);
            const assignee = faker.datatype.boolean(0.8) ? faker.helpers.arrayElement(mockAssignees) : null;

            const task: Task = {
                id: `task-${i + 1}`,
                title: faker.lorem.sentence({ min: 3, max: 7 }),
                contactId: contact.id,
                channel: faker.helpers.arrayElement(channels),
                unreadCount,
                messages,
                get lastActivity() { return this.messages[this.messages.length - 1]; },
                status,
                assigneeId: assignee?.id || null,
                dueDate: faker.datatype.boolean() ? faker.date.future().toISOString() : null,
                priority: faker.helpers.arrayElement(priorities),
                tags: faker.helpers.arrayElements(['onboarding', 'pricing', 'bug-report', 'urgent', 'tech-support'], faker.number.int({min: 0, max: 2})),
                aiSummary: {
                    sentiment: faker.helpers.arrayElement(['positive', 'negative', 'neutral']),
                    summaryPoints: Array.from({ length: 3 }, () => faker.lorem.sentence()),
                    suggestedReplies: Array.from({ length: 2 }, () => faker.lorem.words({ min: 3, max: 6})),
                },
                activeHandlerId: faker.helpers.arrayElement([assignee?.id, null, 'user-ai-1']),
            };
            tasks.push(task);
        }
        return tasks;
    }


    export const mockTasks: Task[] = generateTasks(200);
  src/pages/DataDemo/types.ts: >
    export type ViewMode = 'list' | 'cards' | 'grid' | 'table' | 'kanban' |
    'calendar'


    export type GroupableField = 'status' | 'priority' | 'category'


    export type CalendarDateProp = 'dueDate' | 'createdAt' | 'updatedAt';

    export type CalendarDisplayProp = 'priority' | 'assignee' | 'tags';

    export type CalendarColorProp = 'none' | 'priority' | 'status' | 'category';


    export type SortableField = 'title' | 'status' | 'priority' | 'updatedAt' |
    'assignee.name' | 'metrics.views' | 'metrics.completion' | 'createdAt'

    export type SortDirection = 'asc' | 'desc'

    export interface SortConfig {
      key: SortableField
      direction: SortDirection
    }


    export interface DataItem {
      id: string
      title: string
      description: string
      category: string
      status: 'active' | 'pending' | 'completed' | 'archived'
      priority: 'low' | 'medium' | 'high' | 'critical'
      assignee: {
        name: string
        avatar: string
        email: string
      }
      metrics: {
        views: number
        likes: number
        shares: number
        completion: number
      }
      tags: string[]
      createdAt: string
      updatedAt: string
      dueDate?: string
      thumbnail?: string
      content?: {
        summary: string
        details: string
        attachments?: Array<{
          name: string
          type: string
          size: string
          url: string
        }>
      }
    }


    export interface ViewProps {
      data: DataItem[] | Record<string, DataItem[]>
      onItemSelect: (item: DataItem) => void
      selectedItem: DataItem | null
      isGrid?: boolean

      // Props for table view specifically
      sortConfig?: SortConfig | null
      onSort?: (field: SortableField) => void
    }


    export type Status = DataItem['status']

    export type Priority = DataItem['priority']


    export interface FilterConfig {
      searchTerm: string
      status: Status[]
      priority: Priority[]
    }
  src/hooks/useAppViewManager.hook.ts: "import { useMemo, useCallback, useEffect, useRef } from 'react';\nimport { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\nimport type { DataItem, ViewMode, SortConfig, SortableField, GroupableField, Status, Priority, CalendarDateProp, CalendarDisplayProp, CalendarColorProp } from '@/pages/DataDemo/types';\nimport type { FilterConfig } from '@/pages/DataDemo/types';\nimport type { TaskView } from '@/pages/Messaging/types';\nimport { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n\nconst pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n  dashboard: 'main',\n  settings: 'settings',\n  toaster: 'toaster',\n  notifications: 'notifications',\n  'data-demo': 'dataDemo',\n  messaging: 'messaging',\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n/**\n * A centralized hook to manage and synchronize all URL-based view states.\n * This is the single source of truth for view modes, side panes, split views,\n * and page-specific parameters.\n */\nexport function useAppViewManager() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const params = useParams<{ itemId: string; conversationId: string }>();\n  const { itemId, conversationId } = params;\n  const { setSidebarState, sidebarState } = useAppShellStore();\n\n  // --- DERIVED STATE FROM URL ---\n\n  const view = searchParams.get('view');\n  const sidePane = searchParams.get('sidePane');\n  const right = searchParams.get('right');\n  const messagingView = searchParams.get('messagingView') as TaskView | null;\n  const q = searchParams.get('q');\n  const status = searchParams.get('status');\n  const priority = searchParams.get('priority');\n  const sort = searchParams.get('sort');\n  const calDate = searchParams.get('calDate');\n  const calDisplay = searchParams.get('calDisplay');\n  const calLimit = searchParams.get('calLimit');\n  const calColor = searchParams.get('calColor');\n\n  const { bodyState, sidePaneContent } = useMemo(() => {\n    const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo', 'messaging'];\n    \n    // 1. Priority: Explicit side pane overlay via URL param\n    if (sidePane && validPanes.includes(sidePane as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n    }\n\n    // 2. Data item detail view (can be overlay or split)\n    if (itemId) {\n      if (view === 'split') {\n        return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n      }\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n    }\n\n    // 3. Messaging conversation view (always split)\n    if (conversationId) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'messaging' as const };\n    }\n\n    // 4. Generic split view via URL param\n    if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: right as AppShellState['sidePaneContent'] };\n    }\n\n    return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n  }, [itemId, conversationId, view, sidePane, right]);\n  \n  const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n  const prevActivePage = usePrevious(currentActivePage);\n\n  // --- SIDE EFFECTS ---\n  useEffect(() => {\n    // On navigating to messaging page, collapse sidebar if it's expanded.\n    // This ensures a good default view but allows the user to expand it again if they wish.\n    if (currentActivePage === 'messaging' && prevActivePage !== 'messaging' && sidebarState === SIDEBAR_STATES.EXPANDED) {\n      setSidebarState(SIDEBAR_STATES.COLLAPSED);\n    }\n  }, [currentActivePage, prevActivePage, sidebarState, setSidebarState]);\n\n  // DataDemo specific state\n  const viewMode = useMemo(() => (searchParams.get('dataView') as ViewMode) || 'list', [searchParams]);\n\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField | 'none') || 'none', [searchParams]);\n\tconst activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n\tconst filters = useMemo<FilterConfig>(\n\t\t() => ({\n\t\t\tsearchTerm: q || '',\n\t\t\tstatus: (status?.split(',') || []).filter(Boolean) as Status[],\n\t\t\tpriority: (priority?.split(',') || []).filter(Boolean) as Priority[],\n\t\t}),\n\t\t[q, status, priority],\n\t);\n\tconst sortConfig = useMemo<SortConfig | null>(() => {\n\t\tconst sortParam = sort;\n\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n\t\tif (sortParam === 'default') return null;\n\n\t\tconst [key, direction] = sortParam.split('-');\n\t\treturn { key: key as SortableField, direction: direction as 'asc' | 'desc' };\n\t}, [sort]);\n  const calendarDateProp = useMemo(() => (calDate || 'dueDate') as CalendarDateProp, [calDate]);\n  const calendarDisplayProps = useMemo(\n    () => {\n      if (calDisplay === null) return []; // Default is now nothing\n      if (calDisplay === '') return []; // Explicitly empty is also nothing\n      return calDisplay.split(',') as CalendarDisplayProp[];\n    },\n    [calDisplay]\n  );\n  const calendarItemLimit = useMemo(() => {\n    const limit = parseInt(calLimit || '3', 10);\n    if (calLimit === 'all') return 'all';\n    return isNaN(limit) ? 3 : limit;\n  }, [calLimit]);\n  const calendarColorProp = useMemo(() => (calColor || 'none') as CalendarColorProp, [calColor]);\n\n  // --- MUTATOR ACTIONS ---\n\n  const handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | string[] | null | undefined>, resetPage = false) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\t\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resetPage) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n  const navigateTo = useCallback((page: string, params?: Record<string, string | null>) => {\n    const targetPath = page.startsWith('/') ? page : `/${page}`;\n    const isSamePage = location.pathname === targetPath;\n    \n    const newSearchParams = new URLSearchParams(isSamePage ? searchParams : undefined);\n\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n          newSearchParams.delete(key);\n        } else {\n          newSearchParams.set(key, value);\n        }\n      }\n    }\n\n    navigate({ pathname: targetPath, search: newSearchParams.toString() });\n  }, [navigate, location.pathname, searchParams]);\n\n  const openSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (location.pathname === `/${Object.keys(pageToPaneMap).find(key => pageToPaneMap[key] === pane)}`) {\n        navigate({ pathname: '/dashboard', search: `?sidePane=${pane}` }, { replace: true });\n    } else {\n        handleParamsChange({ sidePane: pane, view: null, right: null });\n    }\n  }, [handleParamsChange, navigate, location.pathname]);\n\n  const closeSidePane = useCallback(() => {\n    if (itemId) {\n      navigate('/data-demo');\n    } else {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n    }\n  }, [itemId, navigate, handleParamsChange]);\n\n  const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (sidePane === pane) {\n      closeSidePane();\n    } else {\n      openSidePane(pane);\n    }\n  }, [sidePane, openSidePane, closeSidePane]);\n\n  const toggleSplitView = useCallback(() => {\n    if (bodyState === BODY_STATES.SIDE_PANE) {\n      handleParamsChange({ view: 'split', right: sidePane, sidePane: null });\n    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {\n      handleParamsChange({ sidePane: right, view: null, right: null });\n    } else { // From normal\n      const paneContent = pageToPaneMap[currentActivePage] || 'details';\n      handleParamsChange({ view: 'split', right: paneContent, sidePane: null });\n    }\n  }, [bodyState, sidePane, right, currentActivePage, handleParamsChange]);\n  \n  const setNormalView = useCallback(() => {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const switchSplitPanes = useCallback(() => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    const newSidePaneContent = pageToPaneMap[currentActivePage];\n    const newActivePage = Object.entries(pageToPaneMap).find(\n      ([, value]) => value === sidePaneContent\n    )?.[0] as ActivePage | undefined;\n\n    if (newActivePage && newSidePaneContent) {\n      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const closeSplitPane = useCallback((paneToClose: 'main' | 'right') => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    if (paneToClose === 'right') {\n      navigate(`/${currentActivePage}`, { replace: true });\n    } else { // Closing main pane\n      const pageToBecomeActive = Object.entries(pageToPaneMap).find(\n        ([, value]) => value === sidePaneContent\n      )?.[0] as ActivePage | undefined;\n      \n      if (pageToBecomeActive) {\n        navigate(`/${pageToBecomeActive}`, { replace: true });\n      } else {\n        navigate(`/dashboard`, { replace: true });\n      }\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  // DataDemo actions\n  const setViewMode = (mode: ViewMode) => handleParamsChange({ dataView: mode === 'list' ? null : mode });\n  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val }, true);\n  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n  const setFilters = (newFilters: FilterConfig) => {\n    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority }, true);\n  }\n  const setSort = (config: SortConfig | null) => {\n    if (!config) {\n      handleParamsChange({ sort: null }, true);\n    } else {\n      handleParamsChange({ sort: `${config.key}-${config.direction}` }, true);\n    }\n  }\n  const setTableSort = (field: SortableField) => {\n    let newSort: string | null = `${field}-desc`;\n    if (sortConfig?.key === field) {\n      if (sortConfig.direction === 'desc') newSort = `${field}-asc`;\n      else if (sortConfig.direction === 'asc') newSort = null;\n    }\n    handleParamsChange({ sort: newSort }, true);\n  };\n  const setPage = (newPage: number) => handleParamsChange({ page: newPage.toString() });\n\n  // Calendar specific actions\n  const setCalendarDateProp = (prop: CalendarDateProp) => handleParamsChange({ calDate: prop === 'dueDate' ? null : prop });\n  const setCalendarDisplayProps = (props: CalendarDisplayProp[]) => {\n    // Check for default state to keep URL clean\n    const isDefault = props.length === 0;\n    handleParamsChange({ calDisplay: isDefault ? null : props.join(',') });\n  };\n  const setCalendarItemLimit = (limit: number | 'all') => handleParamsChange({ calLimit: limit === 3 ? null : String(limit) });\n  const setCalendarColorProp = (prop: CalendarColorProp) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n\n  const onItemSelect = useCallback((item: DataItem) => {\n\t\tnavigate(`/data-demo/${item.id}${location.search}`);\n\t}, [navigate, location.search]);\n\n  const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n\n\n  return useMemo(() => ({\n    // State\n    bodyState,\n    sidePaneContent,\n    currentActivePage,\n    itemId,\n    messagingView,\n    // DataDemo State\n    viewMode,\n    page,\n    groupBy,\n    activeGroupTab,\n    filters,\n    sortConfig,\n    calendarDateProp,\n    calendarDisplayProps,\n    calendarItemLimit,\n    calendarColorProp,\n    // Actions\n    navigateTo,\n    openSidePane,\n    closeSidePane,\n    toggleSidePane,\n    toggleSplitView,\n    setNormalView,\n    switchSplitPanes,\n    setMessagingView,\n    closeSplitPane,\n    // DataDemo Actions\n    onItemSelect,\n    setViewMode,\n    setGroupBy,\n    setActiveGroupTab,\n    setFilters,\n    setSort,\n    setTableSort,\n    setPage,\n    setCalendarDateProp,\n    setCalendarDisplayProps,\n    setCalendarItemLimit,\n    setCalendarColorProp,\n  }), [\n    bodyState, sidePaneContent, currentActivePage, itemId, messagingView, viewMode,\n    page, groupBy, activeGroupTab, filters, sortConfig, calendarDateProp,\n    calendarDisplayProps, calendarItemLimit, calendarColorProp,\n    navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, setNormalView, setMessagingView,\n    switchSplitPanes, closeSplitPane, onItemSelect, setViewMode, setGroupBy, setActiveGroupTab, setFilters,\n    setSort, setTableSort, setPage, setCalendarDateProp, setCalendarDisplayProps, setCalendarItemLimit, setCalendarColorProp\n  ]);\n}"
  src/pages/DataDemo/store/dataDemo.store.tsx: >-
    import { create } from 'zustand';

    import { type ReactNode } from 'react';

    import { capitalize, cn } from '@/lib/utils';

    import { Badge } from '@/components/ui/badge';

    import { mockDataItems } from '../data/mockData';

    import type { DataItem, GroupableField, SortConfig, FilterConfig } from
    '../types';


    // --- State and Actions ---

    interface DataDemoState {
        items: DataItem[];
        hasMore: boolean;
        isLoading: boolean;
        isInitialLoading: boolean;
        totalItemCount: number;
    }


    interface DataDemoActions {
        loadData: (params: {
            page: number;
            groupBy: GroupableField | 'none';
            filters: FilterConfig;
            sortConfig: SortConfig | null;
        isFullLoad?: boolean;
        }) => void;
        updateItem: (itemId: string, updates: Partial<DataItem>) => void;
    }


    const defaultState: DataDemoState = {
        items: [],
        hasMore: true,
        isLoading: true,
        isInitialLoading: true,
        totalItemCount: 0,
    };


    // --- Store Implementation ---

    export const useDataDemoStore = create<DataDemoState &
    DataDemoActions>((set, get) => ({
        ...defaultState,

        loadData: ({ page, groupBy, filters, sortConfig, isFullLoad }) => {
            set({ isLoading: true, ...(page === 1 && { isInitialLoading: true }) });
            const isFirstPage = page === 1;

            const filteredAndSortedData = (() => {
                const filteredItems = mockDataItems.filter((item) => {
                    const searchTermMatch =
                        item.title.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
                        item.description.toLowerCase().includes(filters.searchTerm.toLowerCase());
                    const statusMatch = filters.status.length === 0 || filters.status.includes(item.status);
                    const priorityMatch = filters.priority.length === 0 || filters.priority.includes(item.priority);
                    return searchTermMatch && statusMatch && priorityMatch;
                });

                if (sortConfig) {
                    filteredItems.sort((a, b) => {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        const getNestedValue = (obj: DataItem, path: string): any =>
                            path.split('.').reduce((o: any, k) => (o || {})[k], obj);

                        const aValue = getNestedValue(a, sortConfig.key);
                        const bValue = getNestedValue(b, sortConfig.key);

                        if (aValue === undefined || bValue === undefined) return 0;
                        if (typeof aValue === 'string' && typeof bValue === 'string') {
                            return sortConfig.direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                        }
                        if (typeof aValue === 'number' && typeof bValue === 'number') {
                            return sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue;
                        }
                        if (sortConfig.key === 'updatedAt' || sortConfig.key === 'createdAt') {
                            if (typeof aValue === 'string' && typeof bValue === 'string') {
                                return sortConfig.direction === 'asc'
                                    ? new Date(aValue).getTime() - new Date(bValue).getTime()
                                    : new Date(bValue).getTime() - new Date(aValue).getTime();
                            }
                        }
                        return 0;
                    });
                }
                return filteredItems;
            })();
            
            const totalItemCount = filteredAndSortedData.length;

            setTimeout(() => {
                if (groupBy !== 'none' || isFullLoad) {
                    set({
                        items: filteredAndSortedData,
                        hasMore: false,
                        isLoading: false,
                        isInitialLoading: false,
                        totalItemCount,
                    });
                    return;
                }

                const pageSize = 12;
                const newItems = filteredAndSortedData.slice((page - 1) * pageSize, page * pageSize);
                
                set(state => ({
                    items: isFirstPage ? newItems : [...state.items, ...newItems],
                    hasMore: totalItemCount > page * pageSize,
                    isLoading: false,
                    isInitialLoading: false,
                    totalItemCount,
                }));

            }, isFirstPage ? 1500 : 500);
        },

        updateItem: (itemId, updates) => {
            // In a real app, this would be an API call. Here we update the mock source.
            const itemIndex = mockDataItems.findIndex(i => i.id === itemId);
            if (itemIndex > -1) {
                mockDataItems[itemIndex] = { ...mockDataItems[itemIndex], ...updates };
            }

            // Also update the currently loaded items in the store's state for UI consistency
            set(state => ({
                items: state.items.map(item => 
                    item.id === itemId ? { ...item, ...updates } : item
                ),
            }));
        },
    }));


    // --- Selectors ---

    export const useGroupTabs = (
        groupBy: GroupableField | 'none',
        activeGroupTab: string,
    ) => useDataDemoStore(state => {
        const items = state.items;
        if (groupBy === 'none' || !items.length) return [];
        
        const groupCounts = items.reduce((acc, item) => {
            const groupKey = String(item[groupBy as GroupableField]);
            acc[groupKey] = (acc[groupKey] || 0) + 1;
            return acc;
        }, {} as Record<string, number>);

        const sortedGroups = Object.keys(groupCounts).sort((a, b) => a.localeCompare(b));

        const createLabel = (text: string, count: number, isActive: boolean): ReactNode => (
            <>
                {text}
                <Badge variant={isActive ? 'default' : 'secondary'} className={cn('transition-colors duration-300 text-xs font-semibold', !isActive && 'group-hover:bg-accent group-hover:text-accent-foreground')}>
                    {count}
                </Badge>
            </>
        );
        
        const totalCount = items.length;

        return [
            { id: 'all', label: createLabel('All', totalCount, activeGroupTab === 'all') },
            ...sortedGroups.map((g) => ({
                id: g,
                label: createLabel(capitalize(g), groupCounts[g], activeGroupTab === g),
            })),
        ];
    });


    export const useDataToRender = (
        groupBy: GroupableField | 'none',
        activeGroupTab: string,
    ) => useDataDemoStore(state => {
        const items = state.items;
        if (groupBy === 'none') {
            return items;
        }
        if (activeGroupTab === 'all') {
            return items;
        }
        return items.filter((item) => String(item[groupBy as GroupableField]) === activeGroupTab);
    });


    export const useSelectedItem = (itemId?: string) => {
        if (!itemId) return null;
        return mockDataItems.find(item => item.id === itemId) ?? null;
    };
  src/pages/Messaging/components/TaskHeader.tsx: >
    import React from 'react';

    import { useMessagingStore } from '../store/messaging.store';

    import type { Task, TaskStatus, TaskPriority, Assignee, Contact } from
    '../types';

    import {
      DropdownMenu,
      DropdownMenuContent,
      DropdownMenuItem,
      DropdownMenuRadioGroup,
      DropdownMenuRadioItem,
      DropdownMenuTrigger,
      DropdownMenuSeparator
    } from '@/components/ui/dropdown-menu';

    import { Button } from '@/components/ui/button';

    import { Avatar, AvatarFallback, AvatarImage } from
    '@/components/ui/avatar';

    import { ChevronDown, Inbox, Zap, Shield, Clock, Calendar, Plus, User, Eye }
    from 'lucide-react';

    import { Badge } from '@/components/ui/badge';

    import { format } from 'date-fns';


    const statusOptions: { value: TaskStatus; label: string; icon:
    React.ReactNode }[] = [
        { value: 'open', label: 'Open', icon: <Inbox className="w-4 h-4" /> },
        { value: 'in-progress', label: 'In Progress', icon: <Zap className="w-4 h-4" /> },
        { value: 'done', label: 'Done', icon: <Shield className="w-4 h-4" /> },
        { value: 'snoozed', label: 'Snoozed', icon: <Clock className="w-4 h-4" /> },
    ];


    const priorityOptions: { value: TaskPriority; label: string; icon:
    React.ReactNode }[] = [
        { value: 'high', label: 'High', icon: <div className="w-2.5 h-2.5 rounded-full bg-red-500" /> },
        { value: 'medium', label: 'Medium', icon: <div className="w-2.5 h-2.5 rounded-full bg-yellow-500" /> },
        { value: 'low', label: 'Low', icon: <div className="w-2.5 h-2.5 rounded-full bg-green-500" /> },
        { value: 'none', label: 'None', icon: <div className="w-2.5 h-2.5 rounded-full bg-gray-400" /> },
    ];



    interface TaskHeaderProps {
      task: (Task & { contact: Contact; assignee: Assignee | null });
    }


    export const TaskHeader: React.FC<TaskHeaderProps> = ({ task }) => {
      const { updateTask, assignees } = useMessagingStore();
      const currentStatus = statusOptions.find(o => o.value === task.status);
      const currentPriority = priorityOptions.find(o => o.value === task.priority);
      const currentUserId = 'user-1'; // Mock current user
      const isHandledByOther = task.activeHandler && task.activeHandlerId !== currentUserId;


      return (
        <div className="space-y-4">
          {/* Task Title & Contact */}
          <div className="overflow-hidden">
            <h2 className="font-bold text-xl lg:text-2xl truncate" title={task.title}>
              {task.title}
            </h2>
            <p className="text-sm text-muted-foreground">
              With <a href="#" className="hover:underline font-medium text-foreground/80">{task.contact.name}</a> from <strong className="font-medium text-foreground/80">{task.contact.company}</strong>
              <span className="mx-1">&middot;</span>
              via <span className="capitalize font-medium text-foreground/80">{task.channel}</span>
            </p>
          </div>

          {/* Properties Bar */}
          <div className="flex flex-wrap items-center gap-y-2 text-sm">
            {/* Assignee Dropdown */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="sm" className="gap-2 font-normal">
                  {task.assignee ? (
                    <Avatar className="h-5 w-5"><AvatarImage src={task.assignee.avatar} /><AvatarFallback>{task.assignee.name.charAt(0)}</AvatarFallback></Avatar>
                  ) : (
                    <User className="h-4 w-4 text-muted-foreground" />
                  )}
                  <span className="font-medium">{task.assignee?.name || 'Unassigned'}</span>
                  <ChevronDown className="w-3 h-3 text-muted-foreground" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start">
                <DropdownMenuRadioGroup value={task.assigneeId || 'null'} onValueChange={val => updateTask(task.id, { assigneeId: val === 'null' ? null : val })}>
                  <DropdownMenuRadioItem value="null">
                    <User className="w-4 h-4 mr-2 text-muted-foreground" /> Unassigned
                  </DropdownMenuRadioItem>
                  <DropdownMenuSeparator />
                  {assignees.map(a => (
                    <DropdownMenuRadioItem key={a.id} value={a.id}>
                      <Avatar className="h-5 w-5 mr-2"><AvatarImage src={a.avatar} /><AvatarFallback>{a.name.charAt(0)}</AvatarFallback></Avatar>
                      {a.name}
                    </DropdownMenuRadioItem>
                  ))}
                </DropdownMenuRadioGroup>
              </DropdownMenuContent>
            </DropdownMenu>

            {isHandledByOther && (
                <>
                    <div className="mx-2 h-4 w-px bg-border" />
                    <Badge variant="outline" className="gap-2 font-normal text-amber-600 border-amber-600/50">
                        <Eye className="w-3.5 h-3.5" /> Viewing: {task.activeHandler?.name}
                    </Badge>
                </>
            )}
            <div className="mx-2 h-4 w-px bg-border" />

            {/* Status Dropdown */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm" className="gap-2 text-muted-foreground hover:text-foreground">
                  {currentStatus?.icon}
                  <span className="font-medium text-foreground">{currentStatus?.label}</span>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start">
                {statusOptions.map(o => (
                  <DropdownMenuItem key={o.value} onClick={() => updateTask(task.id, { status: o.value })}>
                    <div className="flex items-center">
                      <div className="w-4 h-4 mr-2">{o.icon}</div>
                      <span>{o.label}</span>
                    </div>
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>
            
            <div className="mx-2 h-4 w-px bg-border" />
            
            {/* Priority Dropdown */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm" className="gap-2 text-muted-foreground hover:text-foreground">
                  {currentPriority?.icon}
                  <span className="font-medium text-foreground">{currentPriority?.label}</span>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start">
                {priorityOptions.map(o => (
                  <DropdownMenuItem key={o.value} onClick={() => updateTask(task.id, { priority: o.value })}>
                    <div className="flex items-center">
                      <div className="w-2.5 h-2.5 mr-2">{o.icon}</div>
                      <span>{o.label}</span>
                    </div>
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>

            <div className="mx-2 h-4 w-px bg-border" />

            {/* Due Date - for display, could be a popover trigger */}
            <Button variant="ghost" size="sm" className="gap-2 text-muted-foreground cursor-default" disabled>
                <Calendar className="w-4 h-4" />
                <span className="font-medium text-foreground">{task.dueDate ? format(new Date(task.dueDate), 'MMM d, yyyy') : 'No due date'}</span>
            </Button>
          </div>

          {/* Tags */}
          <div className="flex flex-wrap items-center gap-2">
            {task.tags.map(t => <Badge variant="secondary" key={t}>{t}</Badge>)}
            <Button variant="outline" size="sm" className="h-7 px-2 text-xs rounded-md border-dashed">
              <Plus className="w-3 h-3 mr-1" /> Tag
            </Button>
          </div>
        </div>
      );
    };
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 492
