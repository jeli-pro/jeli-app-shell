uuid: 440e234c-6869-450f-90e6-ec069c9b1062
projectId: jeli-app-shell
createdAt: '2025-10-21T17:07:51.656Z'
gitCommitMsg: >-
  refactor(URL State): Decouple path and search params for views

  Refactored the URL state management in `useAppViewManager` to cleanly separate
  main content routing from side pane state.

  - Main content views are now driven exclusively by the URL path (e.g.,
  `/data-demo/:itemId`). - Side pane views are now driven by search parameters
  (e.g., `?itemId=...`).

  This change resolves state conflicts and enables smooth transitions, such as
  automatically closing a detail side pane when navigating to the main list
  view, mimicking the behavior of the Settings page.
promptSummary: >-
  The user wants to fix the data detail view's behavior to be more like other
  pages (e.g., Settings), where navigating to its main page smoothly closes an
  open side pane. This involves refactoring the URL state management to separate
  main content views (driven by path) from side pane views (driven by search
  params).
reasoning:
  - >-
    You've correctly identified a key architectural issue. The previous
    implementation overloaded a single URL pattern (`/data-demo/:itemId`) to
    mean two different things (main content view and side pane view), leading to
    state conflicts and the unsmooth transitions you noticed.
  - >-
    I've now refactored the state management to cleanly separate these concerns,
    mirroring the behavior of the Settings and Notifications pages:
  - >-
    1.  **Main Content is determined by the URL Path**: Navigating to
    `/data-demo/:itemId` will now *always* render the item's details as the main
    page content, with a normal layout.
  - >-
    2.  **Side Pane Content is determined by URL Search Parameters**: Clicking
    an item in a list now adds an `?itemId=...` parameter to the URL. This
    triggers the side pane to open with the item's details, leaving the main
    list view unchanged.
  - >-
    This separation resolves the state conflict. Now, when you are viewing an
    item in the side pane (e.g., at `/data-demo?itemId=123`) and click the "Data
    Showcase" link in the sidebar, the app navigates to `/data-demo`. The
    `?itemId=...` parameter is removed, the side pane smoothly closes, and you
    are left with the main list view, as expected.
  - Here are the precise changes to implement this improved architecture.
operations:
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: "--- src/hooks/useAppViewManager.hook.ts\n+++ src/hooks/useAppViewManager.hook.ts\n@@ -19,13 +19,14 @@\n   const [searchParams, setSearchParams] = useSearchParams();\n   const navigate = useNavigate();\n   const location = useLocation();\n-  const params = useParams<{ itemId: string; conversationId: string }>();\n-  const { itemId, conversationId } = params;\n+  const { itemId: pathItemId, conversationId } = useParams<{ itemId: string; conversationId: string }>();\n   const { setSidebarState, sidebarState } = useAppShellStore();\n \n   // --- DERIVED STATE FROM URL ---\n \n   const view = searchParams.get('view');\n   const sidePane = searchParams.get('sidePane');\n+  const sidePaneItemId = searchParams.get('itemId');\n   const right = searchParams.get('right');\n   const messagingView = searchParams.get('messagingView') as TaskView | null;\n   const q = searchParams.get('q');\n@@ -43,14 +44,14 @@\n       return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n     }\n \n-    // 2. Data item detail view (can be overlay or split)\n-    if (itemId) {\n+    // 2. Data item detail view in a pane, triggered by search param\n+    if (sidePaneItemId) {\n       if (view === 'split') {\n         return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n       }\n       return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n     }\n \n     // 3. Messaging conversation view (always split)\n     if (conversationId) {\n@@ -62,7 +63,7 @@\n     }\n \n     return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n-  }, [itemId, conversationId, view, sidePane, right]);\n+  }, [sidePaneItemId, conversationId, view, sidePane, right]);\n   \n   const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n   const prevActivePage = usePrevious(currentActivePage);\n@@ -148,11 +149,8 @@\n   }, [handleParamsChange, navigate, location.pathname]);\n \n   const closeSidePane = useCallback(() => {\n-    if (itemId) {\n-      navigate('/data-demo');\n-    } else {\n-      handleParamsChange({ sidePane: null, view: null, right: null });\n-    }\n-  }, [itemId, navigate, handleParamsChange]);\n+    // This should close any kind of side pane, including dataItem\n+    handleParamsChange({ sidePane: null, view: null, right: null, itemId: null });\n+  }, [handleParamsChange]);\n \n   const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n     if (sidePane === pane) {\n@@ -216,16 +214,19 @@\n   const setCalendarColorProp = (prop: CalendarColorProp<string>) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n \n   const onItemSelect = useCallback((item: GenericItem) => {\n-\t\tnavigate(`/data-demo/${item.id}${location.search}`);\n-\t}, [navigate, location.search]);\n+\t\thandleParamsChange({ itemId: item.id, sidePane: null });\n+\t}, [handleParamsChange]);\n \n   const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n \n+  // The final active item ID is either from the path (main view) or a search param (pane view)\n+  const itemId = pathItemId || sidePaneItemId;\n \n   return useMemo(() => ({\n     // State\n     bodyState,\n     sidePaneContent,\n     currentActivePage,\n+    pathItemId, // Expose for main content decisions\n     itemId,\n     messagingView,\n     // DataDemo State\n@@ -253,7 +254,7 @@\n     setCalendarItemLimit,\n     setCalendarColorProp,\n   }), [\n-    bodyState, sidePaneContent, currentActivePage, itemId, messagingView, viewMode,\n+    bodyState, sidePaneContent, currentActivePage, pathItemId, itemId, messagingView, viewMode,\n     page, groupBy, activeGroupTab, filters, sortConfig, calendarDateProp,\n     calendarDisplayProps, calendarItemLimit, calendarColorProp,\n     navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, setNormalView, setMessagingView,\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useRightPaneContent.hook.tsx
    content: >+
      --- src/hooks/useRightPaneContent.hook.tsx

      +++ src/hooks/useRightPaneContent.hook.tsx

      @@ -1,5 +1,5 @@
       import { useMemo } from 'react';
      -import { useParams } from 'react-router-dom';

      +import { useParams, useSearchParams } from 'react-router-dom';
       import {
         LayoutDashboard,
         Settings,
      @@ -24,7 +24,9 @@
       import { DataDetailContent } from '@/pages/DataDemo/components/DataDetailContent';
       
       export function useRightPaneContent(sidePaneContent: AppShellState['sidePaneContent']) {
      -  const { itemId, conversationId } = useParams<{ itemId: string;
      conversationId: string }>();

      +  const { conversationId } = useParams<{ conversationId: string }>();

      +  const [searchParams] = useSearchParams();

      +  const sidePaneItemId = searchParams.get('itemId');
       
         const staticContentMap = useMemo(() => ({
           main: {
      @@ -74,17 +76,17 @@
           },
         }), [conversationId, staticContentMap]);
       
      -  const selectedItem = useSelectedItem(itemId);

      +  const selectedItem = useSelectedItem(sidePaneItemId);
       
         const { meta, content } = useMemo(() => {
           if (sidePaneContent === 'dataItem' && selectedItem) {
             return {
               meta: { 
                 title: "Item Details", 
                 icon: Database, 
      -          page: `data-demo/${itemId}`,

      +          page: `data-demo/${sidePaneItemId}`,
                 hasOwnScrolling: true 
               },
               content: <DataDetailContent item={selectedItem} />,
             };
      @@ -94,7 +96,7 @@
             meta: mappedContent,
             content: mappedContent.content,
           };
      -  }, [sidePaneContent, selectedItem, contentMap, itemId]);

      +  }, [sidePaneContent, selectedItem, contentMap, sidePaneItemId]);
       
         return { meta, content };
       }

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: |+
      --- src/pages/DataDemo/index.tsx
      +++ src/pages/DataDemo/index.tsx
      @@ -27,11 +27,11 @@
           setPage,
           setFilters,
           setViewMode,
           onItemSelect,
      -    itemId,
      +    pathItemId,
         } = useAppViewManager();
       
      -  const selectedItem = useSelectedItem(itemId);
      +  const selectedItem = useSelectedItem(pathItemId);
       
         const {
           items: allItems,
      @@ -165,9 +165,9 @@
           [isLoading, hasMore, page, setPage],
         );
       
      -  if (itemId && selectedItem) {
      +  if (pathItemId && selectedItem) {
           // Render detail view as the main content
           return <DataDetailContent item={selectedItem} />;
         }
       
         return (

    patchStrategy: standard-diff
snapshot:
  src/hooks/useAppViewManager.hook.ts: "import { useMemo, useCallback, useEffect, useRef } from 'react';\nimport { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\nimport type { GenericItem, ViewMode, SortConfig, GroupableField, CalendarDateProp, CalendarDisplayProp, CalendarColorProp, FilterConfig } from '@/features/dynamic-view/types';\nimport type { TaskView } from '@/pages/Messaging/types';\nimport { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n\nconst pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n  dashboard: 'main',\n  settings: 'settings',\n  toaster: 'toaster',\n  notifications: 'notifications',\n  'data-demo': 'dataDemo',\n  messaging: 'messaging',\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n/**\n * A centralized hook to manage and synchronize all URL-based view states.\n * This is the single source of truth for view modes, side panes, split views,\n * and page-specific parameters.\n */\nexport function useAppViewManager() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const params = useParams<{ itemId: string; conversationId: string }>();\n  const { itemId, conversationId } = params;\n  const { setSidebarState, sidebarState } = useAppShellStore();\n\n  // --- DERIVED STATE FROM URL ---\n\n  const view = searchParams.get('view');\n  const sidePane = searchParams.get('sidePane');\n  const right = searchParams.get('right');\n  const messagingView = searchParams.get('messagingView') as TaskView | null;\n  const q = searchParams.get('q');\n  const status = searchParams.get('status');\n  const priority = searchParams.get('priority');\n  const sort = searchParams.get('sort');\n  const calDate = searchParams.get('calDate');\n  const calDisplay = searchParams.get('calDisplay');\n  const calLimit = searchParams.get('calLimit');\n  const calColor = searchParams.get('calColor');\n\n  const { bodyState, sidePaneContent } = useMemo(() => {\n    const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo', 'messaging'];\n    \n    // 1. Priority: Explicit side pane overlay via URL param\n    if (sidePane && validPanes.includes(sidePane as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n    }\n\n    // 2. Data item detail view (can be overlay or split)\n    if (itemId) {\n      if (view === 'split') {\n        return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n      }\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n    }\n\n    // 3. Messaging conversation view (always split)\n    if (conversationId) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'messaging' as const };\n    }\n\n    // 4. Generic split view via URL param\n    if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: right as AppShellState['sidePaneContent'] };\n    }\n\n    return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n  }, [itemId, conversationId, view, sidePane, right]);\n  \n  const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n  const prevActivePage = usePrevious(currentActivePage);\n\n  // --- SIDE EFFECTS ---\n  useEffect(() => {\n    // On navigating to messaging page, collapse sidebar if it's expanded.\n    // This ensures a good default view but allows the user to expand it again if they wish.\n    if (currentActivePage === 'messaging' && prevActivePage !== 'messaging' && sidebarState === SIDEBAR_STATES.EXPANDED) {\n      setSidebarState(SIDEBAR_STATES.COLLAPSED);\n    }\n  }, [currentActivePage, prevActivePage, sidebarState, setSidebarState]);\n\n  // DataDemo specific state\n  const viewMode = useMemo(() => (searchParams.get('dataView') as ViewMode) || 'list', [searchParams]);\n  const page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n  const groupBy = useMemo(() => {\n    const groupByParam = (searchParams.get('groupBy') as GroupableField<string> | 'none') || 'none';\n    // Kanban view should default to grouping by status if no group is specified\n    if (viewMode === 'kanban' && groupByParam === 'none') {\n      return 'status';\n    }\n    return groupByParam;\n  }, [searchParams, viewMode]);\n  const activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n  const filters = useMemo<FilterConfig>(\n\t\t() => ({\n\t\t\tsearchTerm: q || '',\n\t\t\tstatus: (status?.split(',') || []).filter(Boolean),\n\t\t\tpriority: (priority?.split(',') || []).filter(Boolean),\n\t\t}),\n\t\t[q, status, priority],\n\t);\n  const sortConfig = useMemo<SortConfig<string> | null>(() => {\n    if (viewMode === 'kanban') return null; // Kanban is manually sorted\n\t\tconst sortParam = sort;\n\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n\t\tif (sortParam === 'default') return null;\n\n\t\tconst [key, direction] = sortParam.split('-');\n\t\treturn { key, direction: direction as 'asc' | 'desc' };\n  }, [sort, viewMode]);\n  const calendarDateProp = useMemo(() => (calDate || 'dueDate') as CalendarDateProp<string>, [calDate]);\n  const calendarDisplayProps = useMemo(\n    () => {\n      if (calDisplay === null) return []; // Default is now nothing\n      if (calDisplay === '') return []; // Explicitly empty is also nothing\n      return calDisplay.split(',') as CalendarDisplayProp<string>[];\n    },\n    [calDisplay]\n  );\n  const calendarItemLimit = useMemo(() => {\n    const limit = parseInt(calLimit || '3', 10);\n    if (calLimit === 'all') return 'all';\n    return isNaN(limit) ? 3 : limit;\n  }, [calLimit]);\n  const calendarColorProp = useMemo(() => (calColor || 'none') as CalendarColorProp<string>, [calColor]);\n\n  // --- MUTATOR ACTIONS ---\n\n  const handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | number | string[] | null | undefined>, resetPage = false) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\t\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resetPage) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n  const navigateTo = useCallback((page: string, params?: Record<string, string | null>) => {\n    const targetPath = page.startsWith('/') ? page : `/${page}`;\n    const isSamePage = location.pathname === targetPath;\n    \n    const newSearchParams = new URLSearchParams(isSamePage ? searchParams : undefined);\n\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n          newSearchParams.delete(key);\n        } else {\n          newSearchParams.set(key, value);\n        }\n      }\n    }\n\n    navigate({ pathname: targetPath, search: newSearchParams.toString() });\n  }, [navigate, location.pathname, searchParams]);\n\n  const openSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (location.pathname === `/${Object.keys(pageToPaneMap).find(key => pageToPaneMap[key] === pane)}`) {\n        navigate({ pathname: '/dashboard', search: `?sidePane=${pane}` }, { replace: true });\n    } else {\n        handleParamsChange({ sidePane: pane, view: null, right: null });\n    }\n  }, [handleParamsChange, navigate, location.pathname]);\n\n  const closeSidePane = useCallback(() => {\n    if (itemId) {\n      navigate('/data-demo');\n    } else {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n    }\n  }, [itemId, navigate, handleParamsChange]);\n\n  const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (sidePane === pane) {\n      closeSidePane();\n    } else {\n      openSidePane(pane);\n    }\n  }, [sidePane, openSidePane, closeSidePane]);\n\n  const toggleSplitView = useCallback(() => {\n    if (bodyState === BODY_STATES.SIDE_PANE) {\n      handleParamsChange({ view: 'split', right: sidePane, sidePane: null });\n    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {\n      handleParamsChange({ sidePane: right, view: null, right: null });\n    } else { // From normal\n      const paneContent = pageToPaneMap[currentActivePage] || 'details';\n      handleParamsChange({ view: 'split', right: paneContent, sidePane: null });\n    }\n  }, [bodyState, sidePane, right, currentActivePage, handleParamsChange]);\n  \n  const setNormalView = useCallback(() => {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const switchSplitPanes = useCallback(() => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    const newSidePaneContent = pageToPaneMap[currentActivePage];\n    const newActivePage = Object.entries(pageToPaneMap).find(\n      ([, value]) => value === sidePaneContent\n    )?.[0] as ActivePage | undefined;\n\n    if (newActivePage && newSidePaneContent) {\n      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const closeSplitPane = useCallback((paneToClose: 'main' | 'right') => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    if (paneToClose === 'right') {\n      navigate(`/${currentActivePage}`, { replace: true });\n    } else { // Closing main pane\n      const pageToBecomeActive = Object.entries(pageToPaneMap).find(\n        ([, value]) => value === sidePaneContent\n      )?.[0] as ActivePage | undefined;\n      \n      if (pageToBecomeActive) {\n        navigate(`/${pageToBecomeActive}`, { replace: true });\n      } else {\n        navigate(`/dashboard`, { replace: true });\n      }\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  // DataDemo actions\n  const setViewMode = (mode: ViewMode) => handleParamsChange({ dataView: mode === 'list' ? null : mode });\n  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val }, true);\n  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n  const setFilters = (newFilters: FilterConfig) => {\n    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority }, true);\n  }\n  const setSort = (config: SortConfig<string> | null) => {\n    if (!config) {\n      handleParamsChange({ sort: null }, true);\n    } else {\n      handleParamsChange({ sort: `${config.key}-${config.direction}` }, true);\n    }\n  }\n  const setTableSort = (field: string) => {\n    let newSort: string | null = `${field}-desc`;\n    if (sortConfig && sortConfig.key === field) {\n      if (sortConfig.direction === 'desc') newSort = `${field}-asc`;\n      else if (sortConfig.direction === 'asc') newSort = null;\n    }\n    handleParamsChange({ sort: newSort }, true);\n  };\n  const setPage = (newPage: number) => handleParamsChange({ page: newPage > 1 ? newPage.toString() : null });\n\n  // Calendar specific actions\n  const setCalendarDateProp = (prop: CalendarDateProp<string>) => handleParamsChange({ calDate: prop === 'dueDate' ? null : prop });\n  const setCalendarDisplayProps = (props: CalendarDisplayProp<string>[]) => {\n    // Check for default state to keep URL clean\n    const isDefault = props.length === 0;\n    handleParamsChange({ calDisplay: isDefault ? null : props.join(',') });\n  };\n  const setCalendarItemLimit = (limit: number | 'all') => handleParamsChange({ calLimit: limit === 3 ? null : String(limit) });\n  const setCalendarColorProp = (prop: CalendarColorProp<string>) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n\n  const onItemSelect = useCallback((item: GenericItem) => {\n\t\tnavigate(`/data-demo/${item.id}${location.search}`);\n\t}, [navigate, location.search]);\n\n  const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n\n\n  return useMemo(() => ({\n    // State\n    bodyState,\n    sidePaneContent,\n    currentActivePage,\n    itemId,\n    messagingView,\n    // DataDemo State\n    viewMode,\n    page,\n    groupBy,\n    activeGroupTab,\n    filters,\n    sortConfig,\n    calendarDateProp,\n    calendarDisplayProps,\n    calendarItemLimit,\n    calendarColorProp,\n    // Actions\n    navigateTo,\n    openSidePane,\n    closeSidePane,\n    toggleSidePane,\n    toggleSplitView,\n    setNormalView,\n    switchSplitPanes,\n    setMessagingView,\n    closeSplitPane,\n    // DataDemo Actions\n    onItemSelect,\n    setViewMode,\n    setGroupBy,\n    setActiveGroupTab,\n    setFilters,\n    setSort,\n    setTableSort,\n    setPage,\n    setCalendarDateProp,\n    setCalendarDisplayProps,\n    setCalendarItemLimit,\n    setCalendarColorProp,\n  }), [\n    bodyState, sidePaneContent, currentActivePage, itemId, messagingView, viewMode,\n    page, groupBy, activeGroupTab, filters, sortConfig, calendarDateProp,\n    calendarDisplayProps, calendarItemLimit, calendarColorProp,\n    navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, setNormalView, setMessagingView,\n    switchSplitPanes, closeSplitPane, onItemSelect, setViewMode, setGroupBy, setActiveGroupTab, setFilters,\n    setSort, setTableSort, setPage, setCalendarDateProp, setCalendarDisplayProps, setCalendarItemLimit, setCalendarColorProp\n  ]);\n}"
  src/pages/DataDemo/index.tsx: >
    import { useRef, useEffect, useCallback } from "react";

    import {
      Layers,
      AlertTriangle,
      PlayCircle,
      TrendingUp,
      CheckCircle,
      Clock,
      Archive,
      PlusCircle,
    } from "lucide-react";

    import { DynamicView } from "@/features/dynamic-view/DynamicView";

    import { PageLayout } from "@/components/shared/PageLayout";

    import { useScrollToBottom } from "@/hooks/useScrollToBottom.hook";

    import { ScrollToBottomButton } from
    "@/components/shared/ScrollToBottomButton";

    import { mockDataItems } from "./data/mockData";

    import { useAppViewManager } from "@/hooks/useAppViewManager.hook";

    import { useDataDemoStore, useSelectedItem } from "./store/dataDemo.store";

    import { AddDataItemCta } from
    "@/features/dynamic-view/components/shared/AddDataItemCta";

    import { DataDetailContent } from "./components/DataDetailContent";


    import { dataDemoViewConfig } from "./DataDemo.config";

    import type { StatItem } from "@/features/dynamic-view/types";


    export default function DataDemoPage() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
        setFilters,
        setViewMode,
        onItemSelect,
        itemId,
      } = useAppViewManager();

      const selectedItem = useSelectedItem(itemId);

      const {
        items: allItems,
        hasMore,
        isLoading,
        isInitialLoading,
        totalItemCount,
        loadData,
        updateItem,
      } = useDataDemoStore((state) => ({
        items: state.items,
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
        updateItem: state.updateItem,
      }));

      const scrollRef = useRef<HTMLDivElement>(null);

      // Note: The `DynamicViewProvider` needs `GenericItem[]`.
      // Our store uses `GenericItem` so no cast is needed.

      // Calculate stats from data
      const totalItems = mockDataItems.length;
      const { showScrollToBottom, scrollToBottom, handleScroll } =
        useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(
        (item) => item.status === "active",
      ).length;
      const highPriorityItems = mockDataItems.filter(
        (item) => item.priority === "high" || item.priority === "critical",
      ).length;
      const avgCompletion =
        totalItems > 0
          ? Math.round(
              mockDataItems.reduce(
                (acc, item) => acc + item.metrics.completion,
                0,
              ) / totalItems,
            )
          : 0;

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          chartData: [120, 125, 122, 130, 135, 138, 142],
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week",
          trend: "up" as const,
          chartData: [45, 50, 48, 55, 53, 60, 58],
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          chartData: [25, 26, 28, 27, 26, 24, 23],
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          chartData: [65, 68, 70, 69, 72, 75, 78],
        },
        {
          title: "Completion Rate",
          value: "88%",
          icon: <CheckCircle className="w-5 h-5" />,
          change: "+1.5% this month",
          trend: "up" as const,
          chartData: [80, 82, 81, 84, 85, 87, 88],
        },
        {
          title: "Overdue Items",
          value: "8",
          icon: <Clock className="w-5 h-5" />,
          change: "-3 this week",
          trend: "down" as const,
        },
        {
          title: "New This Week",
          value: "12",
          icon: <PlusCircle className="w-5 h-5" />,
          change: "+2 from last week",
          trend: "up" as const,
        },
        {
          title: "Archived Projects",
          value: "153",
          icon: <Archive className="w-5 h-5" />,
          change: "+20 this month",
          trend: "up" as const,
        },
      ];

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === "calendar" || viewMode === "kanban",
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );

      if (itemId && selectedItem) {
        // Render detail view as the main content
        return <DataDetailContent item={selectedItem} />;
      }

      return (
        <PageLayout scrollRef={scrollRef} onScroll={handleScroll}>
          <DynamicView
            viewConfig={dataDemoViewConfig}
            items={allItems}
            isLoading={isLoading}
            isInitialLoading={isInitialLoading}
            totalItemCount={totalItemCount}
            hasMore={hasMore}
            // Controlled state
            viewMode={viewMode}
            filters={filters}
            sortConfig={sortConfig}
            groupBy={groupBy}
            activeGroupTab={activeGroupTab}
            page={page}
            // Callbacks
            onViewModeChange={setViewMode}
            onFiltersChange={setFilters}
            onSortChange={setSort}
            onGroupByChange={setGroupBy}
            onActiveGroupTabChange={setActiveGroupTab}
            onPageChange={setPage}
            onItemUpdate={updateItem}
            onItemSelect={onItemSelect}
            loaderRef={loaderRef}
            scrollContainerRef={scrollRef}
            statsData={stats}
            // Custom Renderers
            renderCta={(viewMode, ctaProps) => (
              <AddDataItemCta viewMode={viewMode} colSpan={ctaProps.colSpan} />
            )}
          />

          <ScrollToBottomButton
            isVisible={showScrollToBottom}
            onClick={scrollToBottom}
          />
        </PageLayout>
      );
    }
  src/hooks/useRightPaneContent.hook.tsx: >-
    import { useMemo } from 'react';

    import { useParams } from 'react-router-dom';

    import {
      LayoutDashboard,
      Settings,
      Component,
      Bell,
      SlidersHorizontal,
      Database,
      MessageSquare,
      ExternalLink,
      Share,
    } from 'lucide-react';

    import { DashboardContent } from "@/pages/Dashboard";

    import { SettingsContent } from "@/features/settings/SettingsContent";

    import { ToasterDemo } from "@/pages/ToasterDemo";

    import { NotificationsPage } from "@/pages/Notifications";

    import DataDemoPage from "@/pages/DataDemo/index";

    import { MessagingContent } from
    "@/pages/Messaging/components/MessagingContent";

    import type { AppShellState } from '@/store/appShell.store';

    import { useSelectedItem } from '@/pages/DataDemo/store/dataDemo.store';

    import { DataDetailContent } from
    '@/pages/DataDemo/components/DataDetailContent';


    export function useRightPaneContent(sidePaneContent:
    AppShellState['sidePaneContent']) {
      const { itemId, conversationId } = useParams<{ itemId: string; conversationId: string }>();

      const staticContentMap = useMemo(() => ({
        main: {
          title: "Dashboard",
          icon: LayoutDashboard,
          page: "dashboard",
          content: <DashboardContent />,
        },
        settings: {
          title: "Settings",
          icon: Settings,
          page: "settings",
          content: <div className="p-6"><SettingsContent /></div>,
        },
        toaster: {
          title: "Toaster Demo",
          icon: Component,
          page: "toaster",
          content: <ToasterDemo />,
        },
        notifications: {
          title: "Notifications",
          icon: Bell,
          page: "notifications",
          content: <NotificationsPage />,
        },
        dataDemo: {
          title: "Data Showcase",
          icon: Database,
          page: "data-demo",
          content: <DataDemoPage />,
        },
        details: {
          title: "Details Panel",
          icon: SlidersHorizontal,
          content: (
            <div className="p-6">
              <p className="text-muted-foreground">
                This is the side pane. It can be used to display contextual
                information, forms, or actions related to the main content.
              </p>
            </div>
          ),
        },
      }), []);

      const contentMap = useMemo(() => ({
        ...staticContentMap,
        messaging: {
          title: "Conversation",
          icon: MessageSquare,
          page: "messaging",
          content: <MessagingContent conversationId={conversationId} />,
        },
      }), [conversationId, staticContentMap]);

      const selectedItem = useSelectedItem(itemId);

      const { meta, content } = useMemo(() => {
        if (sidePaneContent === 'dataItem' && selectedItem) {
          return {
            meta: { 
              title: "Item Details", 
              icon: Database, 
              page: `data-demo/${itemId}`,
              hasOwnScrolling: true 
            },
            content: <DataDetailContent item={selectedItem} />,
          };
        }
        const mappedContent = contentMap[sidePaneContent as keyof typeof contentMap] || contentMap.details;
        return {
          meta: mappedContent,
          content: mappedContent.content,
        };
      }, [sidePaneContent, selectedItem, contentMap, itemId]);

      return { meta, content };
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 570
