uuid: 1f0e4c8b-5a3d-4b9c-8f1e-7d6a5c3b2a1d
projectId: jeli-app-shell
createdAt: '2025-10-13T02:51:34.725Z'
gitCommitMsg: >-
  feat(DataDemo): implement context-aware responsive layouts

  Refactors the Data Demo page components to be truly responsive by detecting if
  they are rendered within a constrained container (like a side pane) and
  adjusting their column layouts accordingly.

  - The `isInSidePane` prop is now used to conditionally apply different
    Tailwind CSS responsive classes.
  - Stats, Card, and Grid views now correctly display multiple columns on
    wide viewports and gracefully degrade to fewer columns when placed
    in a side pane, instead of being globally limited.
  - `AnimatedLoadingSkeleton` is also updated to be context-aware,
    preventing layout shifts by generating a skeleton that matches the
    final responsive layout.
promptSummary: >-
  The user corrected me that my previous responsive fixes were too aggressive
  and broke the layout in normal full-width views. I have now implemented a
  proper context-aware responsive solution using an `isInSidePane` prop to
  conditionally apply different responsive classes for stats, cards, and grid
  views.
reasoning:
  - >-
    You've made an excellent point, and my previous solutions were indeed
    shortsighted. I apologize for that. You are absolutely rightâ€”the components
    should be responsive to their *parent container's space*, not just the
    overall browser window size. Forcing a two-column layout everywhere was the
    wrong approach.
  - >-
    I will now implement a proper, context-aware responsive solution. By using
    the existing `isInSidePane` prop, I can apply different sets of responsive
    classes, allowing the components to have multi-column layouts in a normal
    view while gracefully degrading to fewer columns when they are constrained
    within a side pane.
  - >-
    First, I need to update the `ViewProps` type to include the `isInSidePane`
    flag.
  - >-
    Next, in the main `DataDemoPage` component, I will make the stats grid
    responsive to its context and pass the `isInSidePane` prop down to the view
    components and the loading skeleton.
  - >-
    Now, I'll update `DataCardView` to use the `isInSidePane` prop to select the
    appropriate responsive classes for both "cards" and "grid" modes.
  - >-
    Finally, I'll make the `AnimatedLoadingSkeleton` context-aware, ensuring it
    generates a skeleton that accurately reflects the layout in both normal and
    side-pane views.
  - >-
    This comprehensive update correctly interprets your feedback. The components
    now behave as truly responsive modules, adapting their column counts based
    on the context in which they are rendered, providing an optimal layout in
    both full-width and constrained side-pane views. Thank you for pushing for
    the correct implementation.
operations:
  - type: write
    path: src/pages/DataDemo/types.ts
    content: |+
      --- src/pages/DataDemo/types.ts
      +++ src/pages/DataDemo/types.ts
      @@ -28,6 +28,7 @@
         onItemSelect: (item: DataItem) => void
         selectedItem: DataItem | null
         isGrid?: boolean
      +  isInSidePane?: boolean
       
         // Props for table view specifically
         sortConfig?: SortConfig | null

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >+
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ -2,6 +2,7 @@
       import { 
         Layers, 
         AlertTriangle, 
      +  LayoutGrid,
         PlayCircle, 
         TrendingUp,
         Loader2
      @@ -9,6 +10,7 @@
       import { PageLayout } from '@/components/shared/PageLayout'
       import { DataListView } from './components/DataListView'
       import { DataCardView } from './components/DataCardView'
      +import { cn } from '@/lib/utils'
       import { DataTableView } from './components/DataTableView'
       import { DataViewModeSelector } from './components/DataViewModeSelector'
       import { DataDetailPanel } from './components/DataDetailPanel'
      @@ -194,6 +196,7 @@
             selectedItem,
             sortConfig,
             onSort: handleTableSort,
      +      isInSidePane,
           }
       
           switch (viewMode) {
      @@ -226,7 +229,10 @@
       
               {/* Stats Section */}
               {!isInitialLoading && (
      -          <div ref={statsRef} className="grid grid-cols-1 md:grid-cols-2
      gap-6">

      +          <div ref={statsRef} className={cn(

      +            "grid gap-6",

      +            isInSidePane ? "grid-cols-1 sm:grid-cols-2" : "grid-cols-1
      md:grid-cols-2 xl:grid-cols-4"

      +          )}>
                   {stats.map((stat) =>
                     stat.type === 'chart' ? (
                       <StatChartCard
      @@ -250,7 +256,7 @@
               />
       
               <div ref={contentRef} className="min-h-[500px]">
      -          {isInitialLoading ? <AnimatedLoadingSkeleton
      viewMode={viewMode} /> : renderView()}

      +          {isInitialLoading ? <AnimatedLoadingSkeleton
      viewMode={viewMode} isInSidePane={isInSidePane} /> : renderView()}
               </div>
       
               {/* Loader for infinite scroll */}

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/components/DataCardView.tsx
    content: >+
      --- src/pages/DataDemo/components/DataCardView.tsx

      +++ src/pages/DataDemo/components/DataCardView.tsx

      @@ -8,7 +8,7 @@
       import { getStatusColor, getPriorityColor } from '../utils'
       import { EmptyState } from './EmptyState'
       
      -export function DataCardView({ data, onItemSelect, selectedItem, isGrid =
      false }: ViewProps) {

      +export function DataCardView({ data, onItemSelect, selectedItem, isGrid =
      false, isInSidePane = false }: ViewProps) {
         const containerRef = useRef<HTMLDivElement>(null)
         const animatedItemsCount = useRef(0)
       
      @@ -37,10 +37,14 @@
             ref={containerRef}
             className={cn(
               "gap-6",
      -        isGrid 

      -          ? "columns-1 md:columns-2 space-y-6" 

      -          : "grid grid-cols-1 md:grid-cols-2"

      +        isGrid

      +          ? isInSidePane

      +            ? "columns-1 sm:columns-2 space-y-6"

      +            : "columns-1 md:columns-2 xl:columns-3 space-y-6"

      +          : isInSidePane

      +            ? "grid grid-cols-1 sm:grid-cols-2"

      +            : "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3"
             )}
           >
             {data.map((item) => {

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/components/AnimatedLoadingSkeleton.tsx
    content: >+
      --- src/pages/DataDemo/components/AnimatedLoadingSkeleton.tsx

      +++ src/pages/DataDemo/components/AnimatedLoadingSkeleton.tsx

      @@ -7,19 +7,31 @@
         numCards: number
         cols: number
       }
       
      -export const AnimatedLoadingSkeleton = ({ viewMode }: { viewMode:
      ViewMode }) => {

      +export const AnimatedLoadingSkeleton = ({ viewMode, isInSidePane = false
      }: { viewMode: ViewMode, isInSidePane?: boolean }) => {
         const [windowWidth, setWindowWidth] = useState(0)
         const containerRef = useRef<HTMLDivElement>(null)
         const iconRef = useRef<HTMLDivElement>(null)
         const timelineRef = useRef<gsap.core.Timeline | null>(null)
       
         const getGridConfig = (width: number): GridConfig => {
           if (viewMode === 'list' || viewMode === 'table') {
             return { numCards: 5, cols: 1 }
           }
      -    // Conservative column calculation to match responsive layouts in
      side panes

      +    // Column calculation aware of container context
           let cols = 1;
      -    if (width >= 768) cols = 2; // md breakpoint

      +    if (isInSidePane) {

      +      if (width >= 640) cols = 2; // sm breakpoint

      +    } else {

      +      if (viewMode === 'grid') { // Masonry

      +        if (width >= 1280) cols = 3; // xl

      +        else if (width >= 768) cols = 2; // md

      +      } else { // Cards

      +        if (width >= 1024) cols = 3; // lg

      +        else if (width >= 768) cols = 2; // md

      +      }

      +    }
           
           return { numCards: Math.max(6, cols * 2), cols }
         }
      @@ -140,12 +152,29 @@
           )
         }
       
      -  const gridClasses = {

      -    list: "space-y-4",

      -    table: "space-y-4",

      -    cards: "grid grid-cols-1 md:grid-cols-2 gap-6",

      -    grid: "columns-1 md:columns-2 gap-6 space-y-6"

      +  const getGridClass = () => {

      +    switch (viewMode) {

      +      case 'list':

      +      case 'table':

      +        return "space-y-4"

      +      case 'cards':

      +        return cn(

      +          "grid gap-6",

      +          isInSidePane

      +            ? "grid-cols-1 sm:grid-cols-2"

      +            : "grid-cols-1 md:grid-cols-2 lg:grid-cols-3"

      +        )

      +      case 'grid':

      +        return cn(

      +          "gap-6 space-y-6",

      +          isInSidePane

      +            ? "columns-1 sm:columns-2"

      +            : "columns-1 md:columns-2 xl:columns-3"

      +        )

      +      default:

      +        return ""

      +    }
         }
       
         return (
      @@ -159,7 +188,7 @@
       
             <div 
               ref={containerRef}
      -        className={cn(gridClasses[viewMode])}

      +        className={getGridClass()}
             >
               {[...Array(config.numCards)].map((_, i) => renderSkeletonCard(i))}
             </div>

    patchStrategy: standard-diff
snapshot:
  src/pages/DataDemo/index.tsx: >-
    import { useState, useRef, useEffect, useCallback, useMemo } from 'react'

    import { 
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      TrendingUp,
      Loader2
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { DataListView } from './components/DataListView'

    import { DataCardView } from './components/DataCardView'

    import { DataTableView } from './components/DataTableView'

    import { DataViewModeSelector } from './components/DataViewModeSelector'

    import { DataDetailPanel } from './components/DataDetailPanel'

    import { AnimatedLoadingSkeleton } from
    './components/AnimatedLoadingSkeleton'

    import { StatChartCard } from './components/StatChartCard'

    import { DataToolbar, FilterConfig } from './components/DataToolbar'

    import { mockDataItems } from './data/mockData'

    import type { DataItem, ViewMode, SortConfig, SortableField } from './types'


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    export default function DataDemoPage({ isInSidePane = false }: {
    isInSidePane?: boolean }) {
      const [viewMode, setViewMode] = useState<ViewMode>('list')
      const [filters, setFilters] = useState<FilterConfig>({
        searchTerm: '',
        status: [],
        priority: [],
      })
      const [sortConfig, setSortConfig] = useState<SortConfig | null>({ key: 'updatedAt', direction: 'desc' })
      const [selectedItem, setSelectedItem] = useState<DataItem | null>(null)  
      const [items, setItems] = useState<DataItem[]>([])
      const [page, setPage] = useState(0) // Start at 0 to trigger initial load effect
      const [hasMore, setHasMore] = useState(true)
      const [isLoading, setIsLoading] = useState(true)
      const contentRef = useRef<HTMLDivElement>(null)
      const statsRef = useRef<HTMLDivElement>(null)
      const observer = useRef<IntersectionObserver>()

      const isInitialLoading = isLoading && items.length === 0

      // Centralized data processing
      const processedData = useMemo(() => {
        let filteredItems = mockDataItems.filter(item => {
          const searchTermMatch =
            item.title.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
            item.description.toLowerCase().includes(filters.searchTerm.toLowerCase())

          const statusMatch = filters.status.length === 0 || filters.status.includes(item.status)
          const priorityMatch = filters.priority.length === 0 || filters.priority.includes(item.priority)

          return searchTermMatch && statusMatch && priorityMatch
        })

        if (sortConfig) {
          filteredItems.sort((a, b) => {
            let aValue: any
            let bValue: any

            const getNestedValue = (obj: any, path: string) => path.split('.').reduce((o, k) => (o || {})[k], obj)

            aValue = getNestedValue(a, sortConfig.key)
            bValue = getNestedValue(b, sortConfig.key)

            if (aValue === undefined || bValue === undefined) return 0;

            if (typeof aValue === 'string' && typeof bValue === 'string') {
              return sortConfig.direction === 'asc'
                ? aValue.localeCompare(bValue)
                : bValue.localeCompare(aValue)
            }
            if (typeof aValue === 'number' && typeof bValue === 'number') {
              return sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue
            }
            // Date sorting (assuming ISO strings)
            if (sortConfig.key === 'updatedAt' || sortConfig.key === 'createdAt') {
                return sortConfig.direction === 'asc'
                    ? new Date(aValue).getTime() - new Date(aValue).getTime()
                    : new Date(bValue).getTime() - new Date(bValue).getTime()
            }
            return 0
          })
        }
        return filteredItems
      }, [filters, sortConfig])

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      // Reset pagination when filters or sort change
      useEffect(() => {
        setItems([])
        setPage(0) // This will be incremented to 1 in the loader `useEffect`, triggering a fresh load
        setHasMore(true)
        // This timeout helps prevent a flicker between old and new filtered data
        setTimeout(() => setPage(1), 50)
      }, [processedData])

      // Infinite scroll logic
      useEffect(() => { // eslint-disable-line react-hooks/exhaustive-deps
        if (page === 0) return;

        const fetchItems = () => {
          setIsLoading(true);
          const isFirstPage = page === 1
          
          const pageSize = 12;
          const newItems = processedData.slice((page - 1) * pageSize, page * pageSize);
          
          // Simulate network delay, longer for initial load to showcase skeleton
          setTimeout(() => {
            setItems(prev => (isFirstPage ? newItems : [...prev, ...newItems]))
            setHasMore(processedData.length > page * pageSize)
            setIsLoading(false)
          }, isFirstPage && items.length === 0 ? 1500 : 500)
        };

        if (hasMore) fetchItems();
      }, [page]);

      const loaderRef = useCallback(node => {
        if (isLoading) return;
        if (observer.current) observer.current.disconnect();
        
        observer.current = new IntersectionObserver(entries => {
          if (entries[0].isIntersecting && hasMore) {
            setPage(prevPage => prevPage + 1);
          }
        });
        if (node) observer.current.observe(node);
      }, [isLoading, hasMore]);

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78]
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.6,
              y: 0,
              opacity: 1,
              stagger: 0.1,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading])

      const handleSortChange = (config: SortConfig | null) => {
        setSortConfig(config)
      }

      // For table view header clicks
      const handleTableSort = (field: SortableField) => {
        if (sortConfig?.key === field) {
          if (sortConfig.direction === 'desc') {
            // Cycle: desc -> asc
            setSortConfig({ key: field, direction: 'asc' })
          } else {
            // Cycle: asc -> default
            setSortConfig(null)
          }
        } else {
          // New field, default to desc
          setSortConfig({ key: field, direction: 'desc' })
        }
      }

      const handleFilterChange = (newFilters: FilterConfig) => {
        setFilters(newFilters)
      }
      
      // Handle item selection and open side panel
      const handleItemSelect = (item: DataItem) => {
        setSelectedItem(item)
      }

      if (selectedItem) {
        return (
          <DataDetailPanel
            item={selectedItem}
            onClose={() => setSelectedItem(null)}
          />
        )
      }

      const renderView = () => {
        const commonProps = {
          data: items,
          onItemSelect: handleItemSelect,
          selectedItem,
          sortConfig,
          onSort: handleTableSort,
        }

        switch (viewMode) {
          case 'list':
            return <DataListView {...commonProps} />
          case 'cards':
            return <DataCardView {...commonProps} />
          case 'grid':
            return <DataCardView {...commonProps} isGrid />
          case 'table':
            return <DataTableView {...commonProps} />
          default:
            return <DataListView {...commonProps} />
        }
      }

      return (
        <PageLayout
          // Note: Search functionality is handled by a separate SearchBar in the TopBar
        >
          <div className="space-y-8">
            {/* Header */}
            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
              <div className="flex-1">
                <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                <p className="text-muted-foreground">
                  {isInitialLoading 
                    ? "Loading projects..." 
                    : `Showing ${processedData.length} item(s)`}
                </p>
              </div>
              <DataViewModeSelector viewMode={viewMode} onChange={setViewMode} />
            </div>

            {/* Stats Section */}
            {!isInitialLoading && (
              <div ref={statsRef} className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {stats.map((stat) =>
                  stat.type === 'chart' ? (
                    <StatChartCard
                      key={stat.title}
                      title={stat.title}
                      value={stat.value}
                      change={stat.change}
                      trend={stat.trend}
                      icon={stat.icon}
                      chartData={stat.chartData}
                    />
                  ) : null
                )}
              </div>
            )}

            <DataToolbar
              filters={filters}
              onFiltersChange={handleFilterChange}
              sortConfig={sortConfig}
              onSortChange={handleSortChange}
            />

            <div ref={contentRef} className="min-h-[500px]">
              {isInitialLoading ? <AnimatedLoadingSkeleton viewMode={viewMode} /> : renderView()}
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && processedData.length > 0 && !isInitialLoading && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>
        </PageLayout>
      )
    }
  src/pages/DataDemo/components/AnimatedLoadingSkeleton.tsx: >
    import React, { useEffect, useRef, useState } from 'react'

    import { gsap } from 'gsap'

    import { Search } from 'lucide-react'

    import { cn } from '@/lib/utils'

    import type { ViewMode } from '../types'


    interface GridConfig {
      numCards: number
      cols: number
    }


    export const AnimatedLoadingSkeleton = ({ viewMode }: { viewMode: ViewMode
    }) => {
      const [windowWidth, setWindowWidth] = useState(0)
      const containerRef = useRef<HTMLDivElement>(null)
      const iconRef = useRef<HTMLDivElement>(null)
      const timelineRef = useRef<gsap.core.Timeline | null>(null)

      const getGridConfig = (width: number): GridConfig => {
        if (viewMode === 'list' || viewMode === 'table') {
          return { numCards: 5, cols: 1 }
        }
        // Conservative column calculation to match responsive layouts in side panes
        let cols = 1;
        if (width >= 768) cols = 2; // md breakpoint
        
        return { numCards: Math.max(6, cols * 2), cols }
      }

      useEffect(() => {
        const handleResize = () => setWindowWidth(window.innerWidth)
        handleResize()
        window.addEventListener('resize', handleResize)
        return () => window.removeEventListener('resize', handleResize)
      }, [])

      useEffect(() => {
        if (timelineRef.current) {
          timelineRef.current.kill()
        }
        if (!iconRef.current || !containerRef.current || windowWidth === 0) return

        // Allow DOM to update with new skeleton cards
        const timeoutId = setTimeout(() => {
          const cards = Array.from(containerRef.current!.children)
          if (cards.length === 0) return

          const shuffledCards = gsap.utils.shuffle(cards)

          const getCardPosition = (card: Element) => {
            const rect = card.getBoundingClientRect()
            const containerRect = containerRef.current!.getBoundingClientRect()
            const iconRect = iconRef.current!.getBoundingClientRect()

            return {
              x: rect.left - containerRect.left + rect.width / 2 - iconRect.width / 2,
              y: rect.top - containerRect.top + rect.height / 2 - iconRect.height / 2,
            }
          }
          
          const tl = gsap.timeline({
            repeat: -1,
            repeatDelay: 0.5,
            defaults: { duration: 1, ease: 'power2.inOut' }
          });
          timelineRef.current = tl

          // Animate to a few random cards
          shuffledCards.slice(0, 5).forEach(card => {
            const pos = getCardPosition(card)
            tl.to(iconRef.current, { 
              x: pos.x,
              y: pos.y,
              scale: 1.2,
              duration: 0.8
            }).to(iconRef.current, {
              scale: 1,
              duration: 0.2
            })
          });

          // Loop back to the start
          const firstPos = getCardPosition(shuffledCards[0]);
          tl.to(iconRef.current, { x: firstPos.x, y: firstPos.y, duration: 0.8 });
        }, 100) // Small delay to ensure layout is calculated

        return () => {
          clearTimeout(timeoutId)
          if (timelineRef.current) {
            timelineRef.current.kill()
          }
        }

      }, [windowWidth, viewMode])

      const config = getGridConfig(windowWidth)

      const renderSkeletonCard = (key: number) => {
        if (viewMode === 'list' || viewMode === 'table') {
          return (
            <div key={key} className="bg-card/30 border border-border/30 rounded-2xl p-6 flex items-start gap-4 animate-pulse">
              <div className="w-14 h-14 bg-muted rounded-xl flex-shrink-0"></div>
              <div className="flex-1 space-y-3">
                <div className="h-4 bg-muted rounded w-3/4"></div>
                <div className="h-3 bg-muted rounded w-full"></div>
                <div className="h-3 bg-muted rounded w-5/6"></div>
                <div className="flex gap-2 pt-2">
                  <div className="h-6 bg-muted rounded-full w-20"></div>
                  <div className="h-6 bg-muted rounded-full w-20"></div>
                </div>
              </div>
            </div>
          )
        }

        return (
          <div 
            key={key} 
            className={cn(
              "bg-card/30 border border-border/30 rounded-3xl p-6 space-y-4 animate-pulse",
              viewMode === 'grid' && "break-inside-avoid mb-6"
            )}
          >
            <div className="flex items-start justify-between">
              <div className="w-16 h-16 bg-muted rounded-2xl"></div>
              <div className="w-4 h-4 bg-muted rounded-full"></div>
            </div>
            <div className="h-4 bg-muted rounded w-3/4"></div>
            <div className="h-3 bg-muted rounded w-full"></div>
            <div className="h-3 bg-muted rounded w-5/6"></div>
            <div className="h-2 w-full bg-muted rounded-full my-4"></div>
            <div className="flex items-center gap-3">
              <div className="w-8 h-8 bg-muted rounded-full"></div>
              <div className="flex-1 space-y-2">
                <div className="h-3 bg-muted rounded w-1/2"></div>
                <div className="h-2 bg-muted rounded w-1/3"></div>
              </div>
            </div>
          </div>
        )
      }

      const gridClasses = {
        list: "space-y-4",
        table: "space-y-4",
        cards: "grid grid-cols-1 md:grid-cols-2 gap-6",
        grid: "columns-1 md:columns-2 gap-6 space-y-6"
      }

      return (
        <div className="relative overflow-hidden rounded-lg min-h-[500px]">
          <div 
            ref={iconRef}
            className="absolute z-10 p-3 bg-primary/20 rounded-full backdrop-blur-sm"
            style={{ willChange: 'transform' }}
          >
            <Search className="w-6 h-6 text-primary" />
          </div>

          <div 
            ref={containerRef}
            className={cn(gridClasses[viewMode])}
          >
            {[...Array(config.numCards)].map((_, i) => renderSkeletonCard(i))}
          </div>
        </div>
      )
    }
  src/pages/DataDemo/components/DataCardView.tsx: >-
    import { useRef, useLayoutEffect } from 'react'

    import { gsap } from 'gsap'

    import { cn } from '@/lib/utils'

    import { Badge } from '@/components/ui/badge'

    import { Avatar } from '@/components/ui/avatar'

    import { Calendar, Eye, Heart, Share, ArrowUpRight, Tag } from
    'lucide-react'

    import type { ViewProps } from '../types'

    import { getStatusColor, getPriorityColor } from '../utils'

    import { EmptyState } from './EmptyState'


    export function DataCardView({ data, onItemSelect, selectedItem, isGrid =
    false }: ViewProps) {
      const containerRef = useRef<HTMLDivElement>(null)
      const animatedItemsCount = useRef(0)

      useLayoutEffect(() => {
        if (containerRef.current && data.length > animatedItemsCount.current) {
          const newItems = Array.from(containerRef.current.children).slice(
            animatedItemsCount.current
          );
          gsap.fromTo(
            newItems,
            { y: 40, opacity: 0, scale: 0.95 },
            {
              duration: 0.6,
              y: 0,
              opacity: 1,
              scale: 1,
              stagger: 0.1,
              ease: 'power2.out',
            },
          );
          animatedItemsCount.current = data.length;
        }
      }, [data]);

      if (data.length === 0) {
        return <EmptyState />
      }

      return (
        <div 
          ref={containerRef}
          className={cn(
            "gap-6",
            isGrid 
              ? "columns-1 md:columns-2 space-y-6" 
              : "grid grid-cols-1 md:grid-cols-2"
          )}
        >
          {data.map((item) => {
            const isSelected = selectedItem?.id === item.id
            
            return (
              <div
                key={item.id}
                onClick={() => onItemSelect(item)}
                className={cn(
                  "group relative overflow-hidden rounded-3xl border bg-card/50 backdrop-blur-sm transition-all duration-500 cursor-pointer",
                  "hover:bg-card/80 hover:shadow-xl hover:shadow-primary/10 hover:border-primary/30 hover:-translate-y-2",
                  "active:scale-[0.98]",
                  isSelected && "ring-2 ring-primary/30 border-primary/40 bg-card/90 shadow-lg shadow-primary/20",
                  isGrid && "break-inside-avoid mb-6"
                )}
              >
                {/* Card Header with Thumbnail */}
                <div className="relative p-6 pb-4">
                  <div className="flex items-start justify-between mb-4">
                    <div className="w-16 h-16 bg-gradient-to-br from-primary/20 to-primary/10 rounded-2xl flex items-center justify-center text-3xl group-hover:scale-110 transition-transform duration-300">
                      {item.thumbnail}
                    </div>
                    <ArrowUpRight className="w-5 h-5 text-muted-foreground group-hover:text-primary group-hover:translate-x-1 group-hover:-translate-y-1 transition-all duration-300" />
                  </div>

                  {/* Priority indicator */}
                  <div className="absolute top-4 right-4">
                    <div className={cn(
                      "w-3 h-3 rounded-full",
                      item.priority === 'critical' && "bg-red-500",
                      item.priority === 'high' && "bg-orange-500",
                      item.priority === 'medium' && "bg-blue-500",
                      item.priority === 'low' && "bg-green-500"
                    )} />
                  </div>
                </div>

                {/* Card Content */}
                <div className="px-6 pb-6">
                  {/* Title and Description */}
                  <h3 className="font-semibold text-lg mb-2 group-hover:text-primary transition-colors line-clamp-2">
                    {item.title}
                  </h3>
                  <p className="text-muted-foreground text-sm mb-4 line-clamp-3">
                    {item.description}
                  </p>

                  {/* Status and Category */}
                  <div className="flex items-center gap-2 mb-4">
                    <Badge variant="outline" className={getStatusColor(item.status)}>
                      {item.status}
                    </Badge>
                    <Badge variant="outline" className="bg-accent/50 text-xs">
                      {item.category}
                    </Badge>
                  </div>

                  {/* Tags */}
                  <div className="flex items-center gap-1 mb-4">
                    <Tag className="w-3 h-3 text-muted-foreground" />
                    <div className="flex flex-wrap gap-1">
                      {item.tags.slice(0, 3).map((tag, index) => (
                        <span key={index} className="text-xs text-muted-foreground bg-muted/50 px-2 py-1 rounded-md">
                          {tag}
                        </span>
                      ))}
                      {item.tags.length > 3 && (
                        <span className="text-xs text-muted-foreground">
                          +{item.tags.length - 3}
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Progress */}
                  <div className="mb-4">
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-xs text-muted-foreground">Progress</span>
                      <span className="text-xs font-semibold">{item.metrics.completion}%</span>
                    </div>
                    <div className="w-full bg-muted rounded-full h-2">
                      <div 
                        className="bg-gradient-to-r from-primary to-primary/80 h-2 rounded-full transition-all duration-700 ease-out"
                        style={{ width: `${item.metrics.completion}%` }}
                      />
                    </div>
                  </div>

                  {/* Assignee */}
                  <div className="flex items-center gap-3 mb-4">
                    <Avatar className="w-8 h-8 text-sm">
                      {item.assignee.avatar}
                    </Avatar>
                    <div className="flex-1 min-w-0">
                      <p className="text-sm font-medium truncate">
                        {item.assignee.name}
                      </p>
                      <p className="text-xs text-muted-foreground truncate">
                        {item.assignee.email}
                      </p>
                    </div>
                  </div>

                  {/* Metrics */}
                  <div className="flex items-center justify-between text-xs text-muted-foreground">
                    <div className="flex items-center gap-3">
                      <div className="flex items-center gap-1">
                        <Eye className="w-3 h-3" />
                        {item.metrics.views}
                      </div>
                      <div className="flex items-center gap-1">
                        <Heart className="w-3 h-3" />
                        {item.metrics.likes}
                      </div>
                      <div className="flex items-center gap-1">
                        <Share className="w-3 h-3" />
                        {item.metrics.shares}
                      </div>
                    </div>
                    <div className="flex items-center gap-1">
                      <Calendar className="w-3 h-3" />
                      {new Date(item.updatedAt).toLocaleDateString()}
                    </div>
                  </div>
                </div>

                {/* Hover gradient overlay */}
                <div className="absolute inset-0 bg-gradient-to-br from-primary/5 via-transparent to-primary/5 opacity-0 group-hover:opacity-100 transition-opacity duration-500 pointer-events-none" />
                
                {/* Selection indicator */}
                {isSelected && (
                  <div className="absolute inset-0 bg-gradient-to-br from-primary/10 to-primary/5 pointer-events-none" />
                )}
              </div>
            )
          })}
        </div>
      )
    }
  src/pages/DataDemo/types.ts: >
    export type ViewMode = 'list' | 'cards' | 'grid' | 'table'


    export type SortableField = 'title' | 'status' | 'priority' | 'updatedAt' |
    'assignee.name' | 'metrics.views' | 'metrics.completion' | 'createdAt'

    export type SortDirection = 'asc' | 'desc'

    export interface SortConfig {
      key: SortableField
      direction: SortDirection
    }


    export interface DataItem {
      id: string
      title: string
      description: string
      category: string
      status: 'active' | 'pending' | 'completed' | 'archived'
      priority: 'low' | 'medium' | 'high' | 'critical'
      assignee: {
        name: string
        avatar: string
        email: string
      }
      metrics: {
        views: number
        likes: number
        shares: number
        completion: number
      }
      tags: string[]
      createdAt: string
      updatedAt: string
      dueDate?: string
      thumbnail?: string
      content?: {
        summary: string
        details: string
        attachments?: Array<{
          name: string
          type: string
          size: string
          url: string
        }>
      }
    }


    export interface ViewProps {
      data: DataItem[]
      onItemSelect: (item: DataItem) => void
      selectedItem: DataItem | null
      isGrid?: boolean

      // Props for table view specifically
      sortConfig?: SortConfig | null
      onSort?: (field: SortableField) => void
    }


    export type Status = DataItem['status']

    export type Priority = DataItem['priority']
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 188
