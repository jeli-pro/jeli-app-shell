uuid: 4a259b1f-76a0-474d-9a3b-2f16480b556b
projectId: jeli-app-shell
createdAt: '2025-10-21T10:53:50.740Z'
gitCommitMsg: >-
  feat(dynamic-view): implement type-safe configuration for data demo

  This commit completes the end-to-end type safety refactor by applying the new
  generic system to the `DataDemoPage`.

  - Introduces a strongly-typed `DataDemoItem` interface. - Updates the
  `dataDemo` Zustand store to use `DataDemoItem`, ensuring type safety at the
  data layer. - Refactors `DataDemo.config.tsx` to be fully type-safe. It now
  uses `as const` and type inference to validate the entire configuration
  against the `ViewConfig` generic type at compile time. - Updates
  `DataDemoPage` to pass the typed config and data to `DynamicView`, allowing
  for automatic generic inference and completing the type-safe chain.
promptSummary: >-
  Implement part 3 of the type-safety refactor for the DynamicView component and
  its demo page.
reasoning:
  - >-
    Executing Part 3 of the plan to make the `DynamicView` system fully
    type-safe.
  - '### Part 3.1: Create a Specific Type for Demo Data'
  - >-
    First, I'll create a new file to define the specific shape of our demo data.
    This moves us from the generic `GenericItem` to a strongly-typed
    `DataDemoItem`, which is the foundation for type-safe configuration.
  - >-
    Next, I'll update the Zustand store to use this new `DataDemoItem` type,
    ensuring that the data layer is consistent with our new type-safe approach.
  - '### Part 3.2: Create a Type-Safe View Configuration'
  - >-
    This is the key step. I'm modifying the configuration file to leverage
    TypeScript's type inference. By adding `as const` to the `fields` array, we
    can derive a union type of all valid field IDs. Then, by applying a
    `ViewConfig<...>` type annotation to the final export, we force the compiler
    to validate the entire configuration object, ensuring every `fieldId` is
    correct and preventing runtime errors.
  - '### Part 3.3: Update DataDemoPage to Use Typed Components'
  - >-
    Finally, I'll update the main demo page. With the store providing
    strongly-typed `DataDemoItem[]` and the config being fully typed, I can
    remove the `as GenericItem[]` type assertion. The `DynamicView` component
    will now automatically infer its generic types from its props, completing
    the end-to-end type-safe chain.
  - '---'
operations:
  - type: write
    path: src/pages/DataDemo/data/DataDemoItem.ts
    content: >-
      import type { GenericItem, Status, Priority } from
      '@/features/dynamic-view/types';


      export interface DataDemoItem extends GenericItem {
        id: string;
        title: string;
        description: string;
        thumbnail: string;
        category: string;
        status: Status;
        priority: Priority;
        assignee: {
          name: string;
          email: string;
          avatar: string;
        };
        tags: string[];
        metrics: {
          views: number;
          likes: number;
          shares: number;
          completion: number;
        };
        dueDate: string; // ISO date string
        createdAt: string; // ISO date string
        updatedAt: string; // ISO date string
      }
    patchStrategy: replace
  - type: write
    path: src/pages/DataDemo/store/dataDemo.store.tsx
    content: >+
      --- src/pages/DataDemo/store/dataDemo.store.tsx

      +++ src/pages/DataDemo/store/dataDemo.store.tsx

      @@ ... @@
       import { create } from "zustand";
       import { mockDataItems } from "@/pages/DataDemo/data/mockData";
       import type {
      -  GenericItem,
         GroupableField,
         SortConfig,
         FilterConfig,
       } from "@/features/dynamic-view/types";
      +import type { DataDemoItem } from '../data/DataDemoItem';
       
       // --- State and Actions ---
       interface DataDemoState {
      -  items: GenericItem[];

      +  items: DataDemoItem[];
         hasMore: boolean;
         isLoading: boolean;
         isInitialLoading: boolean;
      @@ ... @@
           sortConfig: SortConfig | null;
           isFullLoad?: boolean;
         }) => void;
      -  updateItem: (itemId: string, updates: Partial<GenericItem>) => void;

      +  updateItem: (itemId: string, updates: Partial<DataDemoItem>) => void;
       }
       
       const defaultState: DataDemoState = {
      @@ ... @@
             const filteredAndSortedData = (() => {
               const filteredItems = mockDataItems.filter((item) => {
                 const searchTermMatch =
      @@ ... @@
               if (sortConfig) {
                 filteredItems.sort((a, b) => {
                   // eslint-disable-next-line @typescript-eslint/no-explicit-any
      -            const getNestedValue = (obj: GenericItem, path: string): any
      =>

      +            const getNestedValue = (obj: DataDemoItem, path: string): any
      =>
                     path.split(".").reduce((o: any, k) => (o || {})[k], obj);
       
                   const aValue = getNestedValue(a, sortConfig.key);
      @@ ... @@
       
       export const useSelectedItem = (itemId?: string) => {
         if (!itemId) return null;
         return (
      -    (mockDataItems.find((item) => item.id === itemId) as GenericItem) ??
      null

      +    (mockDataItems.find((item) => item.id === itemId) as DataDemoItem) ??
      null
         );
       };

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/DataDemo.config.tsx
    content: >+
      --- src/pages/DataDemo/DataDemo.config.tsx

      +++ src/pages/DataDemo/DataDemo.config.tsx

      @@ ... @@
       import { FieldRenderer } from "@/features/dynamic-view/components/shared/FieldRenderer";
      -import type { ViewConfig, GenericItem } from
      "@/features/dynamic-view/types";

      +import type { ViewConfig } from "@/features/dynamic-view/types";

      +import type { DataDemoItem } from "./data/DataDemoItem";
       
      -export const dataDemoViewConfig: ViewConfig = {

      +const config = {
         // 1. Field Definitions
         fields: [
           { id: "id", label: "ID", type: "string" },
      @@ ... @@
             id: "project_details",
             label: "Project",
             type: "custom",
      -      render: (item: GenericItem) => (

      +      render: (item: DataDemoItem) => (
               <div className="flex items-center gap-3">
                 <div className="w-10 h-10 bg-gradient-to-br from-primary/20 to-primary/10 rounded-lg flex items-center justify-center text-lg flex-shrink-0">
                   <FieldRenderer item={item} fieldId="thumbnail" />
      @@ ... @@
               </div>
             ),
           },
      -  ],

      +  ] as const,
         // 2. Control Definitions
         sortableFields: [
           { id: "updatedAt", label: "Last Updated" },
      @@ ... @@
           },
         },
       };
      +

      +// Infer the field IDs from the const-asserted array.

      +type DataDemoFieldId = (typeof config.fields)[number]["id"];

      +

      +// This line validates the entire config object against the generic
      ViewConfig type.

      +export const dataDemoViewConfig: ViewConfig<DataDemoFieldId,
      DataDemoItem> = config;

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >+
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ ... @@
       import { useScrollToBottom } from "@/hooks/useScrollToBottom.hook";
       import { ScrollToBottomButton } from "@/components/shared/ScrollToBottomButton";
       import { mockDataItems } from "./data/mockData";
      -import type { GenericItem, StatItem } from
      "@/features/dynamic-view/types";
       import { useAppViewManager } from "@/hooks/useAppViewManager.hook";
       import { useDataDemoStore } from "./store/dataDemo.store";
       {} from "./store/dataDemo.store";
      @@ ... @@
       
       import { dataDemoViewConfig } from "./DataDemo.config";
       
      +import type { StatItem } from "@/features/dynamic-view/types";

      +
       export default function DataDemoPage() {
         const {
           viewMode,
      @@ ... @@
         return (
           <PageLayout scrollRef={scrollRef} onScroll={handleScroll}>
             <DynamicView
               viewConfig={dataDemoViewConfig}
      -        items={allItems as GenericItem[]}

      +        items={allItems}
               isLoading={isLoading}
               isInitialLoading={isInitialLoading}
               totalItemCount={totalItemCount}
      @@ ... @@

    patchStrategy: standard-diff
snapshot:
  src/pages/DataDemo/data/DataDemoItem.ts: null
  src/pages/DataDemo/store/dataDemo.store.tsx: |
    import { create } from "zustand";
    import { mockDataItems } from "@/pages/DataDemo/data/mockData";
    import type {
      GenericItem,
      GroupableField,
      SortConfig,
      FilterConfig,
    } from "@/features/dynamic-view/types";

    // --- State and Actions ---
    interface DataDemoState {
      items: GenericItem[];
      hasMore: boolean;
      isLoading: boolean;
      isInitialLoading: boolean;
      totalItemCount: number;
    }

    interface DataDemoActions {
      loadData: (params: {
        page: number;
        groupBy: GroupableField | "none";
        filters: FilterConfig;
        sortConfig: SortConfig | null;
        isFullLoad?: boolean;
      }) => void;
      updateItem: (itemId: string, updates: Partial<GenericItem>) => void;
    }

    const defaultState: DataDemoState = {
      items: [],
      hasMore: true,
      isLoading: true,
      isInitialLoading: true,
      totalItemCount: 0,
    };

    // --- Store Implementation ---
    export const useDataDemoStore = create<DataDemoState & DataDemoActions>(
      (set) => ({
        ...defaultState,

        loadData: ({ page, groupBy, filters, sortConfig, isFullLoad }) => {
          set({ isLoading: true, ...(page === 1 && { isInitialLoading: true }) });
          const isFirstPage = page === 1;

          const filteredAndSortedData = (() => {
            const filteredItems = mockDataItems.filter((item) => {
              const searchTermMatch =
                item.title
                  .toLowerCase()
                  .includes(filters.searchTerm.toLowerCase()) ||
                item.description
                  .toLowerCase()
                  .includes(filters.searchTerm.toLowerCase());
              const statusMatch =
                filters.status.length === 0 || filters.status.includes(item.status);
              const priorityMatch =
                filters.priority.length === 0 ||
                filters.priority.includes(item.priority);
              return searchTermMatch && statusMatch && priorityMatch;
            });

            if (sortConfig) {
              filteredItems.sort((a, b) => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const getNestedValue = (obj: GenericItem, path: string): any =>
                  path.split(".").reduce((o: any, k) => (o || {})[k], obj);

                const aValue = getNestedValue(a, sortConfig.key);
                const bValue = getNestedValue(b, sortConfig.key);

                if (aValue === undefined || bValue === undefined) return 0;
                if (typeof aValue === "string" && typeof bValue === "string") {
                  return sortConfig.direction === "asc"
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
                }
                if (typeof aValue === "number" && typeof bValue === "number") {
                  return sortConfig.direction === "asc"
                    ? aValue - bValue
                    : bValue - aValue;
                }
                if (
                  sortConfig.key === "updatedAt" ||
                  sortConfig.key === "createdAt"
                ) {
                  if (typeof aValue === "string" && typeof bValue === "string") {
                    return sortConfig.direction === "asc"
                      ? new Date(aValue).getTime() - new Date(bValue).getTime()
                      : new Date(bValue).getTime() - new Date(aValue).getTime();
                  }
                }
                return 0;
              });
            }
            return filteredItems;
          })();

          const totalItemCount = filteredAndSortedData.length;

          setTimeout(
            () => {
              if (groupBy !== "none" || isFullLoad) {
                set({
                  items: filteredAndSortedData,
                  hasMore: false,
                  isLoading: false,
                  isInitialLoading: false,
                  totalItemCount,
                });
                return;
              }

              const pageSize = 12;
              const newItems = filteredAndSortedData.slice(
                (page - 1) * pageSize,
                page * pageSize,
              );

              set((state) => ({
                items: isFirstPage ? newItems : [...state.items, ...newItems],
                hasMore: totalItemCount > page * pageSize,
                isLoading: false,
                isInitialLoading: false,
                totalItemCount,
              }));
            },
            isFirstPage ? 1500 : 500,
          );
        },

        updateItem: (itemId, updates) => {
          // In a real app, this would be an API call. Here we update the mock source.
          const itemIndex = mockDataItems.findIndex((i) => i.id === itemId);
          if (itemIndex > -1) {
            mockDataItems[itemIndex] = { ...mockDataItems[itemIndex], ...updates };
          }

          // Also update the currently loaded items in the store's state for UI consistency
          set((state) => ({
            items: state.items.map((item) =>
              item.id === itemId ? { ...item, ...updates } : item,
            ),
          }));
        },
      }),
    );

    export const useSelectedItem = (itemId?: string) => {
      if (!itemId) return null;
      return (
        (mockDataItems.find((item) => item.id === itemId) as GenericItem) ?? null
      );
    };
  src/pages/DataDemo/DataDemo.config.tsx: >
    import { FieldRenderer } from
    "@/features/dynamic-view/components/shared/FieldRenderer";

    import type { ViewConfig, GenericItem } from
    "@/features/dynamic-view/types";


    export const dataDemoViewConfig: ViewConfig = {
      // 1. Field Definitions
      fields: [
        { id: "id", label: "ID", type: "string" },
        { id: "title", label: "Title", type: "string" },
        { id: "description", label: "Description", type: "longtext" },
        { id: "thumbnail", label: "Thumbnail", type: "thumbnail" },
        { id: "category", label: "Category", type: "badge" },
        {
          id: "status",
          label: "Status",
          type: "badge",
          colorMap: {
            active: "bg-sky-500/10 text-sky-600 border-sky-500/20",
            pending: "bg-amber-500/10 text-amber-600 border-amber-500/20",
            completed: "bg-emerald-600/10 text-emerald-700 border-emerald-600/20",
            archived: "bg-zinc-500/10 text-zinc-600 border-zinc-500/20",
          },
        },
        {
          id: "priority",
          label: "Priority",
          type: "badge",
          colorMap: {
            critical: "bg-red-600/10 text-red-700 border-red-600/20",
            high: "bg-orange-500/10 text-orange-600 border-orange-500/20",
            medium: "bg-blue-500/10 text-blue-600 border-blue-500/20",
            low: "bg-green-500/10 text-green-600 border-green-500/20",
          },
          indicatorColorMap: {
            critical: "bg-red-500",
            high: "bg-orange-500",
            medium: "bg-blue-500",
            low: "bg-green-500",
          },
        },
        { id: "assignee", label: "Assignee", type: "avatar" },
        { id: "tags", label: "Tags", type: "tags" },
        { id: "metrics", label: "Engagement", type: "metrics" },
        { id: "metrics.completion", label: "Progress", type: "progress" },
        { id: "dueDate", label: "Due Date", type: "date" },
        { id: "createdAt", label: "Created At", type: "date" },
        { id: "updatedAt", label: "Last Updated", type: "date" },
        // A custom field to replicate the composite "Project" column in the table view
        {
          id: "project_details",
          label: "Project",
          type: "custom",
          render: (item: GenericItem) => (
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 bg-gradient-to-br from-primary/20 to-primary/10 rounded-lg flex items-center justify-center text-lg flex-shrink-0">
                <FieldRenderer item={item} fieldId="thumbnail" />
              </div>
              <div className="min-w-0 flex-1">
                <h4 className="font-medium group-hover:text-primary transition-colors truncate">
                  <FieldRenderer item={item} fieldId="title" />
                </h4>
                <p className="text-sm text-muted-foreground truncate">
                  <FieldRenderer item={item} fieldId="category" />
                </p>
              </div>
            </div>
          ),
        },
      ],
      // 2. Control Definitions
      sortableFields: [
        { id: "updatedAt", label: "Last Updated" },
        { id: "title", label: "Title" },
        { id: "status", label: "Status" },
        { id: "priority", label: "Priority" },
        { id: "metrics.completion", label: "Progress" },
      ],
      groupableFields: [
        { id: "none", label: "None" },
        { id: "status", label: "Status" },
        { id: "priority", label: "Priority" },
        { id: "category", label: "Category" },
      ],
      filterableFields: [
        {
          id: "status",
          label: "Status",
          options: [
            { id: "active", label: "Active" },
            { id: "pending", label: "Pending" },
            { id: "completed", label: "Completed" },
            { id: "archived", label: "Archived" },
          ],
        },
        {
          id: "priority",
          label: "Priority",
          options: [
            { id: "critical", label: "Critical" },
            { id: "high", label: "High" },
            { id: "medium", label: "Medium" },
            { id: "low", label: "Low" },
          ],
        },
      ],
      // 3. View Layouts
      listView: {
        iconField: "thumbnail",
        titleField: "title",
        metaFields: [
          { fieldId: "status", className: "hidden sm:flex" },
          { fieldId: "tags", className: "hidden lg:flex" },
          { fieldId: "updatedAt", className: "hidden md:flex" },
          { fieldId: "assignee" },
          { fieldId: "priority", className: "hidden xs:flex" },
        ],
      },
      cardView: {
        thumbnailField: "thumbnail",
        titleField: "title",
        descriptionField: "description",
        headerFields: ["priority"],
        statusField: "status",
        categoryField: "category",
        tagsField: "tags",
        progressField: "metrics.completion",
        assigneeField: "assignee",
        metricsField: "metrics",
        dateField: "updatedAt",
      },
      tableView: {
        columns: [
          { fieldId: "project_details", label: "Project", isSortable: true },
          { fieldId: "status", label: "Status", isSortable: true },
          { fieldId: "priority", label: "Priority", isSortable: true },
          { fieldId: "assignee", label: "Assignee", isSortable: true },
          { fieldId: "metrics.completion", label: "Progress", isSortable: true },
          { fieldId: "metrics", label: "Engagement", isSortable: true },
          { fieldId: "updatedAt", label: "Last Updated", isSortable: true },
        ],
      },
      kanbanView: {
        groupByField: "status",
        cardFields: {
          titleField: "title",
          descriptionField: "description",
          priorityField: "priority",
          tagsField: "tags",
          dateField: "dueDate",
          metricsField: "metrics",
          assigneeField: "assignee",
        },
      },
      calendarView: {
        dateField: "dueDate",
        titleField: "title",
        displayFields: ["tags", "priority", "assignee"],
        colorByField: "priority",
      },
      detailView: {
        header: {
          thumbnailField: "thumbnail",
          titleField: "title",
          descriptionField: "description",
          badgeFields: ["status", "priority", "category"],
          progressField: "metrics.completion",
        },
        body: {
          sections: [
            { title: "Assigned to", fields: ["assignee"] },
            { title: "Engagement Metrics", fields: ["metrics"] },
            { title: "Tags", fields: ["tags"] },
            {
              title: "Timeline",
              fields: ["createdAt", "updatedAt", "dueDate"],
            },
          ],
        },
      },
    };
  src/pages/DataDemo/index.tsx: >
    import { useRef, useEffect, useCallback } from "react";

    import {
      Layers,
      AlertTriangle,
      PlayCircle,
      TrendingUp,
      CheckCircle,
      Clock,
      Archive,
      PlusCircle,
    } from "lucide-react";

    import { DynamicView } from "@/features/dynamic-view/DynamicView";

    import { PageLayout } from "@/components/shared/PageLayout";

    import { useScrollToBottom } from "@/hooks/useScrollToBottom.hook";

    import { ScrollToBottomButton } from
    "@/components/shared/ScrollToBottomButton";

    import { mockDataItems } from "./data/mockData";

    import type { GenericItem, StatItem } from "@/features/dynamic-view/types";

    import { useAppViewManager } from "@/hooks/useAppViewManager.hook";

    import { useDataDemoStore } from "./store/dataDemo.store";

    import {} from "./store/dataDemo.store";

    import { AddDataItemCta } from
    "@/features/dynamic-view/components/shared/AddDataItemCta";


    import { dataDemoViewConfig } from "./DataDemo.config";


    export default function DataDemoPage() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
        setFilters,
        setViewMode,
        onItemSelect,
      } = useAppViewManager();

      const {
        items: allItems,
        hasMore,
        isLoading,
        isInitialLoading,
        totalItemCount,
        loadData,
      } = useDataDemoStore((state) => ({
        items: state.items,
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
      }));

      const scrollRef = useRef<HTMLDivElement>(null);

      // Note: The `DynamicViewProvider` needs `GenericItem[]`.
      // Our store uses `GenericItem` so no cast is needed.

      // Calculate stats from data
      const totalItems = mockDataItems.length;
      const { showScrollToBottom, scrollToBottom, handleScroll } =
        useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(
        (item) => item.status === "active",
      ).length;
      const highPriorityItems = mockDataItems.filter(
        (item) => item.priority === "high" || item.priority === "critical",
      ).length;
      const avgCompletion =
        totalItems > 0
          ? Math.round(
              mockDataItems.reduce(
                (acc, item) => acc + item.metrics.completion,
                0,
              ) / totalItems,
            )
          : 0;

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          chartData: [120, 125, 122, 130, 135, 138, 142],
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week",
          trend: "up" as const,
          chartData: [45, 50, 48, 55, 53, 60, 58],
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          chartData: [25, 26, 28, 27, 26, 24, 23],
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          chartData: [65, 68, 70, 69, 72, 75, 78],
        },
        {
          title: "Completion Rate",
          value: "88%",
          icon: <CheckCircle className="w-5 h-5" />,
          change: "+1.5% this month",
          trend: "up" as const,
          chartData: [80, 82, 81, 84, 85, 87, 88],
        },
        {
          title: "Overdue Items",
          value: "8",
          icon: <Clock className="w-5 h-5" />,
          change: "-3 this week",
          trend: "down" as const,
        },
        {
          title: "New This Week",
          value: "12",
          icon: <PlusCircle className="w-5 h-5" />,
          change: "+2 from last week",
          trend: "up" as const,
        },
        {
          title: "Archived Projects",
          value: "153",
          icon: <Archive className="w-5 h-5" />,
          change: "+20 this month",
          trend: "up" as const,
        },
      ];

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === "calendar" || viewMode === "kanban",
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );

      useEffect(() => {
        // Auto-group by status when switching to kanban view for the first time
        if (viewMode === "kanban" && groupBy === "none") {
          setGroupBy("status");
          setSort(null); // Kanban is manually sorted, so disable programmatic sort
        }
        // For calendar view, we don't want grouping.
        else if (viewMode === "calendar" && groupBy !== "none") {
          setGroupBy("none");
        }
      }, [viewMode, groupBy, setGroupBy, setSort]);

      return (
        <PageLayout scrollRef={scrollRef} onScroll={handleScroll}>
          <DynamicView
            viewConfig={dataDemoViewConfig}
            items={allItems as GenericItem[]}
            isLoading={isLoading}
            isInitialLoading={isInitialLoading}
            totalItemCount={totalItemCount}
            hasMore={hasMore}
            // Controlled state
            viewMode={viewMode}
            filters={filters}
            sortConfig={sortConfig}
            groupBy={groupBy}
            activeGroupTab={activeGroupTab}
            page={page}
            // Callbacks
            onViewModeChange={setViewMode}
            onFiltersChange={setFilters}
            onSortChange={setSort}
            onGroupByChange={setGroupBy}
            onActiveGroupTabChange={setActiveGroupTab}
            onPageChange={setPage}
            onItemSelect={onItemSelect}
            loaderRef={loaderRef}
            scrollContainerRef={scrollRef}
            statsData={stats}
            // Custom Renderers
            renderCta={(viewMode, ctaProps) => (
              <AddDataItemCta viewMode={viewMode} colSpan={ctaProps.colSpan} />
            )}
          />

          <ScrollToBottomButton
            isVisible={showScrollToBottom}
            onClick={scrollToBottom}
          />
        </PageLayout>
      );
    }
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 536
