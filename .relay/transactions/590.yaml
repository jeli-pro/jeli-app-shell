uuid: b859f5a8-2045-42f0-a0ac-902e84457223
projectId: jeli-app-shell
createdAt: '2025-10-23T04:24:57.778Z'
gitCommitMsg: >-
  fix(views): Prevent 404 by making view transitions context-aware

  Refactors the view management logic to prevent crashes when promoting
  parameterized views (like `dataItemDetail`) from a pane to the main content
  area. The previous implementation was attempting to navigate to a non-existent
  route (`/dataItemDetail`) instead of the correct, parameterized route
  (`/data-demo/:itemId`).

  - `useAppViewManager`: Adds a guard to `navigateTo` to handle `dataItemDetail`
  correctly and prevent 404s. Fixes `toggleSidePane` to properly pass payloads.
  - `ViewModeSwitcher`: Now uses `useAppViewManager` to access contextual
  parameters (e.g., `itemId`) required for valid navigation. - `AppShell`: Now
  uses `useAppViewManager` to supply the correct `targetPage` to its contextual
  `ViewModeSwitcher` instances, ensuring they operate on the correct view. Also
  removes the now-obsolete `usePaneDnd` hook and related UI.
promptSummary: >-
  The user reported a 404 error when interacting with detail views. This was
  caused by incorrect navigation logic that tried to access a route that doesn't
  exist (`/dataItemDetail`). I'm fixing this by making the `ViewModeSwitcher`
  and `AppShell` context-aware, ensuring they use the correct parameters (like
  `itemId`) when constructing navigation paths.
reasoning:
  - >-
    I understand. It appears my previous refactoring, while architecturally
    sound, introduced a critical bug related to navigation, specifically for
    views like `dataItemDetail` that don't have their own top-level routes. The
    `ViewModeSwitcher` was attempting to navigate to a non-existent path
    (`/dataItemDetail`), causing React Router to throw a 404 error.
  - >-
    My analysis points to a lack of context awareness in the `ViewModeSwitcher`
    and `AppShell`. The switcher needs to know not just *what* view it's
    controlling, but also any associated parameters (like an `itemId`) required
    to navigate to it correctly.
  - 'I will perform a surgical fix with three main objectives:'
  - >-
    1.  **Fortify `useAppViewManager`**: I will add guards to `navigateTo` to
    prevent invalid navigations and correct an improper `trigger` call in
    `toggleSidePane`.
  - >-
    2.  **Empower `ViewModeSwitcher`**: I will have it use the
    `useAppViewManager` hook directly to gain access to necessary context like
    `itemId`. This allows it to construct valid navigation actions.
  - >-
    3.  **Inform `AppShell`**: I will also update `AppShell` to use the view
    manager so it can provide the correct `targetPage` to its contextual
    `ViewModeSwitcher` instances.
  - >-
    These changes will resolve the crash and make view transitions robust and
    context-aware, fully aligning with the specified architecture.
  - '### Part 1: Fortify `useAppViewManager`'
  - >-
    First, I'll make the view manager more robust. I'll add a guard to
    `navigateTo` to prevent it from constructing invalid paths for
    `dataItemDetail`. I will also fix `toggleSidePane` to correctly call
    `openPane` with a payload instead of misusing the `trigger` function.
  - '### Part 2: Make `ViewModeSwitcher` Context-Aware'
  - >-
    Next, I'll update the `ViewModeSwitcher` to fetch the `itemId` from
    `useAppViewManager`. This allows it to construct correct navigation
    parameters when promoting a detail view from a pane to a full page or
    fullscreen.
  - '### Part 3: Update `AppShell` and Clean Up'
  - >-
    Finally, I'll modify `AppShell` to use the view manager hook. This allows it
    to correctly identify the views in the main and right panes and pass them as
    `targetPage` to the contextual `ViewModeSwitcher`s. I will also remove the
    now-obsolete `usePaneDnd` hook and its related UI elements and animations,
    simplifying the component.
operations:
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: >+
      --- src/hooks/useAppViewManager.hook.ts

      +++ src/hooks/useAppViewManager.hook.ts

      @@ -201,13 +201,17 @@
           }
         }, [_executeNavigate, _executeOpenPane, _executeOpenSplit]);
         
      -  const navigateTo = useCallback((page: ViewId, navParams?:
      Record<string, string | null>) => {

      +  const navigateTo = useCallback((page: ViewId, navParams?:
      Record<string, string | null | undefined>) => {
           // This is a simplified navigate, for complex behaviors, use trigger.
           let path = `/${page}`;
           if (page === 'dataItemDetail' && navParams?.itemId) {
               path = `/data-demo/${navParams.itemId}`;
      +    } else if (page === 'dataItemDetail') {

      +      console.error("navigateTo('dataItemDetail') called without an
      itemId. This is not supported. Falling back to '/data-demo'.");

      +      path = '/data-demo';
           }
           
           const newSearchParams = new URLSearchParams(searchParams);
           if (navParams) {
             for (const [key, value] of Object.entries(navParams)) {
      @@ -239,12 +243,12 @@
           }, { replace: true });
         }, [setSearchParams]);
       
      -  const toggleSidePane = useCallback((viewId: ViewId) => {

      +  const toggleSidePane = useCallback((viewId: ViewId, payload?: any) => {
           if (rightPaneViewId === viewId && bodyState === BODY_STATES.SIDE_PANE) {
               closeSidePane();
           } else {
      -        trigger(viewId, 'openPane');

      +        openPane(viewId, payload);
           }
      -  }, [rightPaneViewId, bodyState, closeSidePane, trigger]);

      +  }, [rightPaneViewId, bodyState, closeSidePane, openPane]);
       
         const setNormalView = useCallback(() => {
           // We want to navigate to the path of the main content view, clearing search params.

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/ViewModeSwitcher.tsx
    content: >+
      --- src/components/layout/ViewModeSwitcher.tsx

      +++ src/components/layout/ViewModeSwitcher.tsx

      @@ -1,7 +1,7 @@
       import { useState, useRef, useEffect } from 'react';
       import { gsap } from 'gsap';
       import { cn } from '@/lib/utils';
      -import { useAppShellStore } from '@/store/appShell.store'

      +import { useAppShellStore } from '@/store/appShell.store';
       import { BODY_STATES } from '@/lib/utils'
       import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
       import {
      @@ -24,6 +24,7 @@
           navigateTo,
           toggleSidePane,
           switchSplitPanes,
           closeSplitPane,
      +    itemId,
         } = useAppViewManager();
       
         const activePage = targetPage || currentActivePage;
      @@ -82,8 +83,9 @@
           }
         }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons
       
         const handleSidePaneClick = () => {
      -    toggleSidePane(activePage);

      +    const payload = (activePage === 'dataItemDetail' && itemId) ? {
      itemId } : undefined;

      +    toggleSidePane(activePage, payload);
         }
       
         const handleNormalViewClick = () => {
      @@ -91,7 +93,8 @@
             toggleFullscreen();
           }
           if (targetPage && targetPage !== currentActivePage) {
      -      navigateTo(targetPage);

      +      const navParams = (targetPage === 'dataItemDetail' && itemId) ? {
      itemId } : undefined;

      +      navigateTo(targetPage, navParams);
           } else {
             setNormalView();
           }
      @@ -120,7 +123,8 @@
             id: 'fullscreen',
             onClick: () => {
               if (targetPage && targetPage !== currentActivePage) {
      -          navigateTo(targetPage);

      +          const navParams = (targetPage === 'dataItemDetail' && itemId) ?
      { itemId } : undefined;

      +          navigateTo(targetPage, navParams);
                 setTimeout(() => toggleFullscreen(pane), 50);
               } else {
                 toggleFullscreen(pane);

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/AppShell.tsx
    content: >+
      --- src/components/layout/AppShell.tsx

      +++ src/components/layout/AppShell.tsx

      @@ -5,24 +5,16 @@
       import { useResizableSidebar, useResizableRightPane } from '@/hooks/useResizablePanes.hook'
       import { useSidebarAnimations, useBodyStateAnimations } from '@/hooks/useAppShellAnimations.hook'
       import { ViewModeSwitcher } from './ViewModeSwitcher';
      -import { usePaneDnd } from '@/hooks/usePaneDnd.hook';

      +import { useAppViewManager } from '@/hooks/useAppViewManager.hook';

      +import type { ViewId } from '@/views/viewRegistry';
       
       interface AppShellProps {
         sidebar: ReactElement;
         topBar: ReactElement;
         mainContent: ReactElement;
         rightPane: ReactElement;
         commandPalette?: ReactElement;
         onOverlayClick?: () => void;
       }
      -

      -const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
      'notifications' | 'dataDemo'> = {

      -  dashboard: 'main',

      -  settings: 'settings',

      -  toaster: 'toaster',

      -  notifications: 'notifications',

      -  'data-demo': 'dataDemo',

      -};
       
       // Helper hook to get the previous value of a prop or state
       function usePrevious<T>(value: T): T | undefined {
      @@ -38,11 +30,8 @@
         const autoExpandSidebar = useAppShellStore(s => s.autoExpandSidebar);
         const hoveredPane = useAppShellStore(s => s.hoveredPane);
         const draggedPage = useAppShellStore(s => s.draggedPage);
      -  const dragHoverTarget = useAppShellStore(s => s.dragHoverTarget);
         const bodyState = useAppShellStore(s => s.bodyState);
      -  const sidePaneContent = useAppShellStore(s => s.sidePaneContent);
         const reducedMotion = useAppShellStore(s => s.reducedMotion);
         const isTopBarVisible = useAppShellStore(s => s.isTopBarVisible);
         const isDarkMode = useAppShellStore(s => s.isDarkMode);
      @@ -59,53 +48,15 @@
         const topBarContainerRef = useRef<HTMLDivElement>(null)
         const mainAreaRef = useRef<HTMLDivElement>(null)
       
      -  const prevActivePage = usePrevious(activePage);

      -  const prevSidePaneContent = usePrevious(sidePaneContent);

      -
         const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;
      -  const dndHandlers = usePaneDnd();

      +  const viewManager = useAppViewManager();
       
         // Custom hooks for logic
         useResizableSidebar(sidebarRef, resizeHandleRef);
         useResizableRightPane(rightPaneRef);
         useSidebarAnimations(sidebarRef, resizeHandleRef);
         useBodyStateAnimations(appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef);
         
      -  // Animation for pane swapping

      -  useLayoutEffect(() => {

      -    if (reducedMotion || bodyState !== BODY_STATES.SPLIT_VIEW ||
      !prevActivePage || !prevSidePaneContent) {

      -      return;

      -    }

      -

      -    const pageForPrevSidePane = Object.keys(pageToPaneMap).find(

      -      key => pageToPaneMap[key as keyof typeof pageToPaneMap] ===
      prevSidePaneContent

      -    );

      -

      -    // Check if a swap occurred by comparing current state with previous
      state

      -    if (activePage === pageForPrevSidePane && sidePaneContent ===
      pageToPaneMap[prevActivePage as keyof typeof pageToPaneMap]) {

      -      const mainEl = mainAreaRef.current;

      -      const rightEl = rightPaneRef.current;

      -

      -      if (mainEl && rightEl) {

      -        const mainWidth = mainEl.offsetWidth;

      -        const rightWidth = rightEl.offsetWidth;

      -

      -        const tl = gsap.timeline();

      -        

      -        // Animate main content FROM where right pane was TO its new
      place

      -        tl.from(mainEl, {

      -          x: rightWidth, duration: 0.4, ease: 'power3.inOut'

      -        });

      -

      -        // Animate right pane FROM where main content was TO its new
      place

      -        tl.from(rightEl, {

      -          x: -mainWidth, duration: 0.4, ease: 'power3.inOut'

      -        }, 0); // Start at the same time

      -      }

      -    }

      -  }, [activePage, sidePaneContent, bodyState, prevActivePage,
      prevSidePaneContent, reducedMotion]);

      -  
         const sidebarWithProps = React.cloneElement(sidebar, { 
           ref: sidebarRef,
           onMouseEnter: () => {
      @@ -213,67 +164,23 @@
                       )}
                       onClick={onOverlayClick}
                     />
      -              {/* Left drop overlay */}

      -              <div

      -                className={cn(

      -                  "absolute inset-y-0 left-0 z-40 border-2
      border-transparent transition-all",

      -                  draggedPage

      -                    ? cn("pointer-events-auto", isSplitView ? 'w-full' :
      'w-1/2')

      -                    : "pointer-events-none w-0",

      -                  dragHoverTarget === 'left' && "bg-primary/10
      border-primary"

      -                )}

      -                onDragOver={dndHandlers.handleDragOverLeft}

      -                onDrop={dndHandlers.handleDropLeft}

      -                onDragLeave={dndHandlers.handleDragLeave}

      -              >

      -                {draggedPage && dragHoverTarget === 'left' && (

      -                  <div className="absolute inset-0 flex items-center
      justify-center text-sm font-medium text-primary-foreground/80
      pointer-events-none">

      -                    <span className="px-3 py-1 rounded-md
      bg-primary/70">{isSplitView ? 'Drop to Replace' : 'Drop to Left'}</span>

      -                  </div>

      -                )}

      -              </div>
                     {mainContentWithProps}
                     {isSplitView && hoveredPane === 'left' && !draggedPage && (
                       <div className={cn("absolute right-4 z-50 transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
      -                  <ViewModeSwitcher pane="main" />

      +                  <ViewModeSwitcher pane="main"
      targetPage={viewManager.mainViewId as ViewId} />
                       </div>
                     )}
      -              {/* Right drop overlay (over main area, ONLY when NOT in
      split view) */}

      -              {!isSplitView && (

      -                <div

      -                  className={cn(

      -                    "absolute inset-y-0 right-0 z-40 border-2
      border-transparent",

      -                    draggedPage ? "pointer-events-auto w-1/2" :
      "pointer-events-none",

      -                    dragHoverTarget === 'right' && "bg-primary/10
      border-primary"

      -                  )}

      -                  onDragOver={dndHandlers.handleDragOverRight}

      -                  onDrop={dndHandlers.handleDropRight}

      -                  onDragLeave={dndHandlers.handleDragLeave}

      -                >

      -                  {draggedPage && dragHoverTarget === 'right' && (

      -                    <div className="absolute inset-0 flex items-center
      justify-center pointer-events-none">

      -                      <span className="px-3 py-1 rounded-md bg-primary/70
      text-sm font-medium text-primary-foreground/80">Drop to Right</span>

      -                    </div>

      -                  )}

      -                </div>

      -              )}
                   </div>
                   {isSplitView ? (
                     <div
                       className="relative"
                       onMouseEnter={() => { if (isSplitView && !draggedPage) setHoveredPane('right'); }}
                       onMouseLeave={() => { if (isSplitView && !draggedPage) setHoveredPane(null); }}
      -                onDragOver={dndHandlers.handleDragOverRight}
                     >
                       {rightPaneWithProps}
      -                {draggedPage && (

      -                  <div

      -                    className={cn(

      -                      'absolute inset-0 z-50 transition-all',

      -                      dragHoverTarget === 'right'

      -                        ? 'bg-primary/10 border-2 border-primary'

      -                        : 'pointer-events-none'

      -                    )}

      -                    onDragLeave={dndHandlers.handleDragLeave}

      -                    onDrop={dndHandlers.handleDropRight}

      -                    onDragOver={(e) => e.preventDefault()}

      -                  >

      -                    {dragHoverTarget === 'right' && (

      -                      <div className="absolute inset-0 flex items-center
      justify-center pointer-events-none">

      -                        <span className="px-3 py-1 rounded-md
      bg-primary/70 text-sm font-medium text-primary-foreground/80">

      -                          Drop to Replace

      -                        </span>

      -                      </div>

      -                    )}

      -                  </div>

      -                )}
                       {hoveredPane === 'right' && !draggedPage && (
                         <div className={cn("absolute right-4 z-[70] transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
      -                    <ViewModeSwitcher pane="right" />

      +                    <ViewModeSwitcher pane="right"
      targetPage={viewManager.rightPaneViewId as ViewId} />
                         </div>
                       )}
                     </div>

    patchStrategy: standard-diff
snapshot:
  src/hooks/useAppViewManager.hook.ts: >-
    import { useMemo, useCallback } from 'react';

    import { useSearchParams, useNavigate, useLocation, useParams } from
    'react-router-dom';

    import { useAppShellStore } from '@/store/appShell.store';

    import type { TaskView } from '@/pages/Messaging/types';

    import { BODY_STATES, BodyState } from '@/lib/utils';

    import { getViewById, type ViewId, type ViewRegistration } from
    '@/views/viewRegistry';


    /**
     * A centralized hook to manage and synchronize all URL-based view states.
     * This is the single source of truth for view modes, side panes, split views,
     * and page-specific parameters. It acts as an executor for the declarative
     * rules defined in the `viewRegistry`.
     */
    export function useAppViewManager() {
      const [searchParams, setSearchParams] = useSearchParams();
      const navigate = useNavigate();
      const location = useLocation();
      const params = useParams<{ itemId?: string; conversationId?: string }>();

      const { setSidebarState } = useAppShellStore.getState();

      // --- DERIVED STATE FROM URL & VIEW REGISTRY ---

      const { mainViewId, rightPaneViewId, bodyState } = useMemo(() => {
        const path = location.pathname.split('/')[1] || 'dashboard';
        const viewFromPath = getViewById(path);
        
        const sidePaneParam = searchParams.get('sidePane');
        const viewParam = searchParams.get('view');
        const rightParam = searchParams.get('right');
        const itemIdParam = searchParams.get('itemId');

        let derivedMainViewId: ViewId | null = (path as ViewId) || 'dashboard';
        let derivedRightPaneViewId: ViewId | null = null;
        let derivedBodyState: BodyState = BODY_STATES.NORMAL;

        if (viewFromPath?.compositeView) {
          derivedMainViewId = viewFromPath.compositeView.main;
          derivedRightPaneViewId = viewFromPath.compositeView.right;
          derivedBodyState = BODY_STATES.SPLIT_VIEW;
        } else if (sidePaneParam) {
          derivedRightPaneViewId = sidePaneParam as ViewId;
          derivedBodyState = BODY_STATES.SIDE_PANE;
        } else if (viewParam === 'split' && rightParam) {
          derivedRightPaneViewId = rightParam as ViewId;
          derivedBodyState = BODY_STATES.SPLIT_VIEW;
        }

        // Handle item detail views specially
        if (derivedMainViewId === 'data-demo' && params.itemId) {
          derivedMainViewId = 'dataItemDetail';
        } else if (itemIdParam) {
          derivedRightPaneViewId = 'dataItemDetail';
          // If there's an itemId, it could be a side pane or part of a split
          if (derivedBodyState !== BODY_STATES.SPLIT_VIEW) {
              derivedBodyState = BODY_STATES.SIDE_PANE;
          }
        }

        return { 
          mainViewId: derivedMainViewId, 
          rightPaneViewId: derivedRightPaneViewId, 
          bodyState: derivedBodyState
        };
      }, [location.pathname, searchParams, params.itemId, params.conversationId]);

      const messagingView = searchParams.get('messagingView') as TaskView | null;
      const currentActivePage = (location.pathname.split('/')[1] || 'dashboard') as ViewId;

      // --- PRIVATE ACTION EXECUTORS ---

      const getPathForView = useCallback((viewId: ViewId | null, viewParams: typeof params): string => {
        if (!viewId) return '/dashboard'; // Fallback to dashboard
        if (viewId === 'dataItemDetail' && viewParams.itemId) {
            return `/data-demo/${viewParams.itemId}`;
        }
        // When dealing with a composite view, the "page" is the parent route
        if ((viewId === 'messagingPage' || viewId === 'messagingContextPanel') && viewParams.conversationId) {
          return `/messaging/${viewParams.conversationId}`;
        }
        if (viewId === 'messagingPage' || viewId === 'messagingContextPanel') {
          return '/messaging';
        }
        return `/${viewId}`;
      }, []);

      const _executeNavigate = useCallback((view: ViewRegistration, payload?: any) => {
        if (view.onNavigate?.sidebar) {
          setSidebarState(view.onNavigate.sidebar);
        }
        
        let path = `/${view.id}`;
        if (view.id === 'dataItemDetail' && payload?.itemId) {
            path = `/data-demo/${payload.itemId}`;
        }

        navigate(path);
      }, [navigate, setSidebarState]);

      const _executeOpenPane = useCallback((view: ViewRegistration, payload?: any) => {
        if (!view.renderTarget?.includes('pane')) {
          console.warn(`View "${view.id}" cannot be rendered in a pane.`);
          return;
        }
        
        setSearchParams(prev => {
            prev.delete('view');
            prev.delete('right');
            if (view.id === 'dataItemDetail' && payload?.itemId) {
                prev.set('itemId', payload.itemId);
                prev.delete('sidePane');
            } else {
                prev.set('sidePane', view.id);
                prev.delete('itemId');
            }
            return prev;
        }, { replace: true });

      }, [setSearchParams]);

      const _executeOpenSplit = useCallback((view: ViewRegistration, payload?: any) => {
        // A composite view is triggered by navigating to its main route
        if (view.compositeView) {
          _executeNavigate(view, payload);
          return;
        }
        
        if (!view.renderTarget?.includes('pane')) {
          console.warn(`View "${view.id}" cannot be rendered in a split view's right pane.`);
          return;
        }
        
        setSearchParams(prev => {
            prev.set('view', 'split');
            prev.delete('sidePane');
            if (view.id === 'dataItemDetail' && payload?.itemId) {
                prev.set('itemId', payload.itemId);
                prev.delete('right');
            } else {
                prev.set('right', view.id);
                prev.delete('itemId');
            }
            return prev;
        }, { replace: true });
      }, [setSearchParams, _executeNavigate]);

      // --- PUBLIC API ---

      const trigger = useCallback((viewId: ViewId, source?: string, payload?: any) => {
        const view = getViewById(viewId);
        if (!view) {
          console.error(`View with id "${viewId}" not found in registry.`);
          return;
        }
        
        const behavior = (source && view.triggerBehaviors?.[source]) || view.defaultBehavior || 'navigate';
        
        // TODO: Add check for allowedBodyStates
        
        switch (behavior) {
          case 'navigate':
            _executeNavigate(view, payload);
            break;
          case 'openPane':
            _executeOpenPane(view, payload);
            break;
          case 'openSplit':
            _executeOpenSplit(view, payload);
            break;
          default:
            console.warn(`Unknown behavior "${behavior}" for view "${viewId}".`);
            _executeNavigate(view, payload);
        }
      }, [_executeNavigate, _executeOpenPane, _executeOpenSplit]);
      
      const navigateTo = useCallback((page: ViewId, navParams?: Record<string, string | null>) => {
        // This is a simplified navigate, for complex behaviors, use trigger.
        let path = `/${page}`;
        if (page === 'dataItemDetail' && navParams?.itemId) {
            path = `/data-demo/${navParams.itemId}`;
        }
        
        const newSearchParams = new URLSearchParams(searchParams);
        if (navParams) {
          for (const [key, value] of Object.entries(navParams)) {
            if (value === null || value === undefined) {
              newSearchParams.delete(key);
            } else {
              newSearchParams.set(key, value);
            }
          }
        }
        
        const view = getViewById(page);
        if (view?.onNavigate?.sidebar) {
          setSidebarState(view.onNavigate.sidebar);
        }

        navigate({ pathname: path, search: newSearchParams.toString() });
      }, [navigate, searchParams, setSidebarState]);
      
      const openPane = useCallback((viewId: ViewId, payload?: any) => {
        const view = getViewById(viewId);
        if (view) {
          _executeOpenPane(view, payload);
        }
      }, [_executeOpenPane]);

      const closeSidePane = useCallback(() => {
        setSearchParams(prev => {
            prev.delete('sidePane');
            prev.delete('itemId');
            // if we were in a split view, revert to normal by clearing view and right
            if (prev.get('view') === 'split') {
              prev.delete('view');
              prev.delete('right');
            }
            return prev;
        }, { replace: true });
      }, [setSearchParams]);

      const toggleSidePane = useCallback((viewId: ViewId) => {
        if (rightPaneViewId === viewId && bodyState === BODY_STATES.SIDE_PANE) {
            closeSidePane();
        } else {
            trigger(viewId, 'openPane');
        }
      }, [rightPaneViewId, bodyState, closeSidePane, trigger]);

      const setNormalView = useCallback(() => {
        // We want to navigate to the path of the main content view, clearing search params.
        const path = getPathForView(mainViewId, params);
        navigate(path, { replace: true });
      }, [mainViewId, params, navigate, getPathForView]);

      const toggleSplitView = useCallback((rightViewId: ViewId = 'settings') => {
        if (bodyState === BODY_STATES.SPLIT_VIEW) {
          setNormalView();
        } else {
          trigger(rightViewId, 'openSplit');
        }
      }, [bodyState, setNormalView, trigger]);

      const switchSplitPanes = useCallback(() => {
        if (bodyState !== BODY_STATES.SPLIT_VIEW || !mainViewId || !rightPaneViewId) return;

        const mainView = getViewById(mainViewId);
        const rightView = getViewById(rightPaneViewId);

        if (mainView?.isNavigable && rightView?.isNavigable) {
          navigate(`/${rightPaneViewId}?view=split&right=${mainViewId}`, { replace: true });
        } else {
          console.warn("Cannot switch panes: one or both views are not navigable.", { mainViewId, rightPaneViewId });
        }
      }, [bodyState, mainViewId, rightPaneViewId, navigate]);

      const closeSplitPane = useCallback((pane: 'main' | 'right') => {
        if (bodyState !== BODY_STATES.SPLIT_VIEW || !mainViewId) {
          setNormalView();
          return;
        }
        if (pane === 'right') {
          const path = getPathForView(mainViewId as ViewId, params);
          navigate(path, { replace: true });
        } else if (rightPaneViewId) {
          const rightView = getViewById(rightPaneViewId);
          if (rightView?.isNavigable) navigate(`/${rightPaneViewId}`, { replace: true });
          else navigate('/dashboard', { replace: true });
        } else setNormalView();
      }, [bodyState, mainViewId, rightPaneViewId, navigate, setNormalView, getPathForView, params]);

      const setMessagingView = (view: TaskView) => {
        setSearchParams(prev => {
            prev.set('messagingView', view);
            return prev;
        }, { replace: true });
      };

      const itemId = params.itemId || searchParams.get('itemId');
      
      return useMemo(() => ({
        // State
        mainViewId,
        rightPaneViewId,
        bodyState,
        itemId,
        conversationId: params.conversationId,
        messagingView,
        currentActivePage,

        // Actions
        trigger,
        navigateTo,
        openPane,
        closeSidePane,
        toggleSidePane,
        setNormalView,
        toggleSplitView,
        switchSplitPanes,
        closeSplitPane,
        setMessagingView,
      }), [
        mainViewId, rightPaneViewId, bodyState, itemId, params.conversationId, messagingView, currentActivePage,
        trigger, navigateTo, openPane, closeSidePane, toggleSidePane, setNormalView, toggleSplitView, switchSplitPanes, closeSplitPane, setMessagingView
      ]);
    }
  src/components/layout/ViewModeSwitcher.tsx: >-
    import { useState, useRef, useEffect } from 'react';

    import { gsap } from 'gsap';

    import { cn } from '@/lib/utils';

    import { useAppShellStore } from '@/store/appShell.store'

    import { BODY_STATES } from '@/lib/utils'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import {
      Columns,
      PanelRightOpen,
      SplitSquareHorizontal,
      Maximize,
      Minimize,
      Layers,
      X,
      ArrowLeftRight,
    } from 'lucide-react';

    import type { ViewId } from '@/views/viewRegistry';


    export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
    'right'; targetPage?: ViewId }) {
      const bodyState = useAppShellStore(s => s.bodyState);
      const fullscreenTarget = useAppShellStore(s => s.fullscreenTarget);
      const { toggleFullscreen } = useAppShellStore.getState();
      const {
        currentActivePage,
        toggleSplitView,
        setNormalView,
        navigateTo,
        toggleSidePane,
        switchSplitPanes,
        closeSplitPane,
      } = useAppViewManager();

      const activePage = targetPage || currentActivePage;
      const [isExpanded, setIsExpanded] = useState(false);
      const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isThisPaneFullscreen = isFullscreen && (
        (pane === 'main' && fullscreenTarget !== 'right') || // main pane is fullscreen if target is not right
        (pane === 'right' && fullscreenTarget === 'right') || // right pane is fullscreen if it is the target
        (!pane && fullscreenTarget !== 'right') // global switcher shows minimize if main pane is fullscreen
      );

      useEffect(() => {
        const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
        if (buttonsToAnimate.length === 0) return;

        gsap.killTweensOf(buttonsToAnimate);

        if (isExpanded) {
            gsap.to(buttonsToAnimate, {
                width: 32, // h-8 w-8
                opacity: 1,
                pointerEvents: 'auto',
                marginLeft: 4, // from gap-1 in original
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'start'
                },
                ease: 'power2.out'
            });
        } else {
            gsap.to(buttonsToAnimate, {
                width: 0,
                opacity: 0,
                pointerEvents: 'none',
                marginLeft: 0,
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'end'
                },
                ease: 'power2.in'
            });
        }
      }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

      const handleSidePaneClick = () => {
        toggleSidePane(activePage);
      }

      const handleNormalViewClick = () => {
        if (isFullscreen) {
          toggleFullscreen();
        }
        if (targetPage && targetPage !== currentActivePage) {
          navigateTo(targetPage);
        } else {
          setNormalView();
        }
      }

      const buttons = [
        {
          id: 'normal',
          onClick: handleNormalViewClick,
          active: bodyState === BODY_STATES.NORMAL,
          title: "Normal View",
          icon: <Columns className="w-4 h-4" />
        },
        {
          id: 'side-pane',
          onClick: handleSidePaneClick,
          active: bodyState === BODY_STATES.SIDE_PANE,
          title: "Side Pane View",
          icon: <PanelRightOpen className="w-4 h-4" />
        },
        {
          id: 'split-view',
          onClick: () => toggleSplitView(),
          active: bodyState === BODY_STATES.SPLIT_VIEW,
          title: "Split View",
          icon: <SplitSquareHorizontal className="w-4 h-4" />
        },
        {
          id: 'fullscreen',
          onClick: () => {
            if (targetPage && targetPage !== currentActivePage) {
              navigateTo(targetPage);
              setTimeout(() => toggleFullscreen(pane), 50);
            } else {
              toggleFullscreen(pane);
            }
          },
          active: isThisPaneFullscreen,
          title: "Toggle Fullscreen",
          icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
        }
      ];

      if (bodyState === BODY_STATES.SPLIT_VIEW) {
        buttons.push({
          id: 'switch',
          onClick: switchSplitPanes,
          active: false,
          title: "Switch Panes",
          icon: <ArrowLeftRight className="w-4 h-4" />
        });
        buttons.push({
          id: 'close',
          onClick: () => closeSplitPane(pane || 'right'),
          active: false,
          title: "Close Pane",
          icon: <X className="w-4 h-4 text-muted-foreground group-hover:text-destructive" />
        });
      }

      return (
        <div
          onMouseEnter={() => setIsExpanded(true)}
          onMouseLeave={() => setIsExpanded(false)}
          className="flex items-center gap-0 p-1 bg-card rounded-full border border-border"
        >
            <button
                className='h-8 w-8 flex-shrink-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors'
                title="View Modes"
                onClick={() => setIsExpanded(!isExpanded)}
            >
                <Layers className="w-4 h-4" />
            </button>
          
          {buttons.map((btn, index) => (
            <button
              key={btn.id}
              ref={el => buttonRefs.current[index] = el}
              onClick={btn.onClick}
              className={cn(
                'h-8 w-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors group opacity-0',
                btn.active && 'bg-accent text-accent-foreground',
                btn.id === 'close' && 'hover:bg-destructive/20'
              )}
              style={{ pointerEvents: 'none', marginLeft: 0, overflow: 'hidden' }}
              title={btn.title}
            >
              {btn.icon}
            </button>
          ))}
        </div>
      )
    }
  src/components/layout/AppShell.tsx: >-
    import React, { useRef, type ReactElement, useEffect, useLayoutEffect } from
    'react'

    import { useLocation } from 'react-router-dom';

    import { cn } from '@/lib/utils'

    import { gsap } from 'gsap';

    import { CommandPalette } from '@/components/global/CommandPalette';

    import { useAppShellStore } from '@/store/appShell.store';

    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'

    import { useResizableSidebar, useResizableRightPane } from
    '@/hooks/useResizablePanes.hook'

    import { useSidebarAnimations, useBodyStateAnimations } from
    '@/hooks/useAppShellAnimations.hook'

    import { ViewModeSwitcher } from './ViewModeSwitcher';

    import { usePaneDnd } from '@/hooks/usePaneDnd.hook';


    interface AppShellProps {
      sidebar: ReactElement;
      topBar: ReactElement;
      mainContent: ReactElement;
      rightPane: ReactElement;
      commandPalette?: ReactElement;
      onOverlayClick?: () => void;
    }


    const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
    'notifications' | 'dataDemo'> = {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
      'data-demo': 'dataDemo',
    };


    // Helper hook to get the previous value of a prop or state

    function usePrevious<T>(value: T): T | undefined {
      const ref = useRef<T>();
      useEffect(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }



    export function AppShell({ sidebar, topBar, mainContent, rightPane,
    commandPalette, onOverlayClick }: AppShellProps) {
      const sidebarState = useAppShellStore(s => s.sidebarState);
      const autoExpandSidebar = useAppShellStore(s => s.autoExpandSidebar);
      const hoveredPane = useAppShellStore(s => s.hoveredPane);
      const draggedPage = useAppShellStore(s => s.draggedPage);
      const dragHoverTarget = useAppShellStore(s => s.dragHoverTarget);
      const bodyState = useAppShellStore(s => s.bodyState);
      const sidePaneContent = useAppShellStore(s => s.sidePaneContent);
      const reducedMotion = useAppShellStore(s => s.reducedMotion);
      const isTopBarVisible = useAppShellStore(s => s.isTopBarVisible);
      const isDarkMode = useAppShellStore(s => s.isDarkMode);
      const { setSidebarState, peekSidebar, setHoveredPane, setTopBarHovered } = useAppShellStore.getState();
      
      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isSidePaneOpen = bodyState === BODY_STATES.SIDE_PANE;
      const location = useLocation();
      const activePage = location.pathname.split('/')[1] || 'dashboard';
      const appRef = useRef<HTMLDivElement>(null)
      const sidebarRef = useRef<HTMLDivElement>(null)
      const mainContentRef = useRef<HTMLDivElement>(null)
      const rightPaneRef = useRef<HTMLDivElement>(null)
      const resizeHandleRef = useRef<HTMLDivElement>(null)
      const topBarContainerRef = useRef<HTMLDivElement>(null)
      const mainAreaRef = useRef<HTMLDivElement>(null)

      const prevActivePage = usePrevious(activePage);
      const prevSidePaneContent = usePrevious(sidePaneContent);

      const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;
      const dndHandlers = usePaneDnd();

      // Custom hooks for logic
      useResizableSidebar(sidebarRef, resizeHandleRef);
      useResizableRightPane(rightPaneRef);
      useSidebarAnimations(sidebarRef, resizeHandleRef);
      useBodyStateAnimations(appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef);
      
      // Animation for pane swapping
      useLayoutEffect(() => {
        if (reducedMotion || bodyState !== BODY_STATES.SPLIT_VIEW || !prevActivePage || !prevSidePaneContent) {
          return;
        }

        const pageForPrevSidePane = Object.keys(pageToPaneMap).find(
          key => pageToPaneMap[key as keyof typeof pageToPaneMap] === prevSidePaneContent
        );

        // Check if a swap occurred by comparing current state with previous state
        if (activePage === pageForPrevSidePane && sidePaneContent === pageToPaneMap[prevActivePage as keyof typeof pageToPaneMap]) {
          const mainEl = mainAreaRef.current;
          const rightEl = rightPaneRef.current;

          if (mainEl && rightEl) {
            const mainWidth = mainEl.offsetWidth;
            const rightWidth = rightEl.offsetWidth;

            const tl = gsap.timeline();
            
            // Animate main content FROM where right pane was TO its new place
            tl.from(mainEl, {
              x: rightWidth, duration: 0.4, ease: 'power3.inOut'
            });

            // Animate right pane FROM where main content was TO its new place
            tl.from(rightEl, {
              x: -mainWidth, duration: 0.4, ease: 'power3.inOut'
            }, 0); // Start at the same time
          }
        }
      }, [activePage, sidePaneContent, bodyState, prevActivePage, prevSidePaneContent, reducedMotion]);
      
      const sidebarWithProps = React.cloneElement(sidebar, { 
        ref: sidebarRef,
        onMouseEnter: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.COLLAPSED) {
            peekSidebar()
          }
        },
        onMouseLeave: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.PEEK) {
            setSidebarState(SIDEBAR_STATES.COLLAPSED);
          }
        }
      });

      const mainContentWithProps = React.cloneElement(mainContent, {
        ref: mainContentRef,
      });

      const rightPaneWithProps = React.cloneElement(rightPane, { ref: rightPaneRef });

      return (
        <div 
          ref={appRef}
          className={cn(
            "relative h-screen w-screen overflow-hidden bg-background transition-colors duration-300",
            isDarkMode && "dark"
          )}
        >
          <div className="flex h-screen overflow-hidden">
            {/* Enhanced Sidebar */}
            {sidebarWithProps}

            {/* Resize Handle */}
            {sidebarState !== SIDEBAR_STATES.HIDDEN && (
              <div
                ref={resizeHandleRef}
                className={cn(
                  "absolute top-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
                )}
                onMouseDown={(e) => {
                  e.preventDefault()
                  useAppShellStore.getState().setIsResizing(true);
                }}
              >
                <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
              </div>
            )}

            {/* Main area wrapper */}
            <div className="flex-1 flex flex-col overflow-hidden relative">
              <div
                ref={topBarContainerRef}
                className={cn(
                  "absolute top-0 left-0 right-0 z-30",
                  isFullscreen && "z-0"
                )}
                onMouseEnter={() => {
                  if (isSplitView) {
                    setTopBarHovered(true);
                    setHoveredPane(null);
                  }
                }}
                onMouseLeave={() => {
                  if (isSplitView) {
                    setTopBarHovered(false);
                  }
                }}
              >
                {topBar}
              </div>

              {/* Invisible trigger area for top bar in split view */}
              {isSplitView && (
                <div
                  className="absolute top-0 left-0 right-0 h-4 z-20"
                  onMouseEnter={() => {
                    setTopBarHovered(true);
                    setHoveredPane(null);
                  }}
                />
              )}

              <div className="flex flex-1 min-h-0">
                <div
                  ref={mainAreaRef}
                  className="relative flex-1 overflow-hidden bg-background"
                  onMouseEnter={() => { if (isSplitView && !draggedPage) setHoveredPane('left'); }}
                  onMouseLeave={() => { if (isSplitView && !draggedPage) setHoveredPane(null); }}
                >
                  {/* Side Pane Overlay */}
                  <div
                    role="button"
                    aria-label="Close side pane"
                    tabIndex={isSidePaneOpen ? 0 : -1}
                    className={cn(
                      "absolute inset-0 bg-black/40 z-40 transition-opacity duration-300",
                      isSidePaneOpen
                        ? "opacity-100 pointer-events-auto"
                        : "opacity-0 pointer-events-none"
                    )}
                    onClick={onOverlayClick}
                  />
                  {/* Left drop overlay */}
                  <div
                    className={cn(
                      "absolute inset-y-0 left-0 z-40 border-2 border-transparent transition-all",
                      draggedPage
                        ? cn("pointer-events-auto", isSplitView ? 'w-full' : 'w-1/2')
                        : "pointer-events-none w-0",
                      dragHoverTarget === 'left' && "bg-primary/10 border-primary"
                    )}
                    onDragOver={dndHandlers.handleDragOverLeft}
                    onDrop={dndHandlers.handleDropLeft}
                    onDragLeave={dndHandlers.handleDragLeave}
                  >
                    {draggedPage && dragHoverTarget === 'left' && (
                      <div className="absolute inset-0 flex items-center justify-center text-sm font-medium text-primary-foreground/80 pointer-events-none">
                        <span className="px-3 py-1 rounded-md bg-primary/70">{isSplitView ? 'Drop to Replace' : 'Drop to Left'}</span>
                      </div>
                    )}
                  </div>
                  {mainContentWithProps}
                  {isSplitView && hoveredPane === 'left' && !draggedPage && (
                    <div className={cn("absolute right-4 z-50 transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                      <ViewModeSwitcher pane="main" />
                    </div>
                  )}
                  {/* Right drop overlay (over main area, ONLY when NOT in split view) */}
                  {!isSplitView && (
                    <div
                      className={cn(
                        "absolute inset-y-0 right-0 z-40 border-2 border-transparent",
                        draggedPage ? "pointer-events-auto w-1/2" : "pointer-events-none",
                        dragHoverTarget === 'right' && "bg-primary/10 border-primary"
                      )}
                      onDragOver={dndHandlers.handleDragOverRight}
                      onDrop={dndHandlers.handleDropRight}
                      onDragLeave={dndHandlers.handleDragLeave}
                    >
                      {draggedPage && dragHoverTarget === 'right' && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                          <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">Drop to Right</span>
                        </div>
                      )}
                    </div>
                  )}
                </div>
                {isSplitView ? (
                  <div
                    className="relative"
                    onMouseEnter={() => { if (isSplitView && !draggedPage) setHoveredPane('right'); }}
                    onMouseLeave={() => { if (isSplitView && !draggedPage) setHoveredPane(null); }}
                    onDragOver={dndHandlers.handleDragOverRight}
                  >
                    {rightPaneWithProps}
                    {draggedPage && (
                      <div
                        className={cn(
                          'absolute inset-0 z-50 transition-all',
                          dragHoverTarget === 'right'
                            ? 'bg-primary/10 border-2 border-primary'
                            : 'pointer-events-none'
                        )}
                        onDragLeave={dndHandlers.handleDragLeave}
                        onDrop={dndHandlers.handleDropRight}
                        onDragOver={(e) => e.preventDefault()}
                      >
                        {dragHoverTarget === 'right' && (
                          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">
                              Drop to Replace
                            </span>
                          </div>
                        )}
                      </div>
                    )}
                    {hoveredPane === 'right' && !draggedPage && (
                      <div className={cn("absolute right-4 z-[70] transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                        <ViewModeSwitcher pane="right" />
                      </div>
                    )}
                  </div>
                ) : rightPaneWithProps}
              </div>
            </div>
          </div>
          {commandPalette || <CommandPalette />}
        </div>
      )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 590
