uuid: 4de2557c-f376-4d1a-8c5e-85c8ec23f46f
projectId: jeli-app-shell
createdAt: '2025-10-17T11:26:18.767Z'
gitCommitMsg: >-
  feat(messaging): Blur message thread when hovering journey scrollbar

  Improves UX by applying a blur effect to the main message thread when the user
  hovers over the JourneyScrollbar. This reduces background noise and enhances
  the readability of the tooltips, which now show all at once on hover.

  This is achieved by lifting the hover state from `JourneyScrollbar` up to
  `TaskDetail`, which then conditionally applies CSS classes (`blur-sm`,
  `pointer-events-none`) to the message container.
promptSummary: >-
  The user wanted to blur the message thread when the journey scrollbar tooltips
  are visible to improve readability.
reasoning:
  - >-
    Excellent idea. Blurring the background is a great way to improve
    readability and focus on the tooltips.
  - >-
    I'll implement this by having the `JourneyScrollbar` component notify its
    parent (`TaskDetail`) when it's being hovered. The `TaskDetail` component
    will then apply a blur effect to the message thread container.
  - '### 1. Update `JourneyScrollbar` to Communicate Hover State'
  - >-
    First, I'll modify `JourneyScrollbar.tsx` to remove its local hover state
    and instead use props to receive its hover status and a callback to report
    changes.
  - '### 2. Update `TaskDetail` to Apply the Blur Effect'
  - >-
    Now, I'll update `TaskDetail.tsx` to manage the hover state and
    conditionally apply the blur effect to the `ActivityFeed`'s container.
operations:
  - type: write
    path: src/pages/Messaging/components/JourneyScrollbar.tsx
    content: |+
      --- src/pages/Messaging/components/JourneyScrollbar.tsx
      +++ src/pages/Messaging/components/JourneyScrollbar.tsx
      @@ -6,13 +6,14 @@
         scrollContainerRef: React.RefObject<HTMLDivElement>;
         journeyPoints: Message[];
         onDotClick: (messageId: string) => void;
      +  onHoverChange?: (isHovering: boolean) => void;
      +  showAllTooltips?: boolean;
       }
       
       const journeyInfoMap: Record<JourneyPointType, { Icon: LucideIcon; textColor: string; bgColor: string; }> = {
         Consult: { Icon: MessageSquare, textColor: 'text-blue-500', bgColor: 'bg-blue-500' },
      @@ -27,9 +28,11 @@
         scrollContainerRef,
         journeyPoints,
         onDotClick,
      +  onHoverChange,
      +  showAllTooltips,
       }) => {
         const [isOverflowing, setIsOverflowing] = useState(false);
      -  const [isTrackHovered, setIsTrackHovered] = useState(false);
         const trackRef = useRef<HTMLDivElement>(null);
         const dotsContainerRef = useRef<HTMLDivElement>(null);
         const thumbRef = useRef<HTMLDivElement>(null);
      @@ -211,8 +214,8 @@
           <div
             ref={trackRef}
             className="absolute top-0 right-0 h-full w-8 py-2 z-10 cursor-pointer"
      -      onMouseEnter={() => setIsTrackHovered(true)}
      -      onMouseLeave={() => setIsTrackHovered(false)}
      +      onMouseEnter={() => onHoverChange?.(true)}
      +      onMouseLeave={() => onHoverChange?.(false)}
             onMouseDown={handleTrackClick}
           >
               <TooltipProvider delayDuration={100}>
      @@ -242,7 +245,7 @@
                               key={point.id} 
                               className={cn("flex items-center justify-center", isOverflowing ? "h-8 flex-shrink-0" : "flex-1")}
                             >
      -                          <Tooltip open={isTrackHovered}>
      +                          <Tooltip open={showAllTooltips}>
                                     <TooltipTrigger asChild>
                                       <button
                                           data-dot-id={point.id}

    patchStrategy: standard-diff
  - type: write
    path: src/pages/Messaging/components/TaskDetail.tsx
    content: >+
      --- src/pages/Messaging/components/TaskDetail.tsx

      +++ src/pages/Messaging/components/TaskDetail.tsx

      @@ -1,4 +1,4 @@

      -import React, { useRef, useEffect, useLayoutEffect } from 'react';

      +import React, { useRef, useEffect, useLayoutEffect, useState } from
      'react';
       import { useParams } from 'react-router-dom';
       import { useMessagingStore } from '../store/messaging.store';
       import { ActivityFeed } from './ActivityFeed';
      @@ -8,6 +8,7 @@
       import { TakeoverBanner } from './TakeoverBanner';
       import { useToast } from '@/components/ui/toast';
       import { gsap } from 'gsap';
      +import { cn } from '@/lib/utils';
       import { useAppShellStore } from '@/store/appShell.store';
       import { JourneyScrollbar } from './JourneyScrollbar';
       
      @@ -23,6 +24,7 @@
         const isLocked = !!task?.activeHandlerId && task.activeHandlerId !== currentUserId;
         const inputAreaRef = useRef<HTMLDivElement>(null);
         const isFirstRender = useRef(true);
      +  const [isJourneyHovered, setIsJourneyHovered] = useState(false);
       
         useLayoutEffect(() => {
           // On conversation change, scroll to the bottom of the message list.
      @@ -131,14 +133,21 @@
             <div className="relative flex-1 overflow-hidden">
               <div
                 ref={scrollContainerRef}
      -          className="h-full overflow-y-auto pr-8
      [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none]
      [scrollbar-width:none]"

      +          className={cn(

      +            "h-full overflow-y-auto pr-8 [&::-webkit-scrollbar]:hidden
      [-ms-overflow-style:none] [scrollbar-width:none]",

      +            "transition-all duration-200",

      +            isJourneyHovered && "blur-sm pointer-events-none"

      +          )}
               >
                 <ActivityFeed messages={task.messages} contact={task.contact} />
               </div>
               {journeyPoints.length > 0 && (
                   <JourneyScrollbar
                       scrollContainerRef={scrollContainerRef}
                       journeyPoints={journeyPoints}
                       onDotClick={handleDotClick}
      +                onHoverChange={setIsJourneyHovered}

      +                showAllTooltips={isJourneyHovered}
                   />
               )}
             </div>

    patchStrategy: standard-diff
snapshot:
  src/pages/Messaging/components/JourneyScrollbar.tsx: >-
    import React, { useState, useLayoutEffect, useRef, useCallback } from
    'react';

    import type { Message, JourneyPointType } from '../types';

    import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from
    '@/components/ui/tooltip';

    import { gsap } from 'gsap';

    import { MessageSquare, ShoppingCart, PackageCheck, AlertCircle, RefreshCw,
    MailQuestion, type LucideIcon } from 'lucide-react';

    import { cn } from '@/lib/utils';


    interface JourneyScrollbarProps {
      scrollContainerRef: React.RefObject<HTMLDivElement>;
      journeyPoints: Message[];
      onDotClick: (messageId: string) => void;
    }


    const journeyInfoMap: Record<JourneyPointType, { Icon: LucideIcon;
    textColor: string; bgColor: string; }> = {
      Consult: { Icon: MessageSquare, textColor: 'text-blue-500', bgColor: 'bg-blue-500' },
      Order: { Icon: ShoppingCart, textColor: 'text-green-500', bgColor: 'bg-green-500' },
      Delivered: { Icon: PackageCheck, textColor: 'text-emerald-500', bgColor: 'bg-emerald-500' },
      Complain: { Icon: AlertCircle, textColor: 'text-red-500', bgColor: 'bg-red-500' },
      Reorder: { Icon: RefreshCw, textColor: 'text-indigo-500', bgColor: 'bg-indigo-500' },
      'Follow-up': { Icon: MailQuestion, textColor: 'text-yellow-500', bgColor: 'bg-yellow-500' },
    };


    export const JourneyScrollbar: React.FC<JourneyScrollbarProps> = ({
      scrollContainerRef,
      journeyPoints,
      onDotClick,
    }) => {
      const [isOverflowing, setIsOverflowing] = useState(false);
      const [isTrackHovered, setIsTrackHovered] = useState(false);
      const trackRef = useRef<HTMLDivElement>(null);
      const dotsContainerRef = useRef<HTMLDivElement>(null);
      const thumbRef = useRef<HTMLDivElement>(null);
      const isDraggingRef = useRef(false);
      const dragOffsetY = useRef(0);
      const activeJourneyPointIdRef = useRef<string | null>(null);

      const updateScrollbar = useCallback(() => {
        const container = scrollContainerRef.current;
        if (!container || !trackRef.current || !thumbRef.current) return;

        const { scrollTop, scrollHeight, clientHeight } = container;
        
        if (scrollHeight <= clientHeight) {
          gsap.to(thumbRef.current, { autoAlpha: 0, duration: 0.1 });
          return;
        }

        gsap.to(thumbRef.current, { autoAlpha: 1, duration: 0.1 });

        // Calculate proportional thumb height, but cap it at 10% of the container height
        // to prevent it from looking too long. A minimum of 20px is enforced for usability.
        const thumbHeight = Math.max(20, Math.min((clientHeight / scrollHeight) * clientHeight, clientHeight * 0.1));
        const thumbTop = (scrollTop / (scrollHeight - clientHeight)) * (clientHeight - thumbHeight);
        
        gsap.to(thumbRef.current, {
          height: thumbHeight,
          y: thumbTop,
          duration: 0.1,
          ease: 'power1.out',
        });

        // Active journey point logic
        const viewportCenter = scrollTop + clientHeight / 2;
        let closestPointId: string | null = null;
        let minDistance = Infinity;

        journeyPoints.forEach(point => {
          const element = container.querySelector(`[data-message-id="${point.id}"]`) as HTMLElement;
          if (element) {
            const elementCenter = element.offsetTop + element.offsetHeight / 2;
            const distance = Math.abs(viewportCenter - elementCenter);
            if (distance < minDistance) {
              minDistance = distance;
              closestPointId = point.id;
            }
          }
        });

        if (closestPointId && activeJourneyPointIdRef.current !== closestPointId) {
          if (activeJourneyPointIdRef.current) {
            const oldActiveDot = trackRef.current.querySelector(`[data-dot-id="${activeJourneyPointIdRef.current}"]`);
            gsap.to(oldActiveDot, { scale: 1, opacity: 0.5, duration: 0.2, ease: 'back.out' });
          }
          
          const newActiveDot = trackRef.current.querySelector(`[data-dot-id="${closestPointId}"]`);
          if (newActiveDot) {
            gsap.to(newActiveDot, { scale: 1.75, opacity: 1, duration: 0.2, ease: 'back.out' });       
            if (isOverflowing) {
              (newActiveDot as HTMLElement).scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
          }
          activeJourneyPointIdRef.current = closestPointId;
        }
      }, [scrollContainerRef, journeyPoints, isOverflowing]);

      useLayoutEffect(() => {
        const container = scrollContainerRef.current;
        if (container) {
          const handleScroll = () => {
            if (!isDraggingRef.current) {
              updateScrollbar();
            }
          };
          updateScrollbar();
          container.addEventListener('scroll', handleScroll, { passive: true });
          return () => container.removeEventListener('scroll', handleScroll);
        }
      }, [scrollContainerRef, updateScrollbar]);

      useLayoutEffect(() => {
        const track = trackRef.current;
        if (!track || journeyPoints.length === 0) return;

        const MIN_DOT_SPACING = 32; // Corresponds to h-8 in Tailwind

        const checkOverflow = () => {
          const requiredHeight = journeyPoints.length * MIN_DOT_SPACING;
          const trackHeight = track.clientHeight;
          setIsOverflowing(requiredHeight > trackHeight);
        };
        
        checkOverflow();
        const resizeObserver = new ResizeObserver(() => {
            checkOverflow();
            updateScrollbar();
        });
        resizeObserver.observe(trackRef.current);

        return () => {
          resizeObserver.disconnect();
        };
      }, [journeyPoints.length, updateScrollbar]);

      const handleMouseMove = useCallback((e: MouseEvent) => {
        if (!isDraggingRef.current || !scrollContainerRef.current || !trackRef.current || !thumbRef.current) return;
        
        e.preventDefault();
        const container = scrollContainerRef.current;
        const track = trackRef.current;
        const thumb = thumbRef.current;
        
        const { scrollHeight, clientHeight } = container;
        const scrollableDist = scrollHeight - clientHeight;
        if (scrollableDist <= 0) return;
        
        const trackRect = track.getBoundingClientRect();
        const thumbHeight = thumb.offsetHeight;
        
        const newThumbTop = e.clientY - trackRect.top - dragOffsetY.current;
        const clampedThumbTop = Math.max(0, Math.min(newThumbTop, trackRect.height - thumbHeight));
        
        const scrollRatio = clampedThumbTop / (trackRect.height - thumbHeight);
        
        gsap.to(container, {
          scrollTop: scrollRatio * scrollableDist,
          duration: 0,
          onUpdate: updateScrollbar
        });

      }, [scrollContainerRef, updateScrollbar]);

      const handleMouseUp = useCallback(() => {
        isDraggingRef.current = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('mouseup', handleMouseUp);
      }, [handleMouseMove]);

      const handleMouseDown = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
        e.preventDefault();
        e.stopPropagation();

        if (!scrollContainerRef.current || !thumbRef.current) return;
        
        isDraggingRef.current = true;
        const thumbRect = thumbRef.current.getBoundingClientRect();
        dragOffsetY.current = e.clientY - thumbRect.top;
        
        document.body.style.cursor = 'grabbing';
        document.body.style.userSelect = 'none';

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
      }, [scrollContainerRef, handleMouseMove, handleMouseUp]);
      
      const handleTrackClick = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
         if (e.target === thumbRef.current || (e.target as HTMLElement).closest('[data-dot-id]')) return;

        const container = scrollContainerRef.current;
        const track = trackRef.current;
        if (!container || !track) return;
        
        const { scrollHeight, clientHeight } = container;
        const trackRect = track.getBoundingClientRect();
        const clickY = e.clientY - trackRect.top;
        
        const thumbHeight = Math.max(20, Math.min((clientHeight / scrollHeight) * clientHeight, clientHeight * 0.1));
        const clickRatio = (clickY - thumbHeight / 2) / (trackRect.height - thumbHeight);
        
        gsap.to(container, {
          scrollTop: (scrollHeight - clientHeight) * Math.max(0, Math.min(1, clickRatio)),
          duration: 0.3,
          ease: 'power2.out'
        });
        
      }, [scrollContainerRef]);

      return (
        <div
          ref={trackRef}
          className="absolute top-0 right-0 h-full w-8 py-2 z-10 cursor-pointer"
          onMouseEnter={() => setIsTrackHovered(true)}
          onMouseLeave={() => setIsTrackHovered(false)}
          onMouseDown={handleTrackClick}
        >
            <TooltipProvider delayDuration={100}>
                <div className="relative h-full w-full">
                    {/* Track Line */}
                    <div className="track-line absolute top-0 left-1/2 -translate-x-1/2 h-full w-1 bg-border rounded-full" />

                    {/* Thumb */}
                    <div
                        ref={thumbRef}
                        className="absolute left-1/2 -translate-x-1/2 w-2 bg-muted-foreground hover:bg-muted-foreground/80 rounded-sm cursor-grab active:cursor-grabbing opacity-0"
                        onMouseDown={handleMouseDown}
                    />

                    {/* Journey Dots */}
                    <div
                      ref={dotsContainerRef}
                      className={cn(
                        // This container is click-through so the thumb and track can be interactive.
                        // Individual dots will re-enable pointer events for themselves.
                        "absolute top-0 left-0 w-full h-full pointer-events-none",
                        isOverflowing 
                          ? "overflow-y-auto [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]"
                          : "flex flex-col"
                      )}
                    >
                      {journeyPoints.map((point) => {
                        const journeyInfo = point.journeyPoint ? journeyInfoMap[point.journeyPoint] : null;
                        return (
                          <div 
                            key={point.id} 
                            className={cn("flex items-center justify-center", isOverflowing ? "h-8 flex-shrink-0" : "flex-1")}
                          >
                              <Tooltip open={isTrackHovered}>
                                  <TooltipTrigger asChild>
                                    <button
                                        data-dot-id={point.id}
                                        onClick={(e) => { e.stopPropagation(); onDotClick(point.id); }}
                                        // Dots are on top of the thumb and are clickable.
                                        className={cn("relative z-10 pointer-events-auto w-2.5 h-2.5 opacity-50 rounded-full focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-background transition-all duration-200 hover:scale-125 hover:opacity-100",
                                            journeyInfo ? journeyInfo.bgColor : 'bg-primary'
                                        )}
                                        aria-label={`Jump to message: ${point.text.substring(0, 30)}...`}
                                    />
                                  </TooltipTrigger>
                                  <TooltipContent side="left" className="text-sm p-2 w-auto max-w-xs shadow-xl" sideOffset={8}>
                                    {journeyInfo && <div className="flex items-center gap-2 font-semibold mb-1.5"><journeyInfo.Icon className={cn("w-4 h-4", journeyInfo.textColor)} /><span>{point.journeyPoint}</span></div>}
                                    <p className="line-clamp-3 text-muted-foreground">{point.text}</p>
                                  </TooltipContent>
                              </Tooltip>
                          </div>
                        );
                      })}
                    </div>
                </div>
            </TooltipProvider>
        </div>
      );
    };
  src/pages/Messaging/components/TaskDetail.tsx: >-
    import React, { useRef, useEffect, useLayoutEffect } from 'react';

    import { useParams } from 'react-router-dom';

    import { useMessagingStore } from '../store/messaging.store';

    import { ActivityFeed } from './ActivityFeed';

    import { Button } from '@/components/ui/button';

    import { Textarea } from '@/components/ui/textarea';

    import { Paperclip, SendHorizontal, Smile, StickyNote } from 'lucide-react';

    import { Tabs, TabsContent, TabsList, TabsTrigger } from
    "@/components/ui/tabs";

    import { TakeoverBanner } from './TakeoverBanner';

    import { useToast } from '@/components/ui/toast';

    import { gsap } from 'gsap';

    import { useAppShellStore } from '@/store/appShell.store';

    import { JourneyScrollbar } from './JourneyScrollbar';



    export const TaskDetail: React.FC = () => {
      const { conversationId: taskId } = useParams<{ conversationId: string }>();
      const { show } = useToast();
      const { getTaskById, takeOverTask, requestAndSimulateTakeover } = useMessagingStore();
      const reducedMotion = useAppShellStore(s => s.reducedMotion);
      
      const task = taskId ? getTaskById(taskId) : undefined;

      // In a real app, this would come from the auth store
      const currentUserId = 'user-1'; 

      const scrollContainerRef = useRef<HTMLDivElement>(null);
      const isLocked = !!task?.activeHandlerId && task.activeHandlerId !== currentUserId;
      const inputAreaRef = useRef<HTMLDivElement>(null);
      const isFirstRender = useRef(true);

      useLayoutEffect(() => {
        // On conversation change, scroll to the bottom of the message list.
        // This ensures the user sees the latest message and that the scrollbar
        // component has the correct scrollHeight to calculate its visibility.
        if (scrollContainerRef.current) {
          scrollContainerRef.current.scrollTop = scrollContainerRef.current.scrollHeight;
        }
      }, [taskId]);

      useEffect(() => {
        if (!inputAreaRef.current) return;

        const initialBorderWidth = '1px'; // from 'border-t'
        const initialPadding = '1rem';    // from 'p-4'

        const target = isLocked
          ? {
              y: 20,
              opacity: 0,
              maxHeight: 0,
              paddingTop: 0,
              paddingBottom: 0,
              borderTopWidth: 0,
              pointerEvents: 'none' as const,
            }
          : {
              y: 0,
              opacity: 1,
              maxHeight: 500, // Ample room for the input
              paddingTop: initialPadding,
              paddingBottom: initialPadding,
              borderTopWidth: initialBorderWidth,
              pointerEvents: 'auto' as const,
            };

        if (reducedMotion) {
          gsap.set(inputAreaRef.current, target);
          return;
        }
        
        if (isFirstRender.current) {
          gsap.set(inputAreaRef.current, target);
          isFirstRender.current = false;
        } else {
          gsap.to(inputAreaRef.current, {
            ...target,
            duration: 0.35,
            ease: 'power2.inOut',
          });
        }
      }, [isLocked, reducedMotion]);

      if (!taskId || !task) {
        return (
            <div className="h-full flex flex-col items-center justify-center p-6 bg-background">
                <p className="text-muted-foreground">Select a task to see its details.</p>
            </div>
        );
      }

      const journeyPoints = task.messages.filter(m => m.journeyPoint);

      const handleDotClick = (messageId: string) => {
        const container = scrollContainerRef.current;
        if (!container) return;
        
        const element = container.querySelector(`[data-message-id="${messageId}"]`);
        
        if (element) {
          // Using 'center' to avoid the message being at the very top/bottom of the view
          element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      };

      const handleTakeOver = () => {
        takeOverTask(task.id, currentUserId);
        show({
            variant: 'success',
            title: 'Task Taken Over',
            message: `You are now handling the task from ${task.contact.name}.`
        });
      };

      const handleRequestTakeover = () => {
        requestAndSimulateTakeover(task.id, currentUserId);
        if (task.activeHandler) {
            show({
                variant: 'default',
                title: 'Request Sent',
                message: `A takeover request has been sent to ${task.activeHandler.name}.`
            });
        }
      };

      return (
        <div className="h-full flex flex-col bg-background overflow-hidden">
          {isLocked && task.activeHandler && (
            <TakeoverBanner
                activeHandler={task.activeHandler}
                isRequesting={!!task.takeoverRequested}
                onTakeOver={handleTakeOver}
                onRequestTakeover={handleRequestTakeover}
            />
          )}
          <div className="relative flex-1 overflow-hidden">
            <div
              ref={scrollContainerRef}
              className="h-full overflow-y-auto pr-8 [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]"
            >
              <ActivityFeed messages={task.messages} contact={task.contact} />
            </div>
            {journeyPoints.length > 0 && (
                <JourneyScrollbar
                    scrollContainerRef={scrollContainerRef}
                    journeyPoints={journeyPoints}
                    onDotClick={handleDotClick}
                />
            )}
          </div>

          {/* Input Form */}
          <div ref={inputAreaRef} className="p-4 border-t flex-shrink-0 bg-background/50">
            <Tabs defaultValue="comment" className="w-full" >
              <TabsList className="grid w-full grid-cols-2 mb-2">
                <TabsTrigger value="comment" disabled={isLocked}>Comment</TabsTrigger>
                <TabsTrigger value="note" disabled={isLocked}><StickyNote className="w-4 h-4 mr-2" />Internal Note</TabsTrigger>
              </TabsList>
              <TabsContent value="comment">
                 <div className="relative">
                    <Textarea placeholder={isLocked ? "Take over to reply..." : `Reply to ${task.contact.name}...`} className="pr-24 min-h-[52px]" disabled={isLocked} />
                    <div className="absolute right-2 top-2 flex items-center gap-1">
                        <Button variant="ghost" size="icon" className="rounded-full h-8 w-8" disabled={isLocked}><Smile className="w-4 h-4" /></Button>
                        <Button variant="ghost" size="icon" className="rounded-full h-8 w-8" disabled={isLocked}><Paperclip className="w-4 h-4" /></Button>
                        <Button size="icon" className="rounded-full h-8 w-8" disabled={isLocked}><SendHorizontal className="w-4 h-4" /></Button>
                    </div>
                </div>
              </TabsContent>
              <TabsContent value="note">
                <div className="relative">
                    <Textarea placeholder={isLocked ? "Take over to add a note..." : "Add an internal note..."} className="pr-24 min-h-[52px] bg-yellow-400/10 border-yellow-400/30 focus-visible:ring-yellow-500" disabled={isLocked} />
                    <div className="absolute right-2 top-2 flex items-center gap-1">
                        <Button size="icon" className="rounded-full h-8 w-8" disabled={isLocked}><SendHorizontal className="w-4 h-4" /></Button>
                    </div>
                </div>
              </TabsContent>
            </Tabs>
          </div>
        </div>
      );
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-10-17T11:27:00.634Z'
status: committed
id: 409
