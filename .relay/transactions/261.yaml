uuid: 13ed15ca-e23e-469b-814d-5654c6074211
projectId: jeli-app-shell
createdAt: '2025-10-14T02:01:24.144Z'
gitCommitMsg: >-
  fix(lint): Address all ESLint warnings across multiple components

  This commit resolves various ESLint warnings throughout the codebase to
  improve code quality and maintainability.

  - Disabled `react-refresh/only-export-components` for files that
    intentionally export hooks or helper functions alongside components.
  - Corrected `no-explicit-any` warnings by using safer types or disabling
    the rule where `any` is pragmatically necessary (e.g., generic context,
    dynamic property access).
  - Fixed `react-hooks/exhaustive-deps` warnings by removing unused
    dependencies or disabling the rule for effects that should only run on
    mount.
promptSummary: Fix all ESLint warnings in the provided files.
reasoning:
  - >-
    I will address the ESLint warnings by applying fixes to the respective
    files. The changes include removing unnecessary dependencies from hooks,
    adding `eslint-disable` comments for rules that are pragmatically being
    broken, and fixing `any` types where possible.
  - '### `src/components/layout/AppShell.tsx`'
  - >-
    I'll start by fixing the `react-hooks/exhaustive-deps` warning in
    `AppShell.tsx`. The `bodyState` dependency is not used inside the
    `handleDropRight` callback and can be safely removed.
  - '### `src/components/layout/Sidebar.tsx`'
  - >-
    Next, I'll address the `react-refresh/only-export-components` warning in
    `Sidebar.tsx`. It's common to export a context consumer hook along with the
    provider component. I'll add an `eslint-disable` comment to allow this
    pattern.
  - '### `src/components/layout/WorkspaceSwitcher.tsx`'
  - This file has three `no-explicit-any` warnings.
  - >-
    1.  I'll replace `any` with the safer `unknown` for the index signature in
    the `Workspace` interface.
  - >-
    2.  For the generic `WorkspaceContext`, using `any` is a common pattern to
    avoid complex typing. I'll disable the ESLint rule for this specific line.
  - >-
    3.  I'll remove the unnecessary type assertion `(workspace as any).plan` and
    use direct property access `workspace.plan`.
  - '### `src/components/ui/badge.tsx`'
  - >-
    Similar to the `Sidebar` component, `badge.tsx` exports a non-component
    variable (`badgeVariants`). I'll disable the
    `react-refresh/only-export-components` rule here as well.
  - '### `src/components/ui/button.tsx`'
  - >-
    The `button.tsx` file has the same issue as `badge.tsx`, exporting
    `buttonVariants`. I'll apply the same fix.
  - '### `src/components/ui/toast.tsx`'
  - >-
    The `toast.tsx` file exports the `useToast` hook, triggering the
    `react-refresh` warning. I'll disable the rule.
  - '### `src/context/AppShellContext.tsx`'
  - >-
    The `AppShellContext.tsx` file exports the `useAppShell` hook. I'll disable
    the `react-refresh` warning here too.
  - '### `src/pages/DataDemo/components/DataViewModeSelector.tsx`'
  - >-
    The `useEffect` hook is intentionally set to run only on mount to set an
    initial position. The `react-hooks/exhaustive-deps` warning can be safely
    ignored for this case.
  - '### `src/pages/DataDemo/hooks/useDataManagement.hook.tsx`'
  - >-
    Finally, I'll address the `no-explicit-any` warning in
    `useDataManagement.hook.tsx`. Accessing nested object properties dynamically
    is a tricky case in TypeScript, and using `any` in the `reduce` accumulator
    is a pragmatic solution. I'll disable the ESLint rule for this line.
  - These changes should resolve all the reported ESLint warnings.
operations:
  - type: write
    path: src/components/layout/AppShell.tsx
    content: |+
      --- src/components/layout/AppShell.tsx
      +++ src/components/layout/AppShell.tsx
      @@ -203,7 +203,7 @@
           }
           dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
           dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      -  }, [draggedPage, dispatch, bodyState, activePage, navigate]);
      +  }, [draggedPage, dispatch, activePage, navigate]);
       
         return (
           <div 

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/Sidebar.tsx
    content: |+
      --- src/components/layout/Sidebar.tsx
      +++ src/components/layout/Sidebar.tsx
      @@ -14,6 +14,7 @@
       
       const SidebarContext = React.createContext<SidebarContextValue | null>(null);
       
      +// eslint-disable-next-line react-refresh/only-export-components
       export const useSidebar = () => {
         const context = React.useContext(SidebarContext);
         if (!context) {

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/WorkspaceSwitcher.tsx
    content: "--- src/components/layout/WorkspaceSwitcher.tsx\n+++ src/components/layout/WorkspaceSwitcher.tsx\n@@ -12,7 +12,7 @@\n \tname: string;\n \tlogo?: string;\n \tplan?: string;\n-\t[key: string]: any; // Allow additional properties\n+\t[key: string]: unknown; // Allow additional properties\n }\n \n // Context for workspace state management\n@@ -26,6 +26,7 @@\n \tgetWorkspaceName: (workspace: T) => string;\n }\n \n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n const WorkspaceContext = React.createContext<WorkspaceContextValue<any> | null>(\n \tnull,\n );\n@@ -233,7 +234,7 @@\n \t\t\t\t<span className=\"truncate text-sm\">{getWorkspaceName(workspace)}</span>\n \t\t\t\t{workspace.plan && (\n \t\t\t\t\t<span className=\"text-muted-foreground text-xs\">\n-\t\t\t\t\t\t{(workspace as any).plan}\n+\t\t\t\t\t\t{workspace.plan}\n \t\t\t\t\t</span>\n \t\t\t\t)}\n \t\t\t</div>\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/components/ui/badge.tsx
    content: |+
      --- src/components/ui/badge.tsx
      +++ src/components/ui/badge.tsx
      @@ -34,4 +34,5 @@
         )
       }
       
      +// eslint-disable-next-line react-refresh/only-export-components
       export { Badge, badgeVariants }

    patchStrategy: standard-diff
  - type: write
    path: src/components/ui/button.tsx
    content: |+
      --- src/components/ui/button.tsx
      +++ src/components/ui/button.tsx
      @@ -53,4 +53,5 @@
       )
       Button.displayName = "Button"
       
      +// eslint-disable-next-line react-refresh/only-export-components
       export { Button, buttonVariants }

    patchStrategy: standard-diff
  - type: write
    path: src/components/ui/toast.tsx
    content: |+
      --- src/components/ui/toast.tsx
      +++ src/components/ui/toast.tsx
      @@ -207,6 +207,7 @@
         null,
       );
       
      +// eslint-disable-next-line react-refresh/only-export-components
       export const useToast = () => {
         const context = useContext(ToasterContext);
         if (!context) {

    patchStrategy: standard-diff
  - type: write
    path: src/context/AppShellContext.tsx
    content: |+
      --- src/context/AppShellContext.tsx
      +++ src/context/AppShellContext.tsx
      @@ -211,6 +211,7 @@
       
       // --- Hook ---
       
      +// eslint-disable-next-line react-refresh/only-export-components
       export function useAppShell() {
         const context = useContext(AppShellContext);
         if (!context) {

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/components/DataViewModeSelector.tsx
    content: |+
      --- src/pages/DataDemo/components/DataViewModeSelector.tsx
      +++ src/pages/DataDemo/components/DataViewModeSelector.tsx
      @@ -53,7 +53,8 @@
           const timer = setTimeout(() => {
             updateIndicatorPosition(true)
           }, 0)
           return () => clearTimeout(timer)
      -  }, []) // Only run once on mount
      +    // eslint-disable-next-line react-hooks/exhaustive-deps
      +  }, []) // Only run once on mount
       
         useEffect(() => {
           if (!isTransitioning) {

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/hooks/useDataManagement.hook.tsx
    content: "--- src/pages/DataDemo/hooks/useDataManagement.hook.tsx\n+++ src/pages/DataDemo/hooks/useDataManagement.hook.tsx\n@@ -94,8 +94,9 @@\n \t\tif (sortConfig) {\n \t\t\tfilteredItems.sort((a, b) => {\n \t\t\t\tconst getNestedValue = (obj: DataItem, path: string): unknown => \n-\t\t\t\t\tpath.split('.').reduce((o: any, k) => (o || {})[k], obj);\n-\n+\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+\t\t\t\t\tpath.split('.').reduce((o: any, k) => (o || {})[k], obj);\n+\t\t\t\t\n \t\t\t\tconst aValue = getNestedValue(a, sortConfig.key);\n \t\t\t\tconst bValue = getNestedValue(b, sortConfig.key);\n \n\n"
    patchStrategy: standard-diff
snapshot:
  src/components/layout/AppShell.tsx: >-
    import React, { useRef, type ReactElement, useCallback, useEffect,
    useLayoutEffect } from 'react'

    import { useLocation, useNavigate } from 'react-router-dom';

    import { cn } from '@/lib/utils'

    import { gsap } from 'gsap';

    import { CommandPalette } from '@/components/global/CommandPalette';

    import { useAppStore } from '@/store/appStore'

    import { useAppShell } from '@/context/AppShellContext';

    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'

    import { useResizableSidebar, useResizableRightPane } from
    '@/hooks/useResizablePanes.hook'

    import { useSidebarAnimations, useBodyStateAnimations } from
    '@/hooks/useAppShellAnimations.hook'

    import { ViewModeSwitcher } from './ViewModeSwitcher';


    interface AppShellProps {
      sidebar: ReactElement;
      topBar: ReactElement;
      mainContent: ReactElement;
      rightPane: ReactElement;
      commandPalette?: ReactElement;
      onOverlayClick?: () => void;
    }


    const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
    'notifications' | 'dataDemo'> = {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
      'data-demo': 'dataDemo',
    };


    // Helper hook to get the previous value of a prop or state

    function usePrevious<T>(value: T): T | undefined {
      const ref = useRef<T>();
      useEffect(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }



    export function AppShell({ sidebar, topBar, mainContent, rightPane,
    commandPalette, onOverlayClick }: AppShellProps) {
      const {
        sidebarState,
        dispatch,
        autoExpandSidebar,
        toggleSidebar,
        hoveredPane,
        peekSidebar,
        draggedPage,
        dragHoverTarget,
        bodyState,
        sidePaneContent,
        reducedMotion,
        isTopBarVisible,
      } = useAppShell();
      
      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isSidePaneOpen = bodyState === BODY_STATES.SIDE_PANE;

      const { isDarkMode, toggleDarkMode } = useAppStore();
      const navigate = useNavigate();
      const location = useLocation();
      const activePage = location.pathname.split('/')[1] || 'dashboard';
      const appRef = useRef<HTMLDivElement>(null)
      const sidebarRef = useRef<HTMLDivElement>(null)
      const mainContentRef = useRef<HTMLDivElement>(null)
      const rightPaneRef = useRef<HTMLDivElement>(null)
      const resizeHandleRef = useRef<HTMLDivElement>(null)
      const topBarContainerRef = useRef<HTMLDivElement>(null)
      const mainAreaRef = useRef<HTMLDivElement>(null)

      const prevActivePage = usePrevious(activePage);
      const prevSidePaneContent = usePrevious(sidePaneContent);

      const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;

      // Custom hooks for logic
      useResizableSidebar(sidebarRef, resizeHandleRef);
      useResizableRightPane();
      useSidebarAnimations(sidebarRef, resizeHandleRef);
      useBodyStateAnimations(appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef);
      
      // Animation for pane swapping
      useLayoutEffect(() => {
        if (reducedMotion || bodyState !== BODY_STATES.SPLIT_VIEW || !prevActivePage || !prevSidePaneContent) {
          return;
        }

        const pageForPrevSidePane = Object.keys(pageToPaneMap).find(
          key => pageToPaneMap[key as keyof typeof pageToPaneMap] === prevSidePaneContent
        );

        // Check if a swap occurred by comparing current state with previous state
        if (activePage === pageForPrevSidePane && sidePaneContent === pageToPaneMap[prevActivePage as keyof typeof pageToPaneMap]) {
          const mainEl = mainAreaRef.current;
          const rightEl = rightPaneRef.current;

          if (mainEl && rightEl) {
            const mainWidth = mainEl.offsetWidth;
            const rightWidth = rightEl.offsetWidth;

            const tl = gsap.timeline();
            
            // Animate main content FROM where right pane was TO its new place
            tl.from(mainEl, {
              x: rightWidth, duration: 0.4, ease: 'power3.inOut'
            });

            // Animate right pane FROM where main content was TO its new place
            tl.from(rightEl, {
              x: -mainWidth, duration: 0.4, ease: 'power3.inOut'
            }, 0); // Start at the same time
          }
        }
      }, [activePage, sidePaneContent, bodyState, prevActivePage, prevSidePaneContent, reducedMotion]);
      
      const sidebarWithProps = React.cloneElement(sidebar, { 
        ref: sidebarRef,
        onMouseEnter: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.COLLAPSED) {
            peekSidebar()
          }
        },
        onMouseLeave: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.PEEK) {
            dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
          }
        }
      });

      const topBarWithProps = React.cloneElement(topBar, {
        onToggleSidebar: toggleSidebar,
        onToggleDarkMode: toggleDarkMode,
      });

      const mainContentWithProps = React.cloneElement(mainContent, {
        ref: mainContentRef,
      });

      const rightPaneWithProps = React.cloneElement(rightPane, { ref: rightPaneRef });

      // Drag and drop handlers for docking
      const handleDragOverLeft = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'left') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'left' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropLeft = useCallback(() => {
        if (!draggedPage) return;

        // If we drop the page that's already in the side pane, just make it the main view.
        const paneContentOfDraggedPage = pageToPaneMap[draggedPage];
        if (paneContentOfDraggedPage === sidePaneContent && (bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {
          navigate(`/${draggedPage}`, { replace: true });
        } 
        // New context-aware logic: if we are in normal view and drop a NEW page on the left
        else if (bodyState === BODY_STATES.NORMAL && draggedPage !== activePage) {
            const originalActivePagePaneContent = pageToPaneMap[activePage];
            if (originalActivePagePaneContent) {
                navigate(`/${draggedPage}?view=split&right=${originalActivePagePaneContent}`, { replace: true });
            } else {
                // Fallback for pages that can't be in a pane
                navigate(`/${draggedPage}`, { replace: true });
            }
        } else { // Default behavior: just make the dropped page the main one
          // If in split view, replace the main content and keep the right pane
          if (bodyState === BODY_STATES.SPLIT_VIEW) {
            const rightPane = location.search.split('right=')[1];
            if (rightPane) {
              navigate(`/${draggedPage}?view=split&right=${rightPane}`, { replace: true });
              return;
            }
          }
          navigate(`/${draggedPage}`, { replace: true });
        }
        
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, activePage, bodyState, sidePaneContent, navigate, dispatch, location]);

      const handleDragOverRight = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'right') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'right' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropRight = useCallback(() => {
        if (!draggedPage) return;
        const pane = pageToPaneMap[draggedPage as keyof typeof pageToPaneMap];
        if (pane) {
          let mainPage = activePage;
          // If dropping the currently active page to the right,
          // set a default page (e.g., dashboard) as the new active page.
          if (draggedPage === activePage) {
            mainPage = 'dashboard';
          }

          navigate(`/${mainPage}?view=split&right=${pane}`, { replace: true });
        }
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, dispatch, bodyState, activePage, navigate]);

      return (
        <div 
          ref={appRef}
          className={cn(
            "relative h-screen w-screen overflow-hidden bg-background transition-colors duration-300",
            isDarkMode && "dark"
          )}
        >
          <div className="flex h-screen overflow-hidden">
            {/* Enhanced Sidebar */}
            {sidebarWithProps}

            {/* Resize Handle */}
            {sidebarState !== SIDEBAR_STATES.HIDDEN && (
              <div
                ref={resizeHandleRef}
                className={cn(
                  "absolute top-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
                )}
                onMouseDown={(e) => {
                  e.preventDefault()
                  dispatch({ type: 'SET_IS_RESIZING', payload: true });
                }}
              >
                <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
              </div>
            )}

            {/* Main area wrapper */}
            <div className="flex-1 flex flex-col overflow-hidden relative">
              <div
                ref={topBarContainerRef}
                className={cn(
                  "absolute top-0 left-0 right-0 z-30",
                  isFullscreen && "z-0"
                )}
                onMouseEnter={() => { if (isSplitView) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
              >
                {topBarWithProps}
              </div>

              <div className="flex flex-1 min-h-0">
                <div
                  ref={mainAreaRef}
                  className="relative flex-1 overflow-hidden bg-background"
                  onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'left' }); }}
                  onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                >
                  {/* Side Pane Overlay */}
                  <div
                    role="button"
                    aria-label="Close side pane"
                    tabIndex={isSidePaneOpen ? 0 : -1}
                    className={cn(
                      "absolute inset-0 bg-black/40 z-40 transition-opacity duration-300",
                      isSidePaneOpen
                        ? "opacity-100 pointer-events-auto"
                        : "opacity-0 pointer-events-none"
                    )}
                    onClick={onOverlayClick}
                  />
                  {/* Left drop overlay */}
                  <div
                    className={cn(
                      "absolute inset-y-0 left-0 z-40 border-2 border-transparent transition-all",
                      draggedPage
                        ? cn("pointer-events-auto", isSplitView ? 'w-full' : 'w-1/2')
                        : "pointer-events-none w-0",
                      dragHoverTarget === 'left' && "bg-primary/10 border-primary"
                    )}
                    onDragOver={handleDragOverLeft}
                    onDrop={handleDropLeft}
                    onDragLeave={() => {
                      if (dragHoverTarget === 'left') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                    }}
                  >
                    {draggedPage && dragHoverTarget === 'left' && (
                      <div className="absolute inset-0 flex items-center justify-center text-sm font-medium text-primary-foreground/80 pointer-events-none">
                        <span className="px-3 py-1 rounded-md bg-primary/70">{isSplitView ? 'Drop to Replace' : 'Drop to Left'}</span>
                      </div>
                    )}
                  </div>
                  {mainContentWithProps}
                  {isSplitView && hoveredPane === 'left' && !draggedPage && (
                    <div className={cn("absolute right-4 z-50 transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                      <ViewModeSwitcher pane="main" />
                    </div>
                  )}
                  {/* Right drop overlay (over main area, ONLY when NOT in split view) */}
                  {!isSplitView && (
                    <div
                      className={cn(
                        "absolute inset-y-0 right-0 z-40 border-2 border-transparent",
                        draggedPage ? "pointer-events-auto w-1/2" : "pointer-events-none",
                        dragHoverTarget === 'right' && "bg-primary/10 border-primary"
                      )}
                      onDragOver={handleDragOverRight}
                      onDrop={handleDropRight}
                      onDragLeave={() => {
                        if (dragHoverTarget === 'right') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                      }}
                    >
                      {draggedPage && dragHoverTarget === 'right' && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                          <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">Drop to Right</span>
                        </div>
                      )}
                    </div>
                  )}
                </div>
                {isSplitView ? (
                  <div
                    className="relative"
                    onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'right' }); }}
                    onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                    onDragOver={handleDragOverRight}
                  >
                    {rightPaneWithProps}
                    {draggedPage && (
                      <div
                        className={cn(
                          'absolute inset-0 z-50 transition-all',
                          dragHoverTarget === 'right'
                            ? 'bg-primary/10 border-2 border-primary'
                            : 'pointer-events-none'
                        )}
                        onDragLeave={() => {
                          if (dragHoverTarget === 'right')
                            dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                        }}
                        onDrop={handleDropRight}
                        onDragOver={(e) => e.preventDefault()}
                      >
                        {dragHoverTarget === 'right' && (
                          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">
                              Drop to Replace
                            </span>
                          </div>
                        )}
                      </div>
                    )}
                    {hoveredPane === 'right' && !draggedPage && (
                      <div className={cn("absolute right-4 z-[70] transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                        <ViewModeSwitcher pane="right" />
                      </div>
                    )}
                  </div>
                ) : rightPaneWithProps}
              </div>
            </div>
          </div>
          {commandPalette || <CommandPalette />}
        </div>
      )
    }
  src/components/ui/badge.tsx: |-
    import * as React from "react"
    import { cva, type VariantProps } from "class-variance-authority"

    import { cn } from "@/lib/utils"

    const badgeVariants = cva(
      "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
      {
        variants: {
          variant: {
            default:
              "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
            secondary:
              "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
            destructive:
              "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
            outline: "text-foreground",
          },
        },
        defaultVariants: {
          variant: "default",
        },
      },
    )

    export interface BadgeProps
      extends React.HTMLAttributes<HTMLDivElement>,
        VariantProps<typeof badgeVariants> {}

    function Badge({ className, variant, ...props }: BadgeProps) {
      return (
        <div className={cn(badgeVariants({ variant }), className)} {...props} />
      )
    }

    export { Badge, badgeVariants }
  src/components/layout/WorkspaceSwitcher.tsx: "import * as React from 'react';\nimport { CheckIcon, ChevronsUpDownIcon, Search } from 'lucide-react';\nimport { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar';\nimport { cn } from '@/lib/utils';\nimport {\n\tPopover,\n\tPopoverTrigger,\n\tPopoverContent,\n\ttype PopoverContentProps,\n} from '@/components/ui/popover';\n\n// Generic workspace interface - can be extended\nexport interface Workspace {\n\tid: string;\n\tname: string;\n\tlogo?: string;\n\tplan?: string;\n\t[key: string]: any; // Allow additional properties\n}\n\n// Context for workspace state management\ninterface WorkspaceContextValue<T extends Workspace> {\n\topen: boolean;\n\tsetOpen: (open: boolean) => void;\n\tselectedWorkspace: T | undefined;\n\tworkspaces: T[];\n\tonWorkspaceSelect: (workspace: T) => void;\n\tgetWorkspaceId: (workspace: T) => string;\n\tgetWorkspaceName: (workspace: T) => string;\n}\n\nconst WorkspaceContext = React.createContext<WorkspaceContextValue<any> | null>(\n\tnull,\n);\n\nfunction useWorkspaceContext<T extends Workspace>() {\n\tconst context = React.useContext(\n\t\tWorkspaceContext,\n\t) as WorkspaceContextValue<T> | null;\n\tif (!context) {\n\t\tthrow new Error(\n\t\t\t'Workspace components must be used within WorkspaceProvider',\n\t\t);\n\t}\n\treturn context;\n}\n\n// Main provider component\ninterface WorkspaceProviderProps<T extends Workspace> {\n\tchildren: React.ReactNode;\n\tworkspaces: T[];\n\tselectedWorkspaceId?: string;\n\tonWorkspaceChange?: (workspace: T) => void;\n\topen?: boolean;\n\tonOpenChange?: (open: boolean) => void;\n\tgetWorkspaceId?: (workspace: T) => string;\n\tgetWorkspaceName?: (workspace: T) => string;\n}\n\nfunction WorkspaceProvider<T extends Workspace>({\n\tchildren,\n\tworkspaces,\n\tselectedWorkspaceId,\n\tonWorkspaceChange,\n\topen: controlledOpen,\n\tonOpenChange,\n\tgetWorkspaceId = (workspace) => workspace.id,\n\tgetWorkspaceName = (workspace) => workspace.name,\n}: WorkspaceProviderProps<T>) {\n\tconst [internalOpen, setInternalOpen] = React.useState(false);\n\n\tconst open = controlledOpen ?? internalOpen;\n\tconst setOpen = onOpenChange ?? setInternalOpen;\n\n\tconst selectedWorkspace = React.useMemo(() => {\n\t\tif (!selectedWorkspaceId) return workspaces[0];\n\t\treturn (\n\t\t\tworkspaces.find((ws) => getWorkspaceId(ws) === selectedWorkspaceId) ||\n\t\t\tworkspaces[0]\n\t\t);\n\t}, [workspaces, selectedWorkspaceId, getWorkspaceId]);\n\n\tconst handleWorkspaceSelect = React.useCallback(\n\t\t(workspace: T) => {\n\t\t\tonWorkspaceChange?.(workspace);\n\t\t\tsetOpen(false);\n\t\t},\n\t\t[onWorkspaceChange, setOpen],\n\t);\n\n\tconst value: WorkspaceContextValue<T> = {\n\t\topen,\n\t\tsetOpen,\n\t\tselectedWorkspace,\n\t\tworkspaces,\n\t\tonWorkspaceSelect: handleWorkspaceSelect,\n\t\tgetWorkspaceId,\n\t\tgetWorkspaceName,\n\t};\n\n\treturn (\n\t\t<WorkspaceContext.Provider value={value}>\n\t\t\t<Popover open={open} onOpenChange={setOpen}>\n\t\t\t\t{children}\n\t\t\t</Popover>\n\t\t</WorkspaceContext.Provider>\n\t);\n}\n\n// Trigger component\ninterface WorkspaceTriggerProps extends React.ComponentProps<'button'> {\n\trenderTrigger?: (workspace: Workspace, isOpen: boolean) => React.ReactNode;\n  collapsed?: boolean;\n  avatarClassName?: string;\n}\n\nfunction WorkspaceTrigger({\n\tclassName,\n\trenderTrigger,\n  collapsed = false,\n  avatarClassName,\n\t...props\n}: WorkspaceTriggerProps) {\n\tconst { open, selectedWorkspace, getWorkspaceName } = useWorkspaceContext();\n\n\tif (!selectedWorkspace) return null;\n\n\tif (renderTrigger) {\n\t\treturn (\n\t\t\t<PopoverTrigger asChild>\n\t\t\t\t<button className={className} {...props}>\n\t\t\t\t\t{renderTrigger(selectedWorkspace, open)}\n\t\t\t\t</button>\n\t\t\t</PopoverTrigger>\n\t\t);\n\t}\n\n\treturn (\n\t\t<PopoverTrigger asChild>\n\t\t\t<button\n\t\t\t\tdata-state={open ? 'open' : 'closed'}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'flex w-full items-center justify-between text-sm',\n\t\t\t\t\t'focus:ring-ring focus:ring-2 focus:ring-offset-2 focus:outline-none',\n\t\t\t\t\tclassName,\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t<div className={cn(\"flex items-center gap-3\", collapsed ? \"w-full justify-center\" : \"min-w-0 flex-1\")}>\n\t\t\t\t\t<Avatar className={cn(avatarClassName)}>\n\t\t\t\t\t\t<AvatarImage\n\t\t\t\t\t\t\tsrc={selectedWorkspace.logo}\n\t\t\t\t\t\t\talt={getWorkspaceName(selectedWorkspace)}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<AvatarFallback className=\"text-xs\">\n\t\t\t\t\t\t\t{getWorkspaceName(selectedWorkspace).charAt(0).toUpperCase()}\n\t\t\t\t\t\t</AvatarFallback>\n\t\t\t\t\t</Avatar>\n\t\t\t\t\t{!collapsed && (\n\t\t\t\t\t\t<div className=\"flex min-w-0 flex-1 flex-col items-start\">\n\t\t\t\t\t\t\t<span className=\"truncate font-medium\">{getWorkspaceName(selectedWorkspace)}</span>\n\t\t\t\t\t\t\t<span className=\"text-muted-foreground truncate text-xs\">{selectedWorkspace.plan}</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t{!collapsed && <ChevronsUpDownIcon className=\"h-4 w-4 shrink-0 opacity-50\" />}\n\t\t\t</button>\n\t\t</PopoverTrigger>\n\t);\n}\n\n// Content component\ninterface WorkspaceContentProps\n\textends PopoverContentProps {\n\trenderWorkspace?: (\n\t\tworkspace: Workspace,\n\t\tisSelected: boolean,\n\t) => React.ReactNode;\n\ttitle?: string;\n\tsearchable?: boolean;\n\tonSearch?: (query: string) => void;\n}\n\nfunction WorkspaceContent({\n\tclassName,\n\tchildren,\n\trenderWorkspace,\n\ttitle = 'Workspaces',\n\tsearchable = false,\n\tonSearch,\n\tside = 'right',\n\talign = 'start',\n\tsideOffset = 8,\n\tuseTriggerWidth = false,\n\t...props\n}: WorkspaceContentProps) {\n\tconst {\n\t\tworkspaces,\n\t\tselectedWorkspace,\n\t\tonWorkspaceSelect,\n\t\tgetWorkspaceId,\n\t\tgetWorkspaceName,\n\t} = useWorkspaceContext();\n\n\tconst [searchQuery, setSearchQuery] = React.useState('');\n\n\tconst filteredWorkspaces = React.useMemo(() => {\n\t\tif (!searchQuery) return workspaces;\n\t\treturn workspaces.filter((ws) =>\n\t\t\tgetWorkspaceName(ws).toLowerCase().includes(searchQuery.toLowerCase()),\n\t\t);\n\t}, [workspaces, searchQuery, getWorkspaceName]);\n\n\tReact.useEffect(() => {\n\t\tonSearch?.(searchQuery);\n\t}, [searchQuery, onSearch]);\n\n\tconst defaultRenderWorkspace = (\n\t\tworkspace: Workspace,\n\t\tisSelected: boolean,\n\t) => (\n\t\t<div className=\"flex min-w-0 flex-1 items-center gap-2\">\n\t\t\t<Avatar className=\"h-6 w-6\">\n\t\t\t\t<AvatarImage\n\t\t\t\t\tsrc={workspace.logo}\n\t\t\t\t\talt={getWorkspaceName(workspace)}\n\t\t\t\t/>\n\t\t\t\t<AvatarFallback className=\"text-xs\">\n\t\t\t\t\t{getWorkspaceName(workspace).charAt(0).toUpperCase()}\n\t\t\t\t</AvatarFallback>\n\t\t\t</Avatar>\n\t\t\t<div className=\"flex min-w-0 flex-1 flex-col items-start\">\n\t\t\t\t<span className=\"truncate text-sm\">{getWorkspaceName(workspace)}</span>\n\t\t\t\t{workspace.plan && (\n\t\t\t\t\t<span className=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t{(workspace as any).plan}\n\t\t\t\t\t</span>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t\t{isSelected && <CheckIcon className=\"ml-auto h-4 w-4\" />}\n\t\t</div>\n\t);\n\n\treturn (\n\t\t<PopoverContent\n\t\t\tclassName={cn('p-0', className)}\n\t\t\talign={align}\n\t\t\tsideOffset={sideOffset}\n\t\t\tuseTriggerWidth={useTriggerWidth}\n\t\t\t{...{ ...props, side }}\n\t\t>\n\t\t\t<div className=\"border-b px-4 py-3\">\n\t\t\t\t<h3 className=\"text-sm font-semibold text-foreground\">{title}</h3>\n\t\t\t</div>\n\n\t\t\t{searchable && (\n\t\t\t\t<div className=\"border-b p-2\">\n\t\t\t\t\t<div className=\"relative\">\n\t\t\t\t\t\t<Search className=\"absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground\" />\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\tplaceholder=\"Search workspaces...\"\n\t\t\t\t\t\t\tvalue={searchQuery}\n\t\t\t\t\t\t\tonChange={(e) => setSearchQuery(e.target.value)}\n\t\t\t\t\t\t\tclassName=\"h-9 w-full rounded-md bg-transparent pl-9 text-sm placeholder:text-muted-foreground focus:bg-accent focus:outline-none\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t)}\n\n\t\t\t<div className=\"max-h-[300px] overflow-y-auto\">\n\t\t\t\t{filteredWorkspaces.length === 0 ? (\n\t\t\t\t\t<div className=\"text-muted-foreground px-3 py-2 text-center text-sm\">\n\t\t\t\t\t\tNo workspaces found\n\t\t\t\t\t</div>\n\t\t\t\t) : (\n\t\t\t\t\t<div className=\"space-y-1 p-2\">\n\t\t\t\t\t\t{filteredWorkspaces.map((workspace) => {\n\t\t\t\t\t\t\tconst isSelected =\n\t\t\t\t\t\t\t\tselectedWorkspace &&\n\t\t\t\t\t\t\t\tgetWorkspaceId(selectedWorkspace) === getWorkspaceId(workspace);\n\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tkey={getWorkspaceId(workspace)}\n\t\t\t\t\t\t\t\t\tonClick={() => onWorkspaceSelect(workspace)}\n\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t'flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-left text-sm',\n\t\t\t\t\t\t\t\t\t\t'hover:bg-accent hover:text-accent-foreground',\n\t\t\t\t\t\t\t\t\t\t'focus:outline-none',\n\t\t\t\t\t\t\t\t\t\tisSelected && 'bg-accent text-accent-foreground',\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{renderWorkspace\n\t\t\t\t\t\t\t\t\t\t? renderWorkspace(workspace, !!isSelected)\n\t\t\t\t\t\t\t\t\t\t: defaultRenderWorkspace(workspace, !!isSelected)}\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</div>\n\n\t\t\t{children && (\n\t\t\t\t<>\n\t\t\t\t\t<div className=\"border-t\" />\n\t\t\t\t\t<div className=\"p-1\">{children}</div>\n\t\t\t\t</>\n\t\t\t)}\n\t\t</PopoverContent>\n\t);\n}\n\nexport { WorkspaceProvider as Workspaces, WorkspaceTrigger, WorkspaceContent };"
  src/components/ui/button.tsx: |-
    import * as React from "react"
    import { Slot } from "@radix-ui/react-slot"
    import { cva, type VariantProps } from "class-variance-authority"

    import { cn } from "@/lib/utils"

    const buttonVariants = cva(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      {
        variants: {
          variant: {
            default: "bg-primary text-primary-foreground hover:bg-primary/90",
            destructive:
              "bg-destructive text-destructive-foreground hover:bg-destructive/90",
            outline:
              "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
            secondary:
              "bg-secondary text-secondary-foreground hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline",
          },
          size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-11 rounded-md px-8",
            icon: "h-10 w-10",
          },
        },
        defaultVariants: {
          variant: "default",
          size: "default",
        },
      }
    )

    export interface ButtonProps
      extends React.ButtonHTMLAttributes<HTMLButtonElement>,
        VariantProps<typeof buttonVariants> {
      asChild?: boolean
    }

    const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
      ({ className, variant, size, asChild = false, ...props }, ref) => {
        const Comp = asChild ? Slot : "button"
        return (
          <Comp
            className={cn(buttonVariants({ variant, size, className }))}
            ref={ref}
            {...props}
          />
        )
      }
    )
    Button.displayName = "Button"

    export { Button, buttonVariants }
  src/components/layout/Sidebar.tsx: >-
    import * as React from 'react';

    import { ChevronDown } from 'lucide-react';

    import { Slot } from '@radix-ui/react-slot';

    import { useAppShell } from '@/context/AppShellContext';

    import { SIDEBAR_STATES } from '@/lib/utils';

    import { cn } from '@/lib/utils';

    import { Button } from '@/components/ui/button';


    // --- Context ---

    interface SidebarContextValue {
      isCollapsed: boolean;
      isPeek: boolean;
      compactMode: boolean;
    }


    const SidebarContext = React.createContext<SidebarContextValue |
    null>(null);


    export const useSidebar = () => {
      const context = React.useContext(SidebarContext);
      if (!context) {
        throw new Error('useSidebar must be used within a Sidebar component');
      }
      return context;
    };


    // --- Main Sidebar Component ---

    interface SidebarProps extends React.HTMLAttributes<HTMLDivElement> {
      children: React.ReactNode;
    }


    const Sidebar = React.forwardRef<HTMLDivElement, SidebarProps>(
      ({ children, className, ...props }, ref) => {
        const { sidebarState, compactMode } = useAppShell();
        const isCollapsed = sidebarState === SIDEBAR_STATES.COLLAPSED;
        const isPeek = sidebarState === SIDEBAR_STATES.PEEK;

        return (
          <SidebarContext.Provider value={{ isCollapsed, isPeek, compactMode }}>
            <div
              ref={ref}
              className={cn(
                'relative bg-card flex-shrink-0',
                'h-full',
                isPeek && 'shadow-xl z-40',
                compactMode && 'text-sm',
                className,
              )}
              {...props}
            >
              {isPeek && <div className="absolute inset-0 bg-background/80 backdrop-blur-sm" />}
              {children}
            </div>
          </SidebarContext.Provider>
        );
      },
    );

    Sidebar.displayName = 'Sidebar';


    // --- Sidebar Content Wrapper ---

    const SidebarContent = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => {
      const { compactMode } = useSidebar();
      return (
        <div
          ref={ref}
          className={cn(
            'relative z-10 h-full flex flex-col',
            compactMode ? 'p-3' : 'p-4',
            className,
          )}
          {...props}
        />
      );
    });

    SidebarContent.displayName = 'SidebarContent';


    // --- Sidebar Header ---

    const SidebarHeader = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      return (
        <div
          ref={ref}
          className={cn(
            'flex items-center gap-3',
            isCollapsed ? 'justify-center' : 'px-3',
            'h-16',
            className,
          )}
          {...props}
        />
      );
    });

    SidebarHeader.displayName = 'SidebarHeader';


    const SidebarTitle = React.forwardRef<
      HTMLParagraphElement,
      React.HTMLAttributes<HTMLParagraphElement>
    >(({ className, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      if (isCollapsed) return null;
      return (
        <h1
          ref={ref}
          className={cn('text-lg font-bold nav-label', className)}
          {...props}
        />
      );
    });

    SidebarTitle.displayName = 'SidebarTitle';


    // --- Sidebar Body ---

    const SidebarBody = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => (
      <div
        ref={ref}
        className={cn(
          'flex-1 overflow-y-auto space-y-6 pt-4',
          className,
        )}
        {...props}
      />
    ));

    SidebarBody.displayName = 'SidebarBody';


    // --- Sidebar Footer ---

    const SidebarFooter = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => {
      const { compactMode } = useSidebar();
      return (
        <div
          ref={ref}
          className={cn('pt-4 border-t border-border', compactMode && 'pt-3', className)}
          {...props}
        />
      );
    });

    SidebarFooter.displayName = 'SidebarFooter';


    // --- Sidebar Section ---

    const SidebarSection = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement> & {
        title?: string;
        collapsible?: boolean;
        defaultExpanded?: boolean;
      }
    >(({ title, collapsible = false, defaultExpanded = true, children, ...props
    }, ref) => {
      const { isCollapsed } = useSidebar();
      const [isExpanded, setIsExpanded] = React.useState(defaultExpanded);

      const handleToggle = () => {
        if (collapsible) {
          setIsExpanded(!isExpanded);
        }
      };

      return (
        <div ref={ref} className="space-y-1" {...props}>
          {!isCollapsed && title && (
            <div
              className={cn(
                'flex items-center justify-between px-3 text-xs font-medium text-muted-foreground uppercase tracking-wider',
                collapsible && 'cursor-pointer hover:text-foreground transition-colors',
              )}
              onClick={handleToggle}
            >
              <span className="section-title">{title}</span>
              {collapsible && (
                <ChevronDown
                  className={cn(
                    'section-chevron w-3 h-3 transition-transform',
                    isExpanded ? 'rotate-0' : '-rotate-90',
                  )}
                />
              )}
            </div>
          )}
          {(!collapsible || isExpanded || isCollapsed) && (
            <nav className="space-y-1">{children}</nav>
          )}
        </div>
      );
    });

    SidebarSection.displayName = 'SidebarSection';


    // --- Sidebar Menu Item ---

    const SidebarMenuItem = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => {
      return <div ref={ref} className={cn('group/item relative flex items-stretch', className)} {...props} />;
    });

    SidebarMenuItem.displayName = 'SidebarMenuItem';



    // --- Sidebar Menu Button ---

    interface SidebarMenuButtonProps extends
    React.ButtonHTMLAttributes<HTMLButtonElement> {
      asChild?: boolean;
      isActive?: boolean;
    }

    const SidebarMenuButton = React.forwardRef<HTMLButtonElement,
    SidebarMenuButtonProps>(
      ({ className, asChild = false, isActive, ...props }, ref) => {
        const { isCollapsed, compactMode } = useSidebar();
        const Comp = asChild ? Slot : 'button';

        return (
          <Comp
            ref={ref}
            className={cn(
              'group flex items-center gap-3 rounded-lg cursor-pointer transition-all duration-200 w-full text-left flex-1',
              compactMode ? 'px-2 py-1.5' : 'px-4 py-2.5',
              'hover:bg-accent',
              isActive && 'bg-primary text-primary-foreground hover:bg-primary/90',
              isCollapsed && 'justify-center',
              className
            )}
            {...props}
          />
        );
      }
    );

    SidebarMenuButton.displayName = 'SidebarMenuButton';


    // --- Sidebar Menu Action ---

    const SidebarMenuAction = React.forwardRef<
      HTMLButtonElement,
      React.ButtonHTMLAttributes<HTMLButtonElement>
    >(({ className, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      if (isCollapsed) return null;
      return (
        <Button
          ref={ref}
          variant="ghost"
          size="icon"
          className={cn(
            'absolute right-1 top-1/2 -translate-y-1/2 h-8 w-8 rounded-md opacity-0 group-hover/item:opacity-100 transition-opacity',
            'focus:opacity-100', // show on focus for accessibility
            className
          )}
          {...props}
        />
      );
    });

    SidebarMenuAction.displayName = 'SidebarMenuAction';


    // --- Sidebar Menu Label ---

    const SidebarLabel = React.forwardRef<
      HTMLSpanElement,
      React.HTMLAttributes<HTMLSpanElement>
    >(({ className, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      if (isCollapsed) return null;
      return (
        <span
          ref={ref}
          className={cn('nav-label flex-1 font-medium truncate', className)}
          {...props}
        />
      );
    });

    SidebarLabel.displayName = 'SidebarLabel';



    // --- Sidebar Menu Badge ---

    const SidebarBadge = React.forwardRef<
      HTMLSpanElement,
      React.HTMLAttributes<HTMLSpanElement>
    >(({ className, children, ...props }, ref) => {
      const { isCollapsed } = useSidebar();
      if (isCollapsed) return null;
      const badgeContent = typeof children === 'number' && children > 99 ? '99+' : children;
      return (
        <span
          ref={ref}
          className={cn(
            'nav-badge bg-destructive text-destructive-foreground text-xs px-1.5 py-0.5 rounded-full min-w-[1.25rem] text-center',
            className
          )}
          {...props}
        >
          {badgeContent}
        </span>
      );
    });

    SidebarBadge.displayName = 'SidebarBadge';



    // --- Sidebar Tooltip ---

    interface SidebarTooltipProps extends React.HTMLAttributes<HTMLDivElement> {
      label: string;
      badge?: number | string;
    }

    const SidebarTooltip = ({ label, badge, className, ...props }:
    SidebarTooltipProps) => {
      const { isCollapsed } = useSidebar();
      if (!isCollapsed) return null;
      return (
        <div
          className={cn(
            'absolute left-full ml-2 px-2 py-1 bg-popover text-popover-foreground text-sm rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-50',
            className
          )}
          {...props}
        >
          {label}
          {badge && (
            <span className="ml-2 bg-destructive text-destructive-foreground text-xs px-1.5 py-0.5 rounded-full">
              {typeof badge === 'number' && badge > 99 ? '99+' : badge}
            </span>
          )}
        </div>
      );
    };

    SidebarTooltip.displayName = 'SidebarTooltip';



    // --- Icon Wrapper for consistent sizing ---

    const SidebarIcon = ({ children, className }: { children: React.ReactNode,
    className?: string }) => {
      return (
        <div className={cn("flex-shrink-0 w-4 h-4", className)}>
          {children}
        </div>
      )
    }


    export {
      Sidebar,
      SidebarContent,
      SidebarHeader,
      SidebarTitle,
      SidebarBody,
      SidebarFooter,
      SidebarSection,
      SidebarMenuItem,
      SidebarMenuButton,
      SidebarMenuAction,
      SidebarLabel,
      SidebarBadge,
      SidebarTooltip,
      SidebarIcon
    };
  src/components/ui/toast.tsx: >
    import {
      forwardRef,
      useImperativeHandle,
      createContext,
      useContext,
      useCallback,
      useRef,
      type ReactNode,
    } from "react";

    import { Toaster as SonnerToaster, toast as sonnerToast } from "sonner";

    import { CheckCircle, AlertCircle, Info, AlertTriangle, X } from
    "lucide-react";


    import { Button } from "@/components/ui/button";

    import { cn } from "@/lib/utils";


    type Variant = "default" | "success" | "error" | "warning";

    type Position =
      | "top-left"
      | "top-center"
      | "top-right"
      | "bottom-left"
      | "bottom-center"
      | "bottom-right";

    interface ActionButton {
      label: string;
      onClick: () => void;
      variant?: "default" | "outline" | "ghost";
    }


    export interface ToasterProps {
      title?: string;
      message: string;
      variant?: Variant;
      duration?: number;
      position?: Position;
      actions?: ActionButton;
      onDismiss?: () => void;
      highlightTitle?: boolean;
    }


    export interface ToasterRef {
      show: (props: ToasterProps) => void;
    }


    const variantStyles: Record<Variant, string> = {
      default: "border-border",
      success: "border-green-600/50",
      error: "border-destructive/50",
      warning: "border-amber-600/50",
    };


    const titleColor: Record<Variant, string> = {
      default: "text-foreground",
      success: "text-green-600 dark:text-green-400",
      error: "text-destructive",
      warning: "text-amber-600 dark:text-amber-400",
    };


    const iconColor: Record<Variant, string> = {
      default: "text-muted-foreground",
      success: "text-green-600 dark:text-green-400",
      error: "text-destructive",
      warning: "text-amber-600 dark:text-amber-400",
    };


    const variantIcons: Record<
      Variant,
      React.ComponentType<{ className?: string }>
    > = {
      default: Info,
      success: CheckCircle,
      error: AlertCircle,
      warning: AlertTriangle,
    };


    const CustomToast = ({
      toastId,
      title,
      message,
      variant = "default",
      actions,
      highlightTitle,
    }: Omit<ToasterProps, "duration" | "position" | "onDismiss"> & {
      toastId: number | string;
    }) => {
      const Icon = variantIcons[variant];

      const handleDismiss = () => {
        sonnerToast.dismiss(toastId);
      };

      return (
        <div
          className={cn(
            "flex items-center justify-between w-full max-w-sm p-4 rounded-lg border shadow-xl bg-popover text-popover-foreground",
            variantStyles[variant],
          )}
        >
          <div className="flex items-start gap-3">
            <Icon
              className={cn("h-5 w-5 mt-0.5 flex-shrink-0", iconColor[variant])}
            />
            <div className="space-y-1">
              {title && (
                <h3
                  className={cn(
                    "text-sm font-semibold leading-none",
                    titleColor[variant],
                    highlightTitle && titleColor["success"],
                  )}
                >
                  {title}
                </h3>
              )}
              <p className="text-sm text-muted-foreground">{message}</p>
            </div>
          </div>

          <div className="flex items-center gap-2">
            {actions?.label && (
              <Button
                variant={actions.variant || "outline"}
                size="sm"
                onClick={() => {
                  actions.onClick();
                  handleDismiss();
                }}
                className={cn(
                  "h-8 px-3 text-xs cursor-pointer",
                  variant === "success"
                    ? "text-green-600 border-green-600 hover:bg-green-600/10 dark:hover:bg-green-400/20"
                    : variant === "error"
                      ? "text-destructive border-destructive hover:bg-destructive/10 dark:hover:bg-destructive/20"
                      : variant === "warning"
                        ? "text-amber-600 border-amber-600 hover:bg-amber-600/10 dark:hover:bg-amber-400/20"
                        : "text-foreground border-border hover:bg-muted/10 dark:hover:bg-muted/20",
                )}
              >
                {actions.label}
              </Button>
            )}
            <button
              onClick={handleDismiss}
              className="rounded-md p-1 hover:bg-muted/50 dark:hover:bg-muted/30 transition-colors focus:outline-none focus:ring-2 focus:ring-ring"
              aria-label="Dismiss notification"
            >
              <X className="h-4 w-4 text-muted-foreground" />
            </button>
          </div>
        </div>
      );
    };


    const Toaster = forwardRef<ToasterRef, { defaultPosition?: Position }>(
      ({ defaultPosition = "bottom-right" }, ref) => {
        useImperativeHandle(ref, () => ({
          show({
            title,
            message,
            variant = "default",
            duration = 4000,
            position = defaultPosition,
            actions,
            onDismiss,
            highlightTitle,
          }) {
            sonnerToast.custom(
              (toastId) => (
                <CustomToast
                  toastId={toastId}
                  title={title}
                  message={message}
                  variant={variant}
                  actions={actions}
                  highlightTitle={highlightTitle}
                />
              ),
              {
                duration,
                position,
                onDismiss,
              },
            );
          },
        }));

        return (
          <SonnerToaster
            position={defaultPosition}
            toastOptions={{
              // By removing `unstyled`, sonner handles positioning and animations.
              // We then use `classNames` to override only the styles we don't want,
              // allowing our custom component to define the appearance.
              classNames: {
                toast: "p-0 border-none shadow-none bg-transparent", // Neutralize wrapper styles
                // We can add specific styling to other parts if needed
                // closeButton: '...',
              },
            }}
            // The z-index is still useful as a safeguard
            className="z-[2147483647]"
          />
        );
      },
    );

    Toaster.displayName = "Toaster";


    const ToasterContext = createContext<((props: ToasterProps) => void) |
    null>(
      null,
    );


    export const useToast = () => {
      const context = useContext(ToasterContext);
      if (!context) {
        throw new Error("useToast must be used within a ToasterProvider");
      }
      return { show: context };
    };


    export const ToasterProvider = ({ children }: { children: ReactNode }) => {
      const toasterRef = useRef<ToasterRef>(null);

      const showToast = useCallback((props: ToasterProps) => {
        toasterRef.current?.show(props);
      }, []);

      return (
        <ToasterContext.Provider value={showToast}>
          {children}
          <Toaster ref={toasterRef} />
        </ToasterContext.Provider>
      );
    };
  src/pages/DataDemo/hooks/useDataManagement.hook.tsx: "import { useState, useRef, useEffect, useCallback, useMemo, ReactNode } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport { capitalize, cn } from '@/lib/utils';\nimport { Badge } from '@/components/ui/badge';\nimport { mockDataItems } from '../data/mockData';\nimport type { DataItem, ViewMode, SortConfig, SortableField, GroupableField, Status, Priority } from '../types';\nimport type { FilterConfig } from '../components/DataToolbar';\n\nexport function useDataManagement() {\n\tconst [searchParams, setSearchParams] = useSearchParams();\n\n\t// Derive state from URL search params\n\tconst viewMode = useMemo(() => (searchParams.get('view') as ViewMode) || 'list', [searchParams]);\n\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField | 'none') || 'none', [searchParams]);\n\tconst activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n\n\tconst filters = useMemo<FilterConfig>(\n\t\t() => ({\n\t\t\tsearchTerm: searchParams.get('q') || '',\n\t\t\tstatus: (searchParams.get('status')?.split(',') || []).filter(Boolean) as Status[],\n\t\t\tpriority: (searchParams.get('priority')?.split(',') || []).filter(Boolean) as Priority[],\n\t\t}),\n\t\t[searchParams],\n\t);\n\n\tconst sortConfig = useMemo<SortConfig | null>(() => {\n\t\tconst sortParam = searchParams.get('sort');\n\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n\t\tif (sortParam === 'default') return null;\n\n\t\tconst [key, direction] = sortParam.split('-');\n\t\treturn { key: key as SortableField, direction: direction as 'asc' | 'desc' };\n\t}, [searchParams]);\n\n\t// Centralized handler for updating URL search params\n\tconst handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | string[] | null | undefined>) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\tlet pageReset = false;\n\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tconst isFilterOrSort = ['q', 'status', 'priority', 'sort', 'groupBy'].includes(key);\n\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isFilterOrSort) {\n\t\t\t\t\t\t\tpageReset = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pageReset) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n\tconst [items, setItems] = useState<DataItem[]>([]);\n\tconst [hasMore, setHasMore] = useState(true);\n\tconst [isLoading, setIsLoading] = useState(true);\n\tconst observer = useRef<IntersectionObserver>();\n\n\t// Centralized data filtering and sorting from the master list\n\tconst filteredAndSortedData = useMemo(() => {\n\t\tconst filteredItems = mockDataItems.filter((item) => {\n\t\t\tconst searchTermMatch =\n\t\t\t\titem.title.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||\n\t\t\t\titem.description.toLowerCase().includes(filters.searchTerm.toLowerCase());\n\n\t\t\tconst statusMatch = filters.status.length === 0 || filters.status.includes(item.status);\n\t\t\tconst priorityMatch = filters.priority.length === 0 || filters.priority.includes(item.priority);\n\n\t\t\treturn searchTermMatch && statusMatch && priorityMatch;\n\t\t});\n\n\t\tif (sortConfig) {\n\t\t\tfilteredItems.sort((a, b) => {\n\t\t\t\tconst getNestedValue = (obj: DataItem, path: string): unknown => \n\t\t\t\t\tpath.split('.').reduce((o: any, k) => (o || {})[k], obj);\n\n\t\t\t\tconst aValue = getNestedValue(a, sortConfig.key);\n\t\t\t\tconst bValue = getNestedValue(b, sortConfig.key);\n\n\t\t\t\tif (aValue === undefined || bValue === undefined) return 0;\n\n\t\t\t\tif (typeof aValue === 'string' && typeof bValue === 'string') {\n\t\t\t\t\treturn sortConfig.direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);\n\t\t\t\t}\n\t\t\t\tif (typeof aValue === 'number' && typeof bValue === 'number') {\n\t\t\t\t\treturn sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue;\n\t\t\t\t}\n\t\t\t\t// Date sorting (assuming ISO strings)\n\t\t\t\tif (sortConfig.key === 'updatedAt' || sortConfig.key === 'createdAt') {\n\t\t\t\t\treturn sortConfig.direction === 'asc'\n\t\t\t\t\t\t? new Date(aValue).getTime() - new Date(bValue).getTime()\n\t\t\t\t\t\t: new Date(bValue).getTime() - new Date(aValue).getTime();\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t}\n\n\t\treturn filteredItems;\n\t}, [filters, sortConfig]);\n\n\t// Data loading effect\n\tuseEffect(() => {\n\t\tsetIsLoading(true);\n\t\tconst isFirstPage = page === 1;\n\n\t\tconst loadData = () => {\n\t\t\tif (groupBy !== 'none') {\n\t\t\t\t// For grouped views, load all data at once, pagination is disabled.\n\t\t\t\tsetItems(filteredAndSortedData);\n\t\t\t\tsetHasMore(false);\n\t\t\t\tsetIsLoading(false);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle paginated view\n\t\t\tconst pageSize = 12;\n\t\t\tconst newItems = filteredAndSortedData.slice((page - 1) * pageSize, page * pageSize);\n\n\t\t\tsetTimeout(() => {\n\t\t\t\t// Double-check in case groupBy changed during the timeout\n\t\t\t\tif (groupBy === 'none') {\n\t\t\t\t\tsetItems((prev) => (isFirstPage ? newItems : [...prev, ...newItems]));\n\t\t\t\t\tsetHasMore(filteredAndSortedData.length > page * pageSize);\n\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t}\n\t\t\t}, isFirstPage && items.length === 0 ? 1500 : 500); // Longer delay for initial skeleton\n\t\t};\n\n\t\tloadData();\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [searchParams, filteredAndSortedData]); // Reacts to any URL change\n\n\tconst loaderRef = useCallback(\n\t\t(node: Element | null) => {\n\t\t\tif (isLoading) return;\n\t\t\tif (observer.current) observer.current.disconnect();\n\n\t\t\tobserver.current = new IntersectionObserver((entries) => {\n\t\t\t\tif (entries[0].isIntersecting && hasMore) {\n\t\t\t\t\t// Instead of setting local state, we update the URL, which triggers the data loading effect.\n\t\t\t\t\thandleParamsChange({ page: (page + 1).toString() });\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (node) observer.current.observe(node);\n\t\t},\n\t\t[isLoading, hasMore, page, handleParamsChange],\n\t);\n\n\tconst groupTabs = useMemo(() => {\n\t\tif (groupBy === 'none' || !filteredAndSortedData.length) return [];\n\n\t\tconst groupCounts = filteredAndSortedData.reduce((acc, item) => {\n\t\t\tconst groupKey = String(item[groupBy as GroupableField]);\n\t\t\tacc[groupKey] = (acc[groupKey] || 0) + 1;\n\t\t\treturn acc;\n\t\t}, {} as Record<string, number>);\n\n\t\tconst sortedGroups = Object.keys(groupCounts).sort((a, b) => a.localeCompare(b));\n\n\t\tconst createLabel = (text: string, count: number, isActive: boolean): ReactNode => (\n\t\t\t<>\n\t\t\t\t{text}\n\t\t\t\t<Badge\n\t\t\t\t\tvariant={isActive ? 'default' : 'secondary'}\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t'transition-colors duration-300 text-xs font-semibold',\n\t\t\t\t\t\t!isActive && 'group-hover:bg-accent group-hover:text-accent-foreground',\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t{count}\n\t\t\t\t</Badge>\n\t\t\t</>\n\t\t);\n\n\t\treturn [\n\t\t\t{ id: 'all', label: createLabel('All', filteredAndSortedData.length, activeGroupTab === 'all') },\n\t\t\t...sortedGroups.map((g) => ({\n\t\t\t\tid: g,\n\t\t\t\tlabel: createLabel(capitalize(g), groupCounts[g], activeGroupTab === g),\n\t\t\t})),\n\t\t];\n\t}, [filteredAndSortedData, groupBy, activeGroupTab]);\n\n\t// Data to be rendered in the current view, after grouping and tab selection is applied\n\tconst dataToRender = useMemo(() => {\n\t\tif (groupBy === 'none') {\n\t\t\treturn items; // This is the paginated list.\n\t\t}\n\n\t\t// When grouped, `items` contains ALL filtered/sorted data.\n\t\tif (activeGroupTab === 'all') {\n\t\t\treturn items;\n\t\t}\n\t\treturn items.filter((item) => String(item[groupBy as GroupableField]) === activeGroupTab);\n\t}, [items, groupBy, activeGroupTab]);\n\n\tconst totalItemCount = filteredAndSortedData.length;\n\tconst isInitialLoading = isLoading && items.length === 0;\n\n  const setViewMode = (mode: ViewMode) => handleParamsChange({ view: mode });\n  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val });\n  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n  const setFilters = (newFilters: FilterConfig) => {\n    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority });\n  }\n  const setSort = (config: SortConfig | null) => {\n    if (!config) {\n      handleParamsChange({ sort: 'default' });\n    } else {\n      handleParamsChange({ sort: `${config.key}-${config.direction}` });\n    }\n  }\n  const setTableSort = (field: SortableField) => {\n    if (sortConfig?.key === field) {\n      if (sortConfig.direction === 'desc') {\n        // Cycle: desc -> asc\n        handleParamsChange({ sort: `${field}-asc` });\n      } else {\n        // Cycle: asc -> default (by removing param)\n        handleParamsChange({ sort: 'default' });\n      }\n    } else {\n      // New field, default to desc\n      handleParamsChange({ sort: `${field}-desc` });\n    }\n  }\n\n\treturn {\n\t\tviewMode,\n\t\tgroupBy,\n\t\tactiveGroupTab,\n\t\tfilters,\n\t\tsortConfig,\n\t\thasMore,\n\t\tisLoading,\n\t\tloaderRef,\n\t\tgroupTabs,\n\t\tdataToRender,\n\t\ttotalItemCount,\n\t\tisInitialLoading,\n    setViewMode,\n    setGroupBy,\n    setActiveGroupTab,\n    setFilters,\n    setSort,\n    setTableSort\n\t};\n}"
  src/context/AppShellContext.tsx: >-
    import {
      createContext,
      useContext,
      useReducer,
      useEffect,
      useMemo,
      useCallback,
      type ReactNode,
      type ReactElement,
      type Dispatch,
    } from 'react';

    import { SIDEBAR_STATES, BODY_STATES, type SidebarState, type BodyState }
    from '@/lib/utils';


    // --- State and Action Types ---


    export interface AppShellState {
      sidebarState: SidebarState;
      bodyState: BodyState;
      sidePaneContent: 'details' | 'settings' | 'main' | 'toaster' | 'notifications' | 'dataDemo' | 'dataItem';
      sidebarWidth: number;
      sidePaneWidth: number;
      splitPaneWidth: number;
      previousBodyState: BodyState;
      fullscreenTarget: 'main' | 'right' | null;
      isResizing: boolean;
      isResizingRightPane: boolean;
      isTopBarVisible: boolean;
      autoExpandSidebar: boolean;
      reducedMotion: boolean;
      compactMode: boolean;
      primaryColor: string;
      appName?: string;
      appLogo?: ReactElement;
     draggedPage: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | null;
     dragHoverTarget: 'left' | 'right' | null;
     hoveredPane: 'left' | 'right' | null;
    }


    type AppShellAction =
      | { type: 'SET_SIDEBAR_STATE'; payload: SidebarState }
      | { type: 'SET_BODY_STATE'; payload: BodyState }
      | { type: 'SET_SIDE_PANE_CONTENT'; payload: AppShellState['sidePaneContent'] }
      | { type: 'SET_SIDEBAR_WIDTH'; payload: number }
      | { type: 'SET_SIDE_PANE_WIDTH'; payload: number }
      | { type: 'SET_SPLIT_PANE_WIDTH'; payload: number }
      | { type: 'SET_IS_RESIZING'; payload: boolean }
      | { type: 'SET_PREVIOUS_BODY_STATE'; payload: BodyState }
      | { type: 'SET_FULLSCREEN_TARGET'; payload: 'main' | 'right' | null }
      | { type: 'SET_IS_RESIZING_RIGHT_PANE'; payload: boolean }
      | { type: 'SET_TOP_BAR_VISIBLE'; payload: boolean }
      | { type: 'SET_AUTO_EXPAND_SIDEBAR'; payload: boolean }
      | { type: 'SET_REDUCED_MOTION'; payload: boolean }
      | { type: 'SET_COMPACT_MODE'; payload: boolean }
      | { type: 'SET_PRIMARY_COLOR'; payload: string }
      | { type: 'SET_DRAGGED_PAGE'; payload: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | null }
      | { type: 'SET_DRAG_HOVER_TARGET'; payload: 'left' | 'right' | null }
      | { type: 'SET_HOVERED_PANE'; payload: 'left' | 'right' | null }
      | { type: 'RESET_TO_DEFAULTS' };

    // --- Reducer ---


    const defaultState: AppShellState = {
      sidebarState: SIDEBAR_STATES.EXPANDED,
      bodyState: BODY_STATES.NORMAL,
      sidePaneContent: 'details',
      sidebarWidth: 280,
      sidePaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.6)) : 400,
      splitPaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.35)) : 400,
      previousBodyState: BODY_STATES.NORMAL,
      fullscreenTarget: null,
      isResizing: false,
      isResizingRightPane: false,
      isTopBarVisible: true,
      autoExpandSidebar: true,
      reducedMotion: false,
      compactMode: false,
      primaryColor: '220 84% 60%',
      appName: 'Jeli App',
      appLogo: undefined,
      draggedPage: null,
      dragHoverTarget: null,
      hoveredPane: null,
    };


    function appShellReducer(state: AppShellState, action: AppShellAction):
    AppShellState {
      switch (action.type) {
        case 'SET_SIDEBAR_STATE': return { ...state, sidebarState: action.payload };
        case 'SET_BODY_STATE':
          // If we're leaving fullscreen, reset the target and previous state
          if (state.bodyState === BODY_STATES.FULLSCREEN && action.payload !== BODY_STATES.FULLSCREEN) {
            return { ...state, bodyState: action.payload, fullscreenTarget: null, previousBodyState: BODY_STATES.NORMAL };
          }
          return { ...state, bodyState: action.payload };
        case 'SET_SIDE_PANE_CONTENT': return { ...state, sidePaneContent: action.payload };
        case 'SET_SIDEBAR_WIDTH': return { ...state, sidebarWidth: Math.max(200, Math.min(500, action.payload)) };
        case 'SET_SIDE_PANE_WIDTH': return { ...state, sidePaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };
        case 'SET_SPLIT_PANE_WIDTH': return { ...state, splitPaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };
        case 'SET_IS_RESIZING': return { ...state, isResizing: action.payload };
        case 'SET_PREVIOUS_BODY_STATE': return { ...state, previousBodyState: action.payload };
        case 'SET_FULLSCREEN_TARGET': return { ...state, fullscreenTarget: action.payload };
        case 'SET_IS_RESIZING_RIGHT_PANE': return { ...state, isResizingRightPane: action.payload };
        case 'SET_TOP_BAR_VISIBLE': return { ...state, isTopBarVisible: action.payload };
        case 'SET_AUTO_EXPAND_SIDEBAR': return { ...state, autoExpandSidebar: action.payload };
        case 'SET_REDUCED_MOTION': return { ...state, reducedMotion: action.payload };
        case 'SET_COMPACT_MODE': return { ...state, compactMode: action.payload };
        case 'SET_PRIMARY_COLOR': return { ...state, primaryColor: action.payload };
        case 'SET_DRAGGED_PAGE': return { ...state, draggedPage: action.payload };
        case 'SET_DRAG_HOVER_TARGET': return { ...state, dragHoverTarget: action.payload };
        case 'SET_HOVERED_PANE': return { ...state, hoveredPane: action.payload };
        case 'RESET_TO_DEFAULTS':
          return {
            ...defaultState,
            appName: state.appName, // Preserve props passed to provider
            appLogo: state.appLogo,   // Preserve props passed to provider
          };
        default: return state;
      }
    }


    // --- Context and Provider ---


    interface AppShellContextValue extends AppShellState {
      dispatch: Dispatch<AppShellAction>;
      rightPaneWidth: number;
      // Composite actions for convenience
      toggleSidebar: () => void;
      hideSidebar: () => void;
      showSidebar: () => void;
      peekSidebar: () => void;
      toggleFullscreen: (target?: 'main' | 'right' | null) => void;
      resetToDefaults: () => void;
    }


    const AppShellContext = createContext<AppShellContextValue | null>(null);


    interface AppShellProviderProps {
      children: ReactNode;
      appName?: string;
      appLogo?: ReactElement;
      defaultSplitPaneWidth?: number;
    }


    export function AppShellProvider({ children, appName, appLogo,
    defaultSplitPaneWidth }: AppShellProviderProps) {
      const [state, dispatch] = useReducer(appShellReducer, {
        ...defaultState,
        ...(appName && { appName }),
        ...(appLogo && { appLogo }),
        ...(defaultSplitPaneWidth && { splitPaneWidth: defaultSplitPaneWidth }),
      });

      // Side effect for primary color
      useEffect(() => {
        document.documentElement.style.setProperty('--primary-hsl', state.primaryColor);
      }, [state.primaryColor]);

      // Memoized composite actions using useCallback for stable function identities
      const toggleSidebar = useCallback(() => {
        const current = state.sidebarState;
        if (current === SIDEBAR_STATES.HIDDEN) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
        else if (current === SIDEBAR_STATES.COLLAPSED) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.EXPANDED });
        else if (current === SIDEBAR_STATES.EXPANDED) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
      }, [state.sidebarState]);

      const hideSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.HIDDEN }), []);
      const showSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.EXPANDED }), []);
      const peekSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.PEEK }), []);
      
      const toggleFullscreen = useCallback((target: 'main' | 'right' | null = null) => {
        const current = state.bodyState;
        if (current === BODY_STATES.FULLSCREEN) {
          // Exiting fullscreen, go back to the previous state
          dispatch({ type: 'SET_BODY_STATE', payload: state.previousBodyState || BODY_STATES.NORMAL });
        } else {
          // Entering fullscreen
          dispatch({ type: 'SET_PREVIOUS_BODY_STATE', payload: current });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.FULLSCREEN });
          dispatch({ type: 'SET_FULLSCREEN_TARGET', payload: target });
        }
      }, [state.bodyState, state.previousBodyState]);

      const resetToDefaults = useCallback(() => dispatch({ type: 'RESET_TO_DEFAULTS' }), []);

      const rightPaneWidth = useMemo(() => (
        state.bodyState === BODY_STATES.SPLIT_VIEW ? state.splitPaneWidth : state.sidePaneWidth
      ), [state.bodyState, state.splitPaneWidth, state.sidePaneWidth]);

      const value = useMemo(() => ({ 
        ...state, 
        dispatch,
        rightPaneWidth,
        toggleSidebar,
        hideSidebar,
        showSidebar,
        peekSidebar,
        toggleFullscreen,
        resetToDefaults,
      }), [
        state, 
        rightPaneWidth,
        toggleSidebar,
        hideSidebar,
        showSidebar,
        peekSidebar,
        toggleFullscreen,
        resetToDefaults
      ]);

      return (
        <AppShellContext.Provider value={value}>
          {children}
        </AppShellContext.Provider>
      );
    }


    // --- Hook ---


    export function useAppShell() {
      const context = useContext(AppShellContext);
      if (!context) {
        throw new Error('useAppShell must be used within an AppShellProvider');
      }
      return context;
    }
  src/pages/DataDemo/components/DataViewModeSelector.tsx: >-
    import { useEffect, useRef, useState, useCallback } from 'react'

    import { gsap } from 'gsap'

    import { cn } from '@/lib/utils'

    import { List, Grid3X3, LayoutGrid, Table } from 'lucide-react'

    import type { ViewMode } from '../types'


    interface DataViewModeSelectorProps {
      viewMode: ViewMode
      onChange: (mode: ViewMode) => void
    }


    const viewModes = [
      { id: 'list' as ViewMode, label: 'List', icon: List, description: 'Compact list with details' },
      { id: 'cards' as ViewMode, label: 'Cards', icon: LayoutGrid, description: 'Rich card layout' },
      { id: 'grid' as ViewMode, label: 'Grid', icon: Grid3X3, description: 'Masonry grid view' },
      { id: 'table' as ViewMode, label: 'Table', icon: Table, description: 'Structured data table' }
    ]


    export function DataViewModeSelector({ viewMode, onChange }:
    DataViewModeSelectorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null)
      const containerRef = useRef<HTMLDivElement>(null)
      const [isExpanded, setIsExpanded] = useState(false)
      const [isTransitioning, setIsTransitioning] = useState(false)

      const updateIndicatorPosition = useCallback((immediate = false) => {
        if (!indicatorRef.current || !containerRef.current || isTransitioning) return

        const activeButton = containerRef.current.querySelector(`[data-mode="${viewMode}"]`) as HTMLElement
        if (!activeButton) return

        const containerRect = containerRef.current.getBoundingClientRect()
        const buttonRect = activeButton.getBoundingClientRect()
        
        const left = buttonRect.left - containerRect.left
        const width = buttonRect.width

        if (immediate) {
          // Set position immediately without animation for initial load
          gsap.set(indicatorRef.current, {
            x: left,
            width: width
          })
        } else {
          gsap.to(indicatorRef.current, {
            duration: 0.3,
            x: left,
            width: width,
            ease: "power2.out"
          })
        }
      }, [viewMode, isTransitioning])

      // Initial setup - set position immediately without animation
      useEffect(() => {
        const timer = setTimeout(() => {
          updateIndicatorPosition(true)
        }, 0)
        return () => clearTimeout(timer)
      }, []) // Only run once on mount

      useEffect(() => {
        if (!isTransitioning) {
          updateIndicatorPosition()
        }
      }, [viewMode, isTransitioning, updateIndicatorPosition])

      const handleMouseEnter = () => {
        setIsTransitioning(true)
        setIsExpanded(true)
        
        // Wait for expand animation to complete
        setTimeout(() => {
          setIsTransitioning(false)
        }, 500)
      }

      const handleMouseLeave = () => {
        setIsTransitioning(true)
        setIsExpanded(false)
        
        // Wait for collapse animation to complete
        setTimeout(() => {
          setIsTransitioning(false)
        }, 500)
      }

      return (
        <div 
          ref={containerRef}
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
          className={cn(
            "relative flex items-center bg-card/50 backdrop-blur-sm border border-border/50 rounded-2xl p-1.5 shadow-lg transition-all duration-500 ease-out",
            "hover:shadow-xl hover:bg-card/70",
            isExpanded ? "gap-1" : "gap-0"
          )}
        >
          {/* Animated indicator */}
          <div
            ref={indicatorRef}
            className="absolute inset-y-1.5 bg-gradient-to-r from-primary/20 to-primary/10 border border-primary/20 rounded-xl transition-all duration-300"
            style={{ left: 0, width: 0 }}
          />
          
          {/* Mode buttons */}
          {viewModes.map((mode, index) => {
            const IconComponent = mode.icon
            const isActive = viewMode === mode.id
            
            return (
              <button
                key={mode.id}
                data-mode={mode.id}
                onClick={() => onChange(mode.id)}
                className={cn(
                  "relative flex items-center justify-center rounded-xl transition-all duration-500 ease-out group overflow-hidden",
                  "hover:bg-accent/20 active:scale-95",
                  isActive && "text-primary",
                  isExpanded ? "gap-3 px-4 py-2.5" : "gap-0 px-3 py-2.5"
                )}
                title={mode.description}
                style={{
                  transitionDelay: isExpanded ? `${index * 50}ms` : `${(viewModes.length - index - 1) * 30}ms`
                }}
              >
                <IconComponent className={cn(
                  "w-5 h-5 transition-all duration-300 flex-shrink-0",
                  isActive && "scale-110",
                  "group-hover:scale-105",
                  isExpanded ? "rotate-0" : "rotate-0"
                )} />
                
                {/* Label with smooth expand/collapse */}
                <div className={cn(
                  "overflow-hidden transition-all duration-500 ease-out",
                  isExpanded ? "max-w-[80px] opacity-100" : "max-w-0 opacity-0"
                )}>
                  <span className={cn(
                    "font-medium whitespace-nowrap transition-all duration-300",
                    isActive ? "text-primary" : "text-muted-foreground",
                    "group-hover:text-foreground"
                  )}>
                    {mode.label}
                  </span>
                </div>
              </button>
            )
          })}
        </div>
      )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-10-14T02:02:07.306Z'
status: committed
id: 261
