uuid: b09dd873-195c-411a-ae4c-53530867a5df
projectId: jeli-app-shell
createdAt: '2025-10-18T07:13:44.315Z'
gitCommitMsg: >-
  feat(DataDemo): add auto-hiding stats header on scroll

  Implemented a sliver-style animation for the stats card section on the Data
  Demo page. The stats container now gracefully animates out of view when
  scrolling down and animates back in when scrolling up.

  This behavior is encapsulated in a new reusable `useAutoAnimateStats` hook,
  which uses GSAP for smooth animations and handles layout reflow by managing
  the element's display property. This improves the user experience by
  prioritizing content while scrolling.
promptSummary: >-
  Implement a sliver-style header for the stats cards on the Data Demo page, so
  they animate out of view on scroll-down and reappear on scroll-up.
reasoning:
  - >-
    To achieve the desired "sliver app bar" effect for the stats cards, I will
    encapsulate the animation and scroll-handling logic into a new, reusable
    custom hook. This keeps the component logic clean and promotes reuse.
  - '### Part 1: Create the Auto-Animation Hook'
  - >-
    First, I'll create a new file `src/hooks/useAutoAnimateStats.hook.ts`. This
    hook will be responsible for listening to scroll events on the page's scroll
    container. When the user scrolls down past a certain threshold, it will use
    `gsap` to smoothly animate the stats container's height and opacity to zero,
    finally setting `display: none` to ensure the layout reflows correctly. When
    the user scrolls up, it will reverse the process, bringing the stats back
    into view.
  - '### Part 2: Integrate Hook into DataDemo Page'
  - >-
    Next, I'll integrate this new hook into the `DataDemo` component. I'll
    import `useAutoAnimateStats` and call it with the existing `scrollRef` (for
    the `PageLayout`) and `statsRef` (for the stats container). This single line
    of code is all that's needed to connect the animation logic to the
    component's elements.
operations:
  - type: write
    path: src/hooks/useAutoAnimateStats.hook.ts
    content: |-
      import { useEffect, useRef, useCallback } from 'react';
      import { gsap } from 'gsap';

      export function useAutoAnimateStats(
        scrollContainerRef: React.RefObject<HTMLElement>,
        statsContainerRef: React.RefObject<HTMLElement>
      ) {
        const lastScrollY = useRef(0);
        const isHidden = useRef(false);
        const animation = useRef<gsap.core.Tween | null>(null);
        const originalDisplay = useRef<string>('');

        useEffect(() => {
          // On mount, store the original display property if the ref is available
          if (statsContainerRef.current) {
              originalDisplay.current = window.getComputedStyle(statsContainerRef.current).display;
          }
        }, [statsContainerRef]);

        const handleScroll = useCallback(() => {
          if (!scrollContainerRef.current || !statsContainerRef.current) return;

          // Ensure we have originalDisplay. It might not be available on first scroll if ref isn't ready.
          if (!originalDisplay.current && statsContainerRef.current) {
              originalDisplay.current = window.getComputedStyle(statsContainerRef.current).display;
              if (!originalDisplay.current || originalDisplay.current === 'none') {
                // Fallback if it's still none (e.g. initially hidden)
                originalDisplay.current = 'grid';
              }
          }
          
          const scrollY = scrollContainerRef.current.scrollTop;

          if (animation.current && animation.current.isActive()) {
            return;
          }

          // Scroll down past threshold
          if (scrollY > lastScrollY.current && scrollY > 150 && !isHidden.current) {
            isHidden.current = true;
            animation.current = gsap.to(statsContainerRef.current, {
              height: 0,
              autoAlpha: 0,
              duration: 0.3,
              ease: 'power2.inOut',
              overwrite: true,
              onComplete: () => {
                  if (statsContainerRef.current) {
                      statsContainerRef.current.style.display = 'none';
                  }
              }
            });
          } 
          // Scroll up
          else if (scrollY < lastScrollY.current && isHidden.current) {
            isHidden.current = false;
            
            if (statsContainerRef.current) {
              statsContainerRef.current.style.display = originalDisplay.current;
              
              animation.current = gsap.from(statsContainerRef.current, {
                height: 0,
                autoAlpha: 0,
                duration: 0.3,
                ease: 'power2.out',
                overwrite: true,
                clearProps: 'all' // Clean up inline styles after animation
              });
            }
          }

          lastScrollY.current = scrollY < 0 ? 0 : scrollY;
        }, [scrollContainerRef, statsContainerRef]);

        useEffect(() => {
          const scrollEl = scrollContainerRef.current;
          if (scrollEl) {
            scrollEl.addEventListener('scroll', handleScroll, { passive: true });
          }
          return () => {
            if (scrollEl) {
              scrollEl.removeEventListener('scroll', handleScroll);
            }
            if (animation.current) {
              animation.current.kill();
            }
          };
        }, [handleScroll, scrollContainerRef]);
      }
    patchStrategy: replace
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: |+
      --- src/pages/DataDemo/index.tsx
      +++ src/pages/DataDemo/index.tsx
      @@ -28,6 +28,7 @@
       import { mockDataItems } from './data/mockData'
       import type { GroupableField, DataItem } from './types'
       import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
      +import { useAutoAnimateStats } from '@/hooks/useAutoAnimateStats.hook'
       import { 
         useDataDemoStore, 
         useGroupTabs
      @@ -124,6 +125,9 @@
       
         const statsRef = useRef<HTMLDivElement>(null)
         const scrollRef = useRef<HTMLDivElement>(null);
      +
      +  // Animate stats section in/out on scroll
      +  useAutoAnimateStats(scrollRef, statsRef);
       
         // Calculate stats from data
         const totalItems = mockDataItems.length

    patchStrategy: standard-diff
snapshot:
  src/hooks/useAutoAnimateStats.hook.ts: null
  src/pages/DataDemo/index.tsx: >
    import { useRef, useEffect, useCallback, useMemo } from 'react'

    import {
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      TrendingUp,
      Loader2,
      ChevronsUpDown
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { cn } from '@/lib/utils'

    import { Button } from '@/components/ui/button'

    import { 
      DropdownMenu, 
      DropdownMenuContent, 
      DropdownMenuRadioGroup, 
      DropdownMenuRadioItem, 
      DropdownMenuTrigger 
    } from '@/components/ui/dropdown-menu'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { useScrollToBottom } from '@/hooks/useScrollToBottom.hook';

    import { ScrollToBottomButton } from
    '@/components/shared/ScrollToBottomButton';

    import { DataListView } from './components/DataListView'

    import { DataCardView } from './components/DataCardView'

    import { DataTableView } from './components/DataTableView'

    import { DataKanbanView } from './components/DataKanbanView'

    import { DataCalendarView } from './components/DataCalendarView'

    import { DataViewModeSelector } from './components/DataViewModeSelector'

    import { AnimatedTabs } from '@/components/ui/animated-tabs'

    import { StatCard } from '@/components/shared/StatCard'

    import { AnimatedLoadingSkeleton } from
    './components/AnimatedLoadingSkeleton'

    import { DataToolbar } from './components/DataToolbar'

    import { mockDataItems } from './data/mockData'

    import type { GroupableField, DataItem } from './types'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { 
      useDataDemoStore, 
      useGroupTabs
    } from './store/dataDemo.store'


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    function DataDemoContent() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
      } = useAppViewManager();

      const { hasMore, isLoading, isInitialLoading, totalItemCount, loadData } = useDataDemoStore(state => ({
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
      }));

      const groupTabs = useGroupTabs(groupBy, activeGroupTab);
      const allItems = useDataDemoStore(s => s.items);

      const groupedData = useMemo(() => {
        if (groupBy === 'none') {
            return null;
        }
        return allItems.reduce((acc, item) => {
            const groupKey = String(item[groupBy as GroupableField]);
            if (!acc[groupKey]) {
                acc[groupKey] = [];
            }
            acc[groupKey].push(item);
            return acc;
        }, {} as Record<string, DataItem[]>);
      }, [allItems, groupBy]);

      const dataToRender = useMemo(() => {
        if (groupBy === 'none' || activeGroupTab === 'all' || !groupedData) {
          return allItems;
        }
        return groupedData[activeGroupTab] || [];
      }, [groupBy, activeGroupTab, allItems, groupedData]);

      const groupOptions = useMemo(() => [
        { id: 'none' as const, label: 'None' }, { id: 'status' as const, label: 'Status' }, { id: 'priority' as const, label: 'Priority' }, { id: 'category' as const, label: 'Category' }
      ], []);

      const statsRef = useRef<HTMLDivElement>(null)
      const scrollRef = useRef<HTMLDivElement>(null);

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const { showScrollToBottom, scrollToBottom, handleScroll } = useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78]
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.6,
              y: 0,
              opacity: 1,
              stagger: 0.1,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading]);

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === 'calendar',
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );
      
      // Auto-group by status when switching to kanban view for the first time
      useEffect(() => {
        if (viewMode === 'kanban' && groupBy === 'none') {
          setGroupBy('status');
          setSort(null); // Kanban is manually sorted, so disable programmatic sort
        }
        // For calendar view, we don't want grouping.
        if (viewMode === 'calendar') {
          if (groupBy !== 'none') setGroupBy('none');
        }
      }, [viewMode, groupBy, setGroupBy]);

      const renderViewForData = useCallback((data: DataItem[]) => {
        switch (viewMode) {
            case 'table': return <DataTableView data={data} />;
            case 'cards': return <DataCardView data={data} />;
            case 'calendar': return null; // Calendar has its own render path below
            case 'kanban': return null; // Kanban has its own render path below
            case 'grid': return <DataCardView data={data} isGrid />;
            case 'list':
            default:
                return <DataListView data={data} />;
        }
      }, [viewMode]);

      const GroupByDropdown = useCallback(() => (
        <div className="flex items-center gap-2 shrink-0">
          <span className="text-sm font-medium text-muted-foreground shrink-0">Group by:</span>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" className="w-[180px] justify-between">
                {groupOptions.find(o => o.id === groupBy)?.label}
                <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent className="w-[180px]">
              <DropdownMenuRadioGroup value={groupBy} onValueChange={setGroupBy}>
                {groupOptions.map(option => (
                  <DropdownMenuRadioItem key={option.id} value={option.id}>
                    {option.label}
                  </DropdownMenuRadioItem>
                ))}
              </DropdownMenuRadioGroup>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      ), [groupBy, setGroupBy, groupOptions]);

      const isGroupedView = useMemo(() => 
        groupBy !== 'none' && groupTabs.length > 1 && groupedData,
      [groupBy, groupTabs.length, groupedData]);


      return (
        <PageLayout
          scrollRef={scrollRef}
          onScroll={handleScroll}
          // Note: Search functionality is handled by a separate SearchBar in the TopBar
        >
          <div className="space-y-8">
            {/* Header */}
            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
              <div className="flex-1">
                <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                <p className="text-muted-foreground">
                  {isInitialLoading 
                    ? "Loading projects..." 
                    : `Showing ${dataToRender.length} of ${totalItemCount} item(s)`}
                </p>
              </div>
              <DataViewModeSelector />
            </div>

            {/* Stats Section */}
            {!isInitialLoading && (
              <div ref={statsRef} className="grid grid-cols-[repeat(auto-fit,minmax(250px,1fr))] gap-6">
                {stats.map((stat) => (
                  <StatCard
                    key={stat.title}
                    title={stat.title}
                    value={stat.value}
                    change={stat.change}
                    trend={stat.trend}
                    icon={stat.icon}
                    chartData={stat.type === 'chart' ? stat.chartData : undefined}
                  />
                ))}
              </div>
            )}

            {/* Controls Area */}
            <div className="space-y-6">
              <DataToolbar />
            </div>

            <div className="min-h-[500px]">
              {isInitialLoading 
                ? <AnimatedLoadingSkeleton viewMode={viewMode} /> 
                : viewMode === 'calendar' ? (
                  <DataCalendarView data={allItems} />
                )
                : viewMode === 'kanban' ? (
                  <>
                    <div className="flex items-center justify-end gap-4 h-[68px]">
                      <GroupByDropdown />
                    </div>
                    {isGroupedView ? (
                      <DataKanbanView data={groupedData} />
                    ) : (
                      <div className="flex items-center justify-center h-96 text-muted-foreground">
                        Group data by a metric to use the Kanban view.
                      </div>
                    )}
                  </>
                )
                : !isGroupedView ? (
                  // Not grouped view
                  <>
                    <div className="flex items-center justify-between gap-4 h-[68px]">
                      <div className="flex-grow border-b" /> {/* Mimic tab border */}
                      <GroupByDropdown />
                    </div>
                    {renderViewForData(allItems)}
                  </>
                ) : (
                  // Grouped view with AnimatedTabs
                  <div className="relative">
                    <AnimatedTabs
                      tabs={groupTabs}
                      activeTab={activeGroupTab}
                      onTabChange={setActiveGroupTab}
                      wrapperClassName="flex flex-col"
                      className="border-b"
                      contentClassName="pt-6 flex-grow"
                    >
                      {groupTabs.map(tab => (
                        <div key={tab.id} className="min-h-[440px]">
                          {renderViewForData(
                            tab.id === 'all' ? allItems : groupedData?.[tab.id] || []
                          )}
                        </div>
                      ))}
                    </AnimatedTabs>
                    <div className="absolute top-[14px] right-0">
                        <GroupByDropdown />
                    </div>
                  </div>
                )
              }
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && dataToRender.length > 0 && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>
          <ScrollToBottomButton isVisible={showScrollToBottom} onClick={scrollToBottom} />
        </PageLayout>
      )
    }


    export default function DataDemoPage() {
      return <DataDemoContent />;
    }
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 453
