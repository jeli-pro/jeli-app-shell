uuid: c32c744e-60b6-4c4f-9e79-58a36411f18e
projectId: jeli-app-shell
createdAt: '2025-10-22T06:03:15.400Z'
gitCommitMsg: >-
  feat(shell): re-wire UI components to new view manager

  This commit completes the app shell refactor by connecting all UI components
  and pages to the new centralized `useAppViewManager` hook.

  - `App.tsx` is now the master layout controller, using the hook to determine
  which view IDs to pass to `MainContent` and `RightPane`. - The
  `ViewModeSwitcher` component has been completely refactored to use the simple,
  declarative actions from the view manager (e.g., `toggleSplitView`,
  `toggleFullscreen`). - Sidebar menu items and the Command Palette now use the
  new view manager actions for navigation and pane control. - Page components
  (`Dashboard`, `Notifications`, `ToasterDemo`) have been updated to remove
  layout-specific logic, ensuring they render consistently across all view
  states (main, side pane, fullscreen).
promptSummary: >-
  The user requested to execute Part 3 of the refactoring plan, which involves
  re-wiring the application components to use the new centralized view
  management system and simplifying page components to be layout-agnostic.
reasoning:
  - >-
    Here are the final changes to re-wire the application components and
    simplify the pages.
  - >-
    I've updated `App.tsx` to be the central controller, using the new
    `useAppViewManager` hook to determine which views to render in the main and
    right panes. The `ViewModeSwitcher` has been completely overhauled to use
    the clean actions provided by the hook, significantly simplifying its
    internal logic. Sidebar menu items and the command palette are now also
    wired into this new, unified system for navigation and view management.
  - >-
    Finally, I've gone through the page components (`Dashboard`,
    `Notifications`, `ToasterDemo`) to remove layout-specific logic, making them
    agnostic to where they are rendered. This ensures they behave consistently
    whether they appear as the main content, in a side pane, or in fullscreen
    mode.
  - '### Re-wiring the Application Core'
  - >-
    First, I'll update `App.tsx` to use the `useAppViewManager` as the single
    source of truth for the layout state, determining which views to render.
  - >-
    To support the `ViewModeSwitcher`, I'll update the `toggleSplitView` action
    in our view manager hook to be more flexible.
  - '### Updating UI Controls'
  - >-
    Now, I'll refactor the `ViewModeSwitcher` to use the new centralized
    actions, simplifying its logic significantly.
  - >-
    Next, I'll update the sidebar menu items to use the new view manager
    actions.
  - '### Simplifying Page Components'
  - >-
    Finally, I will update the page components to ensure they render correctly
    in any layout state (main, side pane, or fullscreen).
operations:
  - type: write
    path: src/App.tsx
    content: >+
      --- src/App.tsx

      +++ src/App.tsx

      @@ -107,20 +107,23 @@
       
       // The main App component that composes the shell
       function ComposedApp() {
      -  const { setBodyState, setSidePaneContent } =
      useAppShellStore.getState();
         const viewManager = useAppViewManager();
         const location = useLocation();
         const params = useParams();
      +  const { setBodyState, setSidePaneContent } =
      useAppShellStore.getState();
       
         // Sync URL state with AppShellStore
         useEffect(() => {
           setBodyState(viewManager.bodyState);
      -    setSidePaneContent(viewManager.sidePaneContent);

      -  }, [viewManager.bodyState, viewManager.sidePaneContent, setBodyState,
      setSidePaneContent]);

      +    // The view manager uses a generic 'dataItem' id for pane content.

      +    // We map it to the specific viewId for rendering.

      +    if (viewManager.sidePaneContent === 'dataItem') {

      +      setSidePaneContent('dataItemDetail');

      +    } else {

      +      setSidePaneContent(viewManager.sidePaneContent);

      +    }

      +  }, [viewManager.bodyState, viewManager.sidePaneContent, setBodyState,
      setSidePaneContent]);
       
      -  const rightViewId = useAppShellStore(s => s.sidePaneContent);

      +  const rightViewId = useAppShellStore(s => s.sidePaneContent);
       
         // Determine mainViewId from the route path
         const pathSegments = location.pathname.split('/').filter(Boolean);
      @@ -144,7 +147,6 @@
               }
               mainContent={<MainContent viewId={mainViewId} />}
               rightPane={<RightPane viewId={rightViewId} />}
      -        commandPalette={<CommandPalette />}
             />
           </AppShellProvider>
         );

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: >+
      --- src/hooks/useAppViewManager.hook.ts

      +++ src/hooks/useAppViewManager.hook.ts

      @@ -122,14 +122,14 @@
           }
         }, [sidePane, openSidePane, closeSidePane]);
       
      -  const toggleSplitView = useCallback(() => {

      +  const toggleSplitView = useCallback((paneContent?:
      AppShellState['sidePaneContent']) => {
           if (bodyState === BODY_STATES.SIDE_PANE) {
             handleParamsChange({ view: 'split', right: sidePane, sidePane: null });
           } else if (bodyState === BODY_STATES.SPLIT_VIEW) {
             handleParamsChange({ sidePane: right, view: null, right: null });
           } else { // From normal
      -      const paneContent = pageToPaneMap[currentActivePage] || 'details';

      -      handleParamsChange({ view: 'split', right: paneContent, sidePane:
      null });

      +      const content = paneContent || pageToPaneMap[currentActivePage] ||
      'details';

      +      handleParamsChange({ view: 'split', right: content, sidePane: null
      });
           }
      -  }, [bodyState, sidePane, right, currentActivePage,
      handleParamsChange]);

      +  }, [bodyState, sidePane, right, currentActivePage,
      handleParamsChange]);
         
         const toggleFullscreen = useCallback((target?: 'main' | 'right') => {
           // This logic is handled by the store, which will be updated by ViewModeSwitcher

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/ViewModeSwitcher.tsx
    content: >
      <<<<<<< SEARCH

      import {
        Columns,
        PanelRightOpen,
        SplitSquareHorizontal,
        Maximize,
        Minimize,
        Layers,
        X,
        ArrowLeftRight
      } from 'lucide-react'


      export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
      'right', targetPage?: string }) {
        const bodyState = useAppShellStore(s => s.bodyState);
        const fullscreenTarget = useAppShellStore(s => s.fullscreenTarget);
        const { toggleFullscreen } = useAppShellStore.getState();
        const {
          currentActivePage,
          toggleSidePane,
          toggleSplitView,
          setNormalView,
          navigateTo,
          switchSplitPanes,
          closeSplitPane,
        } = useAppViewManager();

        const activePage = targetPage || currentActivePage;
        const [isExpanded, setIsExpanded] = useState(false);
        const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

        const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
        const isThisPaneFullscreen = isFullscreen && (
          (pane === 'main' && fullscreenTarget !== 'right') ||
          (pane === 'right' && fullscreenTarget === 'right') ||
          (!pane && !fullscreenTarget) // Global switcher, global fullscreen
        );

        useEffect(() => {
          const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
          if (buttonsToAnimate.length === 0) return;

          gsap.killTweensOf(buttonsToAnimate);

          if (isExpanded) {
              gsap.to(buttonsToAnimate, {
                  width: 32, // h-8 w-8
                  opacity: 1,
                  pointerEvents: 'auto',
                  marginLeft: 4, // from gap-1 in original
                  duration: 0.2,
                  stagger: {
                      each: 0.05,
                      from: 'start'
                  },
                  ease: 'power2.out'
              });
          } else {
              gsap.to(buttonsToAnimate, {
                  width: 0,
                  opacity: 0,
                  pointerEvents: 'none',
                  marginLeft: 0,
                  duration: 0.2,
                  stagger: {
                      each: 0.05,
                      from: 'end'
                  },
                  ease: 'power2.in'
              });
          }
        }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

        const handlePaneClick = (type: 'side-pane' | 'split-view') => {
          const pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {
            dashboard: 'main', settings: 'settings', toaster: 'toaster', notifications: 'notifications', 'data-demo': 'dataDemo',
            messaging: 'messaging',
          };
          const basePage = activePage.split('/')[0];
          const paneContent = pageToPaneMap[basePage];
          if (type === 'side-pane') toggleSidePane(paneContent);
          else toggleSplitView();
        }

        const handleNormalViewClick = () => {
          if (isFullscreen) {
            toggleFullscreen();
          }
          if (targetPage && targetPage !== currentActivePage) {
            navigateTo(targetPage);
          } else {
            setNormalView();
          }
        }

        const buttons = [
          {
            id: 'normal',
            onClick: handleNormalViewClick,
            active: bodyState === BODY_STATES.NORMAL,
            title: "Normal View",
            icon: <Columns className="w-4 h-4" />
          },
          {
            id: 'side-pane',
            onClick: () => handlePaneClick('side-pane'),
            active: bodyState === BODY_STATES.SIDE_PANE,
            title: "Side Pane View",
            icon: <PanelRightOpen className="w-4 h-4" />
          },
          {
            id: 'split-view',
            onClick: () => handlePaneClick('split-view'),
            active: bodyState === BODY_STATES.SPLIT_VIEW,
            title: bodyState === BODY_STATES.SPLIT_VIEW ? 'Switch to Overlay View' : 'Switch to Split View',
            icon: bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-4 h-4" /> : <SplitSquareHorizontal className="w-4 h-4" />
          },
          {
            id: 'fullscreen',
            onClick: () => {
              if (targetPage && targetPage !== currentActivePage ) {
                navigateTo(targetPage);
                setTimeout(() => toggleFullscreen(pane), 50);
              } else {
                toggleFullscreen(pane);
              }
            },
            active: isThisPaneFullscreen,
            title: "Toggle Fullscreen",
            icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
          }
        ];
      =======

      import {
        Columns,
        PanelRightOpen,
        SplitSquareHorizontal,
        Maximize,
        Minimize,
        Layers,
        X,
        ArrowLeftRight
      } from 'lucide-react'


      export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
      'right', targetPage?: string }) {
        const bodyState = useAppShellStore(s => s.bodyState);
        const fullscreenTarget = useAppShellStore(s => s.fullscreenTarget);
        const { toggleFullscreen } = useAppShellStore.getState();
        const {
          currentActivePage,
          toggleSidePane,
          toggleSplitView,
          setNormalView,
          navigateTo,
          switchSplitPanes,
          closeSplitPane,
        } = useAppViewManager();

        const activePage = targetPage || currentActivePage;
        const [isExpanded, setIsExpanded] = useState(false);
        const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

        const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
        const isThisPaneFullscreen = isFullscreen && (
          (pane === 'main' && fullscreenTarget !== 'right') || // main pane is fullscreen if target is not right
          (pane === 'right' && fullscreenTarget === 'right') || // right pane is fullscreen if it is the target
          (!pane && fullscreenTarget !== 'right') // global switcher shows minimize if main pane is fullscreen
        );

        useEffect(() => {
          const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
          if (buttonsToAnimate.length === 0) return;

          gsap.killTweensOf(buttonsToAnimate);

          if (isExpanded) {
              gsap.to(buttonsToAnimate, {
                  width: 32, // h-8 w-8
                  opacity: 1,
                  pointerEvents: 'auto',
                  marginLeft: 4, // from gap-1 in original
                  duration: 0.2,
                  stagger: {
                      each: 0.05,
                      from: 'start'
                  },
                  ease: 'power2.out'
              });
          } else {
              gsap.to(buttonsToAnimate, {
                  width: 0,
                  opacity: 0,
                  pointerEvents: 'none',
                  marginLeft: 0,
                  duration: 0.2,
                  stagger: {
                      each: 0.05,
                      from: 'end'
                  },
                  ease: 'power2.in'
              });
          }
        }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

        const handleSidePaneClick = () => {
          const pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {
            dashboard: 'main', settings: 'settings', toaster: 'toaster', notifications: 'notifications', 'data-demo': 'dataDemo',
            messaging: 'messaging', dataItemDetail: 'dataItemDetail',
          };
          const basePage = activePage.split('/')[0] as keyof typeof pageToPaneMap;
          const paneContent = pageToPaneMap[basePage] || 'details';
          toggleSidePane(paneContent);
        }

        const handleNormalViewClick = () => {
          if (isFullscreen) {
            toggleFullscreen();
          }
          if (targetPage && targetPage !== currentActivePage) {
            navigateTo(targetPage);
          } else {
            setNormalView();
          }
        }

        const buttons = [
          {
            id: 'normal',
            onClick: handleNormalViewClick,
            active: bodyState === BODY_STATES.NORMAL,
            title: "Normal View",
            icon: <Columns className="w-4 h-4" />
          },
          {
            id: 'side-pane',
            onClick: handleSidePaneClick,
            active: bodyState === BODY_STATES.SIDE_PANE,
            title: "Side Pane View",
            icon: <PanelRightOpen className="w-4 h-4" />
          },
          {
            id: 'split-view',
            onClick: () => toggleSplitView(),
            active: bodyState === BODY_STATES.SPLIT_VIEW,
            title: "Split View",
            icon: <SplitSquareHorizontal className="w-4 h-4" />
          },
          {
            id: 'fullscreen',
            onClick: () => {
              if (targetPage && targetPage !== currentActivePage ) {
                navigateTo(targetPage);
                setTimeout(() => toggleFullscreen(pane), 50);
              } else {
                toggleFullscreen(pane);
              }
            },
            active: isThisPaneFullscreen,
            title: "Toggle Fullscreen",
            icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
          }
        ];
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/components/layout/EnhancedSidebar.tsx
    content: >+
      --- src/components/layout/EnhancedSidebar.tsx

      +++ src/components/layout/EnhancedSidebar.tsx

      @@ -213,7 +213,7 @@
         const calculatedIsActive = (
           (!opensInSidePane && page && viewManager.currentActivePage === page)
         ) || (
      -    opensInSidePane && page === 'notifications' &&
      viewManager.sidePaneContent === 'notifications'

      +    (opensInSidePane && page && viewManager.sidePaneContent === page)
         );
       
         const isActive = isActiveProp ?? calculatedIsActive;
      @@ -226,8 +226,7 @@
           }
           if (page) {
             if (opensInSidePane) {
      -        // The only item using this is Notifications

      -        viewManager.toggleSidePane('notifications');

      +        viewManager.toggleSidePane(page as any);
             } else {
               viewManager.navigateTo(page);
             }

    patchStrategy: standard-diff
  - type: write
    path: src/pages/Dashboard/index.tsx
    content: >+
      --- src/pages/Dashboard/index.tsx

      +++ src/pages/Dashboard/index.tsx

      @@ -156,9 +156,10 @@
           const statsCardsContainerRef = useRef<HTMLDivElement>(null);
           const featureCardsContainerRef = useRef<HTMLDivElement>(null);
           const bodyState = useAppShellStore(s => s.bodyState);
      +    const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
           const isInSidePane = bodyState === BODY_STATES.SIDE_PANE;
           
      -    const { onScroll: handleTopBarScroll } =
      useAutoAnimateTopBar(isInSidePane);

      +    const { onScroll: handleTopBarScroll } =
      useAutoAnimateTopBar(isInSidePane || isFullscreen);
           const { showScrollToBottom, scrollToBottom, handleScroll: handleScrollToBottom } = useScrollToBottom(scrollRef);
       
           const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
      @@ -187,7 +188,7 @@
           return (
             <PageLayout scrollRef={scrollRef} onScroll={handleScroll} ref={contentRef}>
               {/* Header */}
      -        {!isInSidePane && (

      +        {!isInSidePane && !isFullscreen && (
                 <PageHeader
                   title="Dashboard"
                   description="Welcome to the Jeli App Shell demo! Explore all the features and customization options."

    patchStrategy: standard-diff
  - type: write
    path: src/pages/Notifications/index.tsx
    content: >+
      --- src/pages/Notifications/index.tsx

      +++ src/pages/Notifications/index.tsx

      @@ -124,6 +124,7 @@
       export function NotificationsPage() {
         const bodyState = useAppShellStore(s => s.bodyState);
         const isInSidePane = bodyState === BODY_STATES.SIDE_PANE;
      +  const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
         
         const { activeTab, setActiveTab, markAllAsRead } = useNotificationsStore(s => ({ activeTab: s.activeTab, setActiveTab: s.setActiveTab, markAllAsRead: s.markAllAsRead }));
         const filteredNotifications = useFilteredNotifications();
      @@ -150,8 +151,8 @@
         };
       
         const content = (
      -    <Card className={cn("flex w-full flex-col shadow-none", isInSidePane
      ? "border-none" : "")}>

      -      <CardHeader className={cn(isInSidePane ? "p-4" : "p-6")}>

      +    <Card className={cn("flex w-full flex-col shadow-none", (isInSidePane
      || isFullscreen) ? "border-none" : "")}>

      +      <CardHeader className={cn((isInSidePane || isFullscreen) ? "p-4" :
      "p-6")}>
               <div className="flex items-center justify-between">
                 <h3 className="text-lg font-semibold">
                   Your notifications
      @@ -178,7 +179,7 @@
               </Tabs>
             </CardHeader>
       
      -      <CardContent className={cn("h-full p-0", isInSidePane ? "px-2" :
      "px-6")}>

      +      <CardContent className={cn("h-full p-0", (isInSidePane ||
      isFullscreen) ? "px-2" : "px-6")}>
               <div className="space-y-2 divide-y divide-border">
                 {filteredNotifications.length > 0 ? (
                   filteredNotifications.map((notification) => (
      @@ -197,7 +198,7 @@
       
         return (
           <PageLayout>
      -      {!isInSidePane && (

      +      {!isInSidePane && !isFullscreen && (
               <PageHeader
                 title="Notifications"
                 description="Manage your notifications and stay up-to-date."

    patchStrategy: standard-diff
  - type: write
    path: src/pages/ToasterDemo/index.tsx
    content: |+
      --- src/pages/ToasterDemo/index.tsx
      +++ src/pages/ToasterDemo/index.tsx
      @@ -33,6 +33,7 @@
       export function ToasterDemo() {
         const toast = useToast();
         const bodyState = useAppShellStore(s => s.bodyState);
      +  const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
         const isInSidePane = bodyState === BODY_STATES.SIDE_PANE;
       
         const showToast = (variant: Variant, position: Position = 'bottom-right') => {
      @@ -82,7 +83,7 @@
         return (
           <PageLayout>
             {/* Header */}
      -      {!isInSidePane && (
      +      {!isInSidePane && !isFullscreen && (
               <PageHeader
                 title="Toaster"
                 description="A customizable toast component for notifications."

    patchStrategy: standard-diff
snapshot:
  src/hooks/useAppViewManager.hook.ts: "import { useMemo, useCallback, useEffect, useRef } from 'react';\nimport { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\nimport type { TaskView } from '@/pages/Messaging/types';\nimport { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n\nconst pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n  dashboard: 'main',\n  settings: 'settings',\n  toaster: 'toaster',\n  notifications: 'notifications',\n  'data-demo': 'dataDemo',\n  messaging: 'messaging',\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n/**\n * A centralized hook to manage and synchronize all URL-based view states.\n * This is the single source of truth for view modes, side panes, split views,\n * and page-specific parameters.\n */\nexport function useAppViewManager() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { itemId: pathItemId, conversationId } = useParams<{ itemId?: string; conversationId?: string }>();\n  const { setSidebarState, sidebarState } = useAppShellStore();\n\n  // --- DERIVED STATE FROM URL ---\n\n  const view = searchParams.get('view');\n  const sidePane = searchParams.get('sidePane');\n  const sidePaneItemId = searchParams.get('itemId');\n  const right = searchParams.get('right');\n  const messagingView = searchParams.get('messagingView') as TaskView | null;\n\n  const { bodyState, sidePaneContent } = useMemo(() => {\n    const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo', 'messaging'];\n    \n    // 1. Priority: Explicit side pane overlay via URL param\n    if (sidePane && validPanes.includes(sidePane as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n    }\n\n    // 2. Data item detail view in a pane, triggered by search param\n    if (sidePaneItemId) {\n      if (view === 'split') {\n        return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n      }\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n    }\n\n    // 4. Generic split view via URL param\n    if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: right as AppShellState['sidePaneContent'] };\n    }\n\n    return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n  }, [sidePaneItemId, conversationId, view, sidePane, right]);\n  \n  const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n  const prevActivePage = usePrevious(currentActivePage);\n\n  // --- SIDE EFFECTS ---\n  useEffect(() => {\n    // On navigating to messaging page, collapse sidebar if it's expanded.\n    // This ensures a good default view but allows the user to expand it again if they wish.\n    if (currentActivePage === 'messaging' && prevActivePage !== 'messaging' && sidebarState === SIDEBAR_STATES.EXPANDED) {\n      setSidebarState(SIDEBAR_STATES.COLLAPSED);\n    }\n  }, [currentActivePage, prevActivePage, sidebarState, setSidebarState]);\n\n  // --- MUTATOR ACTIONS ---\n\n  const handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | number | string[] | null | undefined>, resetPage = false) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\t\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resetPage) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n  const navigateTo = useCallback((page: string, params?: Record<string, string | null>) => {\n    const targetPath = page.startsWith('/') ? page : `/${page}`;\n    const isSamePage = location.pathname === targetPath;\n    \n    const newSearchParams = new URLSearchParams(isSamePage ? searchParams : undefined);\n\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n          newSearchParams.delete(key);\n        } else {\n          newSearchParams.set(key, value);\n        }\n      }\n    }\n\n    navigate({ pathname: targetPath, search: newSearchParams.toString() });\n  }, [navigate, location.pathname, searchParams]);\n\n  const openSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (location.pathname === `/${Object.keys(pageToPaneMap).find(key => pageToPaneMap[key] === pane)}`) {\n        navigate({ pathname: '/dashboard', search: `?sidePane=${pane}` }, { replace: true });\n    } else {\n        handleParamsChange({ sidePane: pane, view: null, right: null });\n    }\n  }, [handleParamsChange, navigate, location.pathname]);\n\n  const closeSidePane = useCallback(() => {\n    // This should close any kind of side pane, including dataItem\n    handleParamsChange({ sidePane: null, view: null, right: null, itemId: null });\n  }, [handleParamsChange]);\n\n  const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (sidePane === pane) {\n      closeSidePane();\n    } else {\n      openSidePane(pane);\n    }\n  }, [sidePane, openSidePane, closeSidePane]);\n\n  const toggleSplitView = useCallback(() => {\n    if (bodyState === BODY_STATES.SIDE_PANE) {\n      handleParamsChange({ view: 'split', right: sidePane, sidePane: null });\n    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {\n      handleParamsChange({ sidePane: right, view: null, right: null });\n    } else { // From normal\n      const paneContent = pageToPaneMap[currentActivePage] || 'details';\n      handleParamsChange({ view: 'split', right: paneContent, sidePane: null });\n    }\n  }, [bodyState, sidePane, right, currentActivePage, handleParamsChange]);\n  \n  const toggleFullscreen = useCallback((target?: 'main' | 'right') => {\n    // This logic is handled by the store, which will be updated by ViewModeSwitcher\n    // For now, we assume the store has a `toggleFullscreen` action\n    useAppShellStore.getState().toggleFullscreen(target);\n  }, []);\n\n  const setNormalView = useCallback(() => {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const switchSplitPanes = useCallback(() => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    const newSidePaneContent = pageToPaneMap[currentActivePage];\n    const newActivePage = Object.entries(pageToPaneMap).find(\n      ([, value]) => value === sidePaneContent\n    )?.[0] as ActivePage | undefined;\n\n    if (newActivePage && newSidePaneContent) {\n      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const closeSplitPane = useCallback((paneToClose: 'main' | 'right') => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    if (paneToClose === 'right') {\n      navigate(`/${currentActivePage}`, { replace: true });\n    } else { // Closing main pane\n      const pageToBecomeActive = Object.entries(pageToPaneMap).find(\n        ([, value]) => value === sidePaneContent\n      )?.[0] as ActivePage | undefined;\n      \n      if (pageToBecomeActive) {\n        navigate(`/${pageToBecomeActive}`, { replace: true });\n      } else {\n        navigate(`/dashboard`, { replace: true });\n      }\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const onItemSelect = useCallback((itemId: string) => {\n    handleParamsChange({ itemId: itemId, sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n\n  // The final active item ID is either from the path (main view) or a search param (pane view)\n  const itemId = pathItemId || sidePaneItemId;\n\n  return useMemo(() => ({\n    // State\n    bodyState,\n    sidePaneContent,\n    currentActivePage,\n    pathItemId, // Expose for main content decisions\n    itemId,\n    messagingView,\n    // Actions\n    navigateTo,\n    openSidePane,\n    closeSidePane,\n    toggleSidePane,\n    toggleSplitView,\n    toggleFullscreen,\n    setNormalView,\n    switchSplitPanes,\n    setMessagingView,\n    closeSplitPane,\n    onItemSelect,\n  }), [\n    bodyState, sidePaneContent, currentActivePage, pathItemId, itemId, messagingView,\n    navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, toggleFullscreen,\n    setNormalView, switchSplitPanes, setMessagingView, closeSplitPane, onItemSelect\n  ]);\n}"
  src/App.tsx: |-
    import React, { useEffect } from "react";
    import {
      createBrowserRouter,
      RouterProvider,
      Outlet,
      Navigate,
      useNavigate, // used in LoginPageWrapper
      useLocation,
      useParams,
    } from "react-router-dom";

    import { AppShell } from "./components/layout/AppShell";
    import { AppShellProvider } from "./providers/AppShellProvider";
    import { useAppShellStore } from "./store/appShell.store";
    import { useAuthStore } from "./store/authStore";
    import "./index.css";

    // Import library components
    import { EnhancedSidebar } from "./components/layout/EnhancedSidebar";
    import { MainContent } from "./components/layout/MainContent";
    import { RightPane } from "./components/layout/RightPane";
    import { TopBar } from "./components/layout/TopBar";
    import { CommandPalette } from "./components/global/CommandPalette";
    import { ToasterProvider } from "./components/ui/toast";
    import { Input } from "./components/ui/input";
    import { Button } from "./components/ui/button";

    import { LoginPage } from "./components/auth/LoginPage";
    import { type ViewId } from "./views/viewRegistry";

    // --- Icons ---
    import {
      Search,
      Filter,
      Plus,
      ChevronRight,
      Rocket,
    } from "lucide-react";

    // --- Utils & Hooks ---
    import { cn } from "./lib/utils";
    import { useAppViewManager } from "./hooks/useAppViewManager.hook";

    // Checks for authentication and redirects to login if needed
    function ProtectedRoute() {
      const { isAuthenticated } = useAuthStore();
      const location = useLocation();
      if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
      }
      return <ComposedApp />; // ComposedApp is the layout for all protected routes
    }

    // A root component to apply global styles and effects
    function Root() {
      const isDarkMode = useAppShellStore((state) => state.isDarkMode);

      useEffect(() => {
        document.documentElement.classList.toggle("dark", isDarkMode);
      }, [isDarkMode]);

      return <Outlet />;
    }

    // Breadcrumbs for the Top Bar
    function AppBreadcrumbs() {
      const { currentActivePage } = useAppViewManager();
      const activePageName = currentActivePage.replace('-', ' ');

      return (
        <div className="hidden md:flex items-center gap-2 text-sm">
          <a
            href="#"
            className="text-muted-foreground hover:text-foreground transition-colors"
          >
            Home
          </a>
          <ChevronRight className="w-4 h-4 text-muted-foreground" />
          <span className="font-medium text-foreground capitalize">
            {activePageName}
          </span>
        </div>
      );
    }

    // Page-specific controls for the Top Bar
    function TopBarPageControls() {
      const { currentActivePage, filters, setFilters } = useAppViewManager();
      const [searchTerm, setSearchTerm] = React.useState('');
      const [isSearchFocused, setIsSearchFocused] = React.useState(false);

      if (currentActivePage === 'dashboard') {
        return (
          <div className="flex items-center gap-2 flex-1 justify-end">
            <div
              className={cn(
                "relative transition-all duration-300 ease-in-out",
                isSearchFocused ? "flex-1 max-w-lg" : "w-auto",
              )}
            >
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4 pointer-events-none" />
              <input
                type="text"
                placeholder="Search dashboard..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                onFocus={() => setIsSearchFocused(true)}
                onBlur={() => setIsSearchFocused(false)}
                className="pl-9 pr-4 py-2 h-10 border-none rounded-lg bg-card focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all duration-300 ease-in-out w-full"
              />
            </div>
            <Button variant="ghost" size="icon" className="flex-shrink-0">
              <Filter className="w-5 h-5" />
            </Button>
            <Button className="flex-shrink-0">
              <Plus className="w-5 h-5 mr-0 sm:mr-2" />
              <span className={cn(isSearchFocused ? "hidden sm:inline" : "inline")}>
                New Project
              </span>
            </Button>
          </div>
        );
      }

      if (currentActivePage === 'data-demo') {
        return (
          <div className="flex items-center gap-2">
            <div className="relative w-64">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground h-4 w-4" />
              <Input
                placeholder="Search items..."
                className="pl-9 bg-card border-none"
                value={filters.searchTerm}
                onChange={(e) => setFilters({ ...filters, searchTerm: e.target.value })}
              />
            </div>
            <Button variant="outline">
              <Filter className="w-4 h-4 mr-2" />
              Filter
            </Button>
            <Button>
              <Plus className="w-4 h-4 mr-2" />
              New Item
            </Button>
          </div>
        );
      }

      return null;
    }

    // The main App component that composes the shell
    function ComposedApp() {
      const { setBodyState, setSidePaneContent } = useAppShellStore.getState();
      const viewManager = useAppViewManager();
      const location = useLocation();
      const params = useParams();

      // Sync URL state with AppShellStore
      useEffect(() => {
        setBodyState(viewManager.bodyState);
        setSidePaneContent(viewManager.sidePaneContent);
      }, [viewManager.bodyState, viewManager.sidePaneContent, setBodyState, setSidePaneContent]);

      const rightViewId = useAppShellStore(s => s.sidePaneContent);

      // Determine mainViewId from the route path
      const pathSegments = location.pathname.split('/').filter(Boolean);
      let mainViewId: ViewId | null = (pathSegments[0] as ViewId) || 'dashboard';
      
      // Handle detail views that are part of the main content
      if (mainViewId === 'data-demo' && params.itemId) {
        mainViewId = 'dataItemDetail';
      }

      return (
        <AppShellProvider
          appName="Jeli App"
          appLogo={
            <div className="p-2 bg-primary/20 rounded-lg">
              <Rocket className="w-5 h-5 text-primary" />
            </div>
          }
        >
          <AppShell
            sidebar={<EnhancedSidebar />}
            onOverlayClick={viewManager.closeSidePane}
            topBar={
              <TopBar breadcrumbs={<AppBreadcrumbs />} pageControls={<TopBarPageControls />} />
            }
            mainContent={<MainContent viewId={mainViewId} />}
            rightPane={<RightPane viewId={rightViewId} />}
            commandPalette={<CommandPalette />}
          />
        </AppShellProvider>
      );
    }

    const router = createBrowserRouter([
        {
          element: <Root />,
          children: [
            {
              path: "/login",
              element: <LoginPage />,
            },
            {
              path: "/",
              element: <ProtectedRoute />,
              children: [
                {
                  // The ComposedApp layout will render the correct view based on the path
                  // so these elements can be null. The paths are still needed for matching.
                  { index: true, element: <Navigate to="/dashboard" replace /> },
                  { path: "dashboard", element: null },
                  { path: "settings", element: null },
                  { path: "toaster", element: null },
                  { path: "notifications", element: null },
                  { path: "data-demo", element: null },
                  { path: "data-demo/:itemId", element: null },
                  { path: "messaging", element: null },
                  { path: "messaging/:conversationId", element: null },
                ]
              ],
            },
          ],
        },
      ]);

    function App() {
      return (
        <ToasterProvider>
          <RouterProvider router={router} />
        </ToasterProvider>
      );
    }

    export default App;
  src/components/layout/EnhancedSidebar.tsx: >-
    import React from 'react';

    import {
      Home,
      Settings,
      HelpCircle,
      Component,
      Rocket,
      MoreHorizontal,
      Bell,
      Search,
      FileText,
      Star,
      Trash2,
      FolderOpen,
      Mail,
      Bookmark,
      Download,
      User,
      Plus,
      Database,
      PanelLeftClose,
      Inbox,
      UserX,
      CheckCircle2,
    } from 'lucide-react';

    import { useAppShellStore, type ActivePage } from '@/store/appShell.store';

    import {
      Workspaces,
      WorkspaceTrigger,
      WorkspaceContent,
      type Workspace,
    } from './WorkspaceSwitcher';

    import {
      DropdownMenu,
      DropdownMenuContent,
      DropdownMenuItem,
      DropdownMenuTrigger,
    } from '@/components/ui/dropdown-menu';

    import {
      Sidebar,
      SidebarContent,
      SidebarHeader,
      SidebarTitle,
      SidebarBody,
      SidebarFooter,
      SidebarSection,
      SidebarMenuItem,
      SidebarMenuButton,
      SidebarMenuAction,
      SidebarLabel,
      SidebarBadge,
      SidebarTooltip,
      SidebarIcon,
      useSidebar,
    } from './Sidebar';

    import { ViewModeSwitcher } from './ViewModeSwitcher';

    import { cn } from '@/lib/utils';

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook';


    interface MyWorkspace extends Workspace {
      logo: string;
      plan: string;
    }


    const mockWorkspaces: MyWorkspace[] = [
      { id: 'ws1', name: 'Acme Inc.', logo: 'https://avatar.vercel.sh/acme.png', plan: 'Pro' },
      { id: 'ws2', name: 'Monsters Inc.', logo: 'https://avatar.vercel.sh/monsters.png', plan: 'Free' },
      { id: 'ws3', name: 'Stark Industries', logo: 'https://avatar.vercel.sh/stark.png', plan: 'Enterprise' },
    ];


    const SidebarWorkspaceTrigger = () => {
      const { isCollapsed, compactMode } = useSidebar();

      return (
        <WorkspaceTrigger
          collapsed={isCollapsed}
          className={cn(
            'rounded-xl transition-colors hover:bg-accent/50 w-full',
            isCollapsed ? 'p-2' : 'p-3 bg-accent/50',
          )}
          avatarClassName={cn(compactMode ? 'h-8 w-8' : 'h-10 w-10')}
        />
      );
    };


    const SidebarToggleButton = () => {
      const { isCollapsed } = useSidebar();
      const { toggleSidebar } = useAppShellStore.getState();

      if (isCollapsed) return null;

      return (
        <button
          onClick={toggleSidebar}
          className="ml-auto h-9 w-9 flex items-center justify-center rounded-lg hover:bg-accent transition-colors"
          title="Collapse Sidebar"
        >
          <PanelLeftClose className="w-5 h-5" />
        </button>
      );
    };


    interface SidebarProps {
      onMouseEnter?: () => void;
      onMouseLeave?: () => void;
    }


    export const EnhancedSidebar = React.memo(React.forwardRef<HTMLDivElement,
    SidebarProps>(
      ({ onMouseEnter, onMouseLeave }, ref) => {
        const sidebarWidth = useAppShellStore(s => s.sidebarWidth);
        const compactMode = useAppShellStore(s => s.compactMode);
        const appName = useAppShellStore(s => s.appName);
        const appLogo = useAppShellStore(s => s.appLogo);
        const [selectedWorkspace, setSelectedWorkspace] = React.useState(mockWorkspaces[0]);
        return (
          <Sidebar
            ref={ref}
            style={{ width: sidebarWidth }}
            onMouseEnter={onMouseEnter}
            onMouseLeave={onMouseLeave}
          >
            <SidebarContent>
              <SidebarHeader>
                {appLogo || (
                  <div className="p-2 bg-primary/20 rounded-lg">
                    <Rocket className="w-5 h-5 text-primary" />
                  </div>
                )}
                <SidebarTitle>{appName}</SidebarTitle>
                <SidebarToggleButton />
              </SidebarHeader>

              <SidebarBody>
                <SidebarSection title="Main">
                  <AppMenuItem icon={Home} label="Dashboard" page="dashboard" />
                  <AppMenuItem icon={Database} label="Data Demo" page="data-demo"  />
                  <MessagingSidebarItems />
                  <AppMenuItem icon={Search} label="Search" />
                  <AppMenuItem icon={Bell} label="Notifications" badge={3} page="notifications" opensInSidePane />
                </SidebarSection>
                
                <SidebarSection title="Workspace" collapsible defaultExpanded>
                  <AppMenuItem icon={FileText} label="Documents" hasActions>
                    <AppMenuItem icon={FileText} label="Recent" isSubItem />
                    <AppMenuItem icon={Star} label="Starred" isSubItem />
                    <AppMenuItem icon={Trash2} label="Trash" isSubItem />
                  </AppMenuItem>
                  <AppMenuItem icon={FolderOpen} label="Projects" hasActions />
                  <AppMenuItem icon={Mail} label="Messages" badge={12} />
                </SidebarSection>
                
                <SidebarSection title="Personal" collapsible>
                  <AppMenuItem icon={Bookmark} label="Bookmarks" />
                  <AppMenuItem icon={Star} label="Favorites" />
                  <AppMenuItem icon={Download} label="Downloads" />
                </SidebarSection>

                <SidebarSection title="Components" collapsible defaultExpanded>
                  <AppMenuItem icon={Component} label="Toaster" page="toaster" />
                </SidebarSection>
              </SidebarBody>

              <SidebarFooter>
                <SidebarSection>
                  <AppMenuItem icon={User} label="Profile" />
                  <AppMenuItem icon={Settings} label="Settings" page="settings" />
                  <AppMenuItem icon={HelpCircle} label="Help" />
                </SidebarSection>

                <div className={cn(compactMode ? 'mt-4' : 'mt-6')}>
                  <Workspaces
                    workspaces={mockWorkspaces}
                    selectedWorkspaceId={selectedWorkspace.id}
                    onWorkspaceChange={(ws) => setSelectedWorkspace(ws as MyWorkspace)}
                  >
                    <SidebarWorkspaceTrigger />
                    <WorkspaceContent>
                      <button className="flex w-full items-center gap-2 rounded-sm px-2 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground focus:outline-none">
                        <Plus className="h-4 w-4" />
                        <span>Create Workspace</span>
                      </button>
                    </WorkspaceContent>
                  </Workspaces>
                </div>
              </SidebarFooter>
            </SidebarContent>
          </Sidebar>
        );
      },
    ));

    EnhancedSidebar.displayName = 'EnhancedSidebar';



    // Example of a reusable menu item component built with the new Sidebar
    primitives

    interface AppMenuItemProps {
      icon: React.ElementType;
      label: string;
      badge?: number;
      hasActions?: boolean;
      children?: React.ReactNode;
      isSubItem?: boolean;
      page?: ActivePage;
      opensInSidePane?: boolean;
      onClick?: () => void;
      isActive?: boolean;
    }


    const AppMenuItem: React.FC<AppMenuItemProps> = ({ icon: Icon, label, badge,
    hasActions, children, isSubItem = false, page, opensInSidePane = false,
    onClick, isActive: isActiveProp }) => {
      const compactMode = useAppShellStore(state => state.compactMode);
      const { setDraggedPage, setDragHoverTarget } = useAppShellStore.getState()
      const { isCollapsed } = useSidebar();
      const viewManager = useAppViewManager();

      const calculatedIsActive = (
        (!opensInSidePane && page && viewManager.currentActivePage === page)
      ) || (
        opensInSidePane && page === 'notifications' && viewManager.sidePaneContent === 'notifications'
      );

      const isActive = isActiveProp ?? calculatedIsActive;

      const handleClick = () => {
        if (onClick) {
          onClick();
          return;
        }
        if (page) {
          if (opensInSidePane) {
            // The only item using this is Notifications
            viewManager.toggleSidePane('notifications');
          } else {
            viewManager.navigateTo(page);
          }
        }
      };

      return (
        <div className={isSubItem ? (compactMode ? 'ml-4' : 'ml-6') : ''}>
          <SidebarMenuItem>
            <SidebarMenuButton
              onClick={handleClick}
              isActive={isActive}
              draggable={!!page}
              onDragStart={(_e) => {
                if (page) {
                  // set dragged page in AppShell store
                  setDraggedPage(page);
                }
              }}
              onDragEnd={() => {
                setDraggedPage(null);
                setDragHoverTarget(null);
              }}
            >
              <SidebarIcon>
                <Icon className={isSubItem ? "w-3 h-3" : "w-4 h-4"}/>
              </SidebarIcon>
              <SidebarLabel>{label}</SidebarLabel>
              {badge && <SidebarBadge>{badge}</SidebarBadge>}
              <SidebarTooltip label={label} badge={badge} />
            </SidebarMenuButton>

            {page && !isCollapsed && ( // Always render switcher if there's a page
              <div className={cn(
                "absolute top-1/2 -translate-y-1/2 z-10",
                "opacity-0 group-hover/item:opacity-100 group-focus-within/item:opacity-100",
                "transition-opacity pointer-events-none group-hover/item:pointer-events-auto",
                // If there are actions, move left to make space for the action button
                hasActions ? "right-10" : "right-2"
              )}>
                <ViewModeSwitcher targetPage={page} />
              </div>
            )}

            {hasActions && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <SidebarMenuAction>
                    <MoreHorizontal className="h-4 w-4" />
                  </SidebarMenuAction>
                </DropdownMenuTrigger>
                <DropdownMenuContent side="right" align="start">
                  <DropdownMenuItem>
                    <span>Edit {label}</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem>
                    <span>Delete {label}</span>
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </SidebarMenuItem>
          {!isCollapsed && children && (
            <div className="space-y-1 mt-1">{children}</div>
          )}
        </div>
      );
    };


    const MessagingSidebarItems = () => {
      const { currentActivePage, messagingView, navigateTo } = useAppViewManager();
      const totalUnread = 7; // Mock data, could come from a store

      return (
        <AppMenuItem
          icon={Mail}
          label="Messaging"
          badge={totalUnread}
          page="messaging"
          isActive={currentActivePage === 'messaging'}
          onClick={() => navigateTo('messaging', { messagingView: 'all_open' })}
        >
          <AppMenuItem
            icon={Inbox}
            label="All Open"
            isSubItem
            page="messaging"
            isActive={currentActivePage === 'messaging' && (messagingView === 'all_open' || !messagingView)}
            onClick={() => navigateTo('messaging', { messagingView: 'all_open' })}
          />
          <AppMenuItem
            icon={UserX}
            label="Unassigned"
            isSubItem
            page="messaging"
            isActive={currentActivePage === 'messaging' && messagingView === 'unassigned'}
            onClick={() => navigateTo('messaging', { messagingView: 'unassigned' })}
          />
          <AppMenuItem
            icon={CheckCircle2}
            label="Done"
            isSubItem
            page="messaging"
            isActive={currentActivePage === 'messaging' && messagingView === 'done'}
            onClick={() => navigateTo('messaging', { messagingView: 'done' })}
          />
        </AppMenuItem>
      );
    };
  src/components/layout/ViewModeSwitcher.tsx: >-
    import { useState, useRef, useEffect } from 'react';

    import { gsap } from 'gsap';

    import { cn } from '@/lib/utils'

    import { useAppShellStore, type AppShellState } from
    '@/store/appShell.store'

    import { BODY_STATES } from '@/lib/utils'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import {
      Columns,
      PanelRightOpen,
      SplitSquareHorizontal,
      Maximize,
      Minimize,
      Layers,
      X,
      ArrowLeftRight
    } from 'lucide-react'


    export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
    'right', targetPage?: string }) {
      const bodyState = useAppShellStore(s => s.bodyState);
      const fullscreenTarget = useAppShellStore(s => s.fullscreenTarget);
      const { toggleFullscreen } = useAppShellStore.getState();
      const {
        currentActivePage,
        toggleSidePane,
        toggleSplitView,
        setNormalView,
        navigateTo,
        switchSplitPanes,
        closeSplitPane,
      } = useAppViewManager();

      const activePage = targetPage || currentActivePage;
      const [isExpanded, setIsExpanded] = useState(false);
      const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isThisPaneFullscreen = isFullscreen && (
        (pane === 'main' && fullscreenTarget !== 'right') ||
        (pane === 'right' && fullscreenTarget === 'right') ||
        (!pane && !fullscreenTarget) // Global switcher, global fullscreen
      );

      useEffect(() => {
        const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
        if (buttonsToAnimate.length === 0) return;

        gsap.killTweensOf(buttonsToAnimate);

        if (isExpanded) {
            gsap.to(buttonsToAnimate, {
                width: 32, // h-8 w-8
                opacity: 1,
                pointerEvents: 'auto',
                marginLeft: 4, // from gap-1 in original
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'start'
                },
                ease: 'power2.out'
            });
        } else {
            gsap.to(buttonsToAnimate, {
                width: 0,
                opacity: 0,
                pointerEvents: 'none',
                marginLeft: 0,
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'end'
                },
                ease: 'power2.in'
            });
        }
      }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

      const handlePaneClick = (type: 'side-pane' | 'split-view') => {
        const pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {
          dashboard: 'main', settings: 'settings', toaster: 'toaster', notifications: 'notifications', 'data-demo': 'dataDemo',
          messaging: 'messaging',
        };
        const basePage = activePage.split('/')[0];
        const paneContent = pageToPaneMap[basePage];
        if (type === 'side-pane') toggleSidePane(paneContent);
        else toggleSplitView();
      }

      const handleNormalViewClick = () => {
        if (isFullscreen) {
          toggleFullscreen();
        }
        if (targetPage && targetPage !== currentActivePage) {
          navigateTo(targetPage);
        } else {
          setNormalView();
        }
      }

      const buttons = [
        {
          id: 'normal',
          onClick: handleNormalViewClick,
          active: bodyState === BODY_STATES.NORMAL,
          title: "Normal View",
          icon: <Columns className="w-4 h-4" />
        },
        {
          id: 'side-pane',
          onClick: () => handlePaneClick('side-pane'),
          active: bodyState === BODY_STATES.SIDE_PANE,
          title: "Side Pane View",
          icon: <PanelRightOpen className="w-4 h-4" />
        },
        {
          id: 'split-view',
          onClick: () => handlePaneClick('split-view'),
          active: bodyState === BODY_STATES.SPLIT_VIEW,
          title: bodyState === BODY_STATES.SPLIT_VIEW ? 'Switch to Overlay View' : 'Switch to Split View',
          icon: bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-4 h-4" /> : <SplitSquareHorizontal className="w-4 h-4" />
        },
        {
          id: 'fullscreen',
          onClick: () => {
            if (targetPage && targetPage !== currentActivePage ) {
              navigateTo(targetPage);
              setTimeout(() => toggleFullscreen(pane), 50);
            } else {
              toggleFullscreen(pane);
            }
          },
          active: isThisPaneFullscreen,
          title: "Toggle Fullscreen",
          icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
        }
      ];

      if (bodyState === BODY_STATES.SPLIT_VIEW) {
        buttons.push({
          id: 'switch',
          onClick: switchSplitPanes,
          active: false,
          title: "Switch Panes",
          icon: <ArrowLeftRight className="w-4 h-4" />
        });
        buttons.push({
          id: 'close',
          onClick: () => closeSplitPane(pane || 'right'),
          active: false,
          title: "Close Pane",
          icon: <X className="w-4 h-4 text-muted-foreground group-hover:text-destructive" />
        });
      }

      return (
        <div
          onMouseEnter={() => setIsExpanded(true)}
          onMouseLeave={() => setIsExpanded(false)}
          className="flex items-center gap-0 p-1 bg-card rounded-full border border-border"
        >
            <button
                className='h-8 w-8 flex-shrink-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors'
                title="View Modes"
                onClick={() => setIsExpanded(!isExpanded)}
            >
                <Layers className="w-4 h-4" />
            </button>
          
          {buttons.map((btn, index) => (
            <button
              key={btn.id}
              ref={el => buttonRefs.current[index] = el}
              onClick={btn.onClick}
              className={cn(
                'h-8 w-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors group opacity-0',
                btn.active && 'bg-accent text-accent-foreground',
                btn.id === 'close' && 'hover:bg-destructive/20'
              )}
              style={{ pointerEvents: 'none', marginLeft: 0, overflow: 'hidden' }}
              title={btn.title}
            >
              {btn.icon}
            </button>
          ))}
        </div>
      )
    }
  src/pages/Notifications/index.tsx: >-
    import React from "react";

    import { Avatar, AvatarFallback, AvatarImage } from
    "@/components/ui/avatar";

    import { Badge } from "@/components/ui/badge";

    import { Button } from "@/components/ui/button";

    import { Card, CardContent, CardHeader } from "@/components/ui/card";

    import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";

    import { PageHeader } from "@/components/shared/PageHeader";

    import { useToast } from "@/components/ui/toast";

    import { cn } from "@/lib/utils";

    import { 
      CheckCheck, 
      Download, 
      Settings, 
      Bell,
      MessageSquare,
      UserPlus,
      Mail,
      File as FileIcon,
      Heart,
      AtSign,
      ClipboardCheck,
      ShieldCheck,
    } from "lucide-react";

    import { useAppShellStore } from "@/store/appShell.store";

    import { BODY_STATES } from "@/lib/utils";


    import { PageLayout } from "@/components/shared/PageLayout";

    import { 
      useNotificationsStore,
      useFilteredNotifications,
      useNotificationCounts,
      type Notification
    } from "./notifications.store";


    const iconMap: { [key: string]: React.ElementType } = {
      comment: MessageSquare,
      follow: UserPlus,
      invitation: Mail,
      file_share: FileIcon,
      mention: AtSign,
      like: Heart,
      task_assignment: ClipboardCheck,
      system_update: ShieldCheck,
    };


    function NotificationItem({ notification }: { notification: Notification; })
    {
      const markAsRead = useNotificationsStore(s => s.markAsRead);
      const Icon = iconMap[notification.type];

      return (
        <div className={cn(
          "group w-full p-4 hover:bg-accent/50 rounded-lg transition-colors duration-200"
        )}>
          <div className="flex gap-3">
            <div className="relative h-10 w-10 shrink-0">
              <Avatar className="h-10 w-10">
                <AvatarImage src={notification.user.avatar} alt={`${notification.user.name}'s profile picture`} />
                <AvatarFallback>{notification.user.fallback}</AvatarFallback>
              </Avatar>
              {Icon && (
                <div className="absolute -bottom-1 -right-1 flex h-5 w-5 items-center justify-center rounded-full border-2 border-card bg-background">
                  <Icon className={cn("h-3 w-3", notification.type === 'like' ? 'text-red-500 fill-current' : 'text-muted-foreground')} />
                </div>
              )}
            </div>

            <div className="flex flex-1 flex-col space-y-2">
              <div className="flex items-start justify-between">
                <div className="text-sm">
                  <span className="font-semibold">{notification.user.name}</span>
                  <span className="text-muted-foreground"> {notification.action} </span>
                  {notification.target && <span className="font-semibold">{notification.target}</span>}
                  <div className="mt-0.5 text-xs text-muted-foreground">{notification.timeAgo}</div>
                </div>
                <button
                  onClick={() => !notification.isRead && markAsRead(notification.id)}
                  title={notification.isRead ? "Read" : "Mark as read"}
                  className={cn("size-2.5 rounded-full mt-1 shrink-0 transition-all duration-300",
                    notification.isRead ? 'bg-transparent' : 'bg-primary hover:scale-125 cursor-pointer'
                  )}
                ></button>
              </div>

              {notification.content && <div className="rounded-lg border bg-muted/50 p-3 text-sm">{notification.content}</div>}

              {notification.file && (
                <div className="flex items-center gap-2 rounded-lg bg-muted/50 p-2 border border-border">
                  <div className="shrink-0 w-10 h-10 flex items-center justify-center bg-background rounded-md border border-border">
                    <FileIcon className="w-5 h-5 text-muted-foreground" />
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="text-sm font-medium truncate">{notification.file.name}</div>
                    <div className="text-xs text-muted-foreground">{notification.file.type}  {notification.file.size}</div>
                  </div>
                  <Button variant="ghost" size="icon" className="size-8 shrink-0">
                    <Download className="w-4 h-4" />
                  </Button>
                </div>
              )}

              {notification.hasActions && (
                <div className="flex gap-2">
                  <Button variant="outline" size="sm">Decline</Button>
                  <Button size="sm">Accept</Button>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }


    export function NotificationsPage() {
      const bodyState = useAppShellStore(s => s.bodyState);
      const isInSidePane = bodyState === BODY_STATES.SIDE_PANE;
      
      const { activeTab, setActiveTab, markAllAsRead } = useNotificationsStore(s => ({ activeTab: s.activeTab, setActiveTab: s.setActiveTab, markAllAsRead: s.markAllAsRead }));
      const filteredNotifications = useFilteredNotifications();
      const { unreadCount, verifiedCount, mentionCount } = useNotificationCounts();
      const { show: showToast } = useToast();

      const handleMarkAllAsRead = () => {
        const count = markAllAsRead();
        if (count === 0) {
          showToast({
            title: "Already up to date!",
            message: "You have no unread notifications.",
            variant: "default",
          });
          return;
        }
        showToast({
            title: "All Caught Up!",
            message: "All notifications have been marked as read.",
            variant: "success",
        });
      };

      const content = (
        <Card className={cn("flex w-full flex-col shadow-none", isInSidePane ? "border-none" : "")}>
          <CardHeader className={cn(isInSidePane ? "p-4" : "p-6")}>
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-semibold">
                Your notifications
              </h3>
              <div className="flex items-center gap-1">
                <Button variant="ghost" size="icon" className="size-8" onClick={handleMarkAllAsRead} title="Mark all as read">
                  <CheckCheck className="size-4 text-muted-foreground" />
                </Button>
                <Button variant="ghost" size="icon" className="size-8">
                  <Settings className="size-4 text-muted-foreground" />
                </Button>
              </div>
            </div>

            <Tabs value={activeTab} onValueChange={(val) => setActiveTab(val as 'all' | 'verified' | 'mentions')} className="w-full flex-col justify-start mt-4">
              <TabsList className="gap-1.5">
                <TabsTrigger value="all" className="gap-1.5">
                  View all {unreadCount > 0 && <Badge variant="secondary" className="rounded-full">{unreadCount}</Badge>}
                </TabsTrigger>
                <TabsTrigger value="verified" className="gap-1.5">
                  Verified {verifiedCount > 0 && <Badge variant="secondary" className="rounded-full">{verifiedCount}</Badge>}
                </TabsTrigger>
                <TabsTrigger value="mentions" className="gap-1.5">
                  Mentions {mentionCount > 0 && <Badge variant="secondary" className="rounded-full">{mentionCount}</Badge>}
                </TabsTrigger>
              </TabsList>
            </Tabs>
          </CardHeader>

          <CardContent className={cn("h-full p-0", isInSidePane ? "px-2" : "px-6")}>
            <div className="space-y-2 divide-y divide-border">
              {filteredNotifications.length > 0 ? (
                filteredNotifications.map((notification) => (
                  <NotificationItem key={notification.id} notification={notification} />
                ))
              ) : (
                <div className="flex flex-col items-center justify-center space-y-2.5 py-12 text-center">
                  <div className="rounded-full bg-muted p-4">
                    <Bell className="text-muted-foreground" />
                  </div>
                  <p className="text-sm font-medium text-muted-foreground">No notifications yet.</p>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      );

      return (
        <PageLayout>
          {!isInSidePane && (
            <PageHeader
              title="Notifications"
              description="Manage your notifications and stay up-to-date."
            />
          )}
          {content}
        </PageLayout>
      );
    }
  src/pages/ToasterDemo/index.tsx: >-
    import { Button } from '@/components/ui/button';

    import { useToast } from '@/components/ui/toast';

    import { PageHeader } from '@/components/shared/PageHeader';

    import { PageLayout } from '@/components/shared/PageLayout';

    import { useAppShellStore } from '@/store/appShell.store';

    import { cn, BODY_STATES } from '@/lib/utils';


    type Variant = 'default' | 'success' | 'error' | 'warning';

    type Position =
      | 'top-left'
      | 'top-center'
      | 'top-right'
      | 'bottom-left'
      | 'bottom-center'
      | 'bottom-right';

    const variantColors = {
      default: 'border-border text-foreground hover:bg-muted/10 dark:hover:bg-muted/20',
      success: 'border-green-600 text-green-600 hover:bg-green-600/10 dark:hover:bg-green-400/20',
      error: 'border-destructive text-destructive hover:bg-destructive/10 dark:hover:bg-destructive/20',
      warning: 'border-amber-600 text-amber-600 hover:bg-amber-600/10 dark:hover:bg-amber-400/20',
    }


    const DemoSection: React.FC<{ title: string; children: React.ReactNode }> =
    ({
      title,
      children,
    }) => (
      <section>
        <h2 className="text-lg font-semibold mb-2">{title}</h2>
        {children}
      </section>
    );


    export function ToasterDemo() {
      const toast = useToast();
      const bodyState = useAppShellStore(s => s.bodyState);
      const isInSidePane = bodyState === BODY_STATES.SIDE_PANE;

      const showToast = (variant: Variant, position: Position = 'bottom-right') => {
        toast.show({
          title: `${variant.charAt(0).toUpperCase() + variant.slice(1)} Notification`,
          message: `This is a ${variant} toast notification.`,
          variant,
          position,
          duration: 3000,
          onDismiss: () =>
            console.log(`${variant} toast at ${position} dismissed`),
        });
      };

      const simulateApiCall = async () => {
        toast.show({
          title: 'Scheduling...',
          message: 'Please wait while we schedule your meeting.',
          variant: 'default',
          position: 'bottom-right',
        });

        try {
          await new Promise((resolve) => setTimeout(resolve, 2000));

          toast.show({
            title: 'Meeting Scheduled',
            message: 'Your meeting is scheduled for July 4, 2025, at 3:42 PM IST.',
            variant: 'success',
            position: 'bottom-right',
            highlightTitle: true,
            actions: {
              label: 'Undo',
              onClick: () => console.log('Undoing meeting schedule'),
              variant: 'outline',
            },
          });
        } catch (error) {
          toast.show({
            title: 'Error Scheduling Meeting',
            message: 'Failed to schedule the meeting. Please try again.',
            variant: 'error',
            position: 'bottom-right',
          });
        }
      };

      return (
        <PageLayout>
          {/* Header */}
          {!isInSidePane && (
            <PageHeader
              title="Toaster"
              description="A customizable toast component for notifications."
            />
          )}
          <div className="space-y-6">
            <DemoSection title="Toast Variants">
              <div className="flex flex-wrap gap-4">
                {(['default', 'success', 'error', 'warning'] as Variant[]).map((variantKey) => (
                  <Button
                    key={variantKey}
                    variant="outline"
                    onClick={() => showToast(variantKey as Variant)}
                    className={cn(variantColors[variantKey])}
                  >
                    {variantKey.charAt(0).toUpperCase() + variantKey.slice(1)} Toast
                  </Button>
                ))}
              </div>
            </DemoSection>

            <DemoSection title="Toast Positions">
              <div className="flex flex-wrap gap-4">
                {[
                  'top-left',
                  'top-center',
                  'top-right',
                  'bottom-left',
                  'bottom-center',
                  'bottom-right',
                ].map((positionKey) => (
                  <Button
                    key={positionKey}
                    variant="outline"
                    onClick={() =>
                      showToast('default', positionKey as Position)
                    }
                    className="border-border text-foreground hover:bg-muted/10 dark:hover:bg-muted/20"
                  >
                    {positionKey
                      .replace('-', ' ')
                      .replace(/\b\w/g, (char) => char.toUpperCase())}
                  </Button>
                ))}
              </div>
            </DemoSection>

            <DemoSection title="Real-World Example">
              <Button
                variant="outline"
                onClick={simulateApiCall}
                className="border-border text-foreground hover:bg-muted/10 dark:hover:bg-muted/20"
              >
                Schedule Meeting
              </Button>
            </DemoSection>
          </div>
        </PageLayout>
      );
    }
  src/pages/Dashboard/index.tsx: >-
    import { useRef, useCallback } from 'react'

    import {
      BarChart3, 
      TrendingUp, 
      Users, 
      DollarSign, 
      Activity,
      Calendar,
      Clock,
      MessageSquare,
      FileText,
      Star,
      ChevronRight,
      MoreVertical
    } from 'lucide-react'

    import { cn } from '@/lib/utils'

    import { DemoContent } from './DemoContent';

    import { useDashboardAnimations } from
    './hooks/useDashboardAnimations.motion.hook'

    import { useAutoAnimateTopBar } from '@/hooks/useAutoAnimateTopBar';

    import { useScrollToBottom } from '@/hooks/useScrollToBottom.hook';

    import { useAppShellStore } from '@/store/appShell.store'

    import { BODY_STATES } from '@/lib/utils'

    import { PageHeader } from '@/components/shared/PageHeader';

    import { ScrollToBottomButton } from
    '@/components/shared/ScrollToBottomButton';

    import { StatCard } from '@/components/shared/StatCard';

    import { Card } from '@/components/ui/card';

    import { PageLayout } from '@/components/shared/PageLayout';


    interface StatsCard {
      title: string
      value: string
      change: string
      trend: 'up' | 'down'
      icon: React.ReactNode
    }


    interface ActivityItem {
      id: string
      type: 'comment' | 'file' | 'meeting' | 'task'
      title: string
      description: string
      time: string
      user: string
    }


    const statsCards: StatsCard[] = [
      {
        title: "Total Revenue",
        value: "$45,231.89",
        change: "+20.1%",
        trend: "up",
        icon: <DollarSign className="w-5 h-5" />
      },
      {
        title: "Active Users",
        value: "2,350",
        change: "+180.1%",
        trend: "up",
        icon: <Users className="w-5 h-5" />
      },
      {
        title: "Conversion Rate",
        value: "12.5%",
        change: "+19%",
        trend: "up",
        icon: <TrendingUp className="w-5 h-5" />
      },
      {
        title: "Performance",
        value: "573ms",
        change: "-5.3%",
        trend: "down",
        icon: <Activity className="w-5 h-5" />
      }
    ]


    const recentActivity: ActivityItem[] = [
      {
        id: "1",
        type: "comment",
        title: "New comment on Project Alpha",
        description: "Sarah Johnson added a comment to the design review",
        time: "2 minutes ago",
        user: "SJ"
      },
      {
        id: "2",
        type: "file",
        title: "Document uploaded",
        description: "quarterly-report.pdf was uploaded to Documents",
        time: "15 minutes ago",
        user: "MD"
      },
      {
        id: "3",
        type: "meeting",
        title: "Meeting scheduled",
        description: "Weekly standup meeting scheduled for tomorrow 9 AM",
        time: "1 hour ago",
        user: "RW"
      },
      {
        id: "4",
        type: "task",
        title: "Task completed",
        description: "UI wireframes for mobile app completed",
        time: "2 hours ago",
        user: "AL"
      }
    ]


    export function DashboardContent() {
        const scrollRef = useRef<HTMLDivElement>(null)
        const contentRef = useRef<HTMLDivElement>(null);
        const statsCardsContainerRef = useRef<HTMLDivElement>(null);
        const featureCardsContainerRef = useRef<HTMLDivElement>(null);
        const bodyState = useAppShellStore(s => s.bodyState);
        const isInSidePane = bodyState === BODY_STATES.SIDE_PANE;
        
        const { onScroll: handleTopBarScroll } = useAutoAnimateTopBar(isInSidePane);
        const { showScrollToBottom, scrollToBottom, handleScroll: handleScrollToBottom } = useScrollToBottom(scrollRef);

        const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
            handleTopBarScroll(e);
            handleScrollToBottom();
        }, [handleTopBarScroll, handleScrollToBottom]);

        useDashboardAnimations(contentRef, statsCardsContainerRef, featureCardsContainerRef);

        const getTypeIcon = (type: ActivityItem['type']) => {
          switch (type) {
            case 'comment':
              return <MessageSquare className="w-4 h-4" />
            case 'file':
              return <FileText className="w-4 h-4" />
            case 'meeting':
              return <Calendar className="w-4 h-4" />
            case 'task':
              return <Star className="w-4 h-4" />
            default:
              return <Activity className="w-4 h-4" />
          }
        }

        return (
          <PageLayout scrollRef={scrollRef} onScroll={handleScroll} ref={contentRef}>
            {/* Header */}
            {!isInSidePane && (
              <PageHeader
                title="Dashboard"
                description="Welcome to the Jeli App Shell demo! Explore all the features and customization options."
              />
            )}
              {/* Stats Cards */}
            <div ref={statsCardsContainerRef} className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
              {statsCards.map((stat) => (
                <StatCard
                  key={stat.title}
                  title={stat.title}
                  value={stat.value}
                  change={stat.change}
                  trend={stat.trend}
                  icon={stat.icon}
                />
              ))}
            </div>

            {/* Demo Content */}
            <DemoContent ref={featureCardsContainerRef} />

            {/* Main Content Grid */}
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Chart Area */}
            <div className="lg:col-span-2 space-y-6">
              {/* Analytics Chart */}
              <Card className="p-6 border-border/50">
                <div className="flex items-center justify-between mb-6">
                  <h3 className="text-lg font-semibold">Analytics Overview</h3>
                  <button className="h-8 w-8 flex items-center justify-center hover:bg-accent rounded-full transition-colors">
                    <MoreVertical className="w-5 h-5" />
                  </button>
                </div>
                
                {/* Mock Chart */}
                <div className="h-64 bg-gradient-to-br from-primary/10 to-transparent rounded-xl flex items-center justify-center border border-border/50">
                  <div className="text-center">
                    <BarChart3 className="w-12 h-12 text-primary mx-auto mb-2" />
                    <p className="text-muted-foreground">Chart visualization would go here</p>
                  </div>
                </div>
              </Card>

              {/* Recent Projects */}
              <Card className="p-6 border-border/50">
                <div className="flex items-center justify-between mb-6">
                  <h3 className="text-lg font-semibold">Recent Projects</h3>
                  <button className="text-primary hover:text-primary/80 text-sm font-medium flex items-center gap-1">
                    View All
                    <ChevronRight className="w-4 h-4" />
                  </button>
                </div>
                
                <div className="space-y-4">
                  {[
                    { name: "E-commerce Platform", progress: 75, team: 5, deadline: "Dec 15" },
                    { name: "Mobile App Redesign", progress: 45, team: 3, deadline: "Jan 20" },
                    { name: "Marketing Website", progress: 90, team: 4, deadline: "Dec 5" }
                  ].map((project) => (
                    <div key={project.name} className="p-4 bg-accent/30 rounded-xl hover:bg-accent/50 transition-colors cursor-pointer">
                      <div className="flex items-center justify-between mb-2">
                        <h4 className="font-medium">{project.name}</h4>
                        <span className="text-sm text-muted-foreground">{project.progress}%</span>
                      </div>
                      <div className="w-full bg-muted rounded-full h-2 mb-3">
                        <div 
                          className="bg-primary h-2 rounded-full transition-all duration-500"
                          style={{ width: `${project.progress}%` }}
                        />
                      </div>
                      <div className="flex items-center justify-between text-sm text-muted-foreground">
                        <span>{project.team} team members</span>
                        <span>Due {project.deadline}</span>
                        </div>
                    </div>
                  ))}
                </div>
              </Card>
            </div>

            {/* Sidebar Content */}
            <div className="space-y-6">
              {/* Quick Actions */}
              <Card className="p-6 border-border/50">
                <h3 className="text-lg font-semibold mb-4">Quick Actions</h3>
                <div className="space-y-3">
                  {[
                    { icon: <FileText className="w-4 h-4" />, label: "Create Document", color: "bg-blue-500/10 text-blue-600" },
                    { icon: <Calendar className="w-4 h-4" />, label: "Schedule Meeting", color: "bg-green-500/10 text-green-600" },
                    { icon: <Users className="w-4 h-4" />, label: "Invite Team", color: "bg-purple-500/10 text-purple-600" },
                    { icon: <BarChart3 className="w-4 h-4" />, label: "View Reports", color: "bg-orange-500/10 text-orange-600" }
                  ].map((action) => (
                    <button
                      key={action.label}
                      className="w-full flex items-center gap-3 p-3 hover:bg-accent rounded-lg transition-colors text-left"
                    >
                      <div className={cn("p-2 rounded-full", action.color)}>
                        {action.icon}
                      </div>
                      <span className="font-medium">{action.label}</span>
                    </button>
                  ))}
                </div>
              </Card>

              {/* Recent Activity */}
              <Card className="p-6 border-border/50">
                <h3 className="text-lg font-semibold mb-4">Recent Activity</h3>
                <div className="space-y-4">
                  {recentActivity.map((activity) => (
                    <div key={activity.id} className="flex items-start gap-3 p-3 hover:bg-accent/30 rounded-xl transition-colors cursor-pointer">
                      <div className="p-2 bg-primary/10 rounded-full flex-shrink-0">
                        {getTypeIcon(activity.type)}
                      </div>
                      <div className="flex-1 min-w-0">
                        <h4 className="font-medium text-sm mb-1">{activity.title}</h4>
                        <p className="text-xs text-muted-foreground mb-2">{activity.description}</p>
                        <div className="flex items-center gap-2 text-xs text-muted-foreground">
                          <Clock className="w-3 h-3" />
                          <span>{activity.time}</span>
                          <div className="w-5 h-5 bg-primary rounded-full flex items-center justify-center text-primary-foreground text-xs font-medium">
                            {activity.user}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </Card>
            </div>
          </div>
          <ScrollToBottomButton isVisible={showScrollToBottom} onClick={scrollToBottom} />
          </PageLayout>
        )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 576
