uuid: 42168340-0255-46aa-a82d-8b63e813f381
projectId: jeli-app-shell
createdAt: '2025-10-17T23:23:25.480Z'
gitCommitMsg: >-
  feat(DataDemo): Enhance Kanban view with grouping and horizontal scroll

  - Implemented horizontal scrolling for the Kanban view to better handle
  numerous grouped columns. Columns now have a fixed width and the container
  overflows horizontally. - Added the "Group by" dropdown selector to the Kanban
  view, making its functionality consistent with other view modes. Users can now
  change the data grouping directly within the Kanban interface.
promptSummary: >-
  The user wants to add a grouping selector to the Kanban view and make it
  horizontally scrollable.
reasoning:
  - Here are the modifications to implement the requested changes.
  - '### Rationale'
  - >-
    1.  **Kanban View Horizontal Scrolling:** To accommodate a large number of
    groups, the Kanban view needs to be horizontally scrollable.
  - >-
    *   In `src/pages/DataDemo/components/DataKanbanView.tsx`, I'll change the
    main container from a responsive grid (`grid grid-cols-1 md:grid-cols-2
    xl:grid-cols-4`) to a flexbox layout (`flex overflow-x-auto`).
  - >-
    *   Each Kanban column will be given a fixed width (`w-80`) and prevented
    from shrinking (`flex-shrink-0`) to ensure a consistent layout as the
    container scrolls.
  - >-
    *   I've added negative horizontal margins (`-mx-6`) and positive horizontal
    padding (`px-6`) to the container. This makes the scrollable area extend to
    the edges of the parent `PageLayout`, providing a better user experience.
  - >-
    2.  **Kanban View Grouping Selector:** The "Group by" dropdown was not
    visible when in Kanban mode.
  - >-
    *   In `src/pages/DataDemo/index.tsx`, I've adjusted the conditional
    rendering logic.
  - >-
    *   When `viewMode` is `'kanban'`, it will now consistently render a header
    area containing the `GroupByDropdown` component.
  - >-
    *   Below the dropdown, the component will render the `DataKanbanView` if
    data is grouped, or a message prompting the user to select a grouping option
    if it's not. This makes the Kanban view's behavior consistent with other
    view modes.
  - '### Code Changes'
  - >-
    First, I'll modify the `DataKanbanView` component to support horizontal
    scrolling.
  - >-
    Next, I'll update the main `DataDemoPage` component to include the grouping
    selector for the Kanban view.
  - >-
    These changes together fulfill the request to make the Kanban view more
    flexible and consistent with other data views.
operations:
  - type: write
    path: src/pages/DataDemo/components/DataKanbanView.tsx
    content: >+
      --- src/pages/DataDemo/components/DataKanbanView.tsx

      +++ src/pages/DataDemo/components/DataKanbanView.tsx

      @@ -213,14 +213,14 @@
         };
       
         return (
      -    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4
      items-start gap-6 pb-4">

      +    <div className="flex items-start gap-6 pb-4 overflow-x-auto -mx-6
      px-6">
             {Object.entries(columns).map(([columnId, items]) => (
               <div
                 key={columnId}
                 onDragOver={handleDragOver}
                 onDrop={(e) => handleDrop(e, columnId)}
                 onDragEnter={() => handleDragEnter(columnId)}
                 onDragLeave={() => setDragOverColumn(null)}
                 className={cn(
      -            "bg-card/20 dark:bg-neutral-900/20 backdrop-blur-xl
      rounded-3xl p-5 border border-border dark:border-neutral-700/50
      transition-all duration-300",

      +            "w-80 flex-shrink-0 bg-card/20 dark:bg-neutral-900/20
      backdrop-blur-xl rounded-3xl p-5 border border-border
      dark:border-neutral-700/50 transition-all duration-300",
                   dragOverColumn === columnId && "bg-primary/10 border-primary/30"
                 )}
               >

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >+
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ -293,9 +293,20 @@
               <div className="min-h-[500px]">
                 {isInitialLoading 
                   ? <AnimatedLoadingSkeleton viewMode={viewMode} /> 
                   : viewMode === 'kanban' ? (
      -              isGroupedView ? <DataKanbanView data={groupedData} /> :
      <div className="flex items-center justify-center h-96
      text-muted-foreground">Group data by a metric to use the Kanban
      view.</div>

      -            ) : !isGroupedView ? (

      +              <>

      +                <div className="flex items-center justify-end gap-4
      h-[68px]">

      +                  <GroupByDropdown />

      +                </div>

      +                {isGroupedView ? (

      +                  <DataKanbanView data={groupedData} />

      +                ) : (

      +                  <div className="flex items-center justify-center h-96
      text-muted-foreground">

      +                    Group data by a metric to use the Kanban view.

      +                  </div>

      +                )}

      +              </>

      +            )

      +            : !isGroupedView ? (
                     // Not grouped view
                     <>
                       <div className="flex items-center justify-between gap-4 h-[68px]">

    patchStrategy: standard-diff
snapshot:
  src/pages/DataDemo/index.tsx: >
    import { useRef, useEffect, useCallback, useMemo } from 'react'

    import {
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      TrendingUp,
      Loader2,
      ChevronsUpDown
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { cn } from '@/lib/utils'

    import { Button } from '@/components/ui/button'

    import { 
      DropdownMenu, 
      DropdownMenuContent, 
      DropdownMenuRadioGroup, 
      DropdownMenuRadioItem, 
      DropdownMenuTrigger 
    } from '@/components/ui/dropdown-menu'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { useScrollToBottom } from '@/hooks/useScrollToBottom.hook';

    import { ScrollToBottomButton } from
    '@/components/shared/ScrollToBottomButton';

    import { DataListView } from './components/DataListView'

    import { DataCardView } from './components/DataCardView'

    import { DataTableView } from './components/DataTableView'

    import { DataKanbanView } from './components/DataKanbanView'

    import { DataViewModeSelector } from './components/DataViewModeSelector'

    import { AnimatedTabs } from '@/components/ui/animated-tabs'

    import { StatCard } from '@/components/shared/StatCard'

    import { AnimatedLoadingSkeleton } from
    './components/AnimatedLoadingSkeleton'

    import { DataToolbar } from './components/DataToolbar'

    import { mockDataItems } from './data/mockData'

    import type { GroupableField, DataItem } from './types'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { 
      useDataDemoStore, 
      useGroupTabs
    } from './store/dataDemo.store'


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    function DataDemoContent() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
      } = useAppViewManager();

      const { hasMore, isLoading, isInitialLoading, totalItemCount, loadData } = useDataDemoStore(state => ({
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
      }));

      const groupTabs = useGroupTabs(groupBy, activeGroupTab);
      const allItems = useDataDemoStore(s => s.items);

      const groupedData = useMemo(() => {
        if (groupBy === 'none') {
            return null;
        }
        return allItems.reduce((acc, item) => {
            const groupKey = String(item[groupBy as GroupableField]);
            if (!acc[groupKey]) {
                acc[groupKey] = [];
            }
            acc[groupKey].push(item);
            return acc;
        }, {} as Record<string, DataItem[]>);
      }, [allItems, groupBy]);

      const dataToRender = useMemo(() => {
        if (groupBy === 'none' || activeGroupTab === 'all' || !groupedData) {
          return allItems;
        }
        return groupedData[activeGroupTab] || [];
      }, [groupBy, activeGroupTab, allItems, groupedData]);

      const groupOptions = useMemo(() => [
        { id: 'none' as const, label: 'None' }, { id: 'status' as const, label: 'Status' }, { id: 'priority' as const, label: 'Priority' }, { id: 'category' as const, label: 'Category' }
      ], []);

      const statsRef = useRef<HTMLDivElement>(null)
      const scrollRef = useRef<HTMLDivElement>(null);

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const { showScrollToBottom, scrollToBottom, handleScroll } = useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78]
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.6,
              y: 0,
              opacity: 1,
              stagger: 0.1,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading]);

      useEffect(() => {
        loadData({ page, groupBy, filters, sortConfig });
      }, [page, groupBy, filters, sortConfig, loadData]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );
      
      // Auto-group by status when switching to kanban view for the first time
      useEffect(() => {
        if (viewMode === 'kanban' && groupBy === 'none') {
          setGroupBy('status');
          setSort(null); // Kanban is manually sorted, so disable programmatic sort
        }
      }, [viewMode, groupBy, setGroupBy, setSort]);

      const renderViewForData = useCallback((data: DataItem[]) => {
        switch (viewMode) {
            case 'table': return <DataTableView data={data} />;
            case 'cards': return <DataCardView data={data} />;
            case 'kanban': return null; // Kanban has its own render path below
            case 'grid': return <DataCardView data={data} isGrid />;
            case 'list':
            default:
                return <DataListView data={data} />;
        }
      }, [viewMode]);

      const GroupByDropdown = useCallback(() => (
        <div className="flex items-center gap-2 shrink-0">
          <span className="text-sm font-medium text-muted-foreground shrink-0">Group by:</span>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" className="w-[180px] justify-between">
                {groupOptions.find(o => o.id === groupBy)?.label}
                <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent className="w-[180px]">
              <DropdownMenuRadioGroup value={groupBy} onValueChange={setGroupBy}>
                {groupOptions.map(option => (
                  <DropdownMenuRadioItem key={option.id} value={option.id}>
                    {option.label}
                  </DropdownMenuRadioItem>
                ))}
              </DropdownMenuRadioGroup>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      ), [groupBy, setGroupBy, groupOptions]);

      const isGroupedView = useMemo(() => 
        groupBy !== 'none' && groupTabs.length > 1 && groupedData,
      [groupBy, groupTabs.length, groupedData]);


      return (
        <PageLayout
          scrollRef={scrollRef}
          onScroll={handleScroll}
          // Note: Search functionality is handled by a separate SearchBar in the TopBar
        >
          <div className="space-y-8">
            {/* Header */}
            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
              <div className="flex-1">
                <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                <p className="text-muted-foreground">
                  {isInitialLoading 
                    ? "Loading projects..." 
                    : `Showing ${dataToRender.length} of ${totalItemCount} item(s)`}
                </p>
              </div>
              <DataViewModeSelector />
            </div>

            {/* Stats Section */}
            {!isInitialLoading && (
              <div ref={statsRef} className="grid grid-cols-[repeat(auto-fit,minmax(250px,1fr))] gap-6">
                {stats.map((stat) => (
                  <StatCard
                    key={stat.title}
                    title={stat.title}
                    value={stat.value}
                    change={stat.change}
                    trend={stat.trend}
                    icon={stat.icon}
                    chartData={stat.type === 'chart' ? stat.chartData : undefined}
                  />
                ))}
              </div>
            )}

            {/* Controls Area */}
            <div className="space-y-6">
              <DataToolbar />
            </div>

            <div className="min-h-[500px]">
              {isInitialLoading 
                ? <AnimatedLoadingSkeleton viewMode={viewMode} /> 
                : viewMode === 'kanban' ? (
                  isGroupedView ? <DataKanbanView data={groupedData} /> : <div className="flex items-center justify-center h-96 text-muted-foreground">Group data by a metric to use the Kanban view.</div>
                ) : !isGroupedView ? (
                  // Not grouped view
                  <>
                    <div className="flex items-center justify-between gap-4 h-[68px]">
                      <div className="flex-grow border-b" /> {/* Mimic tab border */}
                      <GroupByDropdown />
                    </div>
                    {renderViewForData(allItems)}
                  </>
                ) : (
                  // Grouped view with AnimatedTabs
                  <div className="relative">
                    <AnimatedTabs
                      tabs={groupTabs}
                      activeTab={activeGroupTab}
                      onTabChange={setActiveGroupTab}
                      wrapperClassName="flex flex-col"
                      className="border-b"
                      contentClassName="pt-6 flex-grow"
                    >
                      {groupTabs.map(tab => (
                        <div key={tab.id} className="min-h-[440px]">
                          {renderViewForData(
                            tab.id === 'all' ? allItems : groupedData?.[tab.id] || []
                          )}
                        </div>
                      ))}
                    </AnimatedTabs>
                    <div className="absolute top-[14px] right-0">
                        <GroupByDropdown />
                    </div>
                  </div>
                )
              }
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && groupBy === 'none' && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && dataToRender.length > 0 && !isInitialLoading && groupBy === 'none' && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>
          <ScrollToBottomButton isVisible={showScrollToBottom} onClick={scrollToBottom} />
        </PageLayout>
      )
    }


    export default function DataDemoPage() {
      return <DataDemoContent />;
    }
  src/pages/DataDemo/components/DataKanbanView.tsx: >-
    import { useState, useEffect } from "react";

    import {
      GripVertical,
      Plus,
      Calendar,
      MessageSquare,
      Paperclip,
    } from "lucide-react";

    import type { DataItem } from "../types";

    import { Card, CardContent } from "@/components/ui/card";

    import { Badge } from "@/components/ui/badge";

    import { Avatar, AvatarFallback, AvatarImage } from
    "@/components/ui/avatar";

    import { cn, getPriorityColor } from "@/lib/utils";

    import { EmptyState } from "./EmptyState";

    import { useAppViewManager } from "@/hooks/useAppViewManager.hook";

    import { useDataDemoStore } from "../store/dataDemo.store";


    interface KanbanCardProps {
      item: DataItem;
      isDragging: boolean;
    }


    function KanbanCard({ item, isDragging, ...props }: KanbanCardProps &
    React.HTMLAttributes<HTMLDivElement>) {
      const { onItemSelect } = useAppViewManager();

      // Mock comment and attachment counts for UI purposes
      const comments = Math.floor(item.metrics.views / 10);
      const attachments = Math.floor(item.metrics.shares / 5);

      return (
        <Card
          {...props}
          onClick={() => onItemSelect(item)}
          className={cn(
            "cursor-pointer transition-all duration-300 border bg-card/60 dark:bg-neutral-800/60 backdrop-blur-sm hover:bg-card/70 dark:hover:bg-neutral-700/70 active:cursor-grabbing",
            isDragging && "opacity-50 ring-2 ring-primary ring-offset-2 ring-offset-background"
          )}
        >
          <CardContent className="p-5">
            <div className="space-y-4">
              <div className="flex items-start justify-between">
                <h4 className="font-semibold text-card-foreground dark:text-neutral-100 leading-tight">
                  {item.title}
                </h4>
                <GripVertical className="w-5 h-5 text-muted-foreground/60 dark:text-neutral-400 cursor-grab flex-shrink-0" />
              </div>

              <p className="text-sm text-muted-foreground dark:text-neutral-300 leading-relaxed line-clamp-2">
                {item.description}
              </p>

              <div className="flex flex-wrap gap-2">
                <Badge className={cn("text-xs border", getPriorityColor(item.priority))}>
                  {item.priority}
                </Badge>
                {item.tags.slice(0, 2).map((tag) => (
                  <Badge key={tag} variant="secondary" className="text-xs backdrop-blur-sm">
                    {tag}
                  </Badge>
                ))}
              </div>

              <div className="flex items-center justify-between pt-2 border-t border-border/30 dark:border-neutral-700/30">
                <div className="flex items-center gap-4 text-muted-foreground/80 dark:text-neutral-400">
                  {item.dueDate && (
                    <div className="flex items-center gap-1">
                      <Calendar className="w-4 h-4" />
                      <span className="text-xs font-medium">
                        {new Date(item.dueDate).toLocaleDateString("en-US", { month: "short", day: "numeric" })}
                      </span>
                    </div>
                  )}
                  <div className="flex items-center gap-1">
                    <MessageSquare className="w-4 h-4" />
                    <span className="text-xs font-medium">{comments}</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <Paperclip className="w-4 h-4" />
                    <span className="text-xs font-medium">{attachments}</span>
                  </div>
                </div>

                <Avatar className="w-8 h-8 ring-2 ring-white/50 dark:ring-neutral-700/50">
                  <AvatarImage src={item.assignee.avatar} />
                  <AvatarFallback className="bg-muted dark:bg-neutral-700 text-foreground dark:text-neutral-200 font-medium">
                    {item.assignee.name.split(" ").map((n) => n[0]).join("")}
                  </AvatarFallback>
                </Avatar>
              </div>
            </div>
          </CardContent>
        </Card>
      );
    }


    interface DataKanbanViewProps {
      data: Record<string, DataItem[]>;
    }


    export function DataKanbanView({ data }: DataKanbanViewProps) {
      const [columns, setColumns] = useState(data);
      const [draggedItemId, setDraggedItemId] = useState<string | null>(null);
      const [dragOverColumn, setDragOverColumn] = useState<string | null>(null);
      const { groupBy } = useAppViewManager();
      const updateItem = useDataDemoStore(s => s.updateItem);

      useEffect(() => {
        setColumns(data);
      }, [data]);

      const handleDragStart = (e: React.DragEvent<HTMLDivElement>, item: DataItem, sourceColumnId: string) => {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', JSON.stringify({ itemId: item.id, sourceColumnId }));
        setDraggedItemId(item.id);
      };

      const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
      };
      
      const handleDragEnter = (columnId: string) => {
        setDragOverColumn(columnId);
      }

      const handleDrop = (e: React.DragEvent<HTMLDivElement>, targetColumnId: string) => {
        e.preventDefault();
        setDragOverColumn(null);
        try {
          const { itemId, sourceColumnId } = JSON.parse(e.dataTransfer.getData('text/plain'));
          if (sourceColumnId === targetColumnId) return;

          const droppedItem = columns[sourceColumnId]?.find(i => i.id === itemId);
          if (!droppedItem) return;

          // Update local state for immediate feedback
          setColumns(prev => {
            const newColumns = { ...prev };
            newColumns[sourceColumnId] = newColumns[sourceColumnId].filter(i => i.id !== itemId);
            newColumns[targetColumnId] = [...newColumns[targetColumnId], droppedItem];
            return newColumns;
          });
          
          // Persist change to global store. The groupBy value tells us which property to update.
          if (groupBy !== 'none') {
            updateItem(itemId, { [groupBy]: targetColumnId } as Partial<DataItem>);
          }

        } catch (err) {
          console.error("Failed to parse drag data", err)
        } finally {
          setDraggedItemId(null);
        }
      };

      const handleDragEnd = () => {
        setDraggedItemId(null);
        setDragOverColumn(null);
      };

      const initialColumns = Object.entries(data);

      if (!initialColumns || initialColumns.length === 0) {
        return <EmptyState />;
      }

      const statusColors: Record<string, string> = {
        active: "bg-blue-500", pending: "bg-yellow-500", completed: "bg-green-500", archived: "bg-gray-500",
        low: "bg-green-500", medium: "bg-blue-500", high: "bg-orange-500", critical: "bg-red-500",
      };

      return (
        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 items-start gap-6 pb-4">
          {Object.entries(columns).map(([columnId, items]) => (
            <div
              key={columnId}
              onDragOver={handleDragOver}
              onDrop={(e) => handleDrop(e, columnId)}
              onDragEnter={() => handleDragEnter(columnId)}
              onDragLeave={() => setDragOverColumn(null)}
              className={cn(
                "bg-card/20 dark:bg-neutral-900/20 backdrop-blur-xl rounded-3xl p-5 border border-border dark:border-neutral-700/50 transition-all duration-300",
                dragOverColumn === columnId && "bg-primary/10 border-primary/30"
              )}
            >
              <div className="flex items-center justify-between mb-6">
                <div className="flex items-center gap-3">
                  <div className={cn("w-3.5 h-3.5 rounded-full", statusColors[columnId] || "bg-muted-foreground")} />
                  <h3 className="font-semibold text-card-foreground dark:text-neutral-100 capitalize">{columnId}</h3>
                  <Badge variant="secondary" className="backdrop-blur-sm">{items.length}</Badge>
                </div>
                <button className="p-1 rounded-full bg-card/30 dark:bg-neutral-800/30 hover:bg-card/50 dark:hover:bg-neutral-700/50 transition-colors">
                  <Plus className="w-4 h-4 text-muted-foreground dark:text-neutral-300" />
                </button>
              </div>

              <div className="space-y-4 min-h-[100px]">
                {items.map((item) => (
                  <KanbanCard 
                    key={item.id} 
                    item={item} 
                    isDragging={draggedItemId === item.id}
                    draggable
                    onDragStart={(e) => handleDragStart(e, item, columnId)}
                    onDragEnd={handleDragEnd}
                  />
                ))}
              </div>
            </div>
          ))}
        </div>
      );
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 434
