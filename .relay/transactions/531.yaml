uuid: d0ac4d6a-5420-4a8e-ae19-33824f9f75f8
projectId: jeli-app-shell
createdAt: '2025-10-21T08:12:10.849Z'
gitCommitMsg: >-
  refactor(dynamic-view): Encapsulate infinite scroll loader

  Moved the infinite scroll loading indicator and "end of list" message from the
  DataDemo page into the generic DynamicView component.

  The DynamicView component now accepts a `loaderRef` prop, allowing the
  consumer (DataDemo page) to control *when* data is loaded via an
  IntersectionObserver, while DynamicView controls *how* the loading state is
  presented. This completes the encapsulation of all view-related presentation
  logic, making the component more self-contained and reusable.
promptSummary: >-
  The user requested to continue making the DynamicView component more generic
  by encapsulating loading animations and state management that were still
  present in the DataDemo page.
reasoning:
  - >-
    Of course. My apologies for the oversight. The goal is to make `DynamicView`
    a fully self-contained presentation component. The stats animation logic is
    tied to the page's scroll container, so it should remain on the page, but
    the presentation of the "infinite scroll" loader definitely belongs inside
    `DynamicView`.
  - >-
    I will move the loading indicator and "end of list" message into the
    `DynamicView` component. The page will remain in control of *when* to load
    more data by providing an `IntersectionObserver` ref, but `DynamicView` will
    now be responsible for *how* that loading state is displayed to the user.
    This completes the encapsulation of all view-related presentation logic.
  - '### Part 1: Encapsulate Infinite Scroll Loader'
  - >-
    First, I'll modify `DynamicView.tsx` to accept a `loaderRef` and render the
    infinite scroll loading indicator internally. This makes the component
    responsible for its own loading state presentation.
  - '### Part 2: Update DataDemo Page'
  - >-
    Next, I'll update the `DataDemoPage` to use the new `loaderRef` prop on
    `DynamicView`, removing the loader's presentation logic from the page and
    completing the abstraction.
operations:
  - type: write
    path: src/features/dynamic-view/DynamicView.tsx
    content: >+
      --- src/features/dynamic-view/DynamicView.tsx

      +++ src/features/dynamic-view/DynamicView.tsx

      @@ -1,4 +1,5 @@
       import { useMemo, useCallback, type ReactNode } from 'react';
      +import { Loader2 } from 'lucide-react';
       import { DynamicViewProvider } from '@/features/dynamic-view/DynamicViewContext';
       import type { ViewConfig, GenericItem, ViewMode, FilterConfig, SortConfig, CalendarDateProp, CalendarDisplayProp, CalendarColorProp } from './types';
       import { ViewControls } from './components/controls/ViewControls';
      @@ -48,11 +49,12 @@
         // Custom Renderers
         renderHeaderControls?: () => ReactNode;
         renderStats?: () => ReactNode;
         renderCta?: (viewMode: ViewMode, ctaProps: { colSpan?: number }) => ReactNode;
      +  loaderRef?: React.Ref<HTMLDivElement>;
       }
       
       export function DynamicView({ viewConfig, ...rest }: DynamicViewProps) {
         
      -  const { viewMode, isInitialLoading, items, groupBy } = rest;

      +  const { viewMode, isInitialLoading, isLoading, hasMore, items, groupBy
      } = rest;
       
         const groupedData = useMemo(() => {
           if (groupBy === 'none' || viewMode !== 'kanban') {
      @@ -128,6 +130,23 @@
                 <div className="min-h-[500px]">
                     {renderContent()}
                 </div>
      +

      +          {/* Loader for infinite scroll */}

      +          <div ref={rest.loaderRef} className="flex justify-center
      items-center py-6">

      +            {isLoading && !isInitialLoading && groupBy === 'none' &&
      viewMode !== 'calendar' && viewMode !== 'kanban' && (

      +              <div className="flex items-center gap-2
      text-muted-foreground">

      +                <Loader2 className="w-5 h-5 animate-spin" />

      +                <span>Loading more...</span>

      +              </div>

      +            )}

      +            {!isLoading && !hasMore && items.length > 0 &&
      !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' &&
      viewMode !== 'kanban' && (

      +              <p className="text-muted-foreground">You've reached the
      end.</p>

      +            )}

      +          </div>
             </div>
           </DynamicViewProvider>
         );

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >+
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ -213,6 +213,7 @@
               onActiveGroupTabChange={setActiveGroupTab}
               onPageChange={setPage}
               onItemSelect={onItemSelect}
      +        loaderRef={loaderRef}
               // Custom Renderers
               renderCta={(viewMode, ctaProps) => (
                 <AddDataItemCta viewMode={viewMode} colSpan={ctaProps.colSpan} />
      @@ -236,21 +237,6 @@
               )}
             />
       
      -        {/* Loader for infinite scroll */}

      -        <div ref={loaderRef} className="flex justify-center items-center
      py-6">

      -          {isLoading && !isInitialLoading && groupBy === 'none' &&
      viewMode !== 'calendar' && viewMode !== 'kanban' && (

      -            <div className="flex items-center gap-2
      text-muted-foreground">

      -              <Loader2 className="w-5 h-5 animate-spin" />

      -              <span>Loading more...</span>

      -            </div>

      -          )}

      -          {!isLoading && !hasMore && allItems.length > 0 &&
      !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' &&
      viewMode !== 'kanban' && (

      -            <p className="text-muted-foreground">You've reached the
      end.</p>

      -          )}

      -        </div>
             <ScrollToBottomButton isVisible={showScrollToBottom} onClick={scrollToBottom} />
           </PageLayout>
         );

    patchStrategy: standard-diff
snapshot:
  src/features/dynamic-view/DynamicView.tsx: >-
    import { useMemo, useCallback, type ReactNode } from 'react';

    import { DynamicViewProvider } from
    '@/features/dynamic-view/DynamicViewContext';

    import type { ViewConfig, GenericItem, ViewMode, FilterConfig, SortConfig,
    CalendarDateProp, CalendarDisplayProp, CalendarColorProp } from './types';

    import { ViewControls } from './components/controls/ViewControls';

    import { ViewModeSelector } from './components/controls/ViewModeSelector';

    import { AnimatedLoadingSkeleton } from
    './components/shared/AnimatedLoadingSkeleton';

    import { ListView } from './components/views/ListView';

    import { CardView } from './components/views/CardView';

    import { TableView } from './components/views/TableView';

    import { KanbanView } from './components/views/KanbanView';

    import { CalendarView } from './components/views/CalendarView';

    import { EmptyState } from './components/shared/EmptyState';


    // Define the props for the controlled DynamicView component

    export interface DynamicViewProps {
      // Config
      viewConfig: ViewConfig;
      
      // Data & State
      items: GenericItem[];
      isLoading: boolean;
      isInitialLoading: boolean;
      totalItemCount: number;
      hasMore: boolean;
      
      // Controlled State Props
      viewMode: ViewMode;
      filters: FilterConfig;
      sortConfig: SortConfig | null;
      groupBy: string;
      activeGroupTab: string;
      page: number;
      selectedItemId?: string;
      // Calendar-specific state
      calendarDateProp?: CalendarDateProp;
      calendarDisplayProps?: CalendarDisplayProp[];
      calendarItemLimit?: 'all' | number;
      calendarColorProp?: CalendarColorProp;

      // State Change Callbacks
      onViewModeChange: (mode: ViewMode) => void;
      onFiltersChange: (filters: FilterConfig) => void;
      onSortChange: (sort: SortConfig | null) => void;
      onGroupByChange: (group: string) => void;
      onActiveGroupTabChange: (tab: string) => void;
      onPageChange: (page: number) => void;
      onItemSelect: (item: GenericItem) => void;
      onItemUpdate?: (itemId: string, updates: Partial<GenericItem>) => void;
      // Calendar-specific callbacks
      onCalendarDatePropChange?: (prop: CalendarDateProp) => void;
      onCalendarDisplayPropsChange?: (props: CalendarDisplayProp[]) => void;
      onCalendarItemLimitChange?: (limit: 'all' | number) => void;
      onCalendarColorPropChange?: (prop: CalendarColorProp) => void;
      
      // Custom Renderers
      renderHeaderControls?: () => ReactNode;
      renderStats?: () => ReactNode;
      renderCta?: (viewMode: ViewMode, ctaProps: { colSpan?: number }) => ReactNode;
    }


    export function DynamicView({ viewConfig, ...rest }: DynamicViewProps) {
      
      const { viewMode, isInitialLoading, items, groupBy } = rest;

      const groupedData = useMemo(() => {
        if (groupBy === 'none' || viewMode !== 'kanban') {
            return null;
        }
        return items.reduce((acc, item) => {
            const groupKey = String(item[groupBy as keyof GenericItem]) || 'N/A';
            if (!acc[groupKey]) {
                acc[groupKey] = [] as GenericItem[];
            }
            acc[groupKey].push(item);
            return acc;
        }, {} as Record<string, GenericItem[]>);
      }, [items, groupBy, viewMode]);

      const renderViewForData = useCallback((data: GenericItem[], cta: ReactNode) => {
        switch (viewMode) {
            case 'table': return <TableView data={data} ctaElement={cta} />;
            case 'cards': return <CardView data={data} ctaElement={cta} />;
            case 'grid': return <CardView data={data} isGrid ctaElement={cta} />;
            case 'list': default: return <ListView data={data} ctaElement={cta} />;
        }
      }, [viewMode]);

      const renderContent = () => {
        if (isInitialLoading) {
          return <AnimatedLoadingSkeleton viewMode={viewMode} />;
        }

        if (viewMode === 'calendar') {
            return <CalendarView data={items} />;
        }

        if (viewMode === 'kanban') {
            return groupedData ? (
              <KanbanView data={groupedData} />
            ) : (
              <div className="flex items-center justify-center h-96 text-muted-foreground">
                Group data by a metric to use the Kanban view.
              </div>
            );
        }
        
        if (items.length === 0 && !isInitialLoading) {
            return <EmptyState />;
        }
        
        const ctaProps = {
            colSpan: viewMode === 'table' ? viewConfig.tableView.columns.length + 1 : undefined,
        };
        const ctaElement = rest.renderCta
            ? rest.renderCta(viewMode, ctaProps)
            : null;
        
        // This will be expanded later to handle group tabs
        return renderViewForData(items, ctaElement);
      };

      return (
        <DynamicViewProvider viewConfig={viewConfig} {...rest}>
          <div className="space-y-6">
              <div className="space-y-4">
                  <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-4">
                      <div className="flex-1">
                          {rest.renderHeaderControls ? rest.renderHeaderControls() : (
                              <>
                                  <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                                  <p className="text-muted-foreground">
                                      {isInitialLoading 
                                          ? "Loading projects..." 
                                          : `Showing ${items.length} of ${rest.totalItemCount} item(s)`}
                                  </p>
                              </>
                          )}
                      </div>
                      <ViewModeSelector />
                  </div>
                  <ViewControls />
              </div>

              {rest.renderStats && !isInitialLoading && rest.renderStats()}
              
              <div className="min-h-[500px]">
                  {renderContent()}
              </div>
          </div>
        </DynamicViewProvider>
      );
    }
  src/pages/DataDemo/index.tsx: >-
    import { useRef, useEffect, useCallback } from 'react'

    import {
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      Loader2,
      TrendingUp,
      CheckCircle,
      Clock,
      Archive,
      PlusCircle,
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { DynamicView } from '@/features/dynamic-view/DynamicView'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { useScrollToBottom } from '@/hooks/useScrollToBottom.hook';

    import { ScrollToBottomButton } from
    '@/components/shared/ScrollToBottomButton';

    import { StatCard } from '@/components/shared/StatCard'

    import { mockDataItems } from './data/mockData'

    import type { GenericItem } from '@/features/dynamic-view/types'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { useAutoAnimateStats } from './hooks/useAutoAnimateStats.hook'

    import { useDataDemoStore } from './store/dataDemo.store'

    import { 

    } from './store/dataDemo.store'

    import { AddDataItemCta } from
    '@/features/dynamic-view/components/shared/AddDataItemCta'


    import { dataDemoViewConfig } from './DataDemo.config';


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    export default function DataDemoPage() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
        setFilters,
        setViewMode,
        onItemSelect,
      } = useAppViewManager();

      const { items: allItems, hasMore, isLoading, isInitialLoading, totalItemCount, loadData } = useDataDemoStore(state => ({
        items: state.items,
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
      }));

      const statsRef = useRef<HTMLDivElement>(null)
      const scrollRef = useRef<HTMLDivElement>(null);

      // Note: The `DynamicViewProvider` needs `GenericItem[]`. 
      // Our store uses `GenericItem` so no cast is needed.
      // Auto-hide stats container on scroll down
      useAutoAnimateStats(scrollRef, statsRef);

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const { showScrollToBottom, scrollToBottom, handleScroll } = useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78],
        },
        {
          title: "Completion Rate",
          value: "88%",
          icon: <CheckCircle className="w-5 h-5" />,
          change: "+1.5% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [80, 82, 81, 84, 85, 87, 88],
        },
        {
          title: "Overdue Items",
          value: "8",
          icon: <Clock className="w-5 h-5" />,
          change: "-3 this week",
          trend: "down" as const,
        },
        {
          title: "New This Week",
          value: "12",
          icon: <PlusCircle className="w-5 h-5" />,
          change: "+2 from last week",
          trend: "up" as const,
        },
        {
          title: "Archived Projects",
          value: "153",
          icon: <Archive className="w-5 h-5" />,
          change: "+20 this month",
          trend: "up" as const,
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.5,
              y: 0,
              opacity: 1,
              stagger: 0.08,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading]);

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === 'calendar' || viewMode === 'kanban',
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );
      
      useEffect(() => {
        // Auto-group by status when switching to kanban view for the first time
        if (viewMode === 'kanban' && groupBy === 'none') {
          setGroupBy('status');
          setSort(null); // Kanban is manually sorted, so disable programmatic sort
        }
        // For calendar view, we don't want grouping.
        else if (viewMode === 'calendar' && groupBy !== 'none') {
          setGroupBy('none');
        }
      }, [viewMode, groupBy, setGroupBy, setSort]);

      return (
        <PageLayout
          scrollRef={scrollRef}
          onScroll={handleScroll}
        >
          <DynamicView
            viewConfig={dataDemoViewConfig}
            items={allItems as GenericItem[]}
            isLoading={isLoading}
            isInitialLoading={isInitialLoading}
            totalItemCount={totalItemCount}
            hasMore={hasMore}
            // Controlled state
            viewMode={viewMode}
            filters={filters}
            sortConfig={sortConfig}
            groupBy={groupBy}
            activeGroupTab={activeGroupTab}
            page={page}
            // Callbacks
            onViewModeChange={setViewMode}
            onFiltersChange={setFilters}
            onSortChange={setSort}
            onGroupByChange={setGroupBy}
            onActiveGroupTabChange={setActiveGroupTab}
            onPageChange={setPage}
            onItemSelect={onItemSelect}
            // Custom Renderers
            renderCta={(viewMode, ctaProps) => (
              <AddDataItemCta viewMode={viewMode} colSpan={ctaProps.colSpan} />
            )}
            renderStats={() => (
              <div ref={statsRef} className="flex overflow-x-auto gap-6 pb-4 no-scrollbar">
                {stats.map((stat) => (
                  <StatCard
                    className="w-64 md:w-72 flex-shrink-0"
                    key={stat.title}
                    title={stat.title}
                    value={stat.value}
                    change={stat.change}
                    trend={stat.trend}
                    icon={stat.icon}
                    chartData={stat.type === 'chart' ? stat.chartData : undefined}
                  />
                ))}
              </div>
            )}
          />

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && viewMode !== 'kanban' && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && allItems.length > 0 && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && viewMode !== 'kanban' && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          <ScrollToBottomButton isVisible={showScrollToBottom} onClick={scrollToBottom} />
        </PageLayout>
      );
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 531
