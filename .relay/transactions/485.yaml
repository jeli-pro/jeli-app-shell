uuid: ccfac706-e7de-4f51-b847-a85966a34ab5
projectId: jeli-app-shell
createdAt: '2025-10-18T15:52:29.723Z'
gitCommitMsg: >-
  refactor(DataDemo): convert stats section to horizontal scroll

  Refactored the stats card section in the DataDemo page to use a single-row,
  horizontal scrolling container instead of a grid that could wrap vertically.

  - Made the `StatCard` component more flexible by accepting a `className` prop
  for external styling. - Removed hardcoded widths from `StatCard` to allow the
  parent to control layout. - Implemented a flexbox container with
  `overflow-x-auto` in `DataDemo/index.tsx` to house the stat cards. - Applied
  `flex-shrink-0` and responsive widths to the cards from the parent, ensuring
  they stay in a single row.
promptSummary: >-
  The user wants to convert the stats card section on the DataDemo page from a
  layout that might wrap vertically into a single row that is only horizontally
  scrollable. This is to ensure the main page has a single vertical scrollbar
  and the UI is cleaner.
reasoning:
  - >-
    Excellent. Executing a clean refactor to improve user experience. The plan
    is solid. We'll make the `StatCard` component more modular and then
    orchestrate the horizontal scrolling layout in the main `DataDemo` page.
    This will keep the main view compact and prevent the stats section from
    wrapping vertically.
  - Here are the required modifications.
  - '### Part 1: Enhance StatCard Component'
  - >-
    First, I'll update the `StatCard` component. I'm adding a `className` prop
    to its interface and function signature. Then, I'll remove the hardcoded
    width and flex-shrink classes, and instead apply the passed-in `className`.
    This transfers layout control to the parent component, making the `StatCard`
    more reusable.
  - '### Part 2: Implement Horizontal Scroll Layout'
  - >-
    Now, in `DataDemo/index.tsx`, I'll modify the container for the stats cards.
    It's already using flexbox, but I'll adjust the padding for a better
    scrollbar appearance. More importantly, I'll pass the sizing and
    shrink-prevention classes to each `StatCard` via the new `className` prop.
    This forces all cards into a single, horizontally scrollable row.
  - '---'
operations:
  - type: write
    path: src/components/shared/StatCard.tsx
    content: >+
      --- src/components/shared/StatCard.tsx

      +++ src/components/shared/StatCard.tsx

      @@ -4,6 +4,7 @@
       import { Card } from '@/components/ui/card';
       
       interface StatCardProps {
      +  className?: string;
         title: string;
         value: string;
         change: string;
      @@ -12,7 +13,7 @@
         chartData?: number[];
       }
       
      -export function StatCard({ title, value, change, trend, icon, chartData
      }: StatCardProps) {

      +export function StatCard({ className, title, value, change, trend, icon,
      chartData }: StatCardProps) {
         const chartRef = useRef<SVGSVGElement>(null);
       
         useLayoutEffect(() => {
      @@ -58,11 +59,11 @@
         // --- End of chart rendering logic ---
       
         return (
      -    <Card className={cn(

      -        "flex-shrink-0 w-64 md:w-72 p-6 border-border/50
      hover:border-primary/30 transition-all duration-300 group cursor-pointer
      flex flex-col justify-between",

      -        !chartData && "h-full" // Ensure cards without charts have
      consistent height if needed

      -    )}>

      +    <Card className={cn(

      +        "p-6 border-border/50 hover:border-primary/30 transition-all
      duration-300 group cursor-pointer flex flex-col justify-between",

      +        !chartData && "h-full", // Ensure cards without charts have
      consistent height if needed

      +        className

      +    )}>
             <div>
               <div className="flex items-center justify-between">
                 <div className="p-3 bg-primary/10 rounded-full group-hover:bg-primary/20 transition-colors">

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >+
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ -402,9 +402,10 @@
       
               {/* Stats Section */}
               {!isInitialLoading && (
      -          <div ref={statsRef} className="flex overflow-x-auto gap-6 pb-2
      no-scrollbar">

      +          <div ref={statsRef} className="flex overflow-x-auto gap-6 pb-4
      no-scrollbar">
                   {stats.map((stat) => (
                     <StatCard
      +                className="w-64 md:w-72 flex-shrink-0"
                       key={stat.title}
                       title={stat.title}
                       value={stat.value}

    patchStrategy: standard-diff
snapshot:
  src/pages/DataDemo/index.tsx: >
    import { useRef, useEffect, useCallback, useMemo } from 'react'

    import {
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      Loader2,
      ChevronsUpDown,
      TrendingUp,
      CheckCircle,
      Clock,
      Archive,
      PlusCircle
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { cn } from '@/lib/utils'

    import { Button } from '@/components/ui/button'

    import { 
      DropdownMenu, 
      DropdownMenuContent, 
      DropdownMenuRadioGroup, 
      DropdownMenuRadioItem, 
      DropdownMenuTrigger 
    } from '@/components/ui/dropdown-menu'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { useScrollToBottom } from '@/hooks/useScrollToBottom.hook';

    import { ScrollToBottomButton } from
    '@/components/shared/ScrollToBottomButton';

    import { DataListView } from './components/DataListView'

    import { DataCardView } from './components/DataCardView'

    import { DataTableView } from './components/DataTableView'

    import { DataKanbanView } from './components/DataKanbanView'

    import { DataCalendarView } from './components/DataCalendarView'

    import { DataViewModeSelector } from './components/DataViewModeSelector'

    import { AnimatedTabs } from '@/components/ui/animated-tabs'

    import { StatCard } from '@/components/shared/StatCard'

    import { AnimatedLoadingSkeleton } from
    './components/AnimatedLoadingSkeleton'

    import { DataToolbar } from './components/DataToolbar'

    import { mockDataItems } from './data/mockData'

    import type { GroupableField, DataItem } from './types'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { useAutoAnimateStats } from './hooks/useAutoAnimateStats.hook'

    import { 
      useDataDemoStore, 
      useGroupTabs
    } from './store/dataDemo.store'


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    function DataDemoContent() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
      } = useAppViewManager();

      const { hasMore, isLoading, isInitialLoading, totalItemCount, loadData } = useDataDemoStore(state => ({
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
      }));

      const groupTabs = useGroupTabs(groupBy, activeGroupTab);
      const allItems = useDataDemoStore(s => s.items);

      const groupedData = useMemo(() => {
        if (groupBy === 'none') {
            return null;
        }
        return allItems.reduce((acc, item) => {
            const groupKey = String(item[groupBy as GroupableField]);
            if (!acc[groupKey]) {
                acc[groupKey] = [];
            }
            acc[groupKey].push(item);
            return acc;
        }, {} as Record<string, DataItem[]>);
      }, [allItems, groupBy]);

      const dataToRender = useMemo(() => {
        if (groupBy === 'none' || activeGroupTab === 'all' || !groupedData) {
          return allItems;
        }
        return groupedData[activeGroupTab] || [];
      }, [groupBy, activeGroupTab, allItems, groupedData]);

      const groupOptions = useMemo(() => [
        { id: 'none' as const, label: 'None' }, { id: 'status' as const, label: 'Status' }, { id: 'priority' as const, label: 'Priority' }, { id: 'category' as const, label: 'Category' }
      ], []);

      const statsRef = useRef<HTMLDivElement>(null)
      const scrollRef = useRef<HTMLDivElement>(null);

      // Auto-hide stats container on scroll down
      useAutoAnimateStats(scrollRef, statsRef);

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const { showScrollToBottom, scrollToBottom, handleScroll } = useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78],
        },
        {
          title: "Completion Rate",
          value: "88%",
          icon: <CheckCircle className="w-5 h-5" />,
          change: "+1.5% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [80, 82, 81, 84, 85, 87, 88],
        },
        {
          title: "Overdue Items",
          value: "8",
          icon: <Clock className="w-5 h-5" />,
          change: "-3 this week",
          trend: "down" as const,
        },
        {
          title: "New This Week",
          value: "12",
          icon: <PlusCircle className="w-5 h-5" />,
          change: "+2 from last week",
          trend: "up" as const,
        },
        {
          title: "Archived Projects",
          value: "153",
          icon: <Archive className="w-5 h-5" />,
          change: "+20 this month",
          trend: "up" as const,
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.5,
              y: 0,
              opacity: 1,
              stagger: 0.08,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading]);

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === 'calendar',
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );
      
      // Auto-group by status when switching to kanban view for the first time
      useEffect(() => {
        if (viewMode === 'kanban' && groupBy === 'none') {
          setGroupBy('status');
          setSort(null); // Kanban is manually sorted, so disable programmatic sort
        }
        // For calendar view, we don't want grouping.
        if (viewMode === 'calendar') {
          if (groupBy !== 'none') setGroupBy('none');
        }
      }, [viewMode, groupBy, setGroupBy]);

      const renderViewForData = useCallback((data: DataItem[]) => {
        switch (viewMode) {
            case 'table': return <DataTableView data={data} />;
            case 'cards': return <DataCardView data={data} />;
            case 'calendar': return null; // Calendar has its own render path below
            case 'kanban': return null; // Kanban has its own render path below
            case 'grid': return <DataCardView data={data} isGrid />;
            case 'list':
            default:
                return <DataListView data={data} />;
        }
      }, [viewMode]);

      const GroupByDropdown = useCallback(() => (
        <div className="flex items-center gap-2 shrink-0">
          <span className="text-sm font-medium text-muted-foreground shrink-0">Group by:</span>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" className="w-[180px] justify-between">
                {groupOptions.find(o => o.id === groupBy)?.label}
                <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent className="w-[180px]">
              <DropdownMenuRadioGroup value={groupBy} onValueChange={setGroupBy}>
                {groupOptions.map(option => (
                  <DropdownMenuRadioItem key={option.id} value={option.id}>
                    {option.label}
                  </DropdownMenuRadioItem>
                ))}
              </DropdownMenuRadioGroup>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      ), [groupBy, setGroupBy, groupOptions]);

      const isGroupedView = useMemo(() => 
        groupBy !== 'none' && groupTabs.length > 1 && groupedData,
      [groupBy, groupTabs.length, groupedData]);


      return (
        <PageLayout
          scrollRef={scrollRef}
          onScroll={handleScroll}
          // Note: Search functionality is handled by a separate SearchBar in the TopBar
        >
          <div className="space-y-8">
            {/* Header */}
            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
              <div className="flex-1">
                <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                <p className="text-muted-foreground">
                  {isInitialLoading 
                    ? "Loading projects..." 
                    : `Showing ${dataToRender.length} of ${totalItemCount} item(s)`}
                </p>
              </div>
              <DataViewModeSelector />
            </div>

            {/* Stats Section */}
            {!isInitialLoading && (
              <div ref={statsRef} className="flex overflow-x-auto gap-6 pb-2 no-scrollbar">
                {stats.map((stat) => (
                  <StatCard
                    key={stat.title}
                    title={stat.title}
                    value={stat.value}
                    change={stat.change}
                    trend={stat.trend}
                    icon={stat.icon}
                    chartData={stat.type === 'chart' ? stat.chartData : undefined}
                  />
                ))}
              </div>
            )}

            {/* Controls Area */}
            <div className="space-y-6">
              <DataToolbar />
            </div>

            <div className="min-h-[500px]">
              {isInitialLoading 
                ? <AnimatedLoadingSkeleton viewMode={viewMode} /> 
                : viewMode === 'calendar' ? (
                  <DataCalendarView data={allItems} />
                )
                : viewMode === 'kanban' ? (
                  <>
                    <div className="flex items-center justify-end gap-4 h-[68px]">
                      <GroupByDropdown />
                    </div>
                    {isGroupedView ? (
                      <DataKanbanView data={groupedData} />
                    ) : (
                      <div className="flex items-center justify-center h-96 text-muted-foreground">
                        Group data by a metric to use the Kanban view.
                      </div>
                    )}
                  </>
                )
                : !isGroupedView ? (
                  // Not grouped view
                  <>
                    <div className="flex items-center justify-between gap-4 h-[68px]">
                      <div className="flex-grow border-b" /> {/* Mimic tab border */}
                      <GroupByDropdown />
                    </div>
                    {renderViewForData(allItems)}
                  </>
                ) : (
                  // Grouped view with AnimatedTabs
                  <div className="relative">
                    <AnimatedTabs
                      tabs={groupTabs}
                      activeTab={activeGroupTab}
                      onTabChange={setActiveGroupTab}
                      wrapperClassName="flex flex-col"
                      className="border-b"
                      contentClassName="pt-6 flex-grow"
                    >
                      {groupTabs.map(tab => (
                        <div key={tab.id} className="min-h-[440px]">
                          {renderViewForData(
                            tab.id === 'all' ? allItems : groupedData?.[tab.id] || []
                          )}
                        </div>
                      ))}
                    </AnimatedTabs>
                    <div className="absolute top-[14px] right-0">
                        <GroupByDropdown />
                    </div>
                  </div>
                )
              }
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && dataToRender.length > 0 && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>
          <ScrollToBottomButton isVisible={showScrollToBottom} onClick={scrollToBottom} />
        </PageLayout>
      )
    }


    export default function DataDemoPage() {
      return <DataDemoContent />;
    }
  src/components/shared/StatCard.tsx: >-
    import React, { useLayoutEffect, useRef } from 'react';

    import { gsap } from 'gsap';

    import { cn } from '@/lib/utils';

    import { Card } from '@/components/ui/card';


    interface StatCardProps {
      title: string;
      value: string;
      change: string;
      trend: 'up' | 'down';
      icon: React.ReactNode;
      chartData?: number[];
    }


    export function StatCard({ title, value, change, trend, icon, chartData }:
    StatCardProps) {
      const chartRef = useRef<SVGSVGElement>(null);

      useLayoutEffect(() => {
        // Only run animation if chartData is present
        if (chartRef.current && chartData) {
          const line = chartRef.current.querySelector('.chart-line');
          const area = chartRef.current.querySelector('.chart-area');
          if (line instanceof SVGPathElement && area) {
            const length = line.getTotalLength();
            gsap.set(line, { strokeDasharray: length, strokeDashoffset: length });
            gsap.to(line, { strokeDashoffset: 0, duration: 1.2, ease: 'power2.inOut' });
            gsap.fromTo(area, { opacity: 0, y: 10 }, { opacity: 1, y: 0, duration: 0.8, ease: 'power2.out', delay: 0.4 });
          }
        }
      }, [chartData]);

      // --- Chart rendering logic (only if chartData is provided) ---
      const renderChart = () => {
        if (!chartData || chartData.length < 2) return null;

        // SVG dimensions
        const width = 150;
        const height = 60;

        // Normalize data
        const max = Math.max(...chartData);
        const min = Math.min(...chartData);
        const range = max - min === 0 ? 1 : max - min;

        const points = chartData
          .map((val, i) => {
            const x = (i / (chartData.length - 1)) * width;
            const y = height - ((val - min) / range) * (height - 10) + 5; // Add vertical padding
            return `${x},${y}`;
          });

        const linePath = "M" + points.join(" L");
        const areaPath = `${linePath} L${width},${height} L0,${height} Z`;

        return (
          <div className="mt-4 -mb-2 -mx-2">
            <svg ref={chartRef} viewBox={`0 0 ${width} ${height}`} className="w-full h-auto" preserveAspectRatio="none">
              <defs>
                <linearGradient id="chartGradient" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="0%" className="text-primary" stopColor="currentColor" stopOpacity={0.3} />
                  <stop offset="100%" className="text-primary" stopColor="currentColor" stopOpacity={0} />
                </linearGradient>
              </defs>
              <path
                className="chart-area"
                d={areaPath}
                fill="url(#chartGradient)"
              />
              <path
                className="chart-line"
                d={linePath}
                fill="none"
                stroke="hsl(var(--primary))"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            </svg>
          </div>
        );
      };
      // --- End of chart rendering logic ---

      return (
        <Card className={cn(
            "flex-shrink-0 w-64 md:w-72 p-6 border-border/50 hover:border-primary/30 transition-all duration-300 group cursor-pointer flex flex-col justify-between",
            !chartData && "h-full" // Ensure cards without charts have consistent height if needed
        )}>
          <div>
            <div className="flex items-center justify-between">
              <div className="p-3 bg-primary/10 rounded-full group-hover:bg-primary/20 transition-colors">
                {icon}
              </div>
              <div className={cn(
                "text-sm font-medium",
                trend === 'up' ? "text-green-600" : "text-red-600"
              )}>
                {change}
              </div>
            </div>
            <div className="mt-4">
              <h3 className="text-2xl font-bold">{value}</h3>
              <p className="text-sm text-muted-foreground mt-1">{title}</p>
            </div>
          </div>
          {renderChart()}
        </Card>
      );
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-10-18T15:53:07.081Z'
status: committed
id: 485
