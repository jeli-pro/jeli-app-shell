uuid: c255b083-d3d6-44ec-b4c4-7548a3d6d062
projectId: jeli-app-shell
createdAt: '2025-10-12T03:09:28.747Z'
gitCommitMsg: >-
  feat(dnd): Implement context-aware split view on drop

  This commit enhances the drag-and-drop functionality to be context-aware,
  creating a more intuitive split-view experience.

  When in a normal, single-pane view, dragging a new page from the sidebar and
  dropping it onto the main content area will now automatically create a split
  view. The original main content is shifted to the right pane, and the newly
  dropped page becomes the main content on the left.

  This improves user workflow by allowing for dynamic creation of split views
  without needing to explicitly open a side pane first.
promptSummary: >-
  The user wants to improve the drag-and-drop split view feature to be
  "context-aware".
reasoning:
  - >-
    Of course. You're looking for a more "context-aware" split-view feature.
    When a user drags a new page onto the main view, it should intelligently
    create a split view, moving the existing main content to the side pane. I
    understand and can implement that enhancement.
  - 'Here''s the plan:'
  - >-
    1.  **Modify `handleDropLeft` in `AppShell.tsx`:** I will update the logic
    for when a user drops a page on the left (main content) area.
  - >-
    *   If the application is in a normal single-pane view and the user drops a
    *different* page, it will trigger the new split-view behavior.
  - >-
    *   The page that was originally in the main view will be moved to the right
    pane.
  - '*   The newly dropped page will become the main content on the left.'
  - '*   The application will transition into `SPLIT_VIEW`.'
  - >-
    2.  **Maintain Existing Logic:** All other drag-and-drop behaviors (like
    dropping on the right or bringing a page back from the side pane) will
    continue to function as they did before.
  - >-
    This change will make the split view feature much more intuitive and
    powerful. I'll now apply the necessary code modification.
operations:
  - type: write
    path: src/components/layout/AppShell.tsx
    content: >+
      --- src/components/layout/AppShell.tsx

      +++ src/components/layout/AppShell.tsx

      @@ -71,19 +71,30 @@
       
         const handleDropLeft = useCallback(() => {
           if (!draggedPage) return;
           
      -    const paneContent = pageToPaneMap[draggedPage];

      -    // If the dropped page is currently in the side pane, close it.

      -    if (paneContent === sidePaneContent && (bodyState ===
      BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {

      -      closeSidePane();

      +    const originalActivePage = activePage;

      +    const originalActivePagePaneContent =
      pageToPaneMap[originalActivePage];

      +

      +    // If we drop the page that's already in the side pane, just make it
      the main view.

      +    const paneContentOfDraggedPage = pageToPaneMap[draggedPage];

      +    if (paneContentOfDraggedPage === sidePaneContent && (bodyState ===
      BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {

      +      closeSidePane();

      +      handleNavigation(draggedPage);

      +    } 

      +    // New context-aware logic: if we are in normal view and drop a NEW
      page on the left

      +    else if (bodyState === BODY_STATES.NORMAL && draggedPage !==
      originalActivePage) {

      +        if (originalActivePagePaneContent) {

      +            // 1. Set the right pane content to be the original page

      +            dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload:
      originalActivePagePaneContent });

      +            // 2. Set the main page to be the new dragged page

      +            handleNavigation(draggedPage);

      +            // 3. Switch to split view

      +            dispatch({ type: 'SET_BODY_STATE', payload:
      BODY_STATES.SPLIT_VIEW });

      +        } else {

      +            // Fallback for pages that can't be in a pane

      +            handleNavigation(draggedPage);

      +        }

      +    } else { // Default behavior: just make the dropped page the main one

      +      handleNavigation(draggedPage);
           }
           
      -    handleNavigation(draggedPage);
           dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
           dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      -  }, [draggedPage, handleNavigation, dispatch, sidePaneContent,
      bodyState, closeSidePane]);

      +  }, [draggedPage, activePage, bodyState, sidePaneContent,
      handleNavigation, dispatch, closeSidePane]);
       
         const handleDragOverRight = useCallback((e: React.DragEvent) => {
           if (!draggedPage) return;

    patchStrategy: standard-diff
snapshot:
  src/components/layout/AppShell.tsx: >-
    import React, { useRef, type ReactElement, useCallback } from 'react'

    import { cn } from '@/lib/utils'

    import { CommandPalette } from '@/components/global/CommandPalette';

    import { useAppStore } from '@/store/appStore';

    import { useAppShell } from '@/context/AppShellContext';

    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'

    import { useResizableSidebar, useResizableRightPane } from
    '@/hooks/useResizablePanes.hook'

    import { useSidebarAnimations, useBodyStateAnimations } from
    '@/hooks/useAppShellAnimations.hook'


    interface AppShellProps {
      sidebar: ReactElement;
      topBar: ReactElement;
      mainContent: ReactElement;
      rightPane: ReactElement;
      commandPalette?: ReactElement;
    }


    const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
    'notifications'> = {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
    };



    export function AppShell({ sidebar, topBar, mainContent, rightPane,
    commandPalette }: AppShellProps) {
      const {
        sidebarState,
        dispatch,
        autoExpandSidebar,
        toggleSidebar,
        peekSidebar,
        draggedPage,
        dragHoverTarget,
        toggleSplitView,
        openSidePane,
        bodyState,
        rightPaneWidth,
        sidePaneContent,
        closeSidePane,
      } = useAppShell();
      
      const { isDarkMode, toggleDarkMode, handleNavigation, activePage } = useAppStore();
      const appRef = useRef<HTMLDivElement>(null)
      const sidebarRef = useRef<HTMLDivElement>(null)
      const mainContentRef = useRef<HTMLDivElement>(null)
      const rightPaneRef = useRef<HTMLDivElement>(null)
      const resizeHandleRef = useRef<HTMLDivElement>(null)
      const topBarContainerRef = useRef<HTMLDivElement>(null)
      const mainAreaRef = useRef<HTMLDivElement>(null)

      // Custom hooks for logic
      useResizableSidebar(sidebarRef, resizeHandleRef);
      useResizableRightPane();
      useSidebarAnimations(sidebarRef, resizeHandleRef);
      useBodyStateAnimations(appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef);
      
      const sidebarWithProps = React.cloneElement(sidebar, { 
        ref: sidebarRef,
        onMouseEnter: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.COLLAPSED) {
            peekSidebar()
          }
        },
        onMouseLeave: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.PEEK) {
            dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
          }
        }
      });

      const topBarWithProps = React.cloneElement(topBar, {
        onToggleSidebar: toggleSidebar,
        onToggleDarkMode: toggleDarkMode,
      });

      const mainContentWithProps = React.cloneElement(mainContent, {
        ref: mainContentRef,
      });

      const rightPaneWithProps = React.cloneElement(rightPane, { ref: rightPaneRef });

      // Drag and drop handlers for docking
      const handleDragOverLeft = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'left') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'left' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropLeft = useCallback(() => {
        if (!draggedPage) return;
        
        const paneContent = pageToPaneMap[draggedPage];
        // If the dropped page is currently in the side pane, close it.
        if (paneContent === sidePaneContent && (bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {
          closeSidePane();
        }
        
        handleNavigation(draggedPage);
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, handleNavigation, dispatch, sidePaneContent, bodyState, closeSidePane]);

      const handleDragOverRight = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'right') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'right' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropRight = useCallback(() => {
        if (!draggedPage) return;
        const pane = pageToPaneMap[draggedPage as keyof typeof pageToPaneMap];
        if (pane) {
          // If dropping the currently active page to the right,
          // set a default page (e.g., dashboard) as the new active page.
          if (draggedPage === activePage) {
            handleNavigation('dashboard');
          }

          // Set the right pane content and ensure split view
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: pane });
          if (bodyState === BODY_STATES.NORMAL) {
            toggleSplitView(pane);
          } else if (bodyState === BODY_STATES.SIDE_PANE) {
            toggleSplitView();
          }
        }
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, toggleSplitView, dispatch, bodyState, activePage, handleNavigation]);

      return (
        <div 
          ref={appRef}
          className={cn(
            "relative h-screen w-screen overflow-hidden bg-background transition-colors duration-300",
            isDarkMode && "dark"
          )}
        >
          <div className="flex h-screen overflow-hidden">
            {/* Enhanced Sidebar */}
            {sidebarWithProps}

            {/* Resize Handle */}
            {sidebarState !== SIDEBAR_STATES.HIDDEN && (
              <div
                ref={resizeHandleRef}
                className={cn(
                  "absolute top-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
                )}
                onMouseDown={(e) => {
                  e.preventDefault()
                  dispatch({ type: 'SET_IS_RESIZING', payload: true });
                }}
              >
                <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
              </div>
            )}

            {/* Main area wrapper */}
            <div className="flex-1 flex flex-col overflow-hidden">
              <div ref={topBarContainerRef} className="relative z-30">
                {topBarWithProps}
              </div>

              <div className="flex flex-1 min-h-0">
                <div ref={mainAreaRef} className="relative flex-1 overflow-hidden bg-background">
                  {/* Left drop overlay */}
                  <div
                    className={cn(
                      "absolute inset-y-0 left-0 z-40 border-2 border-transparent",
                      draggedPage ? "pointer-events-auto w-1/2" : "pointer-events-none w-0",
                      dragHoverTarget === 'left' && "bg-primary/10 border-primary"
                    )}
                    onDragOver={handleDragOverLeft}
                    onDrop={handleDropLeft}
                    onDragLeave={() => {
                      if (dragHoverTarget === 'left') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                    }}
                  >
                    {draggedPage && (
                      <div className="absolute inset-0 flex items-center justify-center text-sm font-medium text-primary-foreground/80">
                        <span className="px-3 py-1 rounded-md bg-primary/70">Drop to Left</span>
                      </div>
                    )}
                  </div>
                  {mainContentWithProps}
                  {/* Right drop overlay (over main area to allow docking even if pane hidden) */}
                  <div
                    className={cn(
                      "absolute inset-y-0 right-0 z-40 border-2 border-transparent",
                      draggedPage ? "pointer-events-auto w-1/2" : "pointer-events-none",
                      dragHoverTarget === 'right' && "bg-primary/10 border-primary"
                    )}
                    onDragOver={handleDragOverRight}
                    onDrop={handleDropRight}
                    onDragLeave={() => {
                      if (dragHoverTarget === 'right') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                    }}
                  >
                    {draggedPage && (
                      <div className="absolute inset-0 flex items-center justify-center">
                        <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">Drop to Right</span>
                      </div>
                    )}
                  </div>
                </div>
                {rightPaneWithProps}
              </div>
            </div>
          </div>
          {commandPalette || <CommandPalette />}
        </div>
      )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 136
