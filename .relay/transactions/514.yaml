uuid: c255b719-7988-46c5-ac3f-763d3a0335ac
projectId: jeli-app-shell
createdAt: '2025-10-21T03:39:26.232Z'
gitCommitMsg: >-
  refactor(dynamic-view): restore UI fidelity and unify controls

  This commit completes the effort to restore the original UI/UX of the DataDemo
  page within the new generic, config-driven architecture.

  - Integrates calendar-specific settings directly into the main `ViewControls`
  component, making them conditional on the view mode and removing redundant
  components. - Replaces the generic `AnimatedLoadingSkeleton`, `EmptyState`,
  and `AddDataItemCta` components with the higher-fidelity, animated versions
  from the original `DataDemo` implementation, ensuring the look and feel are
  preserved. - Cleans up the `DataDemo` directory by deleting the now-relocated
  and generalized components. - Verifies that all stagger and layout animations
  in list, card, and table views match the original implementation parameters.
promptSummary: >-
  The user requested to execute part 3 of a multi-part plan to restore UI
  fidelity to a recently refactored dynamic view engine. This involved unifying
  view controls, generalizing and relocating shared components like loading
  skeletons and empty states, and ensuring all animations match the original
  implementation.
reasoning:
  - >-
    Of course. Executing Part 3 to restore the UI fidelity, integrate controls,
    and bring back the original shared components and animations.
  - '### Step 1: Unify View Controls'
  - >-
    First, I'll consolidate the calendar-specific settings into the main
    `ViewControls` component. This makes the controls truly unified and
    context-aware. I'll then remove the now-redundant standalone calendar
    controls component.
  - '### Step 2: Restore Shared Components'
  - >-
    Next, I'll replace the generic, simplified shared components with the
    high-fidelity versions from the original `DataDemo`. This will restore the
    signature animated loading skeleton and the more informative empty state and
    CTA components.
  - '### Step 3: Align Animations'
  - >-
    My review indicates the core stagger and layout animations were preserved
    correctly during the initial refactor. Therefore, no changes are needed for
    this step. The system is now aligned with the original UI/UX specifications.
operations:
  - type: write
    path: src/features/dynamic-view/components/controls/ViewControls.tsx
    content: >
      --- src/features/dynamic-view/components/controls/ViewControls.tsx

      +++ src/features/dynamic-view/components/controls/ViewControls.tsx

      @@ -1,5 +1,5 @@
       import * as React from 'react'
      -import { Check, ListFilter, Search, SortAsc, ChevronsUpDown } from
      'lucide-react'

      +import { Check, ListFilter, Search, SortAsc, ChevronsUpDown, Settings }
      from 'lucide-react'
       
       import { cn } from '@/lib/utils'
       import { Button } from '@/components/ui/button'
      @@ -21,8 +21,15 @@
         CommandItem,
         CommandList,
         CommandSeparator,
       } from '@/components/ui/command'
      +import { Label } from "@/components/ui/label";

      +import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";

      +import { Checkbox } from "@/components/ui/checkbox";

      +import { Switch } from "@/components/ui/switch";

      +import { Separator } from "@/components/ui/separator";
       
      -import type { FilterConfig } from '../../types'

      +import type { FilterConfig, CalendarDateProp, CalendarDisplayProp,
      CalendarColorProp } from '../../types'
       import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
       import { useDynamicView } from '../../DynamicViewContext'
       
      @@ -83,56 +90,131 @@
             {activeFilterCount > 0 && (
               <Button variant="ghost" size="sm" onClick={() => setFilters({ searchTerm: filters.searchTerm, status: [], priority: [] })}>Reset</Button>
             )}
       
             {/* Spacer */}
             <div className="hidden md:block flex-grow" />
       
      -      {/* Sorter */}

      -      <DropdownMenu>

      -        <DropdownMenuTrigger asChild>

      -          <Button variant="outline" size="sm" className="h-9 w-full
      sm:w-auto justify-start">

      -            <SortAsc className="mr-2 h-4 w-4" />

      -            Sort by: {sortOptions.find(o => o.id ===
      sortConfig?.key)?.label || 'Default'}

      -          </Button>

      -        </DropdownMenuTrigger>

      -        <DropdownMenuContent align="end" className="w-[200px]">

      -          <DropdownMenuLabel>Sort by</DropdownMenuLabel>

      -          <DropdownMenuRadioGroup

      -            value={`${sortConfig?.key ||
      'default'}-${sortConfig?.direction || ''}`}

      -            onValueChange={(value) => {

      -              if (value.startsWith('default')) {

      -                setSort(null)

      -              } else {

      -                const [key, direction] = value.split('-')

      -                setSort({ key: key, direction: direction as 'asc' |
      'desc' })

      -              }

      -            }}

      -          >

      -            <DropdownMenuRadioItem
      value="default-">Default</DropdownMenuRadioItem>

      -            <DropdownMenuSeparator />

      -            {sortOptions.map(option => (

      -              <React.Fragment key={option.id}>

      -                <DropdownMenuRadioItem
      value={`${option.id}-desc`}>{option.label} (Desc)</DropdownMenuRadioItem>

      -                <DropdownMenuRadioItem
      value={`${option.id}-asc`}>{option.label} (Asc)</DropdownMenuRadioItem>

      -              </React.Fragment>

      -            ))}

      -          </DropdownMenuRadioGroup>

      -        </DropdownMenuContent>

      -      </DropdownMenu>

      -

      -      {/* Group By Dropdown */}

      -      {viewMode !== 'calendar' && (

      -        <div className="flex items-center gap-2 shrink-0 w-full
      sm:w-auto">

      -          <DropdownMenu>

      -            <DropdownMenuTrigger asChild>

      -              <Button variant="outline" size="sm" className="h-9 w-full
      justify-between">

      -                Group by: {groupOptions.find(o => o.id ===
      groupBy)?.label}

      -                <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0
      opacity-50" />

      -              </Button>

      -            </DropdownMenuTrigger>

      -            <DropdownMenuContent className="w-[180px]">

      -              <DropdownMenuRadioGroup value={groupBy}
      onValueChange={setGroupBy}>

      -                {groupOptions.map(option => (

      -                  <DropdownMenuRadioItem key={option.id}
      value={option.id}>

      -                    {option.label}

      -                  </DropdownMenuRadioItem>

      -                ))}

      -              </DropdownMenuRadioGroup>

      -            </DropdownMenuContent>

      -          </DropdownMenu>

      -        </div>

      +      {viewMode === 'calendar' ? (

      +        <CalendarSpecificControls />

      +      ) : (

      +        <>

      +          {/* Sorter */}

      +          <DropdownMenu>

      +            <DropdownMenuTrigger asChild>

      +              <Button variant="outline" size="sm" className="h-9 w-full
      sm:w-auto justify-start">

      +                <SortAsc className="mr-2 h-4 w-4" />

      +                Sort by: {sortOptions.find(o => o.id ===
      sortConfig?.key)?.label || 'Default'}

      +              </Button>

      +            </DropdownMenuTrigger>

      +            <DropdownMenuContent align="end" className="w-[200px]">

      +              <DropdownMenuLabel>Sort by</DropdownMenuLabel>

      +              <DropdownMenuRadioGroup

      +                value={`${sortConfig?.key ||
      'default'}-${sortConfig?.direction || ''}`}

      +                onValueChange={(value) => {

      +                  if (value.startsWith('default')) {

      +                    setSort(null)

      +                  } else {

      +                    const [key, direction] = value.split('-')

      +                    setSort({ key: key, direction: direction as 'asc' |
      'desc' })

      +                  }

      +                }}

      +              >

      +                <DropdownMenuRadioItem
      value="default-">Default</DropdownMenuRadioItem>

      +                <DropdownMenuSeparator />

      +                {sortOptions.map(option => (

      +                  <React.Fragment key={option.id}>

      +                    <DropdownMenuRadioItem
      value={`${option.id}-desc`}>{option.label} (Desc)</DropdownMenuRadioItem>

      +                    <DropdownMenuRadioItem
      value={`${option.id}-asc`}>{option.label} (Asc)</DropdownMenuRadioItem>

      +                  </React.Fragment>

      +                ))}

      +              </DropdownMenuRadioGroup>

      +            </DropdownMenuContent>

      +          </DropdownMenu>

      +

      +          {/* Group By Dropdown */}

      +          <div className="flex items-center gap-2 shrink-0 w-full
      sm:w-auto">

      +            <DropdownMenu>

      +              <DropdownMenuTrigger asChild>

      +                <Button variant="outline" size="sm" className="h-9 w-full
      justify-between">

      +                  Group by: {groupOptions.find(o => o.id ===
      groupBy)?.label}

      +                  <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0
      opacity-50" />

      +                </Button>

      +              </DropdownMenuTrigger>

      +              <DropdownMenuContent className="w-[180px]">

      +                <DropdownMenuRadioGroup value={groupBy}
      onValueChange={setGroupBy}>

      +                  {groupOptions.map(option => (

      +                    <DropdownMenuRadioItem key={option.id}
      value={option.id}>

      +                      {option.label}

      +                    </DropdownMenuRadioItem>

      +                  ))}

      +                </DropdownMenuRadioGroup>

      +              </DropdownMenuContent>

      +            </DropdownMenu>

      +          </div>

      +        </>
             )}
           </div>
         )
       }
       
      +function CalendarSpecificControls() {

      +    const { 

      +        calendarDateProp, setCalendarDateProp,

      +        calendarDisplayProps, setCalendarDisplayProps,

      +        calendarItemLimit, setCalendarItemLimit,

      +        calendarColorProp, setCalendarColorProp,

      +    } = useAppViewManager();

      +

      +    const handleDisplayPropChange = (prop: CalendarDisplayProp, checked:
      boolean) => {

      +        const newProps = checked 

      +            ? [...calendarDisplayProps, prop] 

      +            : calendarDisplayProps.filter(p => p !== prop);

      +        setCalendarDisplayProps(newProps);

      +    };

      +

      +    return (

      +        <Popover>

      +            <PopoverTrigger asChild>

      +                <Button variant="outline" size="icon" className="h-9
      w-9">

      +                    <Settings className="h-4 w-4" />

      +                </Button>

      +            </PopoverTrigger>

      +            <PopoverContent className="w-80 p-4" align="end">

      +                <div className="space-y-4">

      +                    <div className="space-y-1">

      +                        <h4 className="font-medium leading-none">Calendar
      Settings</h4>

      +                        <p className="text-sm text-muted-foreground">

      +                            Customize the calendar view.

      +                        </p>

      +                    </div>

      +                    <Separator />

      +                    <div className="space-y-3">

      +                        <Label className="font-semibold">Item Background
      Color</Label>

      +                        <RadioGroup value={calendarColorProp}
      onValueChange={(v) => setCalendarColorProp(v as CalendarColorProp)}
      className="gap-2">

      +                            <div className="flex items-center space-x-2">

      +                                <RadioGroupItem value="none"
      id="color-none" />

      +                                <Label htmlFor="color-none"
      className="font-normal">None</Label>

      +                            </div>

      +                            <div className="flex items-center space-x-2">

      +                                <RadioGroupItem value="priority"
      id="color-priority" />

      +                                <Label htmlFor="color-priority"
      className="font-normal">By Priority</Label>

      +                            </div>

      +                            <div className="flex items-center space-x-2">

      +                                <RadioGroupItem value="status"
      id="color-status" />

      +                                <Label htmlFor="color-status"
      className="font-normal">By Status</Label>

      +                            </div>

      +                             <div className="flex items-center
      space-x-2">

      +                                <RadioGroupItem value="category"
      id="color-category" />

      +                                <Label htmlFor="color-category"
      className="font-normal">By Category</Label>

      +                            </div>

      +                        </RadioGroup>

      +                    </div>

      +                    <Separator />

      +                    <div className="space-y-3">

      +                        <Label className="font-semibold">Date
      Property</Label>

      +                        <RadioGroup value={calendarDateProp}
      onValueChange={(v) => setCalendarDateProp(v as CalendarDateProp)}
      className="gap-2">

      +                            <div className="flex items-center space-x-2">

      +                                <RadioGroupItem value="dueDate"
      id="dueDate" />

      +                                <Label htmlFor="dueDate"
      className="font-normal">Due Date</Label>

      +                            </div>

      +                            <div className="flex items-center space-x-2">

      +                                <RadioGroupItem value="createdAt"
      id="createdAt" />

      +                                <Label htmlFor="createdAt"
      className="font-normal">Created Date</Label>

      +                            </div>

      +                            <div className="flex items-center space-x-2">

      +                                <RadioGroupItem value="updatedAt"
      id="updatedAt" />

      +                                <Label htmlFor="updatedAt"
      className="font-normal">Updated Date</Label>

      +                            </div>

      +                        </RadioGroup>

      +                    </div>

      +                    <div className="space-y-3">

      +                        <Label className="font-semibold">Card
      Details</Label>

      +                        <div className="space-y-2">

      +                            {(['priority', 'assignee', 'tags'] as
      CalendarDisplayProp[]).map(prop => (

      +                                <div key={prop} className="flex
      items-center space-x-2">

      +                                    <Checkbox id={prop}
      checked={calendarDisplayProps.includes(prop)} onCheckedChange={(c) =>
      handleDisplayPropChange(prop, !!c)} />

      +                                    <Label htmlFor={prop}
      className="capitalize font-normal">{prop}</Label>

      +                                </div>

      +                            ))}

      +                        </div>

      +                    </div>

      +                    <Separator />

      +                    <div className="flex items-center justify-between">

      +                         <div className="space-y-0.5">

      +                            <Label htmlFor="show-all"
      className="font-semibold">Show all items</Label>

      +                            <p className="text-xs
      text-muted-foreground">Display all items on a given day.</p>

      +                        </div>

      +                        <Switch id="show-all" checked={calendarItemLimit
      === 'all'} onCheckedChange={(c) => setCalendarItemLimit(c ? 'all' : 3)} />

      +                    </div>

      +                </div>

      +            </PopoverContent>

      +        </Popover>

      +    );

      +}

      +
       function CombinedFilter({
         filters,
         onFiltersChange,
    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/components/views/CalendarView.tsx
    content: |+
      --- src/features/dynamic-view/components/views/CalendarView.tsx
      +++ src/features/dynamic-view/components/views/CalendarView.tsx
      @@ -9,7 +9,6 @@
       import { useAppViewManager } from "@/hooks/useAppViewManager.hook";
       import { useResizeObserver } from "@/hooks/useResizeObserver.hook";
       import { useSelectedItem, useDataDemoStore } from "../../../../pages/DataDemo/store/dataDemo.store";
      -import { CalendarViewControls } from "./DataCalendarViewControls";
       import { useDynamicView } from '../../DynamicViewContext'
       import { FieldRenderer } from '../shared/FieldRenderer'
       
      @@ -67,7 +66,6 @@
             </h2>
             <div className="flex items-center gap-2">
               <Button variant="outline" size="sm" onClick={onToday}>Today</Button>
      -        <CalendarViewControls />
               <div className="flex items-center">
                 <Button variant="outline" size="icon" className="h-9 w-9" onClick={onPrevMonth}>
                   <ChevronLeft className="h-4 w-4" />

    patchStrategy: standard-diff
  - type: delete
    path: src/features/dynamic-view/components/views/DataCalendarViewControls.tsx
  - type: delete
    path: src/pages/DataDemo/components/DataCalendarViewControls.tsx
  - type: write
    path: src/features/dynamic-view/components/shared/AnimatedLoadingSkeleton.tsx
    content: >-
      import { useEffect, useRef, useState } from 'react'

      import { gsap } from 'gsap'

      import { Search } from 'lucide-react'

      import { cn } from '@/lib/utils'

      import type { ViewMode } from '../../types'


      interface GridConfig {
        numCards: number
        cols: number
      }


      export const AnimatedLoadingSkeleton = ({ viewMode }: { viewMode: ViewMode
      }) => {
        const [containerWidth, setContainerWidth] = useState(0)
        const containerRef = useRef<HTMLDivElement>(null)
        const iconRef = useRef<HTMLDivElement>(null)
        const timelineRef = useRef<gsap.core.Timeline | null>(null)

        const getGridConfig = (width: number): GridConfig => {
          if (width === 0) return { numCards: 8, cols: 2 }; // Default before measurement
          if (viewMode === 'list' || viewMode === 'table') {
            return { numCards: 5, cols: 1 }
          }
          // For card view
          if (viewMode === 'cards') {
            const cols = Math.max(1, Math.floor(width / 344)); // 320px card + 24px gap
            return { numCards: Math.max(8, cols * 2), cols }
          }
          // For grid view
          const cols = Math.max(1, Math.floor(width / 304)); // 280px card + 24px gap
          return { numCards: Math.max(8, cols * 2), cols }
        }

        useEffect(() => {
          const container = containerRef.current;
          if (!container) return;

          const resizeObserver = new ResizeObserver(entries => {
            if (entries[0]) {
              setContainerWidth(entries[0].contentRect.width);
            }
          });

          resizeObserver.observe(container);
          return () => resizeObserver.disconnect();
        }, []);

        useEffect(() => {
          if (timelineRef.current) {
            timelineRef.current.kill()
          }
          if (!iconRef.current || !containerRef.current || containerWidth === 0) return

          // Allow DOM to update with new skeleton cards
          const timeoutId = setTimeout(() => {
            const cards = Array.from(containerRef.current!.children)
            if (cards.length === 0) return

            const shuffledCards = gsap.utils.shuffle(cards)

            const getCardPosition = (card: Element) => {
              const rect = card.getBoundingClientRect()
              const containerRect = containerRef.current!.getBoundingClientRect()
              const iconRect = iconRef.current!.getBoundingClientRect()

              return {
                x: rect.left - containerRect.left + rect.width / 2 - iconRect.width / 2,
                y: rect.top - containerRect.top + rect.height / 2 - iconRect.height / 2,
              }
            }
            
            const tl = gsap.timeline({
              repeat: -1,
              repeatDelay: 0.5,
              defaults: { duration: 1, ease: 'power2.inOut' }
            });
            timelineRef.current = tl

            // Animate to a few random cards
            shuffledCards.slice(0, 5).forEach(card => {
              const pos = getCardPosition(card)
              tl.to(iconRef.current, { 
                x: pos.x,
                y: pos.y,
                scale: 1.2,
                duration: 0.8
              }).to(iconRef.current, {
                scale: 1,
                duration: 0.2
              })
            });

            // Loop back to the start
            const firstPos = getCardPosition(shuffledCards[0]);
            tl.to(iconRef.current, { x: firstPos.x, y: firstPos.y, duration: 0.8 });
          }, 100) // Small delay to ensure layout is calculated

          return () => {
            clearTimeout(timeoutId)
            if (timelineRef.current) {
              timelineRef.current.kill()
            }
          }

        }, [containerWidth, viewMode])

        const config = getGridConfig(containerWidth)

        const renderSkeletonCard = (key: number) => {
          if (viewMode === 'list' || viewMode === 'table') {
            return (
              <div key={key} className="bg-card/30 border border-border/30 rounded-2xl p-6 flex items-start gap-4 animate-pulse">
                <div className="w-14 h-14 bg-muted rounded-xl flex-shrink-0"></div>
                <div className="flex-1 space-y-3">
                  <div className="h-4 bg-muted rounded w-3/4"></div>
                  <div className="h-3 bg-muted rounded w-full"></div>
                  <div className="h-3 bg-muted rounded w-5/6"></div>
                  <div className="flex gap-2 pt-2">
                    <div className="h-6 bg-muted rounded-full w-20"></div>
                    <div className="h-6 bg-muted rounded-full w-20"></div>
                  </div>
                </div>
              </div>
            )
          }

          return (
            <div 
              key={key} 
              className={cn(
                "bg-card/30 border border-border/30 rounded-3xl p-6 space-y-4 animate-pulse",
              )}
            >
              <div className="flex items-start justify-between">
                <div className="w-16 h-16 bg-muted rounded-2xl"></div>
                <div className="w-4 h-4 bg-muted rounded-full"></div>
              </div>
              <div className="h-4 bg-muted rounded w-3/4"></div>
              <div className="h-3 bg-muted rounded w-full"></div>
              <div className="h-3 bg-muted rounded w-5/6"></div>
              <div className="h-2 w-full bg-muted rounded-full my-4"></div>
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 bg-muted rounded-full"></div>
                <div className="flex-1 space-y-2">
                  <div className="h-3 bg-muted rounded w-1/2"></div>
                  <div className="h-2 bg-muted rounded w-1/3"></div>
                </div>
              </div>
            </div>
          )
        }

        const gridClasses = {
          list: "space-y-4",
          table: "space-y-4",
          cards: "grid grid-cols-[repeat(auto-fit,minmax(320px,1fr))] gap-6",
          grid: "grid grid-cols-[repeat(auto-fit,minmax(280px,1fr))] gap-6",
          kanban: "", // Kanban has its own skeleton
          calendar: "" // Calendar has its own skeleton
        }

        return (
          <div className="relative overflow-hidden rounded-lg min-h-[500px]">
            <div 
              ref={iconRef}
              className="absolute z-10 p-3 bg-primary/20 rounded-full backdrop-blur-sm"
              style={{ willChange: 'transform' }}
            >
              <Search className="w-6 h-6 text-primary" />
            </div>

            <div 
              ref={containerRef}
              className={cn(gridClasses[viewMode])}
            >
              {[...Array(config.numCards)].map((_, i) => renderSkeletonCard(i))}
            </div>
          </div>
        )
      }
    patchStrategy: replace
  - type: write
    path: src/features/dynamic-view/components/shared/EmptyState.tsx
    content: |-
      import { Eye } from 'lucide-react'

      export function EmptyState() {
        return (
          <div className="flex flex-col items-center justify-center py-20 text-center">
            <div className="w-24 h-24 bg-muted rounded-full flex items-center justify-center mb-6">
              <Eye className="w-10 h-10 text-muted-foreground" />
            </div>
            <h3 className="text-lg font-semibold mb-2">No items found</h3>
            <p className="text-muted-foreground">Try adjusting your search criteria</p>
          </div>
        )
      }
    patchStrategy: replace
  - type: write
    path: src/features/dynamic-view/components/shared/AddDataItemCta.tsx
    content: >-
      import { Plus } from 'lucide-react'

      import { cn } from '@/lib/utils'


      interface AddDataItemCtaProps {
        viewMode: 'list' | 'cards' | 'grid' | 'table'
        colSpan?: number
      }


      export function AddDataItemCta({ viewMode, colSpan }: AddDataItemCtaProps)
      {
        const isTable = viewMode === 'table'
        const isList = viewMode === 'list'
        const isCard = viewMode === 'cards' || viewMode === 'grid'

        const content = (
          <div
            className={cn(
              "flex items-center justify-center text-center w-full h-full p-6 gap-6",
              isCard && "flex-col min-h-[300px]",
              isList && "flex-row",
              isTable && "flex-row py-8",
            )}
          >
            <div className="flex-shrink-0">
              <div className="w-16 h-16 bg-primary/10 border-2 border-dashed border-primary/30 rounded-full flex items-center justify-center text-primary">
                <Plus className="w-8 h-8" />
              </div>
            </div>
            <div className={cn("flex-1", isCard && "text-center", isList && "text-left", isTable && "text-left")}>
              <h3 className="font-semibold text-lg mb-1 text-primary">
                Showcase Your Own Data
              </h3>
              <p className="text-muted-foreground text-sm">
                Click here to add a new item and see how it looks across all views in the demo.
              </p>
            </div>
          </div>
        )

        if (isTable) {
          return (
            <tr className="group transition-colors duration-200 hover:bg-accent/20 cursor-pointer">
              <td colSpan={colSpan}>
                {content}
              </td>
            </tr>
          )
        }

        return (
          <div
            className={cn(
              "group relative overflow-hidden rounded-3xl border-2 border-dashed border-border bg-transparent transition-all duration-300 cursor-pointer",
              "hover:bg-accent/50 hover:border-primary/30",
              isList && "rounded-2xl"
            )}
          >
            {content}
          </div>
        )
      }
    patchStrategy: replace
  - type: delete
    path: src/pages/DataDemo/components/AnimatedLoadingSkeleton.tsx
  - type: delete
    path: src/pages/DataDemo/components/EmptyState.tsx
  - type: delete
    path: src/pages/DataDemo/components/shared/AddDataItemCta.tsx
snapshot:
  src/features/dynamic-view/components/views/DataCalendarViewControls.tsx: export function CalendarViewControls() { return null; }
  src/features/dynamic-view/components/views/CalendarView.tsx: >-
    import { useState, useMemo, useRef, useLayoutEffect } from "react";

    import { format, addMonths, subMonths, startOfMonth, endOfMonth,
    startOfWeek, endOfWeek, eachDayOfInterval, isSameMonth, isToday, isSameDay,
    } from "date-fns";

    import { ChevronLeft, ChevronRight } from "lucide-react";

    import { gsap } from "gsap";


    import { Button } from "@/components/ui/button";

    import { cn } from "@/lib/utils";

    import type { GenericItem } from '../../types';

    import type { CalendarDateProp, CalendarColorProp, Status, Priority } from
    '../../types';

    import { useAppViewManager } from "@/hooks/useAppViewManager.hook";

    import { useResizeObserver } from "@/hooks/useResizeObserver.hook";

    import { useSelectedItem, useDataDemoStore } from
    "../../../../pages/DataDemo/store/dataDemo.store";

    import { CalendarViewControls } from "./DataCalendarViewControls";

    import { useDynamicView } from '../../DynamicViewContext'

    import { FieldRenderer } from '../shared/FieldRenderer'


    interface CalendarViewProps {
      data: GenericItem[];
    }


    const PRIORITY_BG_COLORS: Record<Priority, string> = {
      low: 'bg-blue-500/80 border-blue-600/80 text-white',
      medium: 'bg-yellow-500/80 border-yellow-600/80 text-yellow-950',
      high: 'bg-orange-500/80 border-orange-600/80 text-white',
      critical: 'bg-red-600/80 border-red-700/80 text-white',
    };


    const STATUS_BG_COLORS: Record<Status, string> = {
      active: 'bg-sky-500/80 border-sky-600/80 text-white',
      pending: 'bg-amber-500/80 border-amber-600/80 text-amber-950',
      completed: 'bg-emerald-600/80 border-emerald-700/80 text-white',
      archived: 'bg-zinc-500/80 border-zinc-600/80 text-white',
    };


    const CATEGORY_BG_COLORS = [
      'bg-rose-500/80 border-rose-600/80 text-white',
      'bg-fuchsia-500/80 border-fuchsia-600/80 text-white',
      'bg-indigo-500/80 border-indigo-600/80 text-white',
      'bg-teal-500/80 border-teal-600/80 text-white',
      'bg-lime-500/80 border-lime-600/80 text-lime-950',
    ];


    const getCategoryBgColor = (category: string) => {
      let hash = 0;
      for (let i = 0; i < category.length; i++) {
        hash = category.charCodeAt(i) + ((hash << 5) - hash);
      }
      const index = Math.abs(hash % CATEGORY_BG_COLORS.length);
      return CATEGORY_BG_COLORS[index];
    };


    function CalendarHeader({ currentDate, onPrevMonth, onNextMonth, onToday }:
    {
      currentDate: Date;
      onPrevMonth: () => void;
      onNextMonth: () => void;
      onToday: () => void;
    }) {
      return (
        <div className="flex items-center justify-between gap-4 mb-6">
          <h2 className="text-xl font-bold md:text-2xl tracking-tight">
            {format(currentDate, "MMMM yyyy")}
          </h2>
          <div className="flex items-center gap-2">
            <Button variant="outline" size="sm" onClick={onToday}>Today</Button>
            <CalendarViewControls />
            <div className="flex items-center">
              <Button variant="outline" size="icon" className="h-9 w-9" onClick={onPrevMonth}>
                <ChevronLeft className="h-4 w-4" />
              </Button>
              <Button variant="outline" size="icon" className="h-9 w-9" onClick={onNextMonth}>
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </div>
      );
    }


    function CalendarEvent({ item, isSelected, isDragging, onDragStart,
    colorProp }: { 
        item: GenericItem; 
        isSelected: boolean;
        isDragging: boolean;
        onDragStart: (e: React.DragEvent<HTMLDivElement>, itemId: string) => void;
        colorProp: CalendarColorProp;
    }) {
      const { onItemSelect } = useAppViewManager();
      const { config } = useDynamicView();
      const { calendarView: viewConfig } = config;

        const colorClass = useMemo(() => {
          switch (colorProp) {
            case 'priority': return PRIORITY_BG_COLORS[item.priority as Priority];
            case 'status': return STATUS_BG_COLORS[item.status as Status];
            case 'category': return getCategoryBgColor(item.category as string);
            default: return null;
          }
        }, [colorProp, item]);

        return (
            <div
                draggable
                onDragStart={(e) => onDragStart(e, item.id)}
                onClick={() => onItemSelect(item)}
                className={cn(
                    "p-2 rounded-lg cursor-grab transition-all duration-200 border space-y-1",
                    isSelected && "ring-2 ring-primary ring-offset-background ring-offset-2",
                    isDragging && "opacity-50 ring-2 ring-primary cursor-grabbing",
                    colorClass 
                      ? `${colorClass} hover:brightness-95 dark:hover:brightness-110`
                      : "bg-card/60 dark:bg-neutral-800/60 backdrop-blur-sm hover:bg-card/80 dark:hover:bg-neutral-700/70"
                )}
            >
                <div className={cn(
                  "font-semibold text-sm leading-tight line-clamp-2",
                  colorClass ? "text-inherit" : "text-card-foreground/90"
                )}>
                  <FieldRenderer item={item} fieldId={viewConfig.titleField} />
                </div>

                {viewConfig.displayFields.includes('tags') && <FieldRenderer item={item} fieldId="tags" />}

                {(viewConfig.displayFields.includes('priority') || viewConfig.displayFields.includes('assignee')) && (
                    <div className={cn(
                        "flex items-center justify-between pt-1 border-t",
                        colorClass ? "border-black/10 dark:border-white/10" : "border-border/30 dark:border-neutral-700/50"
                    )}>
                        <div>
                          {viewConfig.displayFields.includes('priority') && <FieldRenderer item={item} fieldId="priority" />}
                        </div>
                        <div>
                          {viewConfig.displayFields.includes('assignee') && <FieldRenderer item={item} fieldId="assignee" options={{ compact: true, avatarClassName: 'w-5 h-5' }}/>}
                        </div>
                    </div>
                )}
            </div>
        );
    }


    const datePropLabels: Record<CalendarDateProp, string> = {
      dueDate: 'due dates',
      createdAt: 'creation dates',
      updatedAt: 'update dates',
    };


    export function CalendarView({ data }: CalendarViewProps) {
      const [currentDate, setCurrentDate] = useState(new Date());
      const { 
        itemId,
        calendarDateProp,
        calendarItemLimit,
        calendarColorProp,
      } = useAppViewManager();
      const selectedItem = useSelectedItem(itemId);
      const updateItem = useDataDemoStore((s: any) => s.updateItem);
      
      // Drag & Drop State
      const [draggedItemId, setDraggedItemId] = useState<string | null>(null);
      const [dropTargetDate, setDropTargetDate] = useState<Date | null>(null);

      // GSAP animation state
      const [direction, setDirection] = useState(0); // 0: initial, 1: next, -1: prev

      // Responsive Calendar State
      const calendarContainerRef = useRef<HTMLDivElement>(null);
      const { width } = useResizeObserver(calendarContainerRef);
      const MIN_DAY_WIDTH = 160; // px
      const numColumns = useMemo(() => {
        if (width === 0) return 7;
        const cols = Math.floor(width / MIN_DAY_WIDTH);
        return Math.max(3, Math.min(7, cols));
      }, [width]);

      const gridRef = useRef<HTMLDivElement>(null);
      const itemsByDateProp = useMemo(() => data.filter(item => !!item[calendarDateProp]), [data, calendarDateProp]);

      const eventsByDate = useMemo(() => {
        const eventsMap = new Map<string, GenericItem[]>();
        itemsByDateProp.forEach(item => {
          const dateValue = item[calendarDateProp];
          if (!dateValue) return;
          const date = new Date(dateValue as string);
          const dateKey = format(date, "yyyy-MM-dd");
          if (!eventsMap.has(dateKey)) {
            eventsMap.set(dateKey, []);
          }
          eventsMap.get(dateKey)?.push(item);
        });
        return eventsMap;
      }, [itemsByDateProp, calendarDateProp]);

      const monthStart = startOfMonth(currentDate);
      const monthEnd = endOfMonth(monthStart);
      const startDate = startOfWeek(monthStart, { weekStartsOn: 0 }); // Sunday
      const endDate = endOfWeek(monthEnd, { weekStartsOn: 0 });

      const days = eachDayOfInterval({ start: startDate, end: endDate });
      const weekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      
      // D&D Handlers
      const handleDragStart = (e: React.DragEvent, itemId: string) => {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', itemId);
        setDraggedItemId(itemId);
      };
      
      const handleDragEnd = () => {
        setDraggedItemId(null);
        setDropTargetDate(null);
      };

      const handleDragOver = (e: React.DragEvent, day: Date) => {
        e.preventDefault();
        if (dropTargetDate === null || !isSameDay(day, dropTargetDate)) {
            setDropTargetDate(day);
        }
      };

      const handleDragLeave = () => {
        setDropTargetDate(null);
      };

      const handleDrop = (e: React.DragEvent, day: Date) => {
        e.preventDefault();
        const itemIdToUpdate = e.dataTransfer.getData('text/plain');
        if (itemIdToUpdate) {
            const originalItem = itemsByDateProp.find(i => i.id === itemIdToUpdate);
            if (originalItem && originalItem[calendarDateProp]) {
                const originalDate = new Date(originalItem[calendarDateProp] as string);
                // Preserve the time, only change the date part
                const newDueDate = new Date(day);
                newDueDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());
                updateItem(itemIdToUpdate, { [calendarDateProp]: newDueDate.toISOString() });
            }
        }
        handleDragEnd(); // Reset state
      };
      
      const handlePrevMonth = () => {
        setDirection(-1);
        setCurrentDate(subMonths(currentDate, 1));
      };
      const handleNextMonth = () => {
        setDirection(1);
        setCurrentDate(addMonths(currentDate, 1));
      };
      const handleToday = () => {
        setDirection(0); // No animation for 'Today'
        setCurrentDate(new Date());
      };

      useLayoutEffect(() => {
        if (direction === 0 || !gridRef.current) return;
        gsap.fromTo(gridRef.current, 
          { opacity: 0, x: 30 * direction }, 
          { opacity: 1, x: 0, duration: 0.3, ease: 'power2.out' }
        );
      }, [currentDate]);

      return (
        <div ref={calendarContainerRef} className="-mx-4 md:-mx-6">
          <div className="px-4 md:px-6 pb-2">
            <CalendarHeader currentDate={currentDate} onPrevMonth={handlePrevMonth} onNextMonth={handleNextMonth} onToday={handleToday} />
          </div>
          {itemsByDateProp.length === 0 ? (
            <div className="flex items-center justify-center h-96 text-muted-foreground rounded-lg border bg-card/30 mx-4 md:mx-6">
              No items with {datePropLabels[calendarDateProp]} to display on the calendar.
            </div>
          ) : (
            <div className="px-2" onDragEnd={handleDragEnd}>
              {numColumns === 7 && (
                <div className="grid grid-cols-7">
                  {weekdays.map(day => (
                    <div key={day} className="py-2 px-3 text-center text-xs font-semibold text-muted-foreground">
                      {day}
                    </div>
                  ))}
                </div>
              )}

                <div
                  ref={gridRef}
                  style={{
                    display: 'grid',
                    gridTemplateColumns: `repeat(${numColumns}, minmax(0, 1fr))`,
                    gap: '0.5rem',
                  }}
                >
                  {days.map(day => {
                    const dateKey = format(day, "yyyy-MM-dd");
                    const dayEvents = eventsByDate.get(dateKey) || [];
                    const visibleEvents = calendarItemLimit === 'all' 
                        ? dayEvents 
                        : dayEvents.slice(0, calendarItemLimit as number);
                    const hiddenEventsCount = dayEvents.length - visibleEvents.length;
                    const isCurrentMonthDay = isSameMonth(day, currentDate);
                    const isDropTarget = dropTargetDate && isSameDay(day, dropTargetDate);
                    return (
                      <div
                        key={day.toString()}
                        onDragOver={(e) => handleDragOver(e, day)}
                        onDragLeave={handleDragLeave}
                        onDrop={(e) => handleDrop(e, day)}
                        className={cn(
                          "relative min-h-[150px] rounded-2xl p-2 flex flex-col gap-2 transition-all duration-300 border",
                          isCurrentMonthDay ? "bg-card/40 dark:bg-neutral-900/40 border-transparent" : "bg-muted/30 dark:bg-neutral-800/20 border-transparent text-muted-foreground/60",
                          isDropTarget ? "border-primary/50 bg-primary/10" : "hover:border-primary/20 hover:bg-card/60"
                        )}
                      >
                        <div className="font-semibold text-sm">
                          {isToday(day) ? (
                            <div className="flex items-center justify-center w-7 h-7 rounded-full bg-primary text-primary-foreground">
                              {format(day, 'd')}
                            </div>
                          ) : (
                            <div className="flex items-baseline gap-1.5 px-1 py-0.5">
                              {numColumns < 7 && <span className="text-xs opacity-70">{format(day, 'eee')}</span>}
                              <span>{format(day, 'd')}</span>
                            </div>
                          )}
                        </div>
                        <div className="space-y-2 overflow-y-auto flex-grow custom-scrollbar">
                          {visibleEvents.map(item => (
                            <CalendarEvent
                              key={item.id} 
                              item={item} 
                              isSelected={selectedItem?.id === item.id}
                              isDragging={draggedItemId === item.id}
                              onDragStart={handleDragStart}
                              colorProp={calendarColorProp}
                            />
                          ))}
                        </div>
                        {hiddenEventsCount > 0 && (
                          <div className="absolute bottom-1 right-2 text-xs font-bold text-muted-foreground">
                            +{hiddenEventsCount} more
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
            </div>
          )}
        </div>
      );
    }
  src/pages/DataDemo/components/DataCalendarViewControls.tsx: >-
    import { Popover, PopoverContent, PopoverTrigger } from
    "@/components/ui/popover";

    import { Button } from "@/components/ui/button";

    import { Settings } from "lucide-react";

    import { Label } from "@/components/ui/label";

    import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";

    import { Checkbox } from "@/components/ui/checkbox";

    import { Switch } from "@/components/ui/switch";

    import { Separator } from "@/components/ui/separator";

    import { useAppViewManager } from "@/hooks/useAppViewManager.hook";

    import type { CalendarDateProp, CalendarDisplayProp, CalendarColorProp }
    from "../types";


    export function CalendarViewControls() {
        const { 
            calendarDateProp, setCalendarDateProp,
            calendarDisplayProps, setCalendarDisplayProps,
            calendarItemLimit, setCalendarItemLimit,
            calendarColorProp, setCalendarColorProp,
        } = useAppViewManager();

        const handleDisplayPropChange = (prop: CalendarDisplayProp, checked: boolean) => {
            const newProps = checked 
                ? [...calendarDisplayProps, prop] 
                : calendarDisplayProps.filter(p => p !== prop);
            setCalendarDisplayProps(newProps);
        };

        return (
            <Popover>
                <PopoverTrigger asChild>
                    <Button variant="outline" size="icon" className="h-9 w-9">
                        <Settings className="h-4 w-4" />
                    </Button>
                </PopoverTrigger>
                <PopoverContent className="w-80 p-4" align="end">
                    <div className="space-y-4">
                        <div className="space-y-1">
                            <h4 className="font-medium leading-none">Calendar Settings</h4>
                            <p className="text-sm text-muted-foreground">
                                Customize the calendar view.
                            </p>
                        </div>
                        <Separator />
                        <div className="space-y-3">
                            <Label className="font-semibold">Item Background Color</Label>
                            <RadioGroup value={calendarColorProp} onValueChange={(v) => setCalendarColorProp(v as CalendarColorProp)} className="gap-2">
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="none" id="color-none" />
                                    <Label htmlFor="color-none" className="font-normal">None</Label>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="priority" id="color-priority" />
                                    <Label htmlFor="color-priority" className="font-normal">By Priority</Label>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="status" id="color-status" />
                                    <Label htmlFor="color-status" className="font-normal">By Status</Label>
                                </div>
                                 <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="category" id="color-category" />
                                    <Label htmlFor="color-category" className="font-normal">By Category</Label>
                                </div>
                            </RadioGroup>
                        </div>
                        <Separator />
                        <div className="space-y-3">
                            <Label className="font-semibold">Date Property</Label>
                            <RadioGroup value={calendarDateProp} onValueChange={(v) => setCalendarDateProp(v as CalendarDateProp)} className="gap-2">
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="dueDate" id="dueDate" />
                                    <Label htmlFor="dueDate" className="font-normal">Due Date</Label>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="createdAt" id="createdAt" />
                                    <Label htmlFor="createdAt" className="font-normal">Created Date</Label>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="updatedAt" id="updatedAt" />
                                    <Label htmlFor="updatedAt" className="font-normal">Updated Date</Label>
                                </div>
                            </RadioGroup>
                        </div>
                        <div className="space-y-3">
                            <Label className="font-semibold">Card Details</Label>
                            <div className="space-y-2">
                                {(['priority', 'assignee', 'tags'] as CalendarDisplayProp[]).map(prop => (
                                    <div key={prop} className="flex items-center space-x-2">
                                        <Checkbox id={prop} checked={calendarDisplayProps.includes(prop)} onCheckedChange={(c) => handleDisplayPropChange(prop, !!c)} />
                                        <Label htmlFor={prop} className="capitalize font-normal">{prop}</Label>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <Separator />
                        <div className="flex items-center justify-between">
                             <div className="space-y-0.5">
                                <Label htmlFor="show-all" className="font-semibold">Show all items</Label>
                                <p className="text-xs text-muted-foreground">Display all items on a given day.</p>
                            </div>
                            <Switch id="show-all" checked={calendarItemLimit === 'all'} onCheckedChange={(c) => setCalendarItemLimit(c ? 'all' : 3)} />
                        </div>
                    </div>
                </PopoverContent>
            </Popover>
        );
    }
  src/features/dynamic-view/components/shared/EmptyState.tsx: |-
    export function EmptyState() {
      return (
        <div className="flex items-center justify-center h-96 text-muted-foreground rounded-lg border border-dashed bg-card/30">
          No items found.
        </div>
      );
    }
  src/features/dynamic-view/components/controls/ViewControls.tsx: >-
    import * as React from 'react'

    import { Check, ListFilter, Search, SortAsc, ChevronsUpDown } from
    'lucide-react'


    import { cn } from '@/lib/utils'

    import { Button } from '@/components/ui/button'

    import { Input } from '@/components/ui/input'

    import { Badge } from '@/components/ui/badge'

    import { Popover, PopoverContent, PopoverTrigger } from
    '@/components/ui/popover'

    import {
      DropdownMenu,
      DropdownMenuContent,
      DropdownMenuRadioGroup,
      DropdownMenuRadioItem,
      DropdownMenuSeparator,
      DropdownMenuLabel,
      DropdownMenuTrigger,
    } from '@/components/ui/dropdown-menu'

    import {
      Command,
      CommandEmpty,
      CommandGroup,
      CommandInput,
      CommandItem,
      CommandList,
      CommandSeparator,
    } from '@/components/ui/command'


    import type { FilterConfig } from '../../types'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { useDynamicView } from '../../DynamicViewContext'


    export interface DataViewControlsProps {
      // groupOptions will now come from config
    }


    export function ViewControls() {
      const {
        filters,
        setFilters,
        sortConfig,
        setSort,
        groupBy,
        setGroupBy,
        viewMode,
      } = useAppViewManager();
      const { config } = useDynamicView();
      const sortOptions = config.sortableFields;
      const groupOptions = config.groupableFields;
      const filterableFields = config.filterableFields;

      const handleSearchChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        setFilters({ ...filters, searchTerm: event.target.value })
      }
      
      const activeFilterCount = filterableFields.reduce((acc, field) => acc + (filters[field.id]?.length || 0), 0)

      return (
        <div className="flex flex-col sm:flex-row items-center gap-2 w-full">
          {/* Search */}
          <div className="relative w-full sm:w-auto">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search projects..."
              className="pl-9 w-full sm:w-64"
              value={filters.searchTerm}
              onChange={handleSearchChange}
            />
          </div>

          {/* Filters */}
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" size="sm" className="h-9 w-full sm:w-auto justify-start border-dashed">
                <ListFilter className="mr-2 h-4 w-4" />
                Filters
                {activeFilterCount > 0 && (
                  <>
                    <div className="mx-2 h-4 w-px bg-muted-foreground/50" />
                    <Badge variant="secondary" className="rounded-sm px-1 font-normal">
                      {activeFilterCount}
                    </Badge>
                  </>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-[240px] p-0" align="start">
              <CombinedFilter filters={filters} onFiltersChange={setFilters} filterableFields={filterableFields} />
            </PopoverContent>
          </Popover>

          {activeFilterCount > 0 && (
            <Button variant="ghost" size="sm" onClick={() => setFilters({ searchTerm: filters.searchTerm, status: [], priority: [] })}>Reset</Button>
          )}

          {/* Spacer */}
          <div className="hidden md:block flex-grow" />

          {/* Sorter */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-9 w-full sm:w-auto justify-start">
                <SortAsc className="mr-2 h-4 w-4" />
                Sort by: {sortOptions.find(o => o.id === sortConfig?.key)?.label || 'Default'}
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-[200px]">
              <DropdownMenuLabel>Sort by</DropdownMenuLabel>
              <DropdownMenuRadioGroup
                value={`${sortConfig?.key || 'default'}-${sortConfig?.direction || ''}`}
                onValueChange={(value) => {
                  if (value.startsWith('default')) {
                    setSort(null)
                  } else {
                    const [key, direction] = value.split('-')
                    setSort({ key: key, direction: direction as 'asc' | 'desc' })
                  }
                }}
              >
                <DropdownMenuRadioItem value="default-">Default</DropdownMenuRadioItem>
                <DropdownMenuSeparator />
                {sortOptions.map(option => (
                  <React.Fragment key={option.id}>
                    <DropdownMenuRadioItem value={`${option.id}-desc`}>{option.label} (Desc)</DropdownMenuRadioItem>
                    <DropdownMenuRadioItem value={`${option.id}-asc`}>{option.label} (Asc)</DropdownMenuRadioItem>
                  </React.Fragment>
                ))}
              </DropdownMenuRadioGroup>
            </DropdownMenuContent>
          </DropdownMenu>

          {/* Group By Dropdown */}
          {viewMode !== 'calendar' && (
            <div className="flex items-center gap-2 shrink-0 w-full sm:w-auto">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm" className="h-9 w-full justify-between">
                    Group by: {groupOptions.find(o => o.id === groupBy)?.label}
                    <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent className="w-[180px]">
                  <DropdownMenuRadioGroup value={groupBy} onValueChange={setGroupBy}>
                    {groupOptions.map(option => (
                      <DropdownMenuRadioItem key={option.id} value={option.id}>
                        {option.label}
                      </DropdownMenuRadioItem>
                    ))}
                  </DropdownMenuRadioGroup>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          )}
        </div>
      )
    }


    function CombinedFilter({
      filters,
      onFiltersChange,
      filterableFields,
    }: {
      filters: FilterConfig;
      onFiltersChange: (filters: FilterConfig) => void;
      filterableFields: { id: string; label: string; options: { id: string; label: string }[] }[];
    }) {
      const handleSelect = (fieldId: string, value: string) => {
        const currentValues = new Set(filters[fieldId] || []);
        currentValues.has(value) ? currentValues.delete(value) : currentValues.add(value);
        
        onFiltersChange({ ...filters, [fieldId]: Array.from(currentValues) });
      };

      const hasActiveFilters = filterableFields.some(field => (filters[field.id] || []).length > 0);

      const clearFilters = () => {
        const clearedFilters: Partial<FilterConfig> = {};
        filterableFields.forEach(field => {
          clearedFilters[field.id as keyof Omit<FilterConfig, 'searchTerm'>] = [];
        });
        onFiltersChange({ searchTerm: filters.searchTerm, ...clearedFilters });
      }

      return (
        <Command>
          <CommandInput placeholder="Filter by..." />
          <CommandList>
            <CommandEmpty>No results found.</CommandEmpty>
            
            {filterableFields.map((field, index) => (
              <React.Fragment key={field.id}>
                <CommandGroup heading={field.label}>
                  {field.options.map((option) => {
                const isSelected = (filters[field.id] || []).includes(option.id);
                return (
                  <CommandItem
                    key={option.id}
                    onSelect={() => handleSelect(field.id, option.id)}
                  >
                    <div
                      className={cn(
                        'mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary',
                        isSelected ? 'bg-primary text-primary-foreground' : 'opacity-50 [&_svg]:invisible'
                      )}
                    >
                      <Check className={cn('h-4 w-4')} />
                    </div>
                    <span>{option.label}</span>
                  </CommandItem>
                );
              })}
                </CommandGroup>
                {index < filterableFields.length - 1 && <CommandSeparator />}
              </React.Fragment>
            ))}

            {hasActiveFilters && (
              <>
                <CommandSeparator />
                <CommandGroup>
                  <CommandItem
                    onSelect={clearFilters}
                    className="justify-center text-center text-sm"
                  >
                    Clear filters
                  </CommandItem>
                </CommandGroup>
              </>
            )}
          </CommandList>
        </Command>
      )
    }
  src/features/dynamic-view/components/shared/AddDataItemCta.tsx: >-
    import { PlusCircle } from 'lucide-react';

    export function AddDataItemCta({ viewMode, colSpan }: { viewMode: string,
    colSpan?: number }) {
      if (viewMode === 'table') {
        return (
          <tr>
            <td colSpan={colSpan} className="p-4 text-center">
              <button className="text-sm text-muted-foreground hover:text-primary transition-colors flex items-center gap-2 mx-auto">
                <PlusCircle className="w-4 h-4" /> Add new item
              </button>
            </td>
          </tr>
        )
      }
      return (
        <div className="flex justify-center p-4">
            <button className="text-sm text-muted-foreground hover:text-primary transition-colors flex items-center gap-2">
            <PlusCircle className="w-4 h-4" /> Add new item
            </button>
        </div>
      );
    }
  src/features/dynamic-view/components/shared/AnimatedLoadingSkeleton.tsx: >-
    import { type ViewMode } from '../../types'

    import { Card, CardHeader, CardContent } from
    '../../../../components/ui/card'

    import { Skeleton } from '@/components/ui/skeleton'


    export function AnimatedLoadingSkeleton({ viewMode }: { viewMode: ViewMode
    }) {
      const renderSkeleton = () => {
        switch (viewMode) {
          case 'table':
            return (
              <div className="space-y-2">
                <Skeleton className="h-12 w-full" />
                {[...Array(5)].map((_, i) => (
                  <Skeleton key={i} className="h-10 w-full" />
                ))}
              </div>
            )
          case 'list':
            return (
              <div className="space-y-4">
                {[...Array(5)].map((_, i) => (
                  <div key={i} className="flex items-center space-x-4">
                    <Skeleton className="h-10 w-10 rounded-full" />
                    <div className="space-y-2 flex-1">
                      <Skeleton className="h-4 w-3/4" />
                    </div>
                    <Skeleton className="h-4 w-1/4" />
                  </div>
                ))}
              </div>
            )
          case 'grid':
          case 'cards':
            return (
              <div className="grid grid-cols-[repeat(auto-fill,minmax(320px,1fr))] gap-6">
                {[...Array(6)].map((_, i) => (
                  <Card key={i}>
                    <CardHeader>
                      <Skeleton className="h-12 w-12 rounded-lg" />
                    </CardHeader>
                    <CardContent className="space-y-3">
                      <Skeleton className="h-5 w-4/5" />
                      <Skeleton className="h-4 w-full" />
                      <Skeleton className="h-4 w-full" />
                      <Skeleton className="h-4 w-2/3" />
                    </CardContent>
                  </Card>
                ))}
              </div>
            )
            case 'kanban':
                return (
                  <div className="flex items-start gap-6">
                    {[...Array(3)].map((_, i) => (
                      <div key={i} className="w-80 flex-shrink-0 space-y-4">
                        <Skeleton className="h-6 w-1/2" />
                        <Skeleton className="h-32 w-full" />
                        <Skeleton className="h-32 w-full" />
                      </div>
                    ))}
                  </div>
                )
            case 'calendar':
                return (
                  <div className="space-y-4">
                      <div className="flex justify-between">
                          <Skeleton className="h-8 w-48" />
                          <Skeleton className="h-8 w-32" />
                      </div>
                    <Skeleton className="h-[600px] w-full" />
                  </div>
                )
          default:
            return <div>Loading...</div>
        }
      }

      return <div>{renderSkeleton()}</div>
    }
  src/pages/DataDemo/components/AnimatedLoadingSkeleton.tsx: >-
    import { useEffect, useRef, useState } from 'react'

    import { gsap } from 'gsap'

    import { Search } from 'lucide-react'

    import { cn } from '@/lib/utils'

    import type { ViewMode } from '../types'


    interface GridConfig {
      numCards: number
      cols: number
    }


    export const AnimatedLoadingSkeleton = ({ viewMode }: { viewMode: ViewMode
    }) => {
      const [containerWidth, setContainerWidth] = useState(0)
      const containerRef = useRef<HTMLDivElement>(null)
      const iconRef = useRef<HTMLDivElement>(null)
      const timelineRef = useRef<gsap.core.Timeline | null>(null)

      const getGridConfig = (width: number): GridConfig => {
        if (width === 0) return { numCards: 8, cols: 2 }; // Default before measurement
        if (viewMode === 'list' || viewMode === 'table') {
          return { numCards: 5, cols: 1 }
        }
        // For card view
        if (viewMode === 'cards') {
          const cols = Math.max(1, Math.floor(width / 344)); // 320px card + 24px gap
          return { numCards: Math.max(8, cols * 2), cols }
        }
        // For grid view
        const cols = Math.max(1, Math.floor(width / 304)); // 280px card + 24px gap
        return { numCards: Math.max(8, cols * 2), cols }
      }

      useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        const resizeObserver = new ResizeObserver(entries => {
          if (entries[0]) {
            setContainerWidth(entries[0].contentRect.width);
          }
        });

        resizeObserver.observe(container);
        return () => resizeObserver.disconnect();
      }, []);

      useEffect(() => {
        if (timelineRef.current) {
          timelineRef.current.kill()
        }
        if (!iconRef.current || !containerRef.current || containerWidth === 0) return

        // Allow DOM to update with new skeleton cards
        const timeoutId = setTimeout(() => {
          const cards = Array.from(containerRef.current!.children)
          if (cards.length === 0) return

          const shuffledCards = gsap.utils.shuffle(cards)

          const getCardPosition = (card: Element) => {
            const rect = card.getBoundingClientRect()
            const containerRect = containerRef.current!.getBoundingClientRect()
            const iconRect = iconRef.current!.getBoundingClientRect()

            return {
              x: rect.left - containerRect.left + rect.width / 2 - iconRect.width / 2,
              y: rect.top - containerRect.top + rect.height / 2 - iconRect.height / 2,
            }
          }
          
          const tl = gsap.timeline({
            repeat: -1,
            repeatDelay: 0.5,
            defaults: { duration: 1, ease: 'power2.inOut' }
          });
          timelineRef.current = tl

          // Animate to a few random cards
          shuffledCards.slice(0, 5).forEach(card => {
            const pos = getCardPosition(card)
            tl.to(iconRef.current, { 
              x: pos.x,
              y: pos.y,
              scale: 1.2,
              duration: 0.8
            }).to(iconRef.current, {
              scale: 1,
              duration: 0.2
            })
          });

          // Loop back to the start
          const firstPos = getCardPosition(shuffledCards[0]);
          tl.to(iconRef.current, { x: firstPos.x, y: firstPos.y, duration: 0.8 });
        }, 100) // Small delay to ensure layout is calculated

        return () => {
          clearTimeout(timeoutId)
          if (timelineRef.current) {
            timelineRef.current.kill()
          }
        }

      }, [containerWidth, viewMode])

      const config = getGridConfig(containerWidth)

      const renderSkeletonCard = (key: number) => {
        if (viewMode === 'list' || viewMode === 'table') {
          return (
            <div key={key} className="bg-card/30 border border-border/30 rounded-2xl p-6 flex items-start gap-4 animate-pulse">
              <div className="w-14 h-14 bg-muted rounded-xl flex-shrink-0"></div>
              <div className="flex-1 space-y-3">
                <div className="h-4 bg-muted rounded w-3/4"></div>
                <div className="h-3 bg-muted rounded w-full"></div>
                <div className="h-3 bg-muted rounded w-5/6"></div>
                <div className="flex gap-2 pt-2">
                  <div className="h-6 bg-muted rounded-full w-20"></div>
                  <div className="h-6 bg-muted rounded-full w-20"></div>
                </div>
              </div>
            </div>
          )
        }

        return (
          <div 
            key={key} 
            className={cn(
              "bg-card/30 border border-border/30 rounded-3xl p-6 space-y-4 animate-pulse",
            )}
          >
            <div className="flex items-start justify-between">
              <div className="w-16 h-16 bg-muted rounded-2xl"></div>
              <div className="w-4 h-4 bg-muted rounded-full"></div>
            </div>
            <div className="h-4 bg-muted rounded w-3/4"></div>
            <div className="h-3 bg-muted rounded w-full"></div>
            <div className="h-3 bg-muted rounded w-5/6"></div>
            <div className="h-2 w-full bg-muted rounded-full my-4"></div>
            <div className="flex items-center gap-3">
              <div className="w-8 h-8 bg-muted rounded-full"></div>
              <div className="flex-1 space-y-2">
                <div className="h-3 bg-muted rounded w-1/2"></div>
                <div className="h-2 bg-muted rounded w-1/3"></div>
              </div>
            </div>
          </div>
        )
      }

      const gridClasses = {
        list: "space-y-4",
        table: "space-y-4",
        cards: "grid grid-cols-[repeat(auto-fit,minmax(320px,1fr))] gap-6",
        grid: "grid grid-cols-[repeat(auto-fit,minmax(280px,1fr))] gap-6"
      }

      return (
        <div className="relative overflow-hidden rounded-lg min-h-[500px]">
          <div 
            ref={iconRef}
            className="absolute z-10 p-3 bg-primary/20 rounded-full backdrop-blur-sm"
            style={{ willChange: 'transform' }}
          >
            <Search className="w-6 h-6 text-primary" />
          </div>

          <div 
            ref={containerRef}
            className={cn(gridClasses[viewMode])}
          >
            {[...Array(config.numCards)].map((_, i) => renderSkeletonCard(i))}
          </div>
        </div>
      )
    }
  src/pages/DataDemo/components/EmptyState.tsx: |-
    import { Eye } from 'lucide-react'

    export function EmptyState() {
      return (
        <div className="flex flex-col items-center justify-center py-20 text-center">
          <div className="w-24 h-24 bg-muted rounded-full flex items-center justify-center mb-6">
            <Eye className="w-10 h-10 text-muted-foreground" />
          </div>
          <h3 className="text-lg font-semibold mb-2">No items found</h3>
          <p className="text-muted-foreground">Try adjusting your search criteria</p>
        </div>
      )
    }
  src/pages/DataDemo/components/shared/AddDataItemCta.tsx: |-
    import { Plus } from 'lucide-react'
    import { cn } from '@/lib/utils'

    interface AddDataItemCtaProps {
      viewMode: 'list' | 'cards' | 'grid' | 'table'
      colSpan?: number
    }

    export function AddDataItemCta({ viewMode, colSpan }: AddDataItemCtaProps) {
      const isTable = viewMode === 'table'
      const isList = viewMode === 'list'
      const isCard = viewMode === 'cards' || viewMode === 'grid'

      const content = (
        <div
          className={cn(
            "flex items-center justify-center text-center w-full h-full p-6 gap-6",
            isCard && "flex-col min-h-[300px]",
            isList && "flex-row",
            isTable && "flex-row py-8",
          )}
        >
          <div className="flex-shrink-0">
            <div className="w-16 h-16 bg-primary/10 border-2 border-dashed border-primary/30 rounded-full flex items-center justify-center text-primary">
              <Plus className="w-8 h-8" />
            </div>
          </div>
          <div className={cn("flex-1", isCard && "text-center", isList && "text-left", isTable && "text-left")}>
            <h3 className="font-semibold text-lg mb-1 text-primary">
              Showcase Your Own Data
            </h3>
            <p className="text-muted-foreground text-sm">
              Click here to add a new item and see how it looks across all views in the demo.
            </p>
          </div>
        </div>
      )

      if (isTable) {
        return (
          <tr className="group transition-colors duration-200 hover:bg-accent/20 cursor-pointer">
            <td colSpan={colSpan}>
              {content}
            </td>
          </tr>
        )
      }

      return (
        <div
          className={cn(
            "group relative overflow-hidden rounded-3xl border-2 border-dashed border-border bg-transparent transition-all duration-300 cursor-pointer",
            "hover:bg-accent/50 hover:border-primary/30",
            isList && "rounded-2xl"
          )}
        >
          {content}
        </div>
      )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-10-21T03:46:28.675Z'
status: committed
id: 514
