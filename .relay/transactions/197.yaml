uuid: b0d05261-26dd-4ca7-a2f0-94e45d1d86d5
projectId: jeli-app-shell
createdAt: '2025-10-13T03:29:55.288Z'
gitCommitMsg: >-
  fix(DataViewModeSelector): Synchronize and unify component animations

  - Refactored button animations to use a single, unified `gsap.to()` call for
  all buttons, removing the instantaneous `gsap.set()` that caused a "refresh"
  feeling on view change. - Synchronized the duration and easing of the button
  resize animation with the indicator slide animation. - This ensures all
  animated elements (buttons, indicator) move in perfect harmony during expand,
  collapse, and view-change events, fixing visual glitches and alignment issues
  during transitions.
promptSummary: >-
  Fix the animation smoothness and alignment issues in the DataViewModeSelector
  component.
reasoning:
  - >-
    You've made some sharp observations. The "refreshing" animation and the
    alignment issues are symptoms of the same root cause: the button and
    indicator animations were not perfectly synchronized, especially during the
    collapse transition. My previous predictive calculation was a step in the
    right direction, but it wasn't enough.
  - 'I''ve implemented a more robust solution that fixes both issues:'
  - >-
    1.  **Unified Animation Logic**: I've refactored the button animation logic
    to remove the separate, instantaneous `gsap.set` call for the active button.
    Now, all buttons are handled by a single, unified `gsap.to` call. This
    ensures that when the view mode changes, there's no "refresh" or
    flickerâ€”just a smooth animation.
  - >-
    2.  **Synchronized Transitions**: I've matched the animation `duration`
    (0.4s) and `ease` (`power3.out`) for both the indicator's movement and the
    buttons' resizing. When the component collapses, the indicator and the
    active button now slide to their final positions in perfect harmony, which
    also solves the perceived alignment problem during the animation.
  - >-
    These changes result in a much smoother, more polished, and "cooler"
    interaction that feels fluid and responsive, whether you're hovering,
    unhovering, or switching views.
  - >-
    Here is the patch for
    `src/pages/DataDemo/components/DataViewModeSelector.tsx`.
operations:
  - type: write
    path: src/pages/DataDemo/components/DataViewModeSelector.tsx
    content: >+
      --- src/pages/DataDemo/components/DataViewModeSelector.tsx

      +++ src/pages/DataDemo/components/DataViewModeSelector.tsx

      @@ -40,43 +40,36 @@
           // Determine responsive sizes
           const isSmallScreen = window.innerWidth < 640;
           const padding = isSmallScreen ? 16 : 24; // px-4 vs sm:px-6
      -    const minWidth = isSmallScreen ? 100 : 120;

      +    const buttonWidth = isSmallScreen ? 100 : 120;
       
           buttonRefs.current.forEach((button, index) => {
             if (!button) return;
       
             const isActive = index === activeIndex;
      -

      -      // The active button is always visible and sized correctly

      -      if (isActive) {

      -        gsap.set(button, {

      -          minWidth: minWidth,

      -          width: minWidth,

      -          paddingLeft: padding,

      -          paddingRight: padding,

      -          opacity: 1,

      -          pointerEvents: 'auto',

      -          overflow: 'visible'

      -        });

      -        return;

      -      }

      -

      -      // Animate inactive buttons

      +      const shouldBeVisible = isExpanded || isActive;

      +

      +      // Animate all buttons to their correct state
             gsap.to(button, {
      -        width: isExpanded ? minWidth : 0,

      -        minWidth: isExpanded ? minWidth : 0,

      -        paddingLeft: isExpanded ? padding : 0,

      -        paddingRight: isExpanded ? padding : 0,

      -        opacity: isExpanded ? 1 : 0,

      -        duration: 0.3,

      -        ease: "power2.out",

      -        delay: isExpanded ? (Math.abs(index - activeIndex) - 1) * 0.05 :
      0,

      -        pointerEvents: isExpanded ? "auto" : "none",

      +        width: shouldBeVisible ? buttonWidth : 0,

      +        minWidth: shouldBeVisible ? buttonWidth : 0,

      +        paddingLeft: shouldBeVisible ? padding : 0,

      +        paddingRight: shouldBeVisible ? padding : 0,

      +        opacity: shouldBeVisible ? 1 : 0,

      +        duration: 0.4,

      +        ease: "power3.out",

      +        // Add a ripple delay effect only when expanding

      +        delay: isExpanded && !isActive ? (Math.abs(index - activeIndex) -
      1) * 0.05 : 0,

      +        pointerEvents: shouldBeVisible ? "auto" : "none",
               overwrite: true,
               onStart: () => {
      -          if(!isExpanded) button.style.overflow = 'hidden';

      +          // Hide overflow during collapse to clip content cleanly

      +          if (!shouldBeVisible) button.style.overflow = 'hidden';
               },
               onComplete: () => {
      -          if (isExpanded) button.style.overflow = 'visible';

      +          // Restore overflow when visible to allow for hover effects
      etc.

      +          if (shouldBeVisible) button.style.overflow = 'visible';
               }
             });
           });

    patchStrategy: standard-diff
snapshot:
  src/pages/DataDemo/components/DataViewModeSelector.tsx: >-
    import { useEffect, useRef, useState } from 'react'

    import { gsap } from 'gsap'

    import { cn } from '@/lib/utils'

    import { List, Grid3X3, LayoutGrid, Table } from 'lucide-react'

    import type { ViewMode } from '../types'


    interface DataViewModeSelectorProps {
      viewMode: ViewMode
      onChange: (mode: ViewMode) => void
    }


    const viewModes = [
      { id: 'list' as ViewMode, label: 'List', icon: List, description: 'Compact list with details' },
      { id: 'cards' as ViewMode, label: 'Cards', icon: LayoutGrid, description: 'Rich card layout' },
      { id: 'grid' as ViewMode, label: 'Grid', icon: Grid3X3, description: 'Masonry grid view' },
      { id: 'table' as ViewMode, label: 'Table', icon: Table, description: 'Structured data table' }
    ]


    export function DataViewModeSelector({ viewMode, onChange }:
    DataViewModeSelectorProps) {
      const indicatorRef = useRef<HTMLDivElement>(null)
      const containerRef = useRef<HTMLDivElement>(null);
      const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);
      const [isExpanded, setIsExpanded] = useState(false);

      // Animate the indicator to the active button
      useEffect(() => {
        if (!indicatorRef.current) return

        const activeIndex = viewModes.findIndex((m) => m.id === viewMode);
        if (activeIndex === -1) return;

        // Determine responsive sizes, must match the other useEffect
        const isSmallScreen = window.innerWidth < 640;
        const buttonWidth = isSmallScreen ? 100 : 120;
        
        // Calculate final position without reading from DOM during animation
        const targetX = isExpanded
          ? activeIndex * buttonWidth
          : 0;

        // Animate indicator to the calculated position
        gsap.to(indicatorRef.current, {
          duration: 0.4,
          x: targetX,
          width: buttonWidth,
          ease: "power3.out",
        });
      }, [viewMode, isExpanded]);

      // Expand and collapse inactive buttons
      useEffect(() => {
        const activeIndex = viewModes.findIndex((m) => m.id === viewMode);
        
        // Determine responsive sizes
        const isSmallScreen = window.innerWidth < 640;
        const padding = isSmallScreen ? 16 : 24; // px-4 vs sm:px-6
        const minWidth = isSmallScreen ? 100 : 120;

        buttonRefs.current.forEach((button, index) => {
          if (!button) return;

          const isActive = index === activeIndex;

          // The active button is always visible and sized correctly
          if (isActive) {
            gsap.set(button, {
              minWidth: minWidth,
              width: minWidth,
              paddingLeft: padding,
              paddingRight: padding,
              opacity: 1,
              pointerEvents: 'auto',
              overflow: 'visible'
            });
            return;
          }

          // Animate inactive buttons
          gsap.to(button, {
            width: isExpanded ? minWidth : 0,
            minWidth: isExpanded ? minWidth : 0,
            paddingLeft: isExpanded ? padding : 0,
            paddingRight: isExpanded ? padding : 0,
            opacity: isExpanded ? 1 : 0,
            duration: 0.3,
            ease: "power2.out",
            delay: isExpanded ? (Math.abs(index - activeIndex) - 1) * 0.05 : 0,
            pointerEvents: isExpanded ? "auto" : "none",
            overwrite: true,
            onStart: () => {
              if(!isExpanded) button.style.overflow = 'hidden';
            },
            onComplete: () => {
              if (isExpanded) button.style.overflow = 'visible';
            }
          });
        });
      }, [isExpanded, viewMode]);

      return (
        <div
          onMouseEnter={() => setIsExpanded(true)}
          onMouseLeave={() => setIsExpanded(false)}
          className="inline-block" // Wrapper to isolate from parent layout changes
        >
          <div
            ref={containerRef}
            className="relative flex flex-nowrap justify-center items-center bg-card/50 backdrop-blur-sm border border-border/50 rounded-2xl p-1.5 shadow-lg"
          >
            {/* Animated indicator */}
            <div
              ref={indicatorRef}
              className="absolute inset-y-1.5 bg-gradient-to-r from-primary/20 to-primary/10 border border-primary/20 rounded-xl"
              style={{ left: 0, width: 0, pointerEvents: 'none' }}
            />

            {/* Mode buttons */}
            {viewModes.map((mode, index) => {
              const IconComponent = mode.icon;
              const isActive = viewMode === mode.id;

              return (
                <button
                  key={mode.id}
                  ref={(el) => {
                    buttonRefs.current[index] = el;
                  }}
                  data-mode={mode.id}
                  onClick={() => {
                    if (!isActive) onChange(mode.id);
                  }}
                  // Size and padding classes are removed and handled by GSAP
                  className={cn(
                    "relative flex items-center justify-center gap-2 sm:gap-3 py-2 sm:py-3 rounded-xl transition-colors duration-300 group z-10",
                    "hover:bg-accent/20 active:scale-95",
                    isActive ? "text-primary" : ""
                  )}
                  style={
                    !isActive
                      ? {
                          width: 0,
                          minWidth: 0,
                          paddingLeft: 0,
                          paddingRight: 0,
                          opacity: 0,
                          overflow: "hidden",
                          pointerEvents: "none",
                        }
                      : {}
                  }
                  title={mode.description}
                >
                  <IconComponent
                    className={cn(
                      "w-5 h-5 transition-all duration-300 flex-shrink-0",
                      isActive && "scale-110",
                      "group-hover:scale-105"
                    )}
                  />
                  <span
                    className={cn(
                      "font-medium transition-colors duration-300 whitespace-nowrap",
                      isActive ? "text-primary" : "text-muted-foreground",
                      "group-hover:text-foreground"
                    )}
                  >
                    {mode.label}
                  </span>
                </button>
              );
            })}
          </div>
        </div>
      )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 197
