uuid: 44b74bb2-0268-450f-a1c1-4ed141b71b78
projectId: jeli-app-shell
createdAt: '2025-10-21T17:11:36.432Z'
gitCommitMsg: >-
  feat(calendar): Implement URL state and rich tooltips

  - Makes the calendar view's current month controllable via a `?date=YYYY-MM`
  URL parameter, enabling link sharing and bookmarking. - Adds a new rich
  tooltip to calendar events, showing key details like title, status, assignee,
  and due date on hover. - Creates a new `EventTooltipContent` component for a
  stylized, data-rich tooltip display. - Refactors `CalendarView` to be a
  controlled component, driven by state from `useAppViewManager`.
promptSummary: >-
  I need to make the calendar view's month state URL-driven and add rich
  tooltips to calendar events.
reasoning:
  - >-
    Here are the modifications to implement a URL-driven calendar date and rich
    event tooltips.
  - '### Part 1: Implement URL-Driven Calendar Date'
  - >-
    First, I'll enhance our central `useAppViewManager` hook to manage the
    calendar's currently displayed month via a URL search parameter
    (`?date=YYYY-MM`). This makes the calendar state linkable and persistent.
  - >-
    Next, I'll thread the new state and its updater through the `DynamicView`
    component and its context.
  - Now, I'll connect this new state at the page level in `DataDemoPage`.
  - >-
    Finally, I'll refactor `CalendarView` to be a controlled component, removing
    its internal date state and relying on the props passed from the context.
  - '### Part 2: Implement Rich Event Tooltips'
  - >-
    Now I'll create a new, reusable component for the tooltip's content, giving
    it a distinct, data-rich design.
  - >-
    With the tooltip content component created, the final step is to integrate
    it into the `CalendarView`, which was already done in the previous step. The
    view will now display these rich tooltips on hover for each calendar event.
operations:
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: "--- src/hooks/useAppViewManager.hook.ts\n+++ src/hooks/useAppViewManager.hook.ts\n@@ -1,6 +1,7 @@\n import { useMemo, useCallback, useEffect, useRef } from 'react';\n import { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\n import { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\n+import { format, parse, isValid } from 'date-fns';\n import type { GenericItem, ViewMode, SortConfig, GroupableField, CalendarDateProp, CalendarDisplayProp, CalendarColorProp, FilterConfig } from '@/features/dynamic-view/types';\n import type { TaskView } from '@/pages/Messaging/types';\n import { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n@@ -37,6 +38,7 @@\n   const calDisplay = searchParams.get('calDisplay');\n   const calLimit = searchParams.get('calLimit');\n   const calColor = searchParams.get('calColor');\n+  const dateParam = searchParams.get('date');\n \n   const { bodyState, sidePaneContent } = useMemo(() => {\n     const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo', 'messaging'];\n@@ -124,6 +126,14 @@\n   }, [calLimit]);\n   const calendarColorProp = useMemo(() => (calColor || 'none') as CalendarColorProp<string>, [calColor]);\n \n+  const calendarDate = useMemo(() => {\n+    if (!dateParam) return new Date();\n+    const parsedDate = parse(dateParam, 'yyyy-MM', new Date());\n+    return isValid(parsedDate) ? parsedDate : new Date();\n+  }, [dateParam]);\n+\n   // --- MUTATOR ACTIONS ---\n \n   const handleParamsChange = useCallback(\n@@ -259,8 +269,17 @@\n   const setCalendarColorProp = (prop: CalendarColorProp<string>) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n \n   const onItemSelect = useCallback((item: GenericItem) => {\n-\t\thandleParamsChange({ itemId: item.id, sidePane: null });\n-\t}, [handleParamsChange]);\n+    handleParamsChange({ itemId: item.id, sidePane: null });\n+  }, [handleParamsChange]);\n+  \n+  const setCalendarDate = useCallback((date: Date) => {\n+    const newDateStr = format(date, 'yyyy-MM');\n+    const currentDateStr = format(new Date(), 'yyyy-MM');\n+    // If it's the current month, clear the param to keep the URL clean\n+    const valueToSet = newDateStr === currentDateStr ? null : newDateStr;\n+    handleParamsChange({ date: valueToSet });\n+  }, [handleParamsChange]);\n \n   const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n \n@@ -281,6 +300,7 @@\n     calendarDisplayProps,\n     calendarItemLimit,\n     calendarColorProp,\n+    calendarDate,\n     // Actions\n     navigateTo,\n     openSidePane,\n@@ -301,13 +321,14 @@\n     setCalendarDisplayProps,\n     setCalendarItemLimit,\n     setCalendarColorProp,\n+    setCalendarDate,\n   }), [\n     bodyState, sidePaneContent, currentActivePage, pathItemId, itemId, messagingView, viewMode,\n     page, groupBy, activeGroupTab, filters, sortConfig, calendarDateProp,\n-    calendarDisplayProps, calendarItemLimit, calendarColorProp,\n+    calendarDisplayProps, calendarItemLimit, calendarColorProp, calendarDate,\n     navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, setNormalView, setMessagingView,\n     switchSplitPanes, closeSplitPane, onItemSelect, setViewMode, setGroupBy, setActiveGroupTab, setFilters,\n-    setSort, setTableSort, setPage, setCalendarDateProp, setCalendarDisplayProps, setCalendarItemLimit, setCalendarColorProp\n+    setSort, setTableSort, setPage, setCalendarDateProp, setCalendarDisplayProps, setCalendarItemLimit, setCalendarColorProp, setCalendarDate\n   ]);\n }\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/DynamicViewContext.tsx
    content: |+
      --- src/features/dynamic-view/DynamicViewContext.tsx
      +++ src/features/dynamic-view/DynamicViewContext.tsx
      @@ -23,6 +23,8 @@
         calendarDisplayProps?: CalendarDisplayProp<TFieldId>[];
         calendarItemLimit?: 'all' | number;
         calendarColorProp?: CalendarColorProp<TFieldId>;
      +  calendarDate?: Date;
      +
       
         // Callbacks to parent
         onViewModeChange: (mode: ViewMode) => void;
      @@ -37,6 +39,7 @@
         onCalendarDisplayPropsChange?: (props: CalendarDisplayProp<TFieldId>[]) => void;
         onCalendarItemLimitChange?: (limit: 'all' | number) => void;
         onCalendarColorPropChange?: (prop: CalendarColorProp<TFieldId>) => void;
      +  onCalendarDateChange?: (date: Date) => void;
       }
       
       const DynamicViewContext = createContext<DynamicViewContextProps<any, any> | null>(null);

    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/DynamicView.tsx
    content: |+
      --- src/features/dynamic-view/DynamicView.tsx
      +++ src/features/dynamic-view/DynamicView.tsx
      @@ -29,6 +29,7 @@
         calendarDisplayProps?: CalendarDisplayProp<TFieldId>[];
         calendarItemLimit?: 'all' | number;
         calendarColorProp?: CalendarColorProp<TFieldId>;
      +  calendarDate?: Date;
         statsData?: StatItem[];
       
         // State Change Callbacks
      @@ -43,6 +44,7 @@
         onCalendarDisplayPropsChange?: (props: CalendarDisplayProp<TFieldId>[]) => void;
         onCalendarItemLimitChange?: (limit: 'all' | number) => void;
         onCalendarColorPropChange?: (prop: CalendarColorProp<TFieldId>) => void;
      +  onCalendarDateChange?: (date: Date) => void;
         
         // Custom Renderers
         renderHeaderControls?: () => ReactNode;

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: |+
      --- src/pages/DataDemo/index.tsx
      +++ src/pages/DataDemo/index.tsx
      @@ -27,6 +27,8 @@
           setViewMode,
           onItemSelect,
           pathItemId,
      +    calendarDate,
      +    setCalendarDate,
         } = useAppViewManager();
       
         const selectedItem = useSelectedItem(pathItemId);
      @@ -194,6 +196,8 @@
               activeGroupTab={activeGroupTab}
               page={page}
               // Callbacks
      +        calendarDate={calendarDate}
      +        onCalendarDateChange={setCalendarDate}
               onViewModeChange={setViewMode}
               onFiltersChange={setFilters}
               onSortChange={setSort}

    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/components/views/CalendarView.tsx
    content: >+
      --- src/features/dynamic-view/components/views/CalendarView.tsx

      +++ src/features/dynamic-view/components/views/CalendarView.tsx

      @@ -1,13 +1,15 @@
       import { useState, useMemo, useRef, useLayoutEffect } from "react";
      -import { format, addMonths, subMonths, startOfMonth, endOfMonth,
      startOfWeek, endOfWeek, eachDayOfInterval, isSameMonth, isToday,
      isSameDay, } from "date-fns";

      +import { format, addMonths, subMonths, startOfMonth, endOfMonth,
      startOfWeek, endOfWeek, eachDayOfInterval, isSameMonth, isToday, isSameDay
      } from "date-fns";
       import { ChevronLeft, ChevronRight } from "lucide-react";
       import { gsap } from "gsap";
       
       import { Button } from "@/components/ui/button";
      +import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from
      "@/components/ui/tooltip";
       import { cn } from "@/lib/utils";
       import type { GenericItem } from '../../types';
       import type { CalendarDateProp, CalendarColorProp, Status, Priority } from '../../types';
       import { useResizeObserver } from "@/hooks/useResizeObserver.hook";
       import { useDynamicView } from '../../DynamicViewContext'
       import { FieldRenderer } from '../shared/FieldRenderer'
      +import { EventTooltipContent } from "../shared/EventTooltipContent";
       
       interface CalendarViewProps {
         data: GenericItem[];
      @@ -148,12 +150,14 @@
       };
       
       export function CalendarView({ data }: CalendarViewProps) {
      -  const [currentDate, setCurrentDate] = useState(new Date());
         const {
           onItemUpdate,
           calendarDateProp = 'dueDate', // Provide default
           calendarItemLimit = 3, // Provide default
           calendarColorProp = 'none', // Provide default
           selectedItemId,
      +    calendarDate,

      +    onCalendarDateChange,
         } = useDynamicView<string, GenericItem>();
      +  const currentDate = calendarDate ?? new Date();
         
         // Drag & Drop State
         const [draggedItemId, setDraggedItemId] = useState<string | null>(null);
      @@ -218,10 +222,10 @@
       
           if (direction === 'prev') {
             setDirection(-1);
      -      setCurrentDate(current => subMonths(current, 1));

      +      onCalendarDateChange?.(subMonths(currentDate, 1));
           } else {
             setDirection(1);
      -      setCurrentDate(current => addMonths(current, 1));

      +      onCalendarDateChange?.(addMonths(currentDate, 1));
           }
       
           consecutiveMonthChangesRef.current += 1;
      @@ -295,15 +299,15 @@
         
         const handlePrevMonth = () => {
           setDirection(-1);
      -    setCurrentDate(subMonths(currentDate, 1));

      +    onCalendarDateChange?.(subMonths(currentDate, 1));
         };
         const handleNextMonth = () => {
           setDirection(1);
      -    setCurrentDate(addMonths(currentDate, 1));

      +    onCalendarDateChange?.(addMonths(currentDate, 1));
         };
         const handleToday = () => {
           setDirection(0); // No animation for 'Today'
      -    setCurrentDate(new Date());

      +    onCalendarDateChange?.(new Date());
         };
       
         useLayoutEffect(() => {
      @@ -312,7 +316,7 @@
             { opacity: 0, x: 30 * direction }, 
             { opacity: 1, x: 0, duration: 0.3, ease: 'power2.out' }
           );
      -  }, [currentDate]);

      +  }, [currentDate, direction]);
       
         return (
           <div ref={calendarContainerRef} className="-mx-4 md:-mx-6">
      @@ -324,79 +328,87 @@
                 No items with {datePropLabels[calendarDateProp]} to display on the calendar.
               </div>
             ) : (
      -        <div className="px-2 relative" onDragEnd={handleDragEnd}>

      -          {/* Left edge cue */}

      -          <div className={cn(

      -              "absolute top-0 left-2 bottom-0 w-20 bg-gradient-to-r
      from-primary/20 to-transparent pointer-events-none transition-opacity
      duration-300 z-10",

      -              activeEdge === 'left' ? "opacity-100" : "opacity-0"

      -          )} />

      -          {/* Right edge cue */}

      -          <div className={cn(

      -              "absolute top-0 right-2 bottom-0 w-20 bg-gradient-to-l
      from-primary/20 to-transparent pointer-events-none transition-opacity
      duration-300 z-10",

      -              activeEdge === 'right' ? "opacity-100" : "opacity-0"

      -          )} />

      -

      -          {numColumns === 7 && (

      -            <div className="grid grid-cols-7">

      -              {weekdays.map(day => (

      -                <div key={day} className="py-2 px-3 text-center text-xs
      font-semibold text-muted-foreground">

      -                  {day}

      -                </div>

      -              ))}

      -            </div>

      -          )}

      -

      -            <div

      -              ref={gridRef}

      -              style={{

      -                display: 'grid',

      -                gridTemplateColumns: `repeat(${numColumns}, minmax(0,
      1fr))`,

      -                gap: '0.5rem',

      -              }}

      -            >

      -              {days.map(day => {

      -                const dateKey = format(day, "yyyy-MM-dd");

      -                const dayEvents = eventsByDate.get(dateKey) || [];

      -                const visibleEvents = calendarItemLimit === 'all' 

      -                    ? dayEvents 

      -                    : dayEvents.slice(0, calendarItemLimit as number);

      -                const hiddenEventsCount = dayEvents.length -
      visibleEvents.length;

      -                const isCurrentMonthDay = isSameMonth(day, currentDate);

      -                const isDropTarget = dropTargetDate && isSameDay(day,
      dropTargetDate);

      -                return (

      -                  <div

      -                    key={day.toString()}

      -                    onDragOver={(e) => handleDragOver(e, day)}

      -                    onDragLeave={handleDragLeave}

      -                    onDrop={(e) => handleDrop(e, day)}

      -                    className={cn(

      -                      "relative min-h-[150px] rounded-2xl p-2 flex
      flex-col gap-2 transition-all duration-300 border",

      -                      isCurrentMonthDay ? "bg-card/40
      dark:bg-neutral-900/40 border-transparent" : "bg-muted/30
      dark:bg-neutral-800/20 border-transparent text-muted-foreground/60",

      -                      isDropTarget ? "border-primary/50 bg-primary/10" :
      "hover:border-primary/20 hover:bg-card/60"

      -                    )}

      -                  >

      -                    <div className="font-semibold text-sm">

      -                      {isToday(day) ? (

      -                        <div className="flex items-center justify-center
      w-7 h-7 rounded-full bg-primary text-primary-foreground">

      -                          {format(day, 'd')}

      -                        </div>

      -                      ) : (

      -                        <div className="flex items-baseline gap-1.5 px-1
      py-0.5">

      -                          {numColumns < 7 && <span className="text-xs
      opacity-70">{format(day, 'eee')}</span>}

      -                          <span>{format(day, 'd')}</span>

      -                        </div>

      -                      )}

      -                    </div>

      -                    <div className="space-y-2 overflow-y-auto flex-grow
      custom-scrollbar">

      -                      {visibleEvents.map(item => (

      -                        <CalendarEvent

      -                          key={item.id} 

      -                          item={item} 

      -                          isSelected={!!selectedItemId && selectedItemId
      === item.id}

      -                          isDragging={!!draggedItemId && draggedItemId
      === item.id}

      -                          onDragStart={handleDragStart}

      -                          colorProp={calendarColorProp}

      -                        />

      -                      ))}

      -                    </div>

      -                    {hiddenEventsCount > 0 && (

      -                      <div className="absolute bottom-1 right-2 text-xs
      font-bold text-muted-foreground">

      -                        +{hiddenEventsCount} more

      +        <TooltipProvider delayDuration={200}>

      +          <div className="px-2 relative" onDragEnd={handleDragEnd}>

      +            {/* Left edge cue */}

      +            <div className={cn(

      +                "absolute top-0 left-2 bottom-0 w-20 bg-gradient-to-r
      from-primary/20 to-transparent pointer-events-none transition-opacity
      duration-300 z-10",

      +                activeEdge === 'left' ? "opacity-100" : "opacity-0"

      +            )} />

      +            {/* Right edge cue */}

      +            <div className={cn(

      +                "absolute top-0 right-2 bottom-0 w-20 bg-gradient-to-l
      from-primary/20 to-transparent pointer-events-none transition-opacity
      duration-300 z-10",

      +                activeEdge === 'right' ? "opacity-100" : "opacity-0"

      +            )} />

      +

      +            {numColumns === 7 && (

      +              <div className="grid grid-cols-7">

      +                {weekdays.map(day => (

      +                  <div key={day} className="py-2 px-3 text-center text-xs
      font-semibold text-muted-foreground">

      +                    {day}

      +                  </div>

      +                ))}

      +              </div>

      +            )}

      +

      +              <div

      +                ref={gridRef}

      +                style={{

      +                  display: 'grid',

      +                  gridTemplateColumns: `repeat(${numColumns}, minmax(0,
      1fr))`,

      +                  gap: '0.5rem',

      +                }}

      +              >

      +                {days.map(day => {

      +                  const dateKey = format(day, "yyyy-MM-dd");

      +                  const dayEvents = eventsByDate.get(dateKey) || [];

      +                  const visibleEvents = calendarItemLimit === 'all' 

      +                      ? dayEvents 

      +                      : dayEvents.slice(0, calendarItemLimit as number);

      +                  const hiddenEventsCount = dayEvents.length -
      visibleEvents.length;

      +                  const isCurrentMonthDay = isSameMonth(day,
      currentDate);

      +                  const isDropTarget = dropTargetDate && isSameDay(day,
      dropTargetDate);

      +                  return (

      +                    <div

      +                      key={day.toString()}

      +                      onDragOver={(e) => handleDragOver(e, day)}

      +                      onDragLeave={handleDragLeave}

      +                      onDrop={(e) => handleDrop(e, day)}

      +                      className={cn(

      +                        "relative min-h-[150px] rounded-2xl p-2 flex
      flex-col gap-2 transition-all duration-300 border",

      +                        isCurrentMonthDay ? "bg-card/40
      dark:bg-neutral-900/40 border-transparent" : "bg-muted/30
      dark:bg-neutral-800/20 border-transparent text-muted-foreground/60",

      +                        isDropTarget ? "border-primary/50 bg-primary/10"
      : "hover:border-primary/20 hover:bg-card/60"

      +                      )}

      +                    >

      +                      <div className="font-semibold text-sm">

      +                        {isToday(day) ? (

      +                          <div className="flex items-center
      justify-center w-7 h-7 rounded-full bg-primary text-primary-foreground">

      +                            {format(day, 'd')}

      +                          </div>

      +                        ) : (

      +                          <div className="flex items-baseline gap-1.5
      px-1 py-0.5">

      +                            {numColumns < 7 && <span className="text-xs
      opacity-70">{format(day, 'eee')}</span>}

      +                            <span>{format(day, 'd')}</span>

      +                          </div>

      +                        )}
                             </div>
      -                    )}

      -                  </div>

      -                );

      -              })}

      -            </div>

      -        </div>

      +                      <div className="space-y-2 overflow-y-auto flex-grow
      custom-scrollbar">

      +                        {visibleEvents.map(item => (

      +                          <Tooltip key={item.id}>

      +                            <TooltipTrigger asChild>

      +                              <CalendarEvent

      +                                item={item} 

      +                                isSelected={!!selectedItemId &&
      selectedItemId === item.id}

      +                                isDragging={!!draggedItemId &&
      draggedItemId === item.id}

      +                                onDragStart={handleDragStart}

      +                                colorProp={calendarColorProp}

      +                              />

      +                            </TooltipTrigger>

      +                            <TooltipContent side="top" align="center"
      className="border-none bg-transparent p-0 shadow-none">

      +                              <EventTooltipContent item={item} />

      +                            </TooltipContent>

      +                          </Tooltip>

      +                        ))}

      +                      </div>

      +                      {hiddenEventsCount > 0 && (

      +                        <div className="absolute bottom-1 right-2 text-xs
      font-bold text-muted-foreground">

      +                          +{hiddenEventsCount} more

      +                        </div>

      +                      )}

      +                    </div>

      +                  );

      +                })}

      +              </div>

      +          </div>

      +        </TooltipProvider>
             )}
           </div>
         );

    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/components/shared/EventTooltipContent.tsx
    content: >-
      import type { GenericItem } from '../../types';

      import { FieldRenderer } from './FieldRenderer';

      import { formatDistanceToNowShort, getPrioritySolidColor, getStatusColor }
      from '@/lib/utils';

      import { Badge } from '@/components/ui/badge';

      import { Clock } from 'lucide-react';


      interface EventTooltipContentProps {
        item: GenericItem;
      }


      export function EventTooltipContent({ item }: EventTooltipContentProps) {
        const { config } = {
          // This is a placeholder. In a real scenario, this might come from context.
          // For now, we'll hardcode the field IDs we know exist in DataDemoItem.
          statusField: 'status',
          priorityField: 'priority',
          assigneeField: 'assignee',
          dateField: 'dueDate'
        }

        const priorityColor = getPrioritySolidColor(item[config.priorityField]);
        const statusClasses = getStatusColor(item[config.statusField]);

        return (
          <div className="relative w-72 overflow-hidden rounded-xl border border-border/20 bg-background/80 p-4 shadow-xl backdrop-blur-lg">
            {/* Priority Indicator */}
            <div className={`absolute left-0 top-0 h-full w-1.5 ${priorityColor}`} />

            <div className="ml-1.5 space-y-3">
              {/* Header */}
              <div className="flex items-start justify-between gap-4">
                <h3 className="flex-1 font-semibold leading-tight text-foreground">
                  <FieldRenderer item={item} fieldId="title" />
                </h3>
                <div className="flex-shrink-0">
                  <FieldRenderer item={item} fieldId={config.assigneeField} options={{ compact: true, avatarClassName: 'w-7 h-7' }} />
                </div>
              </div>

              {/* Status & Date */}
              <div className="flex items-center justify-between text-sm">
                <Badge variant="outline" className={`border-transparent capitalize ${statusClasses}`}>
                  {item[config.statusField]}
                </Badge>
                <div className="flex items-center gap-1.5 text-muted-foreground">
                  <Clock className="h-4 w-4" />
                  <span>{formatDistanceToNowShort(item[config.dateField])}</span>
                </div>
              </div>

              {/* Tags */}
              <div>
                <FieldRenderer item={item} fieldId="tags" />
              </div>
            </div>
          </div>
        );
      }
    patchStrategy: replace
snapshot:
  src/features/dynamic-view/components/shared/EventTooltipContent.tsx: null
  src/pages/DataDemo/index.tsx: >
    import { useRef, useEffect, useCallback } from "react";

    import {
      Layers,
      AlertTriangle,
      PlayCircle,
      TrendingUp,
      CheckCircle,
      Clock,
      Archive,
      PlusCircle,
    } from "lucide-react";

    import { DynamicView } from "@/features/dynamic-view/DynamicView";

    import { PageLayout } from "@/components/shared/PageLayout";

    import { useScrollToBottom } from "@/hooks/useScrollToBottom.hook";

    import { ScrollToBottomButton } from
    "@/components/shared/ScrollToBottomButton";

    import { mockDataItems } from "./data/mockData";

    import { useAppViewManager } from "@/hooks/useAppViewManager.hook";

    import { useDataDemoStore, useSelectedItem } from "./store/dataDemo.store";

    import { AddDataItemCta } from
    "@/features/dynamic-view/components/shared/AddDataItemCta";

    import { DataDetailContent } from "./components/DataDetailContent";


    import { dataDemoViewConfig } from "./DataDemo.config";

    import type { StatItem } from "@/features/dynamic-view/types";


    export default function DataDemoPage() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
        setFilters,
        setViewMode,
        onItemSelect,
        pathItemId,
      } = useAppViewManager();

      const selectedItem = useSelectedItem(pathItemId);

      const {
        items: allItems,
        hasMore,
        isLoading,
        isInitialLoading,
        totalItemCount,
        loadData,
        updateItem,
      } = useDataDemoStore((state) => ({
        items: state.items,
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
        updateItem: state.updateItem,
      }));

      const scrollRef = useRef<HTMLDivElement>(null);

      // Note: The `DynamicViewProvider` needs `GenericItem[]`.
      // Our store uses `GenericItem` so no cast is needed.

      // Calculate stats from data
      const totalItems = mockDataItems.length;
      const { showScrollToBottom, scrollToBottom, handleScroll } =
        useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(
        (item) => item.status === "active",
      ).length;
      const highPriorityItems = mockDataItems.filter(
        (item) => item.priority === "high" || item.priority === "critical",
      ).length;
      const avgCompletion =
        totalItems > 0
          ? Math.round(
              mockDataItems.reduce(
                (acc, item) => acc + item.metrics.completion,
                0,
              ) / totalItems,
            )
          : 0;

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          chartData: [120, 125, 122, 130, 135, 138, 142],
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week",
          trend: "up" as const,
          chartData: [45, 50, 48, 55, 53, 60, 58],
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          chartData: [25, 26, 28, 27, 26, 24, 23],
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          chartData: [65, 68, 70, 69, 72, 75, 78],
        },
        {
          title: "Completion Rate",
          value: "88%",
          icon: <CheckCircle className="w-5 h-5" />,
          change: "+1.5% this month",
          trend: "up" as const,
          chartData: [80, 82, 81, 84, 85, 87, 88],
        },
        {
          title: "Overdue Items",
          value: "8",
          icon: <Clock className="w-5 h-5" />,
          change: "-3 this week",
          trend: "down" as const,
        },
        {
          title: "New This Week",
          value: "12",
          icon: <PlusCircle className="w-5 h-5" />,
          change: "+2 from last week",
          trend: "up" as const,
        },
        {
          title: "Archived Projects",
          value: "153",
          icon: <Archive className="w-5 h-5" />,
          change: "+20 this month",
          trend: "up" as const,
        },
      ];

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === "calendar" || viewMode === "kanban",
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );

      if (pathItemId && selectedItem) {
        // Render detail view as the main content
        return <DataDetailContent item={selectedItem} />;
      }

      return (
        <PageLayout scrollRef={scrollRef} onScroll={handleScroll}>
          <DynamicView
            viewConfig={dataDemoViewConfig}
            items={allItems}
            isLoading={isLoading}
            isInitialLoading={isInitialLoading}
            totalItemCount={totalItemCount}
            hasMore={hasMore}
            // Controlled state
            viewMode={viewMode}
            filters={filters}
            sortConfig={sortConfig}
            groupBy={groupBy}
            activeGroupTab={activeGroupTab}
            page={page}
            // Callbacks
            onViewModeChange={setViewMode}
            onFiltersChange={setFilters}
            onSortChange={setSort}
            onGroupByChange={setGroupBy}
            onActiveGroupTabChange={setActiveGroupTab}
            onPageChange={setPage}
            onItemUpdate={updateItem}
            onItemSelect={onItemSelect}
            loaderRef={loaderRef}
            scrollContainerRef={scrollRef}
            statsData={stats}
            // Custom Renderers
            renderCta={(viewMode, ctaProps) => (
              <AddDataItemCta viewMode={viewMode} colSpan={ctaProps.colSpan} />
            )}
          />

          <ScrollToBottomButton
            isVisible={showScrollToBottom}
            onClick={scrollToBottom}
          />
        </PageLayout>
      );
    }
  src/features/dynamic-view/components/views/CalendarView.tsx: >-
    import { useState, useMemo, useRef, useLayoutEffect } from "react";

    import { format, addMonths, subMonths, startOfMonth, endOfMonth,
    startOfWeek, endOfWeek, eachDayOfInterval, isSameMonth, isToday, isSameDay,
    } from "date-fns";

    import { ChevronLeft, ChevronRight } from "lucide-react";

    import { gsap } from "gsap";


    import { Button } from "@/components/ui/button";

    import { cn } from "@/lib/utils";

    import type { GenericItem } from '../../types';

    import type { CalendarDateProp, CalendarColorProp, Status, Priority } from
    '../../types';

    import { useResizeObserver } from "@/hooks/useResizeObserver.hook";

    import { useDynamicView } from '../../DynamicViewContext'

    import { FieldRenderer } from '../shared/FieldRenderer'


    interface CalendarViewProps {
      data: GenericItem[];
    }


    const PRIORITY_BG_COLORS: Record<Priority, string> = {
      low: 'bg-blue-500/80 border-blue-600/80 text-white',
      medium: 'bg-yellow-500/80 border-yellow-600/80 text-yellow-950',
      high: 'bg-orange-500/80 border-orange-600/80 text-white',
      critical: 'bg-red-600/80 border-red-700/80 text-white',
    };


    const STATUS_BG_COLORS: Record<Status, string> = {
      active: 'bg-sky-500/80 border-sky-600/80 text-white',
      pending: 'bg-amber-500/80 border-amber-600/80 text-amber-950',
      completed: 'bg-emerald-600/80 border-emerald-700/80 text-white',
      archived: 'bg-zinc-500/80 border-zinc-600/80 text-white',
    };


    const CATEGORY_BG_COLORS = [
      'bg-rose-500/80 border-rose-600/80 text-white',
      'bg-fuchsia-500/80 border-fuchsia-600/80 text-white',
      'bg-indigo-500/80 border-indigo-600/80 text-white',
      'bg-teal-500/80 border-teal-600/80 text-white',
      'bg-lime-500/80 border-lime-600/80 text-lime-950',
    ];


    const getCategoryBgColor = (category: string) => {
      let hash = 0;
      for (let i = 0; i < category.length; i++) {
        hash = category.charCodeAt(i) + ((hash << 5) - hash);
      }
      const index = Math.abs(hash % CATEGORY_BG_COLORS.length);
      return CATEGORY_BG_COLORS[index];
    };


    function CalendarHeader({ currentDate, onPrevMonth, onNextMonth, onToday }:
    {
      currentDate: Date;
      onPrevMonth: () => void;
      onNextMonth: () => void;
      onToday: () => void;
    }) {
      return (
        <div className="flex items-center justify-between gap-4 mb-6">
          <h2 className="text-xl font-bold md:text-2xl tracking-tight">
            {format(currentDate, "MMMM yyyy")}
          </h2>
          <div className="flex items-center gap-2">
            <Button variant="outline" size="sm" onClick={onToday}>Today</Button>
            <div className="flex items-center">
              <Button variant="outline" size="icon" className="h-9 w-9" onClick={onPrevMonth}>
                <ChevronLeft className="h-4 w-4" />
              </Button>
              <Button variant="outline" size="icon" className="h-9 w-9" onClick={onNextMonth}>
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </div>
      );
    }


    function CalendarEvent({ item, isSelected, isDragging, onDragStart,
    colorProp }: { 
        item: GenericItem; 
        isSelected: boolean;
        isDragging: boolean;
        onDragStart: (e: React.DragEvent<HTMLDivElement>, itemId: string) => void
        colorProp: CalendarColorProp<string>;
      }) {
      const { config, onItemSelect } = useDynamicView<string, GenericItem>();
      const { calendarView: viewConfig } = config;

        const colorClass = useMemo(() => {
          switch (colorProp) {
            case 'priority': return PRIORITY_BG_COLORS[item.priority as Priority];
            case 'status': return STATUS_BG_COLORS[item.status as Status];
            case 'category': return getCategoryBgColor(item.category as string);
            default: return null;
          }
        }, [colorProp, item]);

        return (
            <div
                draggable
                onDragStart={(e) => onDragStart(e, item.id)}
                onClick={() => onItemSelect(item)}
                className={cn(
                    "p-2 rounded-lg cursor-grab transition-all duration-200 border space-y-1",
                    isSelected && "ring-2 ring-primary ring-offset-background ring-offset-2",
                    isDragging && "opacity-50 ring-2 ring-primary cursor-grabbing",
                    colorClass 
                      ? `${colorClass} hover:brightness-95 dark:hover:brightness-110`
                      : "bg-card/60 dark:bg-neutral-800/60 backdrop-blur-sm hover:bg-card/80 dark:hover:bg-neutral-700/70"
                )}
            >
                <div className={cn(
                  "font-semibold text-sm leading-tight line-clamp-2",
                  colorClass ? "text-inherit" : "text-card-foreground/90"
                )}>
                  <FieldRenderer item={item} fieldId={viewConfig.titleField} />
                </div>

                {viewConfig.displayFields.includes('tags') && <FieldRenderer item={item} fieldId="tags" />}

                {(viewConfig.displayFields.includes('priority') || viewConfig.displayFields.includes('assignee')) && (
                    <div className={cn(
                        "flex items-center justify-between pt-1 border-t",
                        colorClass ? "border-black/10 dark:border-white/10" : "border-border/30 dark:border-neutral-700/50"
                    )}>
                        <div>
                          {viewConfig.displayFields.includes('priority') && <FieldRenderer item={item} fieldId="priority" />}
                        </div>
                        <div>
                          {viewConfig.displayFields.includes('assignee') && <FieldRenderer item={item} fieldId="assignee" options={{ compact: true, avatarClassName: 'w-5 h-5' }}/>}
                        </div>
                    </div>
                )}
            </div>
        );
    }


    const datePropLabels: Record<CalendarDateProp<string>, string> = {
      dueDate: 'due dates',
      createdAt: 'creation dates',
      updatedAt: 'update dates',
    };


    export function CalendarView({ data }: CalendarViewProps) {
      const [currentDate, setCurrentDate] = useState(new Date());
      const {
        onItemUpdate,
        calendarDateProp = 'dueDate', // Provide default
        calendarItemLimit = 3, // Provide default
        calendarColorProp = 'none', // Provide default
        selectedItemId,
      } = useDynamicView<string, GenericItem>();
      
      // Drag & Drop State
      const [draggedItemId, setDraggedItemId] = useState<string | null>(null);
      const [dropTargetDate, setDropTargetDate] = useState<Date | null>(null);
      const [activeEdge, setActiveEdge] = useState<'left' | 'right' | null>(null);
      const edgeHoverTimerRef = useRef<NodeJS.Timeout | null>(null);
      const currentEdgeRef = useRef<'left' | 'right' | null>(null);
      const consecutiveMonthChangesRef = useRef(0);

      // GSAP animation state
      const [direction, setDirection] = useState(0); // 0: initial, 1: next, -1: prev

      // Responsive Calendar State
      const calendarContainerRef = useRef<HTMLDivElement>(null);
      const { width } = useResizeObserver(calendarContainerRef);
      const MIN_DAY_WIDTH = 160; // px
      const numColumns = useMemo(() => {
        if (width === 0) return 7;
        const cols = Math.floor(width / MIN_DAY_WIDTH);
        return Math.max(3, Math.min(7, cols));
      }, [width]);

      const gridRef = useRef<HTMLDivElement>(null);
      const itemsByDateProp = useMemo(() => data.filter(item => !!item[calendarDateProp]), [data, calendarDateProp]);

      const eventsByDate = useMemo(() => {
        const eventsMap = new Map<string, GenericItem[]>();
        itemsByDateProp.forEach(item => {
          const dateValue = item[calendarDateProp];
          if (!dateValue) return;
          const date = new Date(dateValue as string);
          const dateKey = format(date, "yyyy-MM-dd");
          if (!eventsMap.has(dateKey)) {
            eventsMap.set(dateKey, []);
          }
          eventsMap.get(dateKey)?.push(item);
        });
        return eventsMap;
      }, [itemsByDateProp, calendarDateProp]);

      const monthStart = startOfMonth(currentDate);
      const monthEnd = endOfMonth(monthStart);
      const startDate = startOfWeek(monthStart, { weekStartsOn: 0 }); // Sunday
      const endDate = endOfWeek(monthEnd, { weekStartsOn: 0 });

      const days = eachDayOfInterval({ start: startDate, end: endDate });
      const weekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      
      // D&D Handlers
      const handleDragStart = (e: React.DragEvent, itemId: string) => {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', itemId);
        setDraggedItemId(itemId);
      };
      
      const handleDragEnd = () => {
        if (edgeHoverTimerRef.current) {
          clearTimeout(edgeHoverTimerRef.current);
          edgeHoverTimerRef.current = null;
        }
        currentEdgeRef.current = null;
        consecutiveMonthChangesRef.current = 0;
        setActiveEdge(null);
        setDraggedItemId(null);
        setDropTargetDate(null);
      };

      const handleMonthChange = (direction: 'prev' | 'next') => {
        // Safety check: ensure user is still hovering on the correct edge
        if ((direction === 'prev' && currentEdgeRef.current !== 'left') || (direction === 'next' && currentEdgeRef.current !== 'right')) {
          return;
        }

        if (direction === 'prev') {
          setDirection(-1);
          setCurrentDate(current => subMonths(current, 1));
        } else {
          setDirection(1);
          setCurrentDate(current => addMonths(current, 1));
        }

        consecutiveMonthChangesRef.current += 1;

        // Schedule next accelerated change
        const nextDelay = consecutiveMonthChangesRef.current >= 2 ? 150 : 300;
        edgeHoverTimerRef.current = setTimeout(() => handleMonthChange(direction), nextDelay);
      };

      const handleDragOver = (e: React.DragEvent, day: Date) => {
        e.preventDefault();
        if (!gridRef.current) return;

        const rect = gridRef.current.getBoundingClientRect();
        const edgeZoneWidth = 80; // 80px hotzone on each side

        const clearTimer = () => {
          if (edgeHoverTimerRef.current) {
            clearTimeout(edgeHoverTimerRef.current);
            edgeHoverTimerRef.current = null;
          }
        };

        // Check left edge
        if (e.clientX < rect.left + edgeZoneWidth) {
          if (currentEdgeRef.current !== 'left') {
            clearTimer();
            currentEdgeRef.current = 'left';
            consecutiveMonthChangesRef.current = 0;
            setDropTargetDate(null);
            edgeHoverTimerRef.current = setTimeout(() => handleMonthChange('prev'), 600);
          }
          setActiveEdge('left');
          return;
        }

        // Check right edge
        if (e.clientX > rect.right - edgeZoneWidth) {
          if (currentEdgeRef.current !== 'right') {
            clearTimer();
            currentEdgeRef.current = 'right';
            consecutiveMonthChangesRef.current = 0;
            setDropTargetDate(null);
            edgeHoverTimerRef.current = setTimeout(() => handleMonthChange('next'), 600);
          }
          setActiveEdge('right');
          return;
        }

        // If not in an edge zone
        clearTimer();
        setActiveEdge(null);
        currentEdgeRef.current = null;
        
        if (dropTargetDate === null || !isSameDay(day, dropTargetDate)) {
          setDropTargetDate(day);
        }
      };

      const handleDragLeave = () => {
        setDropTargetDate(null);
      };

      const handleDrop = (e: React.DragEvent, day: Date) => {
        e.preventDefault();
        const itemIdToUpdate = e.dataTransfer.getData('text/plain');
        if (itemIdToUpdate) {
            const originalItem = itemsByDateProp.find(i => i.id === itemIdToUpdate);
            if (originalItem && originalItem[calendarDateProp]) {
                const originalDate = new Date(originalItem[calendarDateProp] as string);
                // Preserve the time, only change the date part
                const newDueDate = new Date(day);
                newDueDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());
                onItemUpdate?.(itemIdToUpdate, { [calendarDateProp]: newDueDate.toISOString() });
            }
        }
        handleDragEnd(); // Reset state
      };
      
      const handlePrevMonth = () => {
        setDirection(-1);
        setCurrentDate(subMonths(currentDate, 1));
      };
      const handleNextMonth = () => {
        setDirection(1);
        setCurrentDate(addMonths(currentDate, 1));
      };
      const handleToday = () => {
        setDirection(0); // No animation for 'Today'
        setCurrentDate(new Date());
      };

      useLayoutEffect(() => {
        if (direction === 0 || !gridRef.current) return;
        gsap.fromTo(gridRef.current, 
          { opacity: 0, x: 30 * direction }, 
          { opacity: 1, x: 0, duration: 0.3, ease: 'power2.out' }
        );
      }, [currentDate]);

      return (
        <div ref={calendarContainerRef} className="-mx-4 md:-mx-6">
          <div className="px-4 md:px-6 pb-2">
            <CalendarHeader currentDate={currentDate} onPrevMonth={handlePrevMonth} onNextMonth={handleNextMonth} onToday={handleToday} />
          </div>
          {itemsByDateProp.length === 0 ? (
            <div className="flex items-center justify-center h-96 text-muted-foreground rounded-lg border bg-card/30 mx-4 md:mx-6">
              No items with {datePropLabels[calendarDateProp]} to display on the calendar.
            </div>
          ) : (
            <div className="px-2 relative" onDragEnd={handleDragEnd}>
              {/* Left edge cue */}
              <div className={cn(
                  "absolute top-0 left-2 bottom-0 w-20 bg-gradient-to-r from-primary/20 to-transparent pointer-events-none transition-opacity duration-300 z-10",
                  activeEdge === 'left' ? "opacity-100" : "opacity-0"
              )} />
              {/* Right edge cue */}
              <div className={cn(
                  "absolute top-0 right-2 bottom-0 w-20 bg-gradient-to-l from-primary/20 to-transparent pointer-events-none transition-opacity duration-300 z-10",
                  activeEdge === 'right' ? "opacity-100" : "opacity-0"
              )} />

              {numColumns === 7 && (
                <div className="grid grid-cols-7">
                  {weekdays.map(day => (
                    <div key={day} className="py-2 px-3 text-center text-xs font-semibold text-muted-foreground">
                      {day}
                    </div>
                  ))}
                </div>
              )}

                <div
                  ref={gridRef}
                  style={{
                    display: 'grid',
                    gridTemplateColumns: `repeat(${numColumns}, minmax(0, 1fr))`,
                    gap: '0.5rem',
                  }}
                >
                  {days.map(day => {
                    const dateKey = format(day, "yyyy-MM-dd");
                    const dayEvents = eventsByDate.get(dateKey) || [];
                    const visibleEvents = calendarItemLimit === 'all' 
                        ? dayEvents 
                        : dayEvents.slice(0, calendarItemLimit as number);
                    const hiddenEventsCount = dayEvents.length - visibleEvents.length;
                    const isCurrentMonthDay = isSameMonth(day, currentDate);
                    const isDropTarget = dropTargetDate && isSameDay(day, dropTargetDate);
                    return (
                      <div
                        key={day.toString()}
                        onDragOver={(e) => handleDragOver(e, day)}
                        onDragLeave={handleDragLeave}
                        onDrop={(e) => handleDrop(e, day)}
                        className={cn(
                          "relative min-h-[150px] rounded-2xl p-2 flex flex-col gap-2 transition-all duration-300 border",
                          isCurrentMonthDay ? "bg-card/40 dark:bg-neutral-900/40 border-transparent" : "bg-muted/30 dark:bg-neutral-800/20 border-transparent text-muted-foreground/60",
                          isDropTarget ? "border-primary/50 bg-primary/10" : "hover:border-primary/20 hover:bg-card/60"
                        )}
                      >
                        <div className="font-semibold text-sm">
                          {isToday(day) ? (
                            <div className="flex items-center justify-center w-7 h-7 rounded-full bg-primary text-primary-foreground">
                              {format(day, 'd')}
                            </div>
                          ) : (
                            <div className="flex items-baseline gap-1.5 px-1 py-0.5">
                              {numColumns < 7 && <span className="text-xs opacity-70">{format(day, 'eee')}</span>}
                              <span>{format(day, 'd')}</span>
                            </div>
                          )}
                        </div>
                        <div className="space-y-2 overflow-y-auto flex-grow custom-scrollbar">
                          {visibleEvents.map(item => (
                            <CalendarEvent
                              key={item.id} 
                              item={item} 
                              isSelected={!!selectedItemId && selectedItemId === item.id}
                              isDragging={!!draggedItemId && draggedItemId === item.id}
                              onDragStart={handleDragStart}
                              colorProp={calendarColorProp}
                            />
                          ))}
                        </div>
                        {hiddenEventsCount > 0 && (
                          <div className="absolute bottom-1 right-2 text-xs font-bold text-muted-foreground">
                            +{hiddenEventsCount} more
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
            </div>
          )}
        </div>
      );
    }
  src/features/dynamic-view/DynamicViewContext.tsx: >-
    import { createContext, useContext, useMemo, type ReactNode } from 'react';

    import type { ViewConfig, GenericItem, ViewMode, FilterConfig, SortConfig,
    CalendarDateProp, CalendarDisplayProp, CalendarColorProp, GroupableField }
    from './types';


    export interface DynamicViewContextProps<TFieldId extends string, TItem
    extends GenericItem> {
      config: ViewConfig<TFieldId, TItem>;
      data: TItem[];
      getFieldDef: (fieldId: TFieldId) => ViewConfig<TFieldId, TItem>['fields'][number] | undefined;

      // Data & State from parent
      items: TItem[];
      isLoading: boolean;
      isInitialLoading: boolean;
      totalItemCount: number;
      hasMore: boolean;

      // Controlled State Props from parent
      viewMode: ViewMode;
      filters: FilterConfig;
      sortConfig: SortConfig<TFieldId> | null;
      groupBy: GroupableField<TFieldId>;
      activeGroupTab: string;
      page: number;
      selectedItemId?: string;
      // Calendar-specific state
      calendarDateProp?: CalendarDateProp<TFieldId>;
      calendarDisplayProps?: CalendarDisplayProp<TFieldId>[];
      calendarItemLimit?: 'all' | number;
      calendarColorProp?: CalendarColorProp<TFieldId>;

      // Callbacks to parent
      onViewModeChange: (mode: ViewMode) => void;
      onFiltersChange: (filters: FilterConfig) => void;
      onSortChange: (sort: SortConfig<TFieldId> | null) => void;
      onGroupByChange: (group: GroupableField<TFieldId>) => void;
      onActiveGroupTabChange: (tab: string) => void;
      onPageChange: (page: number) => void;
      onItemSelect: (item: TItem) => void;
      onItemUpdate?: (itemId: string, updates: Partial<TItem>) => void;
      // Calendar-specific callbacks
      onCalendarDatePropChange?: (prop: CalendarDateProp<TFieldId>) => void;
      onCalendarDisplayPropsChange?: (props: CalendarDisplayProp<TFieldId>[]) => void;
      onCalendarItemLimitChange?: (limit: 'all' | number) => void;
      onCalendarColorPropChange?: (prop: CalendarColorProp<TFieldId>) => void;
    }


    const DynamicViewContext = createContext<DynamicViewContextProps<any, any> |
    null>(null);


    interface DynamicViewProviderProps<TFieldId extends string, TItem extends
    GenericItem> extends Omit<DynamicViewContextProps<TFieldId, TItem>,
    'getFieldDef' | 'config' | 'data'> {
      viewConfig: ViewConfig<TFieldId, TItem>,
      children: ReactNode;
    }


    export function DynamicViewProvider<TFieldId extends string, TItem extends
    GenericItem>({ viewConfig, children, ...rest }:
    DynamicViewProviderProps<TFieldId, TItem>) {
      const fieldDefsById = useMemo(() => {
        return new Map(viewConfig.fields.map(field => [field.id, field]));
      }, [viewConfig.fields]);

      const getFieldDef = (fieldId: TFieldId) => {
        return fieldDefsById.get(fieldId);
      };

      const value = useMemo(() => ({
        ...rest,
        config: viewConfig,
        data: rest.items, // alias for convenience
        getFieldDef,
      }), [viewConfig, getFieldDef, rest]);

      return (
        <DynamicViewContext.Provider value={value}>
          {children}
        </DynamicViewContext.Provider>
      );
    }


    export function useDynamicView<TFieldId extends string, TItem extends
    GenericItem>() {
      const context = useContext(DynamicViewContext);
      if (!context) {
        throw new Error('useDynamicView must be used within a DynamicViewProvider');
      }
      return context as DynamicViewContextProps<TFieldId, TItem>;
    }
  src/hooks/useAppViewManager.hook.ts: "import { useMemo, useCallback, useEffect, useRef } from 'react';\nimport { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\nimport type { GenericItem, ViewMode, SortConfig, GroupableField, CalendarDateProp, CalendarDisplayProp, CalendarColorProp, FilterConfig } from '@/features/dynamic-view/types';\nimport type { TaskView } from '@/pages/Messaging/types';\nimport { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n\nconst pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n  dashboard: 'main',\n  settings: 'settings',\n  toaster: 'toaster',\n  notifications: 'notifications',\n  'data-demo': 'dataDemo',\n  messaging: 'messaging',\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n/**\n * A centralized hook to manage and synchronize all URL-based view states.\n * This is the single source of truth for view modes, side panes, split views,\n * and page-specific parameters.\n */\nexport function useAppViewManager() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { itemId: pathItemId, conversationId } = useParams<{ itemId: string; conversationId: string }>();\n  const { setSidebarState, sidebarState } = useAppShellStore();\n\n  // --- DERIVED STATE FROM URL ---\n\n  const view = searchParams.get('view');\n  const sidePane = searchParams.get('sidePane');\n  const sidePaneItemId = searchParams.get('itemId');\n  const right = searchParams.get('right');\n  const messagingView = searchParams.get('messagingView') as TaskView | null;\n  const q = searchParams.get('q');\n  const status = searchParams.get('status');\n  const priority = searchParams.get('priority');\n  const sort = searchParams.get('sort');\n  const calDate = searchParams.get('calDate');\n  const calDisplay = searchParams.get('calDisplay');\n  const calLimit = searchParams.get('calLimit');\n  const calColor = searchParams.get('calColor');\n\n  const { bodyState, sidePaneContent } = useMemo(() => {\n    const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo', 'messaging'];\n    \n    // 1. Priority: Explicit side pane overlay via URL param\n    if (sidePane && validPanes.includes(sidePane as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n    }\n\n    // 2. Data item detail view in a pane, triggered by search param\n    if (sidePaneItemId) {\n      if (view === 'split') {\n        return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n      }\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n    }\n\n    // 3. Messaging conversation view (always split)\n    if (conversationId) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'messaging' as const };\n    }\n\n    // 4. Generic split view via URL param\n    if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: right as AppShellState['sidePaneContent'] };\n    }\n\n    return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n  }, [sidePaneItemId, conversationId, view, sidePane, right]);\n  \n  const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n  const prevActivePage = usePrevious(currentActivePage);\n\n  // --- SIDE EFFECTS ---\n  useEffect(() => {\n    // On navigating to messaging page, collapse sidebar if it's expanded.\n    // This ensures a good default view but allows the user to expand it again if they wish.\n    if (currentActivePage === 'messaging' && prevActivePage !== 'messaging' && sidebarState === SIDEBAR_STATES.EXPANDED) {\n      setSidebarState(SIDEBAR_STATES.COLLAPSED);\n    }\n  }, [currentActivePage, prevActivePage, sidebarState, setSidebarState]);\n\n  // DataDemo specific state\n  const viewMode = useMemo(() => (searchParams.get('dataView') as ViewMode) || 'list', [searchParams]);\n  const page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n  const groupBy = useMemo(() => {\n    const groupByParam = (searchParams.get('groupBy') as GroupableField<string> | 'none') || 'none';\n    // Kanban view should default to grouping by status if no group is specified\n    if (viewMode === 'kanban' && groupByParam === 'none') {\n      return 'status';\n    }\n    return groupByParam;\n  }, [searchParams, viewMode]);\n  const activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n  const filters = useMemo<FilterConfig>(\n\t\t() => ({\n\t\t\tsearchTerm: q || '',\n\t\t\tstatus: (status?.split(',') || []).filter(Boolean),\n\t\t\tpriority: (priority?.split(',') || []).filter(Boolean),\n\t\t}),\n\t\t[q, status, priority],\n\t);\n  const sortConfig = useMemo<SortConfig<string> | null>(() => {\n    if (viewMode === 'kanban') return null; // Kanban is manually sorted\n\t\tconst sortParam = sort;\n\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n\t\tif (sortParam === 'default') return null;\n\n\t\tconst [key, direction] = sortParam.split('-');\n\t\treturn { key, direction: direction as 'asc' | 'desc' };\n  }, [sort, viewMode]);\n  const calendarDateProp = useMemo(() => (calDate || 'dueDate') as CalendarDateProp<string>, [calDate]);\n  const calendarDisplayProps = useMemo(\n    () => {\n      if (calDisplay === null) return []; // Default is now nothing\n      if (calDisplay === '') return []; // Explicitly empty is also nothing\n      return calDisplay.split(',') as CalendarDisplayProp<string>[];\n    },\n    [calDisplay]\n  );\n  const calendarItemLimit = useMemo(() => {\n    const limit = parseInt(calLimit || '3', 10);\n    if (calLimit === 'all') return 'all';\n    return isNaN(limit) ? 3 : limit;\n  }, [calLimit]);\n  const calendarColorProp = useMemo(() => (calColor || 'none') as CalendarColorProp<string>, [calColor]);\n\n  // --- MUTATOR ACTIONS ---\n\n  const handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | number | string[] | null | undefined>, resetPage = false) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\t\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resetPage) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n  const navigateTo = useCallback((page: string, params?: Record<string, string | null>) => {\n    const targetPath = page.startsWith('/') ? page : `/${page}`;\n    const isSamePage = location.pathname === targetPath;\n    \n    const newSearchParams = new URLSearchParams(isSamePage ? searchParams : undefined);\n\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n          newSearchParams.delete(key);\n        } else {\n          newSearchParams.set(key, value);\n        }\n      }\n    }\n\n    navigate({ pathname: targetPath, search: newSearchParams.toString() });\n  }, [navigate, location.pathname, searchParams]);\n\n  const openSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (location.pathname === `/${Object.keys(pageToPaneMap).find(key => pageToPaneMap[key] === pane)}`) {\n        navigate({ pathname: '/dashboard', search: `?sidePane=${pane}` }, { replace: true });\n    } else {\n        handleParamsChange({ sidePane: pane, view: null, right: null });\n    }\n  }, [handleParamsChange, navigate, location.pathname]);\n\n  const closeSidePane = useCallback(() => {\n    // This should close any kind of side pane, including dataItem\n    handleParamsChange({ sidePane: null, view: null, right: null, itemId: null });\n  }, [handleParamsChange]);\n\n  const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (sidePane === pane) {\n      closeSidePane();\n    } else {\n      openSidePane(pane);\n    }\n  }, [sidePane, openSidePane, closeSidePane]);\n\n  const toggleSplitView = useCallback(() => {\n    if (bodyState === BODY_STATES.SIDE_PANE) {\n      handleParamsChange({ view: 'split', right: sidePane, sidePane: null });\n    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {\n      handleParamsChange({ sidePane: right, view: null, right: null });\n    } else { // From normal\n      const paneContent = pageToPaneMap[currentActivePage] || 'details';\n      handleParamsChange({ view: 'split', right: paneContent, sidePane: null });\n    }\n  }, [bodyState, sidePane, right, currentActivePage, handleParamsChange]);\n  \n  const setNormalView = useCallback(() => {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const switchSplitPanes = useCallback(() => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    const newSidePaneContent = pageToPaneMap[currentActivePage];\n    const newActivePage = Object.entries(pageToPaneMap).find(\n      ([, value]) => value === sidePaneContent\n    )?.[0] as ActivePage | undefined;\n\n    if (newActivePage && newSidePaneContent) {\n      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const closeSplitPane = useCallback((paneToClose: 'main' | 'right') => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    if (paneToClose === 'right') {\n      navigate(`/${currentActivePage}`, { replace: true });\n    } else { // Closing main pane\n      const pageToBecomeActive = Object.entries(pageToPaneMap).find(\n        ([, value]) => value === sidePaneContent\n      )?.[0] as ActivePage | undefined;\n      \n      if (pageToBecomeActive) {\n        navigate(`/${pageToBecomeActive}`, { replace: true });\n      } else {\n        navigate(`/dashboard`, { replace: true });\n      }\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  // DataDemo actions\n  const setViewMode = (mode: ViewMode) => handleParamsChange({ dataView: mode === 'list' ? null : mode });\n  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val }, true);\n  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n  const setFilters = (newFilters: FilterConfig) => {\n    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority }, true);\n  }\n  const setSort = (config: SortConfig<string> | null) => {\n    if (!config) {\n      handleParamsChange({ sort: null }, true);\n    } else {\n      handleParamsChange({ sort: `${config.key}-${config.direction}` }, true);\n    }\n  }\n  const setTableSort = (field: string) => {\n    let newSort: string | null = `${field}-desc`;\n    if (sortConfig && sortConfig.key === field) {\n      if (sortConfig.direction === 'desc') newSort = `${field}-asc`;\n      else if (sortConfig.direction === 'asc') newSort = null;\n    }\n    handleParamsChange({ sort: newSort }, true);\n  };\n  const setPage = (newPage: number) => handleParamsChange({ page: newPage > 1 ? newPage.toString() : null });\n\n  // Calendar specific actions\n  const setCalendarDateProp = (prop: CalendarDateProp<string>) => handleParamsChange({ calDate: prop === 'dueDate' ? null : prop });\n  const setCalendarDisplayProps = (props: CalendarDisplayProp<string>[]) => {\n    // Check for default state to keep URL clean\n    const isDefault = props.length === 0;\n    handleParamsChange({ calDisplay: isDefault ? null : props.join(',') });\n  };\n  const setCalendarItemLimit = (limit: number | 'all') => handleParamsChange({ calLimit: limit === 3 ? null : String(limit) });\n  const setCalendarColorProp = (prop: CalendarColorProp<string>) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n\n  const onItemSelect = useCallback((item: GenericItem) => {\n\t\thandleParamsChange({ itemId: item.id, sidePane: null });\n\t}, [handleParamsChange]);\n\n  const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n\n  // The final active item ID is either from the path (main view) or a search param (pane view)\n  const itemId = pathItemId || sidePaneItemId;\n\n  return useMemo(() => ({\n    // State\n    bodyState,\n    sidePaneContent,\n    currentActivePage,\n    pathItemId, // Expose for main content decisions\n    itemId,\n    messagingView,\n    // DataDemo State\n    viewMode,\n    page,\n    groupBy,\n    activeGroupTab,\n    filters,\n    sortConfig,\n    calendarDateProp,\n    calendarDisplayProps,\n    calendarItemLimit,\n    calendarColorProp,\n    // Actions\n    navigateTo,\n    openSidePane,\n    closeSidePane,\n    toggleSidePane,\n    toggleSplitView,\n    setNormalView,\n    switchSplitPanes,\n    setMessagingView,\n    closeSplitPane,\n    // DataDemo Actions\n    onItemSelect,\n    setViewMode,\n    setGroupBy,\n    setActiveGroupTab,\n    setFilters,\n    setSort,\n    setTableSort,\n    setPage,\n    setCalendarDateProp,\n    setCalendarDisplayProps,\n    setCalendarItemLimit,\n    setCalendarColorProp,\n  }), [\n    bodyState, sidePaneContent, currentActivePage, pathItemId, itemId, messagingView, viewMode,\n    page, groupBy, activeGroupTab, filters, sortConfig, calendarDateProp,\n    calendarDisplayProps, calendarItemLimit, calendarColorProp,\n    navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, setNormalView, setMessagingView,\n    switchSplitPanes, closeSplitPane, onItemSelect, setViewMode, setGroupBy, setActiveGroupTab, setFilters,\n    setSort, setTableSort, setPage, setCalendarDateProp, setCalendarDisplayProps, setCalendarItemLimit, setCalendarColorProp\n  ]);\n}"
  src/features/dynamic-view/DynamicView.tsx: >-
    import { useMemo, useCallback, type ReactNode, useRef, useEffect } from
    'react';

    import { Loader2 } from 'lucide-react';

    import { gsap } from 'gsap';

    import { DynamicViewProvider } from
    '@/features/dynamic-view/DynamicViewContext';

    import type { ViewConfig, GenericItem, ViewMode, FilterConfig, SortConfig,
    CalendarDateProp, CalendarDisplayProp, CalendarColorProp, StatItem,
    GroupableField } from './types';

    import { ViewControls } from './components/controls/ViewControls';

    import { ViewModeSelector } from './components/controls/ViewModeSelector';

    import { AnimatedLoadingSkeleton } from
    './components/shared/AnimatedLoadingSkeleton';

    import { ListView } from './components/views/ListView';

    import { CardView } from './components/views/CardView';

    import { TableView } from './components/views/TableView';

    import { KanbanView } from './components/views/KanbanView';

    import { CalendarView } from './components/views/CalendarView';

    import { EmptyState } from './components/shared/EmptyState';

    import { useAutoAnimateStats } from '@/hooks/useAutoAnimateStats.hook';

    import { StatCard } from '@/components/shared/StatCard';


    // Define the props for the controlled DynamicView component

    export interface DynamicViewProps<TFieldId extends string, TItem extends
    GenericItem> {
      // Config
      viewConfig: ViewConfig<TFieldId, TItem>;
      
      // Data & State
      items: TItem[];
      isLoading: boolean;
      isInitialLoading: boolean;
      totalItemCount: number;
      hasMore: boolean;
      
      // Controlled State Props
      viewMode: ViewMode;
      filters: FilterConfig;
      sortConfig: SortConfig<TFieldId> | null;
      groupBy: GroupableField<TFieldId>;
      activeGroupTab: string;
      page: number;
      selectedItemId?: string;
      // Calendar-specific state
      calendarDateProp?: CalendarDateProp<TFieldId>;
      calendarDisplayProps?: CalendarDisplayProp<TFieldId>[];
      calendarItemLimit?: 'all' | number;
      calendarColorProp?: CalendarColorProp<TFieldId>;
      statsData?: StatItem[];

      // State Change Callbacks
      onViewModeChange: (mode: ViewMode) => void;
      onFiltersChange: (filters: FilterConfig) => void;
      onSortChange: (sort: SortConfig<TFieldId> | null) => void;
      onGroupByChange: (group: GroupableField<TFieldId>) => void;
      onActiveGroupTabChange: (tab: string) => void;
      onPageChange: (page: number) => void;
      onItemSelect: (item: TItem) => void;
      onItemUpdate?: (itemId: string, updates: Partial<TItem>) => void;
      // Calendar-specific callbacks
      onCalendarDatePropChange?: (prop: CalendarDateProp<TFieldId>) => void;
      onCalendarDisplayPropsChange?: (props: CalendarDisplayProp<TFieldId>[]) => void;
      onCalendarItemLimitChange?: (limit: 'all' | number) => void;
      onCalendarColorPropChange?: (prop: CalendarColorProp<TFieldId>) => void;
      
      // Custom Renderers
      renderHeaderControls?: () => ReactNode;
      renderCta?: (viewMode: ViewMode, ctaProps: { colSpan?: number }) => ReactNode;
      loaderRef?: React.Ref<HTMLDivElement>;
      scrollContainerRef?: React.RefObject<HTMLElement>;
    }


    export function DynamicView<TFieldId extends string, TItem extends
    GenericItem>({ viewConfig, ...rest }: DynamicViewProps<TFieldId, TItem>) {
      
      const { viewMode, isInitialLoading, isLoading, hasMore, items, groupBy, statsData, scrollContainerRef } = rest;
      const statsRef = useRef<HTMLDivElement>(null);

      // Auto-hide stats container on scroll down
      useAutoAnimateStats(scrollContainerRef!, statsRef);

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.5,
              y: 0,
              opacity: 1,
              stagger: 0.08,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading]);

      const groupedData = useMemo(() => {
        if (groupBy === 'none' || viewMode !== 'kanban') {
            return null;
        }
        return (items as TItem[]).reduce((acc, item) => {
            const groupKey = String(item[groupBy as keyof TItem]) || 'N/A';
            if (!acc[groupKey]) {
                acc[groupKey] = [] as TItem[];
            }
            acc[groupKey].push(item);
            return acc;
        }, {} as Record<string, TItem[]>);
      }, [items, groupBy, viewMode]);

      const renderViewForData = useCallback((data: TItem[], cta: ReactNode) => {
        switch (viewMode) {
            case 'table': return <TableView data={data} ctaElement={cta} />;
            case 'cards': return <CardView data={data} ctaElement={cta} />;
            case 'grid': return <CardView data={data} isGrid ctaElement={cta} />;
            case 'list': default: return <ListView data={data} ctaElement={cta} />;
        }
      }, [viewMode]);

      const renderContent = () => {
        if (isInitialLoading) {
          return <AnimatedLoadingSkeleton viewMode={viewMode} />;
        }

        if (viewMode === 'calendar') {
            return <CalendarView data={items} />;
        }

        if (viewMode === 'kanban') {
            return groupedData ? (
              <KanbanView data={groupedData} />
            ) : (
              <div className="flex items-center justify-center h-96 text-muted-foreground">
                Group data by a metric to use the Kanban view.
              </div>
            );
        }
        
        if (items.length === 0 && !isInitialLoading) {
            return <EmptyState />;
        }
        
        const ctaProps = {
            colSpan: viewMode === 'table' ? viewConfig.tableView.columns.length + 1 : undefined,
        };
        const ctaElement = rest.renderCta
            ? rest.renderCta(viewMode, ctaProps)
            : null;
        
        // This will be expanded later to handle group tabs
        return renderViewForData(items, ctaElement);
      };

      return (
        <DynamicViewProvider<TFieldId, TItem> viewConfig={viewConfig} {...rest}>
          <div className="space-y-6">
              <div className="space-y-4">
                  <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-4">
                      <div className="flex-1">
                          {rest.renderHeaderControls ? rest.renderHeaderControls() : (
                              <>
                                  <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                                  <p className="text-muted-foreground">
                                      {isInitialLoading 
                                          ? "Loading projects..." 
                                          : `Showing ${items.length} of ${rest.totalItemCount} item(s)`}
                                  </p>
                              </>
                          )}
                      </div>
                      <ViewModeSelector />
                  </div>
                  <ViewControls />
              </div>

              {!isInitialLoading && statsData && statsData.length > 0 && (
                <div ref={statsRef} className="flex overflow-x-auto gap-6 pb-4 no-scrollbar">
                  {statsData.map((stat) => (
                    <StatCard
                      className="w-64 md:w-72 flex-shrink-0"
                      key={stat.title}
                      title={stat.title}
                      value={stat.value}
                      change={stat.change}
                      trend={stat.trend}
                      icon={stat.icon}
                      chartData={stat.chartData}
                    />
                  ))}
                </div>
              )}
              
              <div className="min-h-[500px]">
                  {renderContent()}
              </div>

              {/* Loader for infinite scroll */}
              <div ref={rest.loaderRef} className="flex justify-center items-center py-6">
                {isLoading && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && viewMode !== 'kanban' && (
                  <div className="flex items-center gap-2 text-muted-foreground">
                    <Loader2 className="w-5 h-5 animate-spin" />
                    <span>Loading more...</span>
                  </div>
                )}
                {!isLoading && !hasMore && items.length > 0 && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && viewMode !== 'kanban' && (
                  <p className="text-muted-foreground">You've reached the end.</p>
                )}
              </div>
          </div>
        </DynamicViewProvider>
      );
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 571
