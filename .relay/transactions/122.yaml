uuid: c6e42b26-a644-42f3-a12f-98c4b1a403d7
projectId: jeli-app-shell
createdAt: '2025-10-12T01:37:58.450Z'
gitCommitMsg: >-
  feat(split-view): enhance split view functionality

  - Automatically collapses the sidebar when entering split view to provide more
  screen real estate for the main content and split pane. - Implements
  independent and resizable widths for the overlay side pane and the split view
  pane. The component now remembers the user's preferred width for each mode. -
  Adds a `defaultSplitPaneWidth` prop to `AppShellProvider` for consumer
  customization.
promptSummary: >-
  The user requested to automatically collapse the sidebar when entering split
  view mode, and to make the split view pane width customizable and resizable.
reasoning:
  - >-
    Here are the modifications to implement the requested changes for the split
    view mode.
  - >-
    I'll start by updating the `AppShellContext` to handle separate widths for
    the side pane (overlay) and split view modes. This also includes adding
    logic to automatically collapse the sidebar when entering split view.
  - >-
    Next, I'll update the `useResizableRightPane` hook to handle resizing for
    both the overlay and split-view panes independently.
  - >-
    These changes make the split view more intelligent by collapsing the sidebar
    for more space and allow for independent, persistent width adjustments for
    both side pane modes.
operations:
  - type: write
    path: src/context/AppShellContext.tsx
    content: >+
      --- src/context/AppShellContext.tsx

      +++ src/context/AppShellContext.tsx

      @@ -10,8 +10,9 @@
         bodyState: BodyState;
         sidePaneContent: 'details' | 'settings' | 'main' | 'toaster' | 'notifications';
         sidebarWidth: number;
      -  rightPaneWidth: number;

      +  sidePaneWidth: number;

      +  splitPaneWidth: number;
         isResizing: boolean;
         isResizingRightPane: boolean;
         isTopBarVisible: boolean;
      @@ -28,7 +29,8 @@
         | { type: 'SET_BODY_STATE'; payload: BodyState }
         | { type: 'SET_SIDE_PANE_CONTENT'; payload: AppShellState['sidePaneContent'] }
         | { type: 'SET_SIDEBAR_WIDTH'; payload: number }
      -  | { type: 'SET_RIGHT_PANE_WIDTH'; payload: number }

      +  | { type: 'SET_SIDE_PANE_WIDTH'; payload: number }

      +  | { type: 'SET_SPLIT_PANE_WIDTH'; payload: number }
         | { type: 'SET_IS_RESIZING'; payload: boolean }
         | { type: 'SET_IS_RESIZING_RIGHT_PANE'; payload: boolean }
         | { type: 'SET_TOP_BAR_VISIBLE'; payload: boolean }
      @@ -45,7 +47,8 @@
         bodyState: BODY_STATES.NORMAL,
         sidePaneContent: 'details',
         sidebarWidth: 280,
      -  rightPaneWidth: typeof window !== 'undefined' ? Math.max(300,
      Math.round(window.innerWidth * 0.6)) : 400,

      +  sidePaneWidth: typeof window !== 'undefined' ? Math.max(300,
      Math.round(window.innerWidth * 0.6)) : 400,

      +  splitPaneWidth: typeof window !== 'undefined' ? Math.max(300,
      Math.round(window.innerWidth * 0.35)) : 400,
         isResizing: false,
         isResizingRightPane: false,
         isTopBarVisible: true,
      @@ -62,7 +65,8 @@
           case 'SET_BODY_STATE': return { ...state, bodyState: action.payload };
           case 'SET_SIDE_PANE_CONTENT': return { ...state, sidePaneContent: action.payload };
           case 'SET_SIDEBAR_WIDTH': return { ...state, sidebarWidth: Math.max(200, Math.min(500, action.payload)) };
      -    case 'SET_RIGHT_PANE_WIDTH': return { ...state, rightPaneWidth:
      Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };

      +    case 'SET_SIDE_PANE_WIDTH': return { ...state, sidePaneWidth:
      Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };

      +    case 'SET_SPLIT_PANE_WIDTH': return { ...state, splitPaneWidth:
      Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };
           case 'SET_IS_RESIZING': return { ...state, isResizing: action.payload };
           case 'SET_IS_RESIZING_RIGHT_PANE': return { ...state, isResizingRightPane: action.payload };
           case 'SET_TOP_BAR_VISIBLE': return { ...state, isTopBarVisible: action.payload };
      @@ -82,6 +86,7 @@
       
       interface AppShellContextValue extends AppShellState {
         dispatch: Dispatch<AppShellAction>;
      +  rightPaneWidth: number;
         // Composite actions for convenience
         toggleSidebar: () => void;
         hideSidebar: () => void;
      @@ -98,14 +103,16 @@
         children: ReactNode;
         appName?: string;
         appLogo?: ReactElement;
      +  defaultSplitPaneWidth?: number;
       }
       
      -export function AppShellProvider({ children, appName, appLogo }:
      AppShellProviderProps) {

      +export function AppShellProvider({ children, appName, appLogo,
      defaultSplitPaneWidth }: AppShellProviderProps) {
         const [state, dispatch] = useReducer(appShellReducer, {
           ...defaultState,
           ...(appName && { appName }),
           ...(appLogo && { appLogo }),
      +    ...(defaultSplitPaneWidth && { splitPaneWidth: defaultSplitPaneWidth
      }),
         });
       
         // Side effect for primary color
      @@ -128,10 +135,13 @@
         const toggleSplitView = useCallback(() => {
           const current = state.bodyState;
           if (current === BODY_STATES.SIDE_PANE) {
             dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
      +      if (state.sidebarState === SIDEBAR_STATES.EXPANDED) {

      +        dispatch({ type: 'SET_SIDEBAR_STATE', payload:
      SIDEBAR_STATES.COLLAPSED });

      +      }
           } else if (current === BODY_STATES.SPLIT_VIEW) {
             dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE });
           }
      -  }, [state.bodyState]);

      +  }, [state.bodyState, state.sidebarState]);
       
         const openSidePane = useCallback((content: AppShellState['sidePaneContent']) => {
           if (state.bodyState === BODY_STATES.SIDE_PANE && state.sidePaneContent === content) {
      @@ -147,9 +157,14 @@
         const closeSidePane = useCallback(() => dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.NORMAL }), []);
         const resetToDefaults = useCallback(() => dispatch({ type: 'RESET_TO_DEFAULTS' }), []);
       
      +  const rightPaneWidth = useMemo(() => (

      +    state.bodyState === BODY_STATES.SPLIT_VIEW ? state.splitPaneWidth :
      state.sidePaneWidth

      +  ), [state.bodyState, state.splitPaneWidth, state.sidePaneWidth]);

      +
         const value = useMemo(() => ({ 
           ...state, 
      -    dispatch, 

      +    dispatch,

      +    rightPaneWidth,
           toggleSidebar,
           hideSidebar,
           showSidebar,
      @@ -161,6 +176,7 @@
           resetToDefaults,
         }), [
           state, 
      +    rightPaneWidth,
           toggleSidebar,
           hideSidebar,
           showSidebar,

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useResizablePanes.hook.ts
    content: |+
      --- src/hooks/useResizablePanes.hook.ts
      +++ src/hooks/useResizablePanes.hook.ts
      @@ -28,15 +28,20 @@
       }
       
       export function useResizableRightPane() {
      -  const { isResizingRightPane, dispatch } = useAppShell();
      +  const { isResizingRightPane, dispatch, bodyState } = useAppShell();
       
         useEffect(() => {
           const handleMouseMove = (e: MouseEvent) => {
             if (!isResizingRightPane) return;
       
             const newWidth = window.innerWidth - e.clientX;
      -      dispatch({ type: 'SET_RIGHT_PANE_WIDTH', payload: newWidth });
      +      if (bodyState === BODY_STATES.SPLIT_VIEW) {
      +        dispatch({ type: 'SET_SPLIT_PANE_WIDTH', payload: newWidth });
      +      } else {
      +        dispatch({ type: 'SET_SIDE_PANE_WIDTH', payload: newWidth });
      +      }
           };
       
           const handleMouseUp = () => {
      @@ -55,6 +60,6 @@
             document.removeEventListener('mousemove', handleMouseMove);
             document.removeEventListener('mouseup', handleMouseUp);
             document.body.style.cursor = '';
           };
      -  }, [isResizingRightPane, dispatch]);
      +  }, [isResizingRightPane, dispatch, bodyState]);
       }

    patchStrategy: standard-diff
snapshot:
  src/context/AppShellContext.tsx: >-
    import {
      createContext,
      useContext,
      useReducer,
      useEffect,
      useMemo,
      useCallback,
      type ReactNode,
      type ReactElement,
      type Dispatch,
    } from 'react';

    import { SIDEBAR_STATES, BODY_STATES, type SidebarState, type BodyState }
    from '@/lib/utils';


    // --- State and Action Types ---


    interface AppShellState {
      sidebarState: SidebarState;
      bodyState: BodyState;
      sidePaneContent: 'details' | 'settings' | 'main' | 'toaster' | 'notifications';
      sidebarWidth: number;
      rightPaneWidth: number;
      isResizing: boolean;
      isResizingRightPane: boolean;
      isTopBarVisible: boolean;
      autoExpandSidebar: boolean;
      reducedMotion: boolean;
      compactMode: boolean;
      primaryColor: string;
      appName?: string;
      appLogo?: ReactElement;
    }


    type AppShellAction =
      | { type: 'SET_SIDEBAR_STATE'; payload: SidebarState }
      | { type: 'SET_BODY_STATE'; payload: BodyState }
      | { type: 'SET_SIDE_PANE_CONTENT'; payload: AppShellState['sidePaneContent'] }
      | { type: 'SET_SIDEBAR_WIDTH'; payload: number }
      | { type: 'SET_RIGHT_PANE_WIDTH'; payload: number }
      | { type: 'SET_IS_RESIZING'; payload: boolean }
      | { type: 'SET_IS_RESIZING_RIGHT_PANE'; payload: boolean }
      | { type: 'SET_TOP_BAR_VISIBLE'; payload: boolean }
      | { type: 'SET_AUTO_EXPAND_SIDEBAR'; payload: boolean }
      | { type: 'SET_REDUCED_MOTION'; payload: boolean }
      | { type: 'SET_COMPACT_MODE'; payload: boolean }
      | { type: 'SET_PRIMARY_COLOR'; payload: string }
      | { type: 'RESET_TO_DEFAULTS' };

    // --- Reducer ---


    const defaultState: AppShellState = {
      sidebarState: SIDEBAR_STATES.EXPANDED,
      bodyState: BODY_STATES.NORMAL,
      sidePaneContent: 'details',
      sidebarWidth: 280,
      rightPaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.6)) : 400,
      isResizing: false,
      isResizingRightPane: false,
      isTopBarVisible: true,
      autoExpandSidebar: true,
      reducedMotion: false,
      compactMode: false,
      primaryColor: '220 84% 60%',
      appName: 'Jeli App',
      appLogo: undefined,
    };


    function appShellReducer(state: AppShellState, action: AppShellAction):
    AppShellState {
      switch (action.type) {
        case 'SET_SIDEBAR_STATE': return { ...state, sidebarState: action.payload };
        case 'SET_BODY_STATE': return { ...state, bodyState: action.payload };
        case 'SET_SIDE_PANE_CONTENT': return { ...state, sidePaneContent: action.payload };
        case 'SET_SIDEBAR_WIDTH': return { ...state, sidebarWidth: Math.max(200, Math.min(500, action.payload)) };
        case 'SET_RIGHT_PANE_WIDTH': return { ...state, rightPaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };
        case 'SET_IS_RESIZING': return { ...state, isResizing: action.payload };
        case 'SET_IS_RESIZING_RIGHT_PANE': return { ...state, isResizingRightPane: action.payload };
        case 'SET_TOP_BAR_VISIBLE': return { ...state, isTopBarVisible: action.payload };
        case 'SET_AUTO_EXPAND_SIDEBAR': return { ...state, autoExpandSidebar: action.payload };
        case 'SET_REDUCED_MOTION': return { ...state, reducedMotion: action.payload };
        case 'SET_COMPACT_MODE': return { ...state, compactMode: action.payload };
        case 'SET_PRIMARY_COLOR': return { ...state, primaryColor: action.payload };
        case 'RESET_TO_DEFAULTS':
          return {
            ...defaultState,
            appName: state.appName, // Preserve props passed to provider
            appLogo: state.appLogo,   // Preserve props passed to provider
          };
        default: return state;
      }
    }


    // --- Context and Provider ---


    interface AppShellContextValue extends AppShellState {
      dispatch: Dispatch<AppShellAction>;
      // Composite actions for convenience
      toggleSidebar: () => void;
      hideSidebar: () => void;
      showSidebar: () => void;
      peekSidebar: () => void;
      toggleFullscreen: () => void;
      toggleSplitView: () => void;
      openSidePane: (content: AppShellState['sidePaneContent']) => void;
      closeSidePane: () => void;
      resetToDefaults: () => void;
    }


    const AppShellContext = createContext<AppShellContextValue | null>(null);


    interface AppShellProviderProps {
      children: ReactNode;
      appName?: string;
      appLogo?: ReactElement;
    }


    export function AppShellProvider({ children, appName, appLogo }:
    AppShellProviderProps) {
      const [state, dispatch] = useReducer(appShellReducer, {
        ...defaultState,
        ...(appName && { appName }),
        ...(appLogo && { appLogo }),
      });

      // Side effect for primary color
      useEffect(() => {
        document.documentElement.style.setProperty('--primary-hsl', state.primaryColor);
      }, [state.primaryColor]);

      // Memoized composite actions using useCallback for stable function identities
      const toggleSidebar = useCallback(() => {
        const current = state.sidebarState;
        if (current === SIDEBAR_STATES.HIDDEN) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
        else if (current === SIDEBAR_STATES.COLLAPSED) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.EXPANDED });
        else if (current === SIDEBAR_STATES.EXPANDED) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
      }, [state.sidebarState]);

      const hideSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.HIDDEN }), []);
      const showSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.EXPANDED }), []);
      const peekSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.PEEK }), []);
      
      const toggleFullscreen = useCallback(() => {
        const current = state.bodyState;
        dispatch({ type: 'SET_BODY_STATE', payload: current === BODY_STATES.FULLSCREEN ? BODY_STATES.NORMAL : BODY_STATES.FULLSCREEN });
      }, [state.bodyState]);

      const toggleSplitView = useCallback(() => {
        const current = state.bodyState;
        if (current === BODY_STATES.SIDE_PANE) {
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
        } else if (current === BODY_STATES.SPLIT_VIEW) {
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE });
        }
      }, [state.bodyState]);

      const openSidePane = useCallback((content: AppShellState['sidePaneContent']) => {
        if (state.bodyState === BODY_STATES.SIDE_PANE && state.sidePaneContent === content) {
          // If it's open with same content, close it.
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.NORMAL });
        } else {
          // If closed, or different content, open with new content.
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: content });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE });
        }
      }, [state.bodyState, state.sidePaneContent]);

      const closeSidePane = useCallback(() => dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.NORMAL }), []);
      const resetToDefaults = useCallback(() => dispatch({ type: 'RESET_TO_DEFAULTS' }), []);

      const value = useMemo(() => ({ 
        ...state, 
        dispatch, 
        toggleSidebar,
        hideSidebar,
        showSidebar,
        peekSidebar,
        toggleFullscreen,
        toggleSplitView,
        openSidePane,
        closeSidePane,
        resetToDefaults,
      }), [
        state, 
        toggleSidebar,
        hideSidebar,
        showSidebar,
        peekSidebar,
        toggleFullscreen,
        toggleSplitView,
        openSidePane,
        closeSidePane,
        resetToDefaults
      ]);

      return (
        <AppShellContext.Provider value={value}>
          {children}
        </AppShellContext.Provider>
      );
    }


    // --- Hook ---


    export function useAppShell() {
      const context = useContext(AppShellContext);
      if (!context) {
        throw new Error('useAppShell must be used within an AppShellProvider');
      }
      return context;
    }
  src/hooks/useResizablePanes.hook.ts: |-
    import { useEffect } from 'react';
    import { gsap } from 'gsap';
    import { useAppShell } from '@/context/AppShellContext';

    export function useResizableSidebar(
      sidebarRef: React.RefObject<HTMLDivElement>,
      resizeHandleRef: React.RefObject<HTMLDivElement>
    ) {
      const { isResizing, dispatch } = useAppShell();

      useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
          if (!isResizing) return;

          const newWidth = Math.max(200, Math.min(500, e.clientX));
          dispatch({ type: 'SET_SIDEBAR_WIDTH', payload: newWidth });

          if (sidebarRef.current) {
            gsap.set(sidebarRef.current, { width: newWidth });
          }
          if (resizeHandleRef.current) {
            gsap.set(resizeHandleRef.current, { left: newWidth });
          }
        };

        const handleMouseUp = () => {
          dispatch({ type: 'SET_IS_RESIZING', payload: false });
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        };

        if (isResizing) {
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };
      }, [isResizing, dispatch, sidebarRef, resizeHandleRef]);
    }

    export function useResizableRightPane() {
      const { isResizingRightPane, dispatch } = useAppShell();

      useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
          if (!isResizingRightPane) return;

          const newWidth = window.innerWidth - e.clientX;
          dispatch({ type: 'SET_RIGHT_PANE_WIDTH', payload: newWidth });
        };

        const handleMouseUp = () => {
          dispatch({ type: 'SET_IS_RESIZING_RIGHT_PANE', payload: false });
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        };

        if (isResizingRightPane) {
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          document.body.style.cursor = '';
        };
      }, [isResizingRightPane, dispatch]);
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 122
