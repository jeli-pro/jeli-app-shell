uuid: c3284ff6-93d3-455b-9d41-470a168673a3
projectId: jeli-app-shell
createdAt: '2025-10-23T04:02:29.238Z'
gitCommitMsg: >-
  refactor(views): Re-architect AppViewManager as declarative executor

  This commit implements Part 2 of the view management refactor.

  The `useAppViewManager` hook has been completely rewritten to act as a "dumb"
  executor of declarative rules defined in the `viewRegistry`. It no longer
  contains complex, hardcoded logic for deriving view states.

  Key changes: - The hook now derives `mainViewId`, `rightPaneViewId`, and
  `bodyState` by interpreting `compositeView` definitions and other metadata
  from the `viewRegistry` against the current URL. - A new, context-aware
  `trigger(viewId, source)` function is introduced as the primary method for
  initiating view changes. - Simpler action helpers (`navigateTo`, `openPane`)
  are provided, which are built on top of the new trigger system. - `App.tsx`
  has been updated to consume the derived view IDs directly from the hook,
  removing its own state derivation logic and solidifying the hook as the single
  source of truth for view rendering.
promptSummary: >-
  The user requested to execute Part 2 of the refactoring plan, which involves
  re-architecting the `useAppViewManager` hook to be a declarative rules-engine
  based on the `viewRegistry`, and updating `App.tsx` to consume the new state
  provided by this hook.
reasoning:
  - Executing Part 2 of the master plan.
  - >-
    The core of our view management system, `useAppViewManager.hook.ts`, is
    being fundamentally re-architected. I am ripping out the old, imperative
    logic that manually parsed URL parameters. In its place, I am installing a
    new engine that reads the declarative rules from our enhanced
    `viewRegistry`. This new manager derives the `mainViewId`,
    `rightPaneViewId`, and `bodyState` by interpreting the registry's
    `compositeView` definitions and other metadata against the current URL.
  - >-
    This engine exposes a new, context-aware `trigger(viewId, source)` API,
    along with simpler helpers like `navigateTo()` and `openPane()`. These
    functions are now the sanctioned way to interact with the application's
    layout.
  - >-
    Finally, `App.tsx` is being updated to be a direct consumer of this new,
    intelligent hook. It will no longer calculate view states itself but will
    simply take the `mainViewId` and `rightPaneViewId` from the view manager and
    render the appropriate components, solidifying the new chain of command.
  - '### Part 2.1 & 2.2: Re-architect AppViewManager and Update `App.tsx`'
  - >-
    I'll start by completely replacing the logic in `useAppViewManager.hook.ts`
    with the new declarative rules engine.
  - Next, I'll update `App.tsx` to use the newly derived state from the hook.
operations:
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: >-
      import { useMemo, useCallback } from 'react';

      import { useSearchParams, useNavigate, useLocation, useParams } from
      'react-router-dom';

      import { useAppShellStore } from '@/store/appShell.store';

      import type { TaskView } from '@/pages/Messaging/types';

      import { BODY_STATES, BodyState } from '@/lib/utils';

      import { getViewById, type ViewId, type ViewRegistration } from
      '@/views/viewRegistry';


      /**
       * A centralized hook to manage and synchronize all URL-based view states.
       * This is the single source of truth for view modes, side panes, split views,
       * and page-specific parameters. It acts as an executor for the declarative
       * rules defined in the `viewRegistry`.
       */
      export function useAppViewManager() {
        const [searchParams, setSearchParams] = useSearchParams();
        const navigate = useNavigate();
        const location = useLocation();
        const params = useParams<{ itemId?: string; conversationId?: string }>();

        const { setSidebarState } = useAppShellStore.getState();

        // --- DERIVED STATE FROM URL & VIEW REGISTRY ---

        const { mainViewId, rightPaneViewId, bodyState } = useMemo(() => {
          const path = location.pathname.split('/')[1] || 'dashboard';
          const viewFromPath = getViewById(path);
          
          const sidePaneParam = searchParams.get('sidePane');
          const viewParam = searchParams.get('view');
          const rightParam = searchParams.get('right');
          const itemIdParam = searchParams.get('itemId');

          let derivedMainViewId: ViewId | null = (path as ViewId) || 'dashboard';
          let derivedRightPaneViewId: ViewId | null = null;
          let derivedBodyState: BodyState = BODY_STATES.NORMAL;

          if (viewFromPath?.compositeView) {
            derivedMainViewId = viewFromPath.compositeView.main;
            derivedRightPaneViewId = viewFromPath.compositeView.right;
            derivedBodyState = BODY_STATES.SPLIT_VIEW;
          } else if (sidePaneParam) {
            derivedRightPaneViewId = sidePaneParam as ViewId;
            derivedBodyState = BODY_STATES.SIDE_PANE;
          } else if (viewParam === 'split' && rightParam) {
            derivedRightPaneViewId = rightParam as ViewId;
            derivedBodyState = BODY_STATES.SPLIT_VIEW;
          }

          // Handle item detail views specially
          if (derivedMainViewId === 'data-demo' && params.itemId) {
            derivedMainViewId = 'dataItemDetail';
          } else if (itemIdParam) {
            derivedRightPaneViewId = 'dataItemDetail';
            // If there's an itemId, it could be a side pane or part of a split
            if (derivedBodyState !== BODY_STATES.SPLIT_VIEW) {
                derivedBodyState = BODY_STATES.SIDE_PANE;
            }
          }

          return { 
            mainViewId: derivedMainViewId, 
            rightPaneViewId: derivedRightPaneViewId, 
            bodyState: derivedBodyState
          };
        }, [location.pathname, searchParams, params.itemId]);

        const messagingView = searchParams.get('messagingView') as TaskView | null;
        const currentActivePage = (location.pathname.split('/')[1] || 'dashboard') as ViewId;

        // --- PRIVATE ACTION EXECUTORS ---

        const _executeNavigate = useCallback((view: ViewRegistration, payload?: any) => {
          if (view.onNavigate?.sidebar) {
            setSidebarState(view.onNavigate.sidebar);
          }
          
          let path = `/${view.id}`;
          if (view.id === 'dataItemDetail' && payload?.itemId) {
              path = `/data-demo/${payload.itemId}`;
          }

          navigate(path);
        }, [navigate, setSidebarState]);

        const _executeOpenPane = useCallback((view: ViewRegistration, payload?: any) => {
          if (!view.renderTarget?.includes('pane')) {
            console.warn(`View "${view.id}" cannot be rendered in a pane.`);
            return;
          }
          
          setSearchParams(prev => {
              prev.delete('view');
              prev.delete('right');
              if (view.id === 'dataItemDetail' && payload?.itemId) {
                  prev.set('itemId', payload.itemId);
                  prev.delete('sidePane');
              } else {
                  prev.set('sidePane', view.id);
                  prev.delete('itemId');
              }
              return prev;
          }, { replace: true });

        }, [setSearchParams]);

        const _executeOpenSplit = useCallback((view: ViewRegistration, payload?: any) => {
          // A composite view is triggered by navigating to its main route
          if (view.compositeView) {
            _executeNavigate(view, payload);
            return;
          }
          
          if (!view.renderTarget?.includes('pane')) {
            console.warn(`View "${view.id}" cannot be rendered in a split view's right pane.`);
            return;
          }
          
          setSearchParams(prev => {
              prev.set('view', 'split');
              prev.delete('sidePane');
              if (view.id === 'dataItemDetail' && payload?.itemId) {
                  prev.set('itemId', payload.itemId);
                  prev.delete('right');
              } else {
                  prev.set('right', view.id);
                  prev.delete('itemId');
              }
              return prev;
          }, { replace: true });
        }, [setSearchParams, _executeNavigate]);

        // --- PUBLIC API ---

        const trigger = useCallback((viewId: ViewId, source?: string, payload?: any) => {
          const view = getViewById(viewId);
          if (!view) {
            console.error(`View with id "${viewId}" not found in registry.`);
            return;
          }
          
          const behavior = (source && view.triggerBehaviors?.[source]) || view.defaultBehavior || 'navigate';
          
          // TODO: Add check for allowedBodyStates
          
          switch (behavior) {
            case 'navigate':
              _executeNavigate(view, payload);
              break;
            case 'openPane':
              _executeOpenPane(view, payload);
              break;
            case 'openSplit':
              _executeOpenSplit(view, payload);
              break;
            default:
              console.warn(`Unknown behavior "${behavior}" for view "${viewId}".`);
              _executeNavigate(view, payload);
          }
        }, [_executeNavigate, _executeOpenPane, _executeOpenSplit]);
        
        const navigateTo = useCallback((page: ViewId, params?: Record<string, string | null>) => {
          // This is a simplified navigate, for complex behaviors, use trigger.
          let path = `/${page}`;
          if (page === 'dataItemDetail' && params?.itemId) {
              path = `/data-demo/${params.itemId}`;
          }
          
          const newSearchParams = new URLSearchParams(searchParams);
          if (params) {
            for (const [key, value] of Object.entries(params)) {
              if (value === null || value === undefined) {
                newSearchParams.delete(key);
              } else {
                newSearchParams.set(key, value);
              }
            }
          }
          
          const view = getViewById(page);
          if (view?.onNavigate?.sidebar) {
            setSidebarState(view.onNavigate.sidebar);
          }

          navigate({ pathname: path, search: newSearchParams.toString() });
        }, [navigate, searchParams, setSidebarState]);
        
        const openPane = useCallback((viewId: ViewId, payload?: any) => {
          const view = getViewById(viewId);
          if (view) {
            _executeOpenPane(view, payload);
          }
        }, [_executeOpenPane]);

        const closeSidePane = useCallback(() => {
          setSearchParams(prev => {
              prev.delete('sidePane');
              prev.delete('itemId');
              // if we were in a split view, revert to normal by clearing view and right
              if (prev.get('view') === 'split') {
                prev.delete('view');
                prev.delete('right');
              }
              return prev;
          }, { replace: true });
        }, [setSearchParams]);
        
        const toggleSidePane = useCallback((viewId: ViewId) => {
          if (rightPaneViewId === viewId && bodyState === BODY_STATES.SIDE_PANE) {
              closeSidePane();
          } else {
              openPane(viewId);
          }
        }, [rightPaneViewId, bodyState, closeSidePane, openPane]);

        const setMessagingView = (view: TaskView) => {
          setSearchParams(prev => {
              prev.set('messagingView', view);
              return prev;
          }, { replace: true });
        };

        const itemId = params.itemId || searchParams.get('itemId');
        
        return useMemo(() => ({
          // State
          mainViewId,
          rightPaneViewId,
          bodyState,
          itemId,
          conversationId: params.conversationId,
          messagingView,
          currentActivePage,

          // Actions
          trigger,
          navigateTo,
          openPane,
          closeSidePane,
          toggleSidePane,
          setMessagingView,
        }), [
          mainViewId, rightPaneViewId, bodyState, itemId, params.conversationId, messagingView, currentActivePage,
          trigger, navigateTo, openPane, closeSidePane, toggleSidePane, setMessagingView
        ]);
      }
    patchStrategy: replace
  - type: write
    path: src/App.tsx
    content: >+
      --- src/App.tsx

      +++ src/App.tsx

      @@ -147,29 +147,20 @@
       // The main App component that composes the shell
       function ComposedApp() {
         const viewManager = useAppViewManager();
      -  const location = useLocation();

      -  const params = useParams();
         const { setBodyState, setSidePaneContent } = useAppShellStore.getState(); // Non-reactive state setters
      -

      -  // The right pane's content is derived from the URL via the viewManager
      hook.

      -  // This derived value is then used to update the global store.

      -  const rightViewId = React.useMemo(() => {

      -    if (viewManager.sidePaneContent === 'dataItem') return
      'dataItemDetail';

      -    return viewManager.sidePaneContent;

      -  }, [viewManager.sidePaneContent]);
       
         // Sync URL-derived state to the global Zustand store.
         // This allows descendant components (like AppShell) to react to layout changes
         // without having to drill props down. The loop is prevented by using selective
         // subscriptions in other hooks.
         useEffect(() => {
           setBodyState(viewManager.bodyState);
      -    setSidePaneContent(rightViewId);

      -  }, [viewManager.bodyState, rightViewId, setBodyState,
      setSidePaneContent]);

      +    // The view manager now provides the definitive ID for the right
      pane.

      +    // We cast it for the store, which uses a string union. This might be
      an area for future refactoring.

      +    setSidePaneContent(viewManager.rightPaneViewId as any);

      +  }, [viewManager.bodyState, viewManager.rightPaneViewId, setBodyState,
      setSidePaneContent]);
       
      -  // Determine mainViewId from the route path

      -  const pathSegments = location.pathname.split('/').filter(Boolean);

      -  let mainViewId: ViewId | null = (pathSegments[0] as ViewId) ||
      'dashboard';

      -  

      -  // Handle detail views that are part of the main content

      -  if (mainViewId === 'data-demo' && params.itemId) {

      -    mainViewId = 'dataItemDetail';

      -  }

      +  // The view manager is now the single source of truth for which views
      to render.

      +  const { mainViewId, rightPaneViewId } = viewManager;
       
         return (
           <AppShellProvider
      @@ -185,7 +176,7 @@
                 <TopBar breadcrumbs={<AppBreadcrumbs />} pageControls={<TopBarPageControls />} />
               }
               mainContent={<MainContent viewId={mainViewId} />}
      -        rightPane={<RightPane viewId={rightViewId} />}

      +        rightPane={<RightPane viewId={rightPaneViewId} />}
             />
           </AppShellProvider>
         );

    patchStrategy: standard-diff
snapshot:
  src/hooks/useAppViewManager.hook.ts: "import { useMemo, useCallback, useEffect, useRef } from 'react';\nimport { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\nimport type { TaskView } from '@/pages/Messaging/types';\nimport { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n\nconst pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n  dashboard: 'main',\n  settings: 'settings',\n  toaster: 'toaster',\n  notifications: 'notifications',\n  'data-demo': 'dataDemo',\n  messaging: 'messaging',\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n/**\n * A centralized hook to manage and synchronize all URL-based view states.\n * This is the single source of truth for view modes, side panes, split views,\n * and page-specific parameters.\n */\nexport function useAppViewManager() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { itemId: pathItemId, conversationId } = useParams<{ itemId?: string; conversationId?: string }>();\n  const sidebarState = useAppShellStore(s => s.sidebarState);\n  const { setSidebarState } = useAppShellStore.getState();\n\n  // --- DERIVED STATE FROM URL ---\n\n  const view = searchParams.get('view');\n  const sidePane = searchParams.get('sidePane');\n  const sidePaneItemId = searchParams.get('itemId');\n  const right = searchParams.get('right');\n  const messagingView = searchParams.get('messagingView') as TaskView | null;\n\n  const { bodyState, sidePaneContent } = useMemo(() => {\n    const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo', 'messaging'];\n    \n    // 1. Priority: Explicit side pane overlay via URL param\n    if (sidePane && validPanes.includes(sidePane as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n    }\n\n    // 2. Data item detail view in a pane, triggered by search param\n    if (sidePaneItemId) {\n      if (view === 'split') {\n        return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n      }\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n    }\n\n    // 4. Generic split view via URL param\n    if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: right as AppShellState['sidePaneContent'] };\n    }\n\n    return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n  }, [sidePaneItemId, conversationId, view, sidePane, right]);\n  \n  const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n  const prevActivePage = usePrevious(currentActivePage);\n\n  // --- SIDE EFFECTS ---\n  useEffect(() => {\n    // On navigating to messaging page, collapse sidebar if it's expanded.\n    // This ensures a good default view but allows the user to expand it again if they wish.\n    if (currentActivePage === 'messaging' && prevActivePage !== 'messaging' && sidebarState === SIDEBAR_STATES.EXPANDED) {\n      setSidebarState(SIDEBAR_STATES.COLLAPSED);\n    }\n  }, [currentActivePage, prevActivePage, sidebarState, setSidebarState]);\n\n  // --- MUTATOR ACTIONS ---\n\n  const handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | number | string[] | null | undefined>, resetPage = false) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\t\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resetPage) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n  const navigateTo = useCallback((page: string, params?: Record<string, string | null>) => {\n    const targetPath = page.startsWith('/') ? page : `/${page}`;\n    const isSamePage = location.pathname === targetPath;\n    \n    const newSearchParams = new URLSearchParams(isSamePage ? searchParams : undefined);\n\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n          newSearchParams.delete(key);\n        } else {\n          newSearchParams.set(key, value);\n        }\n      }\n    }\n\n    navigate({ pathname: targetPath, search: newSearchParams.toString() });\n  }, [navigate, location.pathname, searchParams]);\n\n  const openSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (location.pathname === `/${Object.keys(pageToPaneMap).find(key => pageToPaneMap[key] === pane)}`) {\n        navigate({ pathname: '/dashboard', search: `?sidePane=${pane}` }, { replace: true });\n    } else {\n        handleParamsChange({ sidePane: pane, view: null, right: null });\n    }\n  }, [handleParamsChange, navigate, location.pathname]);\n\n  const closeSidePane = useCallback(() => {\n    // This should close any kind of side pane, including dataItem\n    handleParamsChange({ sidePane: null, view: null, right: null, itemId: null });\n  }, [handleParamsChange]);\n\n  const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (sidePane === pane) {\n      closeSidePane();\n    } else {\n      openSidePane(pane);\n    }\n  }, [sidePane, openSidePane, closeSidePane]);\n\n  const toggleSplitView = useCallback((paneContent?: AppShellState['sidePaneContent']) => {\n    if (bodyState === BODY_STATES.SIDE_PANE) {\n      handleParamsChange({ view: 'split', right: sidePane, sidePane: null });\n    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {\n      handleParamsChange({ sidePane: right, view: null, right: null });\n    } else { // From normal\n      const content = paneContent || pageToPaneMap[currentActivePage] || 'details';\n      handleParamsChange({ view: 'split', right: content, sidePane: null });\n    }\n  }, [bodyState, sidePane, right, currentActivePage, handleParamsChange]);\n  \n  const toggleFullscreen = useCallback((target?: 'main' | 'right') => {\n    // This logic is handled by the store, which will be updated by ViewModeSwitcher\n    // For now, we assume the store has a `toggleFullscreen` action\n    useAppShellStore.getState().toggleFullscreen(target);\n  }, []);\n\n  const setNormalView = useCallback(() => {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const switchSplitPanes = useCallback(() => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    const newSidePaneContent = pageToPaneMap[currentActivePage];\n    const newActivePage = Object.entries(pageToPaneMap).find(\n      ([, value]) => value === sidePaneContent\n    )?.[0] as ActivePage | undefined;\n\n    if (newActivePage && newSidePaneContent) {\n      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const closeSplitPane = useCallback((paneToClose: 'main' | 'right') => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    if (paneToClose === 'right') {\n      navigate(`/${currentActivePage}`, { replace: true });\n    } else { // Closing main pane\n      const pageToBecomeActive = Object.entries(pageToPaneMap).find(\n        ([, value]) => value === sidePaneContent\n      )?.[0] as ActivePage | undefined;\n      \n      if (pageToBecomeActive) {\n        navigate(`/${pageToBecomeActive}`, { replace: true });\n      } else {\n        navigate(`/dashboard`, { replace: true });\n      }\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const onItemSelect = useCallback((itemId: string) => {\n    handleParamsChange({ itemId: itemId, sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n\n  // The final active item ID is either from the path (main view) or a search param (pane view)\n  const itemId = pathItemId || sidePaneItemId;\n\n  return useMemo(() => ({\n    // State\n    bodyState,\n    sidePaneContent,\n    currentActivePage,\n    pathItemId, // Expose for main content decisions\n    itemId,\n    messagingView,\n    // Actions\n    navigateTo,\n    openSidePane,\n    closeSidePane,\n    toggleSidePane,\n    toggleSplitView,\n    toggleFullscreen,\n    setNormalView,\n    switchSplitPanes,\n    setMessagingView,\n    closeSplitPane,\n    onItemSelect,\n  }), [\n    bodyState, sidePaneContent, currentActivePage, pathItemId, itemId, messagingView,\n    navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, toggleFullscreen,\n    setNormalView, switchSplitPanes, setMessagingView, closeSplitPane, onItemSelect\n  ]);\n}"
  src/App.tsx: >-
    import React, { useEffect } from "react";

    import {
      createBrowserRouter,
      RouterProvider,
      Outlet,
      Navigate,
      useNavigate, // used in LoginPageWrapper
      useLocation,
      useParams,
    } from "react-router-dom";


    import { AppShell } from "./components/layout/AppShell";

    import { AppShellProvider } from "./providers/AppShellProvider";

    import { useAppShellStore } from "./store/appShell.store";

    import { useAuthStore } from "./store/authStore";

    import "./index.css";


    // Import library components

    import { EnhancedSidebar } from "./components/layout/EnhancedSidebar";

    import { MainContent } from "./components/layout/MainContent";

    import { RightPane } from "./components/layout/RightPane";

    import { TopBar } from "./components/layout/TopBar";

    import { CommandPalette } from "./components/global/CommandPalette";

    import { ToasterProvider } from "./components/ui/toast";

    import { Input } from "./components/ui/input";

    import { Button } from "./components/ui/button";


    import { LoginPage } from "./components/auth/LoginPage";

    import { type ViewId } from "./views/viewRegistry";


    // --- Icons ---

    import {
      Search,
      Filter,
      Plus,
      ChevronRight,
      Rocket,
    } from "lucide-react";


    // --- Utils & Hooks ---

    import { cn } from "./lib/utils";

    import { useAppViewManager } from "./hooks/useAppViewManager.hook";

    import { useDataDemoParams } from
    "./pages/DataDemo/hooks/useDataDemoParams.hook";


    // Checks for authentication and redirects to login if needed

    function ProtectedRoute() {
      const { isAuthenticated } = useAuthStore();
      const location = useLocation();
      if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
      }
      return <ComposedApp />; // ComposedApp is the layout for all protected routes
    }


    // A root component to apply global styles and effects

    function Root() {
      const isDarkMode = useAppShellStore((state) => state.isDarkMode);

      useEffect(() => {
        document.documentElement.classList.toggle("dark", isDarkMode);
      }, [isDarkMode]);

      return <Outlet />;
    }


    // Breadcrumbs for the Top Bar

    function AppBreadcrumbs() {
      const { currentActivePage } = useAppViewManager();
      const activePageName = currentActivePage.replace('-', ' ');

      return (
        <div className="hidden md:flex items-center gap-2 text-sm">
          <a
            href="#"
            className="text-muted-foreground hover:text-foreground transition-colors"
          >
            Home
          </a>
          <ChevronRight className="w-4 h-4 text-muted-foreground" />
          <span className="font-medium text-foreground capitalize">
            {activePageName}
          </span>
        </div>
      );
    }


    // Specific controls for DataDemo page

    function DataDemoTopBarControls() {
      const { filters, setFilters } = useDataDemoParams();

      return (
        <div className="flex items-center gap-2">
          <div className="relative w-64">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground h-4 w-4" />
            <Input
              placeholder="Search items..."
              className="pl-9 bg-card border-none"
              value={filters.searchTerm}
              onChange={(e) => setFilters({ ...filters, searchTerm: e.target.value })}
            />
          </div>
          <Button variant="outline">
            <Filter className="w-4 h-4 mr-2" />
            Filter
          </Button>
          <Button>
            <Plus className="w-4 h-4 mr-2" />
            New Item
          </Button>
        </div>
      );
    }

    // Page-specific controls for the Top Bar

    function TopBarPageControls() {
      const { currentActivePage } = useAppViewManager();
      const [searchTerm, setSearchTerm] = React.useState("");
      const [isSearchFocused, setIsSearchFocused] = React.useState(false);

      if (currentActivePage === "dashboard") {
        return (
          <div className="flex items-center gap-2 flex-1 justify-end">
            <div
              className={cn(
                "relative transition-all duration-300 ease-in-out",
                isSearchFocused ? "flex-1 max-w-lg" : "w-auto",
              )}
            >
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4 pointer-events-none" />
              <input
                type="text"
                placeholder="Search dashboard..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                onFocus={() => setIsSearchFocused(true)}
                onBlur={() => setIsSearchFocused(false)}
                className="pl-9 pr-4 py-2 h-10 border-none rounded-lg bg-card focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all duration-300 ease-in-out w-full"
              />
            </div>
            <Button variant="ghost" size="icon" className="flex-shrink-0">
              <Filter className="w-5 h-5" />
            </Button>
            <Button className="flex-shrink-0">
              <Plus className="w-5 h-5 mr-0 sm:mr-2" />
              <span className={cn(isSearchFocused ? "hidden sm:inline" : "inline")}>
                New Project
              </span>
            </Button>
          </div>
        );
      }

      if (currentActivePage === "data-demo") {
        return <DataDemoTopBarControls />;
      }

      return null;
    }


    // The main App component that composes the shell

    function ComposedApp() {
      const viewManager = useAppViewManager();
      const location = useLocation();
      const params = useParams();
      const { setBodyState, setSidePaneContent } = useAppShellStore.getState(); // Non-reactive state setters

      // The right pane's content is derived from the URL via the viewManager hook.
      // This derived value is then used to update the global store.
      const rightViewId = React.useMemo(() => {
        if (viewManager.sidePaneContent === 'dataItem') return 'dataItemDetail';
        return viewManager.sidePaneContent;
      }, [viewManager.sidePaneContent]);

      // Sync URL-derived state to the global Zustand store.
      // This allows descendant components (like AppShell) to react to layout changes
      // without having to drill props down. The loop is prevented by using selective
      // subscriptions in other hooks.
      useEffect(() => {
        setBodyState(viewManager.bodyState);
        setSidePaneContent(rightViewId);
      }, [viewManager.bodyState, rightViewId, setBodyState, setSidePaneContent]);

      // Determine mainViewId from the route path
      const pathSegments = location.pathname.split('/').filter(Boolean);
      let mainViewId: ViewId | null = (pathSegments[0] as ViewId) || 'dashboard';
      
      // Handle detail views that are part of the main content
      if (mainViewId === 'data-demo' && params.itemId) {
        mainViewId = 'dataItemDetail';
      }

      return (
        <AppShellProvider
          appName="Jeli App"
          appLogo={
            <div className="p-2 bg-primary/20 rounded-lg">
              <Rocket className="w-5 h-5 text-primary" />
            </div>
          }
        >
          <AppShell
            sidebar={<EnhancedSidebar />}
            onOverlayClick={viewManager.closeSidePane}
            topBar={
              <TopBar breadcrumbs={<AppBreadcrumbs />} pageControls={<TopBarPageControls />} />
            }
            mainContent={<MainContent viewId={mainViewId} />}
            rightPane={<RightPane viewId={rightViewId} />}
          />
        </AppShellProvider>
      );
    }


    const router = createBrowserRouter([
        {
          element: <Root />,
          children: [
            {
              path: "/login",
              element: <LoginPage />,
            },
            {
              path: "/",
              element: <ProtectedRoute />,
              children: [
                // The ComposedApp layout will render the correct view based on the path
                // so these elements can be null. The paths are still needed for matching.
                { index: true, element: <Navigate to="/dashboard" replace /> },
                { path: "dashboard", element: null },
                { path: "settings", element: null },
                { path: "toaster", element: null },
                { path: "notifications", element: null },
                { path: "data-demo", element: null },
                { path: "data-demo/:itemId", element: null },
                { path: "messaging", element: null },
                { path: "messaging/:conversationId", element: null },
              ],
            },
          ],
        },
      ]);

    function App() {
      return (
        <ToasterProvider>
          <RouterProvider router={router} />
        </ToasterProvider>
      );
    }


    export default App;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 584
