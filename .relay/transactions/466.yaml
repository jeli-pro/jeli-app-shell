uuid: c2584ec6-3914-41d3-a5fe-001091a13470
projectId: jeli-app-shell
createdAt: '2025-10-18T07:53:28.260Z'
gitCommitMsg: >-
  perf: Tweak animation timings for stat cards

  Adjusted the GSAP animation durations and staggers for the stat cards and
  their internal charts. This makes the animations feel snappier and more
  responsive, mitigating the perceived performance heaviness introduced by the
  scroll-based container animation.
promptSummary: >-
  The user wants to fix a perceived lag in the stats cards animations after
  adding a "scroll magnetism" feature. The animations feel heavy.
reasoning:
  - >-
    The "scroll magnetism" feature, which animates the stats card container on
    scroll, can make other animations on the page feel heavy or laggy,
    especially if they are long-running. To address this, I will adjust the
    animation timings for both the initial reveal of the stat cards and the
    chart animations within each card. By making these animations faster and
    snappier, the overall user experience will feel lighter and more responsive,
    mitigating the perceived lag.
  - >-
    First, I will modify the `StatCard` component to shorten the duration of the
    line-drawing and area-reveal animations for the mini-charts.
  - >-
    Next, I will adjust the initial stagger animation for the group of stat
    cards in the `DataDemo` page, making it complete more quickly.
  - >-
    These adjustments will make the animations crisper and should resolve the
    feeling of sluggishness when interacting with the page.
operations:
  - type: write
    path: src/components/shared/StatCard.tsx
    content: >+
      --- src/components/shared/StatCard.tsx

      +++ src/components/shared/StatCard.tsx

      @@ -19,8 +19,8 @@
             if (line instanceof SVGPathElement && area) {
               const length = line.getTotalLength();
               gsap.set(line, { strokeDasharray: length, strokeDashoffset: length });
      -        gsap.to(line, { strokeDashoffset: 0, duration: 1.5, ease:
      'power2.inOut' });

      -        gsap.fromTo(area, { opacity: 0, y: 10 }, { opacity: 1, y: 0,
      duration: 1, ease: 'power2.out', delay: 0.5 });

      +        gsap.to(line, { strokeDashoffset: 0, duration: 1.2, ease:
      'power2.inOut' });

      +        gsap.fromTo(area, { opacity: 0, y: 10 }, { opacity: 1, y: 0,
      duration: 0.8, ease: 'power2.out', delay: 0.4 });
             }
           }
         }, [chartData]);

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: |+
      --- src/pages/DataDemo/index.tsx
      +++ src/pages/DataDemo/index.tsx
      @@ -176,10 +176,10 @@
             gsap.fromTo(statsRef.current.children,
               { y: 30, opacity: 0 },
               {
      -          duration: 0.6,
      +          duration: 0.5,
                 y: 0,
                 opacity: 1,
      -          stagger: 0.1,
      +          stagger: 0.08,
                 ease: "power2.out"
               }
             )

    patchStrategy: standard-diff
snapshot:
  src/components/shared/StatCard.tsx: >-
    import React, { useLayoutEffect, useRef } from 'react';

    import { gsap } from 'gsap';

    import { cn } from '@/lib/utils';

    import { Card } from '@/components/ui/card';


    interface StatCardProps {
      title: string;
      value: string;
      change: string;
      trend: 'up' | 'down';
      icon: React.ReactNode;
      chartData?: number[];
    }


    export function StatCard({ title, value, change, trend, icon, chartData }:
    StatCardProps) {
      const chartRef = useRef<SVGSVGElement>(null);

      useLayoutEffect(() => {
        // Only run animation if chartData is present
        if (chartRef.current && chartData) {
          const line = chartRef.current.querySelector('.chart-line');
          const area = chartRef.current.querySelector('.chart-area');
          if (line instanceof SVGPathElement && area) {
            const length = line.getTotalLength();
            gsap.set(line, { strokeDasharray: length, strokeDashoffset: length });
            gsap.to(line, { strokeDashoffset: 0, duration: 1.5, ease: 'power2.inOut' });
            gsap.fromTo(area, { opacity: 0, y: 10 }, { opacity: 1, y: 0, duration: 1, ease: 'power2.out', delay: 0.5 });
          }
        }
      }, [chartData]);

      // --- Chart rendering logic (only if chartData is provided) ---
      const renderChart = () => {
        if (!chartData || chartData.length < 2) return null;

        // SVG dimensions
        const width = 150;
        const height = 60;

        // Normalize data
        const max = Math.max(...chartData);
        const min = Math.min(...chartData);
        const range = max - min === 0 ? 1 : max - min;

        const points = chartData
          .map((val, i) => {
            const x = (i / (chartData.length - 1)) * width;
            const y = height - ((val - min) / range) * (height - 10) + 5; // Add vertical padding
            return `${x},${y}`;
          });

        const linePath = "M" + points.join(" L");
        const areaPath = `${linePath} L${width},${height} L0,${height} Z`;

        return (
          <div className="mt-4 -mb-2 -mx-2">
            <svg ref={chartRef} viewBox={`0 0 ${width} ${height}`} className="w-full h-auto" preserveAspectRatio="none">
              <defs>
                <linearGradient id="chartGradient" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="0%" className="text-primary" stopColor="currentColor" stopOpacity={0.3} />
                  <stop offset="100%" className="text-primary" stopColor="currentColor" stopOpacity={0} />
                </linearGradient>
              </defs>
              <path
                className="chart-area"
                d={areaPath}
                fill="url(#chartGradient)"
              />
              <path
                className="chart-line"
                d={linePath}
                fill="none"
                stroke="hsl(var(--primary))"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
            </svg>
          </div>
        );
      };
      // --- End of chart rendering logic ---

      return (
        <Card className={cn(
            "p-6 border-border/50 hover:border-primary/30 transition-all duration-300 group cursor-pointer flex flex-col justify-between",
            !chartData && "h-full" // Ensure cards without charts have consistent height if needed
        )}>
          <div>
            <div className="flex items-center justify-between">
              <div className="p-3 bg-primary/10 rounded-full group-hover:bg-primary/20 transition-colors">
                {icon}
              </div>
              <div className={cn(
                "text-sm font-medium",
                trend === 'up' ? "text-green-600" : "text-red-600"
              )}>
                {change}
              </div>
            </div>
            <div className="mt-4">
              <h3 className="text-2xl font-bold">{value}</h3>
              <p className="text-sm text-muted-foreground mt-1">{title}</p>
            </div>
          </div>
          {renderChart()}
        </Card>
      );
    }
  src/pages/DataDemo/index.tsx: >
    import { useRef, useEffect, useCallback, useMemo } from 'react'

    import {
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      TrendingUp,
      Loader2,
      ChevronsUpDown
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { cn } from '@/lib/utils'

    import { Button } from '@/components/ui/button'

    import { 
      DropdownMenu, 
      DropdownMenuContent, 
      DropdownMenuRadioGroup, 
      DropdownMenuRadioItem, 
      DropdownMenuTrigger 
    } from '@/components/ui/dropdown-menu'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { useScrollToBottom } from '@/hooks/useScrollToBottom.hook';

    import { ScrollToBottomButton } from
    '@/components/shared/ScrollToBottomButton';

    import { DataListView } from './components/DataListView'

    import { DataCardView } from './components/DataCardView'

    import { DataTableView } from './components/DataTableView'

    import { DataKanbanView } from './components/DataKanbanView'

    import { DataCalendarView } from './components/DataCalendarView'

    import { DataViewModeSelector } from './components/DataViewModeSelector'

    import { AnimatedTabs } from '@/components/ui/animated-tabs'

    import { StatCard } from '@/components/shared/StatCard'

    import { AnimatedLoadingSkeleton } from
    './components/AnimatedLoadingSkeleton'

    import { DataToolbar } from './components/DataToolbar'

    import { mockDataItems } from './data/mockData'

    import type { GroupableField, DataItem } from './types'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { useAutoAnimateStats } from './hooks/useAutoAnimateStats.hook'

    import { 
      useDataDemoStore, 
      useGroupTabs
    } from './store/dataDemo.store'


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    function DataDemoContent() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
      } = useAppViewManager();

      const { hasMore, isLoading, isInitialLoading, totalItemCount, loadData } = useDataDemoStore(state => ({
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
      }));

      const groupTabs = useGroupTabs(groupBy, activeGroupTab);
      const allItems = useDataDemoStore(s => s.items);

      const groupedData = useMemo(() => {
        if (groupBy === 'none') {
            return null;
        }
        return allItems.reduce((acc, item) => {
            const groupKey = String(item[groupBy as GroupableField]);
            if (!acc[groupKey]) {
                acc[groupKey] = [];
            }
            acc[groupKey].push(item);
            return acc;
        }, {} as Record<string, DataItem[]>);
      }, [allItems, groupBy]);

      const dataToRender = useMemo(() => {
        if (groupBy === 'none' || activeGroupTab === 'all' || !groupedData) {
          return allItems;
        }
        return groupedData[activeGroupTab] || [];
      }, [groupBy, activeGroupTab, allItems, groupedData]);

      const groupOptions = useMemo(() => [
        { id: 'none' as const, label: 'None' }, { id: 'status' as const, label: 'Status' }, { id: 'priority' as const, label: 'Priority' }, { id: 'category' as const, label: 'Category' }
      ], []);

      const statsRef = useRef<HTMLDivElement>(null)
      const scrollRef = useRef<HTMLDivElement>(null);

      // Auto-hide stats container on scroll down
      useAutoAnimateStats(scrollRef, statsRef);

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const { showScrollToBottom, scrollToBottom, handleScroll } = useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78]
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.6,
              y: 0,
              opacity: 1,
              stagger: 0.1,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading]);

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === 'calendar',
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );
      
      // Auto-group by status when switching to kanban view for the first time
      useEffect(() => {
        if (viewMode === 'kanban' && groupBy === 'none') {
          setGroupBy('status');
          setSort(null); // Kanban is manually sorted, so disable programmatic sort
        }
        // For calendar view, we don't want grouping.
        if (viewMode === 'calendar') {
          if (groupBy !== 'none') setGroupBy('none');
        }
      }, [viewMode, groupBy, setGroupBy]);

      const renderViewForData = useCallback((data: DataItem[]) => {
        switch (viewMode) {
            case 'table': return <DataTableView data={data} />;
            case 'cards': return <DataCardView data={data} />;
            case 'calendar': return null; // Calendar has its own render path below
            case 'kanban': return null; // Kanban has its own render path below
            case 'grid': return <DataCardView data={data} isGrid />;
            case 'list':
            default:
                return <DataListView data={data} />;
        }
      }, [viewMode]);

      const GroupByDropdown = useCallback(() => (
        <div className="flex items-center gap-2 shrink-0">
          <span className="text-sm font-medium text-muted-foreground shrink-0">Group by:</span>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" className="w-[180px] justify-between">
                {groupOptions.find(o => o.id === groupBy)?.label}
                <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent className="w-[180px]">
              <DropdownMenuRadioGroup value={groupBy} onValueChange={setGroupBy}>
                {groupOptions.map(option => (
                  <DropdownMenuRadioItem key={option.id} value={option.id}>
                    {option.label}
                  </DropdownMenuRadioItem>
                ))}
              </DropdownMenuRadioGroup>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      ), [groupBy, setGroupBy, groupOptions]);

      const isGroupedView = useMemo(() => 
        groupBy !== 'none' && groupTabs.length > 1 && groupedData,
      [groupBy, groupTabs.length, groupedData]);


      return (
        <PageLayout
          scrollRef={scrollRef}
          onScroll={handleScroll}
          // Note: Search functionality is handled by a separate SearchBar in the TopBar
        >
          <div className="space-y-8">
            {/* Header */}
            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
              <div className="flex-1">
                <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                <p className="text-muted-foreground">
                  {isInitialLoading 
                    ? "Loading projects..." 
                    : `Showing ${dataToRender.length} of ${totalItemCount} item(s)`}
                </p>
              </div>
              <DataViewModeSelector />
            </div>

            {/* Stats Section */}
            {!isInitialLoading && (
              <div ref={statsRef} className="grid grid-cols-[repeat(auto-fit,minmax(250px,1fr))] gap-6">
                {stats.map((stat) => (
                  <StatCard
                    key={stat.title}
                    title={stat.title}
                    value={stat.value}
                    change={stat.change}
                    trend={stat.trend}
                    icon={stat.icon}
                    chartData={stat.type === 'chart' ? stat.chartData : undefined}
                  />
                ))}
              </div>
            )}

            {/* Controls Area */}
            <div className="space-y-6">
              <DataToolbar />
            </div>

            <div className="min-h-[500px]">
              {isInitialLoading 
                ? <AnimatedLoadingSkeleton viewMode={viewMode} /> 
                : viewMode === 'calendar' ? (
                  <DataCalendarView data={allItems} />
                )
                : viewMode === 'kanban' ? (
                  <>
                    <div className="flex items-center justify-end gap-4 h-[68px]">
                      <GroupByDropdown />
                    </div>
                    {isGroupedView ? (
                      <DataKanbanView data={groupedData} />
                    ) : (
                      <div className="flex items-center justify-center h-96 text-muted-foreground">
                        Group data by a metric to use the Kanban view.
                      </div>
                    )}
                  </>
                )
                : !isGroupedView ? (
                  // Not grouped view
                  <>
                    <div className="flex items-center justify-between gap-4 h-[68px]">
                      <div className="flex-grow border-b" /> {/* Mimic tab border */}
                      <GroupByDropdown />
                    </div>
                    {renderViewForData(allItems)}
                  </>
                ) : (
                  // Grouped view with AnimatedTabs
                  <div className="relative">
                    <AnimatedTabs
                      tabs={groupTabs}
                      activeTab={activeGroupTab}
                      onTabChange={setActiveGroupTab}
                      wrapperClassName="flex flex-col"
                      className="border-b"
                      contentClassName="pt-6 flex-grow"
                    >
                      {groupTabs.map(tab => (
                        <div key={tab.id} className="min-h-[440px]">
                          {renderViewForData(
                            tab.id === 'all' ? allItems : groupedData?.[tab.id] || []
                          )}
                        </div>
                      ))}
                    </AnimatedTabs>
                    <div className="absolute top-[14px] right-0">
                        <GroupByDropdown />
                    </div>
                  </div>
                )
              }
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && dataToRender.length > 0 && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>
          <ScrollToBottomButton isVisible={showScrollToBottom} onClick={scrollToBottom} />
        </PageLayout>
      )
    }


    export default function DataDemoPage() {
      return <DataDemoContent />;
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 466
