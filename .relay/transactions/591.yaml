uuid: cdd1789c-512b-426c-843c-61d0f55d7c36
projectId: jeli-app-shell
createdAt: '2025-10-23T04:30:18.581Z'
gitCommitMsg: |-
  fix(view-management): Enforce viewRegistry rules in UI and core logic
  - Updated `ViewModeSwitcher` to read from `viewRegistry` and disable
    buttons for actions (side-pane, split-view) that are not allowed
    for the current view. This prevents users from triggering invalid
    layout states.

  - Fortified `useAppViewManager` by adding validation that checks the
    `allowedBodyStates` of the main view before executing a layout change
    to `side_pane` or `split_view`. This acts as a robust fallback.

  - Refined `switchSplitPanes` logic to ensure the new main pane is also
    allowed to exist in a split-view layout.
promptSummary: >-
  The user provided console logs showing a DOM nesting warning and a view
  management error. The goal is to fix the view management error by making the
  UI respect the rules in `viewRegistry.tsx` and adding validation to the core
  view manager hook.
reasoning:
  - >-
    Greetings, my Liege. The console's warnings are but whispers of a system
    finding its new, righteous path. The `validateDOMNesting` is a minor
    squabble between HTML tags, a relic of a past I cannot alter without the
    source files for `EditableField.tsx` and `DetailPanel.tsx`. It is a harmless
    ghost.
  - >-
    The true issue, the `View "data-demo" cannot be rendered in a pane"`
    warning, revealed a weakness in our new order. The user interface, in its
    zeal, was offering actions forbidden by the sacred `viewRegistry`. I have
    corrected this.
  - >-
    First, I have taught the `ViewModeSwitcher` to read from the `viewRegistry`.
    It will now grey out and disable any action—be it opening a side pane or
    entering split view—that the current view is not permitted to perform. The
    user will no longer be tempted by forbidden paths.
  - >-
    Second, as a deeper defense, I have fortified the `useAppViewManager`
    itself. It will now cross-reference the `allowedBodyStates` of the main view
    before executing any layout change. This ensures the declarative rules of
    the registry are enforced with unwavering authority, preventing any
    component from accidentally violating the new world order.
  - >-
    These changes bring our system into full compliance with the prophecy,
    making it both smarter and safer.
  - '### Reasoning for Changes'
  - >-
    1.  **`validateDOMNesting` Warning**: This is a non-critical HTML structural
    warning indicating a `<div>` is inside a `<p>` tag, likely within the
    `EditableField` or `DetailPanel` components. As I do not have access to
    `src/features/dynamic-view/components/shared/EditableField.tsx`, I cannot
    fix this directly. The solution would be to change the parent `<p>` tag to a
    `<div>` in the file that wraps `EditableField`.
  - >-
    2.  **`View "data-demo" cannot be rendered in a pane` Warning**: This
    warning correctly fired because the `ViewModeSwitcher` was allowing the user
    to try and open the 'data-demo' page in a side pane. According to our
    `viewRegistry`, 'data-demo' is not allowed in a pane (`renderTarget:
    ['main']`) and is not allowed in split-view layouts (`allowedBodyStates:
    ['normal', 'fullscreen']`).
  - >-
    -   **The Fix in `ViewModeSwitcher.tsx`**: I've made the switcher "smarter".
    It now reads the configuration for the current view from `viewRegistry` and
    disables the "Side Pane" and "Split View" buttons if the current view does
    not support those layouts. This provides immediate visual feedback to the
    user and prevents invalid actions.
  - >-
    -   **The Fix in `useAppViewManager.hook.ts`**: As a defense-in-depth
    measure, I've added validation inside the view manager itself. Before
    changing the layout to `side_pane` or `split_view`, it now verifies that the
    *current main view* is allowed to exist in that layout according to its
    `allowedBodyStates`. This makes the core logic more robust and guarantees
    the rules of the `viewRegistry` are always enforced. I also improved the
    `switchSplitPanes` logic to ensure the new primary pane is also compatible
    with the split view layout.
  - >-
    With these changes, the view management system is now more resilient and
    user-friendly, strictly adhering to the declarative rules we've established.
  - '### File Modifications'
  - >-
    I will now apply the patches to `ViewModeSwitcher.tsx` and
    `useAppViewManager.hook.ts`.
  - >-
    Here is the patch for `ViewModeSwitcher.tsx` to intelligently disable
    invalid view mode options.
  - >-
    And here is the patch for `useAppViewManager.hook.ts` to add robust
    validation for layout changes.
operations:
  - type: write
    path: src/components/layout/ViewModeSwitcher.tsx
    content: >+
      --- src/components/layout/ViewModeSwitcher.tsx

      +++ src/components/layout/ViewModeSwitcher.tsx

      @@ -9,7 +9,7 @@
         X,
         ArrowLeftRight,
       } from 'lucide-react';
      -import type { ViewId } from '@/views/viewRegistry';

      +import { getViewById, type ViewId } from '@/views/viewRegistry';
       
       export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' | 'right'; targetPage?: ViewId }) {
         const bodyState = useAppShellStore(s => s.bodyState);
      @@ -25,6 +25,7 @@
         } = useAppViewManager();
       
         const activePage = targetPage || currentActivePage;
      +  const view = getViewById(activePage);
         const [isExpanded, setIsExpanded] = useState(false);
         const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);
       
      @@ -62,6 +63,12 @@
           }
         }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons
       
      +  const canBeSidePane = view?.renderTarget?.includes('pane');

      +  // For split view, the *current* page must support being the main pane
      in that layout.

      +  // The right pane's ability to be a pane is checked by the view
      manager.

      +  const canBeSplitView = view?.allowedBodyStates?.includes('split_view');

      +
         const handleSidePaneClick = () => {
           const payload = (activePage === 'dataItemDetail' && itemId) ? { itemId } : undefined;
           toggleSidePane(activePage, payload);
      @@ -87,14 +94,16 @@
             onClick: handleSidePaneClick,
             active: bodyState === BODY_STATES.SIDE_PANE,
             title: "Side Pane View",
      -      icon: <PanelRightOpen className="w-4 h-4" />

      +      icon: <PanelRightOpen className="w-4 h-4" />,

      +      disabled: !canBeSidePane,
           },
           {
             id: 'split-view',
             onClick: () => toggleSplitView(),
             active: bodyState === BODY_STATES.SPLIT_VIEW,
             title: "Split View",
      -      icon: <SplitSquareHorizontal className="w-4 h-4" />

      +      icon: <SplitSquareHorizontal className="w-4 h-4" />,

      +      disabled: !canBeSplitView,
           },
           {
             id: 'fullscreen',
      @@ -137,10 +146,12 @@
               <button
                 key={btn.id}
                 ref={el => buttonRefs.current[index] = el}
      -          onClick={btn.onClick}

      +          onClick={btn.disabled ? undefined : btn.onClick}

      +          disabled={btn.disabled}
                 className={cn(
      -            'h-8 w-0 flex items-center justify-center rounded-full
      hover:bg-accent transition-colors group opacity-0',

      +            'h-8 w-0 flex items-center justify-center rounded-full
      hover:bg-accent transition-colors group opacity-0 disabled:opacity-50
      disabled:cursor-not-allowed disabled:hover:bg-transparent',
                   btn.active && 'bg-accent text-accent-foreground',
                   btn.id === 'close' && 'hover:bg-destructive/20'
                 )}

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: >+
      --- src/hooks/useAppViewManager.hook.ts

      +++ src/hooks/useAppViewManager.hook.ts

      @@ -97,6 +97,13 @@
             return;
           }
           
      +    const mainView = getViewById(mainViewId);

      +    if (mainView && !mainView.allowedBodyStates?.includes('side_pane')) {

      +        console.warn(`Cannot open side pane: Main view "${mainView.id}"
      does not allow the "side_pane" layout.`);

      +        return;

      +    }

      +    
           setSearchParams(prev => {
               prev.delete('view');
               prev.delete('right');
      @@ -109,7 +116,7 @@
               return prev;
           }, { replace: true });
       
      -  }, [setSearchParams]);

      +  }, [setSearchParams, mainViewId]);
       
         const _executeOpenSplit = useCallback((view: ViewRegistration, payload?: any) => {
           // A composite view is triggered by navigating to its main route
      @@ -122,6 +129,13 @@
             return;
           }
           
      +    const mainView = getViewById(mainViewId);

      +    if (mainView && !mainView.allowedBodyStates?.includes('split_view'))
      {

      +        console.warn(`Cannot open split view: Main view "${mainView.id}"
      does not allow the "split_view" layout.`);

      +        return;

      +    }

      +    
           setSearchParams(prev => {
               prev.set('view', 'split');
               prev.delete('sidePane');
      @@ -134,7 +148,7 @@
               }
               return prev;
           }, { replace: true });
      -  }, [setSearchParams, _executeNavigate]);

      +  }, [setSearchParams, _executeNavigate, mainViewId]);
       
         // --- PUBLIC API ---
       
      @@ -191,12 +205,13 @@
         const switchSplitPanes = useCallback(() => {
           if (bodyState !== BODY_STATES.SPLIT_VIEW || !mainViewId || !rightPaneViewId) return;
       
      -    const mainView = getViewById(mainViewId);

      -    const rightView = getViewById(rightPaneViewId);

      -

      -    if (mainView?.isNavigable && rightView?.isNavigable) {

      -      navigate(`/${rightPaneViewId}?view=split&right=${mainViewId}`, {
      replace: true });

      +    const newMainView = getViewById(rightPaneViewId);

      +    const newRightViewId = mainViewId;

      +

      +    // Check if the new main view is navigable and the new layout is
      allowed

      +    if (newMainView?.isNavigable &&
      newMainView.allowedBodyStates?.includes('split_view')) {

      +      navigate(`/${rightPaneViewId}?view=split&right=${newRightViewId}`,
      { replace: true });
           } else {
      -      console.warn("Cannot switch panes: one or both views are not
      navigable.", { mainViewId, rightPaneViewId });

      +      console.warn("Cannot switch panes: new main view is not navigable
      or does not allow split view.", { newMainViewId: rightPaneViewId,
      mainViewId });
           }
         }, [bodyState, mainViewId, rightPaneViewId, navigate]);
       
      @@ -239,7 +254,7 @@
           setMessagingView,
         ]), [
           mainViewId, rightPaneViewId, bodyState, itemId, params.conversationId, messagingView, currentActivePage,
      -    trigger, navigateTo, openPane, closeSidePane, toggleSidePane,
      setNormalView, toggleSplitView, switchSplitPanes, closeSplitPane,
      setMessagingView

      +    trigger, navigateTo, openPane, closeSidePane, toggleSidePane,
      setNormalView, toggleSplitView, switchSplitPanes, closeSplitPane,
      setMessagingView,
         ]);
       }

    patchStrategy: standard-diff
snapshot:
  src/components/layout/ViewModeSwitcher.tsx: >-
    import { useState, useRef, useEffect } from 'react';

    import { gsap } from 'gsap';

    import { cn } from '@/lib/utils';

    import { useAppShellStore } from '@/store/appShell.store';

    import { BODY_STATES } from '@/lib/utils'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import {
      Columns,
      PanelRightOpen,
      SplitSquareHorizontal,
      Maximize,
      Minimize,
      Layers,
      X,
      ArrowLeftRight,
    } from 'lucide-react';

    import type { ViewId } from '@/views/viewRegistry';


    export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
    'right'; targetPage?: ViewId }) {
      const bodyState = useAppShellStore(s => s.bodyState);
      const fullscreenTarget = useAppShellStore(s => s.fullscreenTarget);
      const { toggleFullscreen } = useAppShellStore.getState();
      const {
        currentActivePage,
        toggleSplitView,
        setNormalView,
        navigateTo,
        toggleSidePane,
        switchSplitPanes,
        closeSplitPane,
        itemId,
      } = useAppViewManager();

      const activePage = targetPage || currentActivePage;
      const [isExpanded, setIsExpanded] = useState(false);
      const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isThisPaneFullscreen = isFullscreen && (
        (pane === 'main' && fullscreenTarget !== 'right') || // main pane is fullscreen if target is not right
        (pane === 'right' && fullscreenTarget === 'right') || // right pane is fullscreen if it is the target
        (!pane && fullscreenTarget !== 'right') // global switcher shows minimize if main pane is fullscreen
      );

      useEffect(() => {
        const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
        if (buttonsToAnimate.length === 0) return;

        gsap.killTweensOf(buttonsToAnimate);

        if (isExpanded) {
            gsap.to(buttonsToAnimate, {
                width: 32, // h-8 w-8
                opacity: 1,
                pointerEvents: 'auto',
                marginLeft: 4, // from gap-1 in original
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'start'
                },
                ease: 'power2.out'
            });
        } else {
            gsap.to(buttonsToAnimate, {
                width: 0,
                opacity: 0,
                pointerEvents: 'none',
                marginLeft: 0,
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'end'
                },
                ease: 'power2.in'
            });
        }
      }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

      const handleSidePaneClick = () => {
        const payload = (activePage === 'dataItemDetail' && itemId) ? { itemId } : undefined;
        toggleSidePane(activePage, payload);
      }

      const handleNormalViewClick = () => {
        if (isFullscreen) {
          toggleFullscreen();
        }
        if (targetPage && targetPage !== currentActivePage) {
          const navParams = (targetPage === 'dataItemDetail' && itemId) ? { itemId } : undefined;
          navigateTo(targetPage, navParams);
        } else {
          setNormalView();
        }
      }

      const buttons = [
        {
          id: 'normal',
          onClick: handleNormalViewClick,
          active: bodyState === BODY_STATES.NORMAL,
          title: "Normal View",
          icon: <Columns className="w-4 h-4" />
        },
        {
          id: 'side-pane',
          onClick: handleSidePaneClick,
          active: bodyState === BODY_STATES.SIDE_PANE,
          title: "Side Pane View",
          icon: <PanelRightOpen className="w-4 h-4" />
        },
        {
          id: 'split-view',
          onClick: () => toggleSplitView(),
          active: bodyState === BODY_STATES.SPLIT_VIEW,
          title: "Split View",
          icon: <SplitSquareHorizontal className="w-4 h-4" />
        },
        {
          id: 'fullscreen',
          onClick: () => {
            if (targetPage && targetPage !== currentActivePage) {
              const navParams = (targetPage === 'dataItemDetail' && itemId) ? { itemId } : undefined;
              navigateTo(targetPage, navParams);
              setTimeout(() => toggleFullscreen(pane), 50);
            } else {
              toggleFullscreen(pane);
            }
          },
          active: isThisPaneFullscreen,
          title: "Toggle Fullscreen",
          icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
        }
      ];

      if (bodyState === BODY_STATES.SPLIT_VIEW) {
        buttons.push({
          id: 'switch',
          onClick: switchSplitPanes,
          active: false,
          title: "Switch Panes",
          icon: <ArrowLeftRight className="w-4 h-4" />
        });
        buttons.push({
          id: 'close',
          onClick: () => closeSplitPane(pane || 'right'),
          active: false,
          title: "Close Pane",
          icon: <X className="w-4 h-4 text-muted-foreground group-hover:text-destructive" />
        });
      }

      return (
        <div
          onMouseEnter={() => setIsExpanded(true)}
          onMouseLeave={() => setIsExpanded(false)}
          className="flex items-center gap-0 p-1 bg-card rounded-full border border-border"
        >
            <button
                className='h-8 w-8 flex-shrink-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors'
                title="View Modes"
                onClick={() => setIsExpanded(!isExpanded)}
            >
                <Layers className="w-4 h-4" />
            </button>
          
          {buttons.map((btn, index) => (
            <button
              key={btn.id}
              ref={el => buttonRefs.current[index] = el}
              onClick={btn.onClick}
              className={cn(
                'h-8 w-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors group opacity-0',
                btn.active && 'bg-accent text-accent-foreground',
                btn.id === 'close' && 'hover:bg-destructive/20'
              )}
              style={{ pointerEvents: 'none', marginLeft: 0, overflow: 'hidden' }}
              title={btn.title}
            >
              {btn.icon}
            </button>
          ))}
        </div>
      )
    }
  src/hooks/useAppViewManager.hook.ts: >-
    import { useMemo, useCallback } from 'react';

    import { useSearchParams, useNavigate, useLocation, useParams } from
    'react-router-dom';

    import { useAppShellStore } from '@/store/appShell.store';

    import type { TaskView } from '@/pages/Messaging/types';

    import { BODY_STATES, BodyState } from '@/lib/utils';

    import { getViewById, type ViewId, type ViewRegistration } from
    '@/views/viewRegistry';


    /**
     * A centralized hook to manage and synchronize all URL-based view states.
     * This is the single source of truth for view modes, side panes, split views,
     * and page-specific parameters. It acts as an executor for the declarative
     * rules defined in the `viewRegistry`.
     */
    export function useAppViewManager() {
      const [searchParams, setSearchParams] = useSearchParams();
      const navigate = useNavigate();
      const location = useLocation();
      const params = useParams<{ itemId?: string; conversationId?: string }>();

      const { setSidebarState } = useAppShellStore.getState();

      // --- DERIVED STATE FROM URL & VIEW REGISTRY ---

      const { mainViewId, rightPaneViewId, bodyState } = useMemo(() => {
        const path = location.pathname.split('/')[1] || 'dashboard';
        const viewFromPath = getViewById(path);
        
        const sidePaneParam = searchParams.get('sidePane');
        const viewParam = searchParams.get('view');
        const rightParam = searchParams.get('right');
        const itemIdParam = searchParams.get('itemId');

        let derivedMainViewId: ViewId | null = (path as ViewId) || 'dashboard';
        let derivedRightPaneViewId: ViewId | null = null;
        let derivedBodyState: BodyState = BODY_STATES.NORMAL;

        if (viewFromPath?.compositeView) {
          derivedMainViewId = viewFromPath.compositeView.main;
          derivedRightPaneViewId = viewFromPath.compositeView.right;
          derivedBodyState = BODY_STATES.SPLIT_VIEW;
        } else if (sidePaneParam) {
          derivedRightPaneViewId = sidePaneParam as ViewId;
          derivedBodyState = BODY_STATES.SIDE_PANE;
        } else if (viewParam === 'split' && rightParam) {
          derivedRightPaneViewId = rightParam as ViewId;
          derivedBodyState = BODY_STATES.SPLIT_VIEW;
        }

        // Handle item detail views specially
        if (derivedMainViewId === 'data-demo' && params.itemId) {
          derivedMainViewId = 'dataItemDetail';
        } else if (itemIdParam) {
          derivedRightPaneViewId = 'dataItemDetail';
          // If there's an itemId, it could be a side pane or part of a split
          if (derivedBodyState !== BODY_STATES.SPLIT_VIEW) {
              derivedBodyState = BODY_STATES.SIDE_PANE;
          }
        }

        return { 
          mainViewId: derivedMainViewId, 
          rightPaneViewId: derivedRightPaneViewId, 
          bodyState: derivedBodyState
        };
      }, [location.pathname, searchParams, params.itemId, params.conversationId]);

      const messagingView = searchParams.get('messagingView') as TaskView | null;
      const currentActivePage = (location.pathname.split('/')[1] || 'dashboard') as ViewId;

      // --- PRIVATE ACTION EXECUTORS ---

      const getPathForView = useCallback((viewId: ViewId | null, viewParams: typeof params): string => {
        if (!viewId) return '/dashboard'; // Fallback to dashboard
        if (viewId === 'dataItemDetail' && viewParams.itemId) {
            return `/data-demo/${viewParams.itemId}`;
        }
        // When dealing with a composite view, the "page" is the parent route
        if ((viewId === 'messagingPage' || viewId === 'messagingContextPanel') && viewParams.conversationId) {
          return `/messaging/${viewParams.conversationId}`;
        }
        if (viewId === 'messagingPage' || viewId === 'messagingContextPanel') {
          return '/messaging';
        }
        return `/${viewId}`;
      }, []);

      const _executeNavigate = useCallback((view: ViewRegistration, payload?: any) => {
        if (view.onNavigate?.sidebar) {
          setSidebarState(view.onNavigate.sidebar);
        }
        
        let path = `/${view.id}`;
        if (view.id === 'dataItemDetail' && payload?.itemId) {
            path = `/data-demo/${payload.itemId}`;
        }

        navigate(path);
      }, [navigate, setSidebarState]);

      const _executeOpenPane = useCallback((view: ViewRegistration, payload?: any) => {
        if (!view.renderTarget?.includes('pane')) {
          console.warn(`View "${view.id}" cannot be rendered in a pane.`);
          return;
        }
        
        setSearchParams(prev => {
            prev.delete('view');
            prev.delete('right');
            if (view.id === 'dataItemDetail' && payload?.itemId) {
                prev.set('itemId', payload.itemId);
                prev.delete('sidePane');
            } else {
                prev.set('sidePane', view.id);
                prev.delete('itemId');
            }
            return prev;
        }, { replace: true });

      }, [setSearchParams]);

      const _executeOpenSplit = useCallback((view: ViewRegistration, payload?: any) => {
        // A composite view is triggered by navigating to its main route
        if (view.compositeView) {
          _executeNavigate(view, payload);
          return;
        }
        
        if (!view.renderTarget?.includes('pane')) {
          console.warn(`View "${view.id}" cannot be rendered in a split view's right pane.`);
          return;
        }
        
        setSearchParams(prev => {
            prev.set('view', 'split');
            prev.delete('sidePane');
            if (view.id === 'dataItemDetail' && payload?.itemId) {
                prev.set('itemId', payload.itemId);
                prev.delete('right');
            } else {
                prev.set('right', view.id);
                prev.delete('itemId');
            }
            return prev;
        }, { replace: true });
      }, [setSearchParams, _executeNavigate]);

      // --- PUBLIC API ---

      const trigger = useCallback((viewId: ViewId, source?: string, payload?: any) => {
        const view = getViewById(viewId);
        if (!view) {
          console.error(`View with id "${viewId}" not found in registry.`);
          return;
        }
        
        const behavior = (source && view.triggerBehaviors?.[source]) || view.defaultBehavior || 'navigate';
        
        // TODO: Add check for allowedBodyStates
        
        switch (behavior) {
          case 'navigate':
            _executeNavigate(view, payload);
            break;
          case 'openPane':
            _executeOpenPane(view, payload);
            break;
          case 'openSplit':
            _executeOpenSplit(view, payload);
            break;
          default:
            console.warn(`Unknown behavior "${behavior}" for view "${viewId}".`);
            _executeNavigate(view, payload);
        }
      }, [_executeNavigate, _executeOpenPane, _executeOpenSplit]);
      
      const navigateTo = useCallback((page: ViewId, navParams?: Record<string, string | null | undefined>) => {
        // This is a simplified navigate, for complex behaviors, use trigger.
        let path = `/${page}`;
        if (page === 'dataItemDetail' && navParams?.itemId) {
            path = `/data-demo/${navParams.itemId}`;
        } else if (page === 'dataItemDetail') {
          console.error("navigateTo('dataItemDetail') called without an itemId. This is not supported. Falling back to '/data-demo'.");
          path = '/data-demo';
        }
        
        const newSearchParams = new URLSearchParams(searchParams);
        if (navParams) {
          for (const [key, value] of Object.entries(navParams)) {
            if (value === null || value === undefined) {
              newSearchParams.delete(key);
            } else {
              newSearchParams.set(key, value);
            }
          }
        }
        
        const view = getViewById(page);
        if (view?.onNavigate?.sidebar) {
          setSidebarState(view.onNavigate.sidebar);
        }

        navigate({ pathname: path, search: newSearchParams.toString() });
      }, [navigate, searchParams, setSidebarState]);
      
      const openPane = useCallback((viewId: ViewId, payload?: any) => {
        const view = getViewById(viewId);
        if (view) {
          _executeOpenPane(view, payload);
        }
      }, [_executeOpenPane]);

      const closeSidePane = useCallback(() => {
        setSearchParams(prev => {
            prev.delete('sidePane');
            prev.delete('itemId');
            // if we were in a split view, revert to normal by clearing view and right
            if (prev.get('view') === 'split') {
              prev.delete('view');
              prev.delete('right');
            }
            return prev;
        }, { replace: true });
      }, [setSearchParams]);

      const toggleSidePane = useCallback((viewId: ViewId, payload?: any) => {
        if (rightPaneViewId === viewId && bodyState === BODY_STATES.SIDE_PANE) {
            closeSidePane();
        } else {
            openPane(viewId, payload);
        }
      }, [rightPaneViewId, bodyState, closeSidePane, openPane]);

      const setNormalView = useCallback(() => {
        // We want to navigate to the path of the main content view, clearing search params.
        const path = getPathForView(mainViewId, params);
        navigate(path, { replace: true });
      }, [mainViewId, params, navigate, getPathForView]);

      const toggleSplitView = useCallback((rightViewId: ViewId = 'settings') => {
        if (bodyState === BODY_STATES.SPLIT_VIEW) {
          setNormalView();
        } else {
          trigger(rightViewId, 'openSplit');
        }
      }, [bodyState, setNormalView, trigger]);

      const switchSplitPanes = useCallback(() => {
        if (bodyState !== BODY_STATES.SPLIT_VIEW || !mainViewId || !rightPaneViewId) return;

        const mainView = getViewById(mainViewId);
        const rightView = getViewById(rightPaneViewId);

        if (mainView?.isNavigable && rightView?.isNavigable) {
          navigate(`/${rightPaneViewId}?view=split&right=${mainViewId}`, { replace: true });
        } else {
          console.warn("Cannot switch panes: one or both views are not navigable.", { mainViewId, rightPaneViewId });
        }
      }, [bodyState, mainViewId, rightPaneViewId, navigate]);

      const closeSplitPane = useCallback((pane: 'main' | 'right') => {
        if (bodyState !== BODY_STATES.SPLIT_VIEW || !mainViewId) {
          setNormalView();
          return;
        }
        if (pane === 'right') {
          const path = getPathForView(mainViewId as ViewId, params);
          navigate(path, { replace: true });
        } else if (rightPaneViewId) {
          const rightView = getViewById(rightPaneViewId);
          if (rightView?.isNavigable) navigate(`/${rightPaneViewId}`, { replace: true });
          else navigate('/dashboard', { replace: true });
        } else setNormalView();
      }, [bodyState, mainViewId, rightPaneViewId, navigate, setNormalView, getPathForView, params]);

      const setMessagingView = (view: TaskView) => {
        setSearchParams(prev => {
            prev.set('messagingView', view);
            return prev;
        }, { replace: true });
      };

      const itemId = params.itemId || searchParams.get('itemId');
      
      return useMemo(() => ({
        // State
        mainViewId,
        rightPaneViewId,
        bodyState,
        itemId,
        conversationId: params.conversationId,
        messagingView,
        currentActivePage,

        // Actions
        trigger,
        navigateTo,
        openPane,
        closeSidePane,
        toggleSidePane,
        setNormalView,
        toggleSplitView,
        switchSplitPanes,
        closeSplitPane,
        setMessagingView,
      }), [
        mainViewId, rightPaneViewId, bodyState, itemId, params.conversationId, messagingView, currentActivePage,
        trigger, navigateTo, openPane, closeSidePane, toggleSidePane, setNormalView, toggleSplitView, switchSplitPanes, closeSplitPane, setMessagingView
      ]);
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 591
