uuid: 18d9f12d-1a84-4861-a0a4-37f2de13550e
projectId: jeli-app-shell
createdAt: '2025-10-13T16:11:00.598Z'
gitCommitMsg: >-
  fix(DataDemo): Create robust control bar to prevent view selector clipping

  The `DataViewModeSelector` inside `DataToolbar` was being hidden on certain
  screen sizes due to a rigid internal layout that did not respond well to being
  squeezed by other controls like the new "Group by" button.

  This commit refactors the control bar layout in `DataDemoPage` to be more
  resilient. By using `flex-wrap` and setting a `min-width` on the toolbar's
  container, we ensure that the toolbar has enough space to render all its
  internal components. On smaller viewports, the controls will now wrap
  gracefully instead of clipping content.
promptSummary: >-
  The user is still reporting that the DataViewModeSelector is missing after
  adding the grouping feature. The previous fix was insufficient. This patch
  implements a more robust flexbox layout to fix it.
reasoning:
  - >-
    I understand. My apologies, it seems my last fix didn't resolve the core
    layout issue. The problem is classic flexbox behavior: when a flex container
    runs out of space, and one of its children (the `DataToolbar`) has a rigid
    internal layout that doesn't shrink gracefully, items inside that child can
    be pushed out of view. The addition of the "Group by" button reduced the
    available space just enough to trigger this.
  - >-
    Since I cannot modify the internal structure of `DataToolbar`, I will make
    the container layout around it much more robust.
  - 'My solution is to:'
  - >-
    1.  Use `flex-wrap` on the main container. This is the most important
    change. It will allow the "Group by" button to wrap onto a new line on
    smaller screens, instead of squeezing the toolbar.
  - >-
    2.  Give the `DataToolbar`'s wrapper a `min-width`. This acts as a
    breakpoint, protecting the toolbar's internal layout from collapsing until
    the container itself has to wrap.
  - 3.  Ensure the "Group by" button does not shrink.
  - >-
    This approach creates a responsive control bar that respects the layout
    requirements of all its children.
  - 'Here is the patch for `src/pages/DataDemo/index.tsx`:'
  - >-
    This refined layout should now correctly display both the `DataToolbar`
    (with its `DataViewModeSelector`) and the new "Group by" control across all
    screen sizes.
  - '---'
operations:
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >+
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ -344,8 +344,8 @@
                 </div>
               )}
       
      -        <div className="flex flex-col gap-4 md:flex-row
      md:justify-between md:items-center">

      -          <div className="flex-1">

      +        <div className="flex flex-wrap items-center justify-between
      gap-x-2 gap-y-4">

      +          <div className="flex-1 min-w-[450px]">
                   <DataToolbar
                     filters={filters}
                     onFiltersChange={handleFilterChange}
      @@ -355,7 +355,7 @@
                     onViewModeChange={setViewMode}
                   />
                 </div>
      -          <div className="flex items-center gap-2">

      +          <div className="flex items-center gap-2 flex-shrink-0">
                   <DropdownMenu>
                     <DropdownMenuTrigger asChild>
                       <Button variant="outline" className="flex items-center gap-2">

    patchStrategy: standard-diff
snapshot:
  src/pages/DataDemo/index.tsx: >
    import { useState, useRef, useEffect, useCallback, useMemo, useLayoutEffect
    } from 'react'

    import { useParams, useNavigate } from 'react-router-dom'

    import {
      Layers,
      AlertTriangle,
      PlayCircle,
      TrendingUp,
      Loader2,
      ChevronDown,
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { capitalize } from '@/lib/utils'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { Button } from '@/components/ui/button'

    import {
      DropdownMenu,
      DropdownMenuContent,
      DropdownMenuRadioGroup,
      DropdownMenuRadioItem,
      DropdownMenuTrigger,
    } from '@/components/ui/dropdown-menu'

    import { DataListView } from './components/DataListView'

    import { DataCardView } from './components/DataCardView'

    import { DataTableView } from './components/DataTableView'

    import { AnimatedTabs } from '@/components/ui/animated-tabs'

    import { AnimatedLoadingSkeleton } from
    './components/AnimatedLoadingSkeleton'

    import { StatChartCard } from './components/StatChartCard'

    import { DataToolbar, FilterConfig } from './components/DataToolbar'

    import { mockDataItems } from './data/mockData'

    import type { DataItem, ViewMode, SortConfig, SortableField, GroupableField
    } from './types'


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    export default function DataDemoPage() {
      const [viewMode, setViewMode] = useState<ViewMode>('list')
      const [filters, setFilters] = useState<FilterConfig>({
        searchTerm: '',
        status: [],
        priority: [],
      })
      const [sortConfig, setSortConfig] = useState<SortConfig | null>({ key: 'updatedAt', direction: 'desc' })
      const [groupBy, setGroupBy] = useState<GroupableField | 'none'>('status')
      const [activeGroupTab, setActiveGroupTab] = useState<string>('all')

      const groupOptions: { id: GroupableField | 'none'; label: string }[] = [
        { id: 'none', label: 'None' }, { id: 'status', label: 'Status' }, { id: 'priority', label: 'Priority' }, { id: 'category', label: 'Category' },
      ]
      const [items, setItems] = useState<DataItem[]>([])
      const [page, setPage] = useState(0) // Start at 0 to trigger initial load effect
      const [hasMore, setHasMore] = useState(true)
      const [isLoading, setIsLoading] = useState(true)
      const contentRef = useRef<HTMLDivElement>(null)
      const statsRef = useRef<HTMLDivElement>(null)
      const observer = useRef<IntersectionObserver>()
      const navigate = useNavigate()
      const { itemId } = useParams<{ itemId: string }>()

      const selectedItem = useMemo(() => {
        if (!itemId) return null
        return mockDataItems.find(item => item.id === itemId) ?? null
      }, [itemId])

      const isInitialLoading = isLoading && items.length === 0

      // Step 1: Centralized data filtering and sorting from the master list
      const filteredAndSortedData = useMemo(() => {
        let filteredItems = mockDataItems.filter(item => {
          const searchTermMatch =
            item.title.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
            item.description.toLowerCase().includes(filters.searchTerm.toLowerCase())

          const statusMatch = filters.status.length === 0 || filters.status.includes(item.status)
          const priorityMatch = filters.priority.length === 0 || filters.priority.includes(item.priority)

          return searchTermMatch && statusMatch && priorityMatch
        })

        if (sortConfig) {
          filteredItems.sort((a, b) => {
            let aValue: any
            let bValue: any

            const getNestedValue = (obj: any, path: string) => path.split('.').reduce((o, k) => (o || {})[k], obj)

            aValue = getNestedValue(a, sortConfig.key)
            bValue = getNestedValue(b, sortConfig.key)

            if (aValue === undefined || bValue === undefined) return 0;

            if (typeof aValue === 'string' && typeof bValue === 'string') {
              return sortConfig.direction === 'asc'
                ? aValue.localeCompare(bValue)
                : bValue.localeCompare(aValue)
            }
            if (typeof aValue === 'number' && typeof bValue === 'number') {
              return sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue
            }
            // Date sorting (assuming ISO strings)
            if (sortConfig.key === 'updatedAt' || sortConfig.key === 'createdAt') {
                return sortConfig.direction === 'asc'
                    ? new Date(aValue).getTime() - new Date(aValue).getTime()
                    : new Date(bValue).getTime() - new Date(bValue).getTime()
            }
            return 0
          })
        }

        return filteredItems
      }, [filters, sortConfig, groupBy])

      // When grouping changes, reset the selected tab to "All"
      useEffect(() => {
        setActiveGroupTab('all');
      }, [groupBy]);

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      // Reset pagination when filters or sort change
      useEffect(() => {
        setItems([])
        setPage(0) // This will be incremented to 1 in the loader `useEffect`, triggering a fresh load
        setHasMore(true)
        setIsLoading(true)
        // Timeout prevents flicker and ensures loading state is visible for new filter/sort/group
        setTimeout(() => {
          if (groupBy !== 'none') {
            setItems(filteredAndSortedData);
            setHasMore(false);
            setIsLoading(false);
          } else {
            setPage(1)
          }
        }, 100);
      }, [filteredAndSortedData, groupBy])

      // Infinite scroll logic
      useEffect(() => {
        if (page === 0) return;
        if (groupBy !== 'none') return; // Pagination is disabled when grouping

        const fetchItems = () => {
          setIsLoading(true);
          const isFirstPage = page === 1

          const pageSize = 12;
          const newItems = filteredAndSortedData.slice((page - 1) * pageSize, page * pageSize);

          // Simulate network delay, longer for initial load to showcase skeleton
          setTimeout(() => {
            // Double-check in case groupBy changed during timeout
            if (groupBy === 'none') {
              setItems(prev => (isFirstPage ? newItems : [...prev, ...newItems]))
              setHasMore(filteredAndSortedData.length > page * pageSize)
              setIsLoading(false)
            }
          }, isFirstPage && items.length === 0 ? 1500 : 500)
        };

        if (hasMore) fetchItems();
      }, [page, groupBy, filteredAndSortedData, hasMore]);

      const loaderRef = useCallback(node => {
        if (isLoading) return;
        if (observer.current) observer.current.disconnect();

        observer.current = new IntersectionObserver(entries => {
          if (entries[0].isIntersecting && hasMore) {
            setPage(prevPage => prevPage + 1);
          }
        });
        if (node) observer.current.observe(node);
      }, [isLoading, hasMore]);

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week",
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78]
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.6,
              y: 0,
              opacity: 1,
              stagger: 0.1,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading])

      const handleSortChange = (config: SortConfig | null) => {
        setSortConfig(config)
      }

      // For table view header clicks
      const handleTableSort = (field: SortableField) => {
        if (sortConfig?.key === field) {
          if (sortConfig.direction === 'desc') {
            // Cycle: desc -> asc
            setSortConfig({ key: field, direction: 'asc' })
          } else {
            // Cycle: asc -> default
            setSortConfig(null)
          }
        } else {
          // New field, default to desc
          setSortConfig({ key: field, direction: 'desc' })
        }
      }

      const handleFilterChange = (newFilters: FilterConfig) => {
        setFilters(newFilters)
      }

      // Handle item selection and open side panel
      const handleItemSelect = (item: DataItem) => {
        navigate(`/data-demo/${item.id}`)
      }

      const groupedData = useMemo(() => {
        if (groupBy === 'none') {
          return null
        }
        return filteredAndSortedData.reduce((acc, item) => {
          const key = item[groupBy as GroupableField] as string
          if (!acc[key]) {
            acc[key] = []
          }
          acc[key].push(item)
          return acc
        }, {} as Record<string, DataItem[]>)
      }, [filteredAndSortedData, groupBy]);

      const groupTabs = useMemo(() => {
        if (!groupedData) return []
        const keys = Object.keys(groupedData).sort()
        return [{ id: 'all', label: 'All' }, ...keys.map(key => ({ id: key, label: capitalize(key) }))]
      }, [groupedData]);

      const dataForView = useMemo(() => {
        if (groupBy === 'none') {
          return items
        }
        if (activeGroupTab === 'all') {
          // For table view, it needs the grouped object to render headers.
          // For other views, we will iterate over this object in the render logic.
          return groupedData
        }
        return groupedData?.[activeGroupTab] || []
      }, [groupBy, activeGroupTab, items, groupedData]);

      const commonViewProps = {
        onItemSelect: handleItemSelect,
        selectedItem,
      };


      const totalItemCount = filteredAndSortedData.length;

      return (
        <PageLayout
          // Note: Search functionality is handled by a separate SearchBar in the TopBar
        >
          <div className="space-y-8">
            {/* Header */}
            <div>
              <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
              <p className="text-muted-foreground">
                {isInitialLoading
                  ? "Loading projects..."
                  : `Showing ${totalItemCount} item(s)`}
              </p>
            </div>

            {/* Stats Section */}
            {!isInitialLoading && (
              <div ref={statsRef} className="grid grid-cols-[repeat(auto-fit,minmax(250px,1fr))] gap-6">
                {stats.map((stat) =>
                  stat.type === 'chart' ? (
                    <StatChartCard
                      key={stat.title}
                      title={stat.title}
                      value={stat.value}
                      change={stat.change}
                      trend={stat.trend}
                      icon={stat.icon}
                      chartData={stat.chartData}
                    />
                  ) : null
                )}
              </div>
            )}

            <div className="flex flex-col gap-4 md:flex-row md:justify-between md:items-center">
              <div className="flex-1">
                <DataToolbar
                  filters={filters}
                  onFiltersChange={handleFilterChange}
                  sortConfig={sortConfig}
                  onSortChange={handleSortChange}
                  viewMode={viewMode}
                  onViewModeChange={setViewMode}
                />
              </div>
              <div className="flex items-center gap-2">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="outline" className="flex items-center gap-2">
                      <span>Group by: {capitalize(groupBy)}</span>
                      <ChevronDown className="w-4 h-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent>
                    <DropdownMenuRadioGroup value={groupBy} onValueChange={(val) => setGroupBy(val as GroupableField | 'none')}>
                      {groupOptions.map(opt => <DropdownMenuRadioItem key={opt.id} value={opt.id}>{opt.label}</DropdownMenuRadioItem>)}
                    </DropdownMenuRadioGroup>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>

            {groupBy !== 'none' && groupTabs.length > 1 && (
               <AnimatedTabs
                tabs={groupTabs}
                activeTab={activeGroupTab}
                onTabChange={(id) => setActiveGroupTab(id)}
                className="mb-4"
              />
            )}

            <div ref={contentRef} className="min-h-[500px]">
              {isInitialLoading ? <AnimatedLoadingSkeleton viewMode={viewMode} /> : (
                <div className="space-y-8">
                  {viewMode === 'table' ? (
                    <DataTableView
                        data={Array.isArray(dataForView) ? dataForView : (dataForView || {})}
                        {...commonViewProps}
                        sortConfig={sortConfig}
                        onSort={handleTableSort}
                      />
                  ) : (dataForView && !Array.isArray(dataForView)) ? ( // Grouped and 'All' tab is selected
                    Object.entries(dataForView).map(([groupName, groupItems]) => (
                      <GroupWrapper key={groupName} title={groupName} count={groupItems.length}>
                        {viewMode === 'list' && <DataListView data={groupItems} {...commonViewProps} />}
                        {viewMode === 'cards' && <DataCardView data={groupItems} {...commonViewProps} />}
                        {viewMode === 'grid' && <DataCardView data={groupItems} {...commonViewProps} isGrid />}
                      </GroupWrapper>
                    ))
                  ) : (
                    // Not grouped, or a specific group tab is selected
                    <>
                      {viewMode === 'list' && <DataListView data={dataForView as DataItem[]} {...commonViewProps} />}
                      {viewMode === 'cards' && <DataCardView data={dataForView as DataItem[]} {...commonViewProps} />}
                      {viewMode === 'grid' && <DataCardView data={dataForView as DataItem[]} {...commonViewProps} isGrid />}
                    </>
                  )}
                </div>
              )}
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && groupBy === 'none' && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && totalItemCount > 0 && !isInitialLoading && groupBy === 'none' && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>
        </PageLayout>
      )
    }


    function GroupWrapper({ title, count, children }: { title: string, count:
    number, children: React.ReactNode }) {
      const groupRef = useRef<HTMLDivElement>(null);

      useLayoutEffect(() => {
        if (groupRef.current) {
          gsap.fromTo(groupRef.current,
            { opacity: 0, y: 30 },
            { opacity: 1, y: 0, duration: 0.6, ease: 'power2.out' }
          );
        }
      }, []);

      return (
        <div ref={groupRef} className="space-y-4">
          <div className="flex items-center gap-3 px-2">
            <h2 className="text-lg font-semibold tracking-tight">{capitalize(title)}</h2>
            <span className="text-sm font-medium px-2.5 py-1 bg-muted rounded-full">{count}</span>
          </div>
          {children}
        </div>
      );
    }
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 240
