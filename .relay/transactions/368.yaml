uuid: 4d284f67-a2f0-459f-933e-b452e89698c1
projectId: jeli-app-shell
createdAt: '2025-10-16T22:08:25.731Z'
gitCommitMsg: >-
  fix(AppShell): use requestAnimationFrame to prevent resize animation flicker

  Replaced `setTimeout(0)` with `requestAnimationFrame` in the
  `useResizableRightPane` hook to synchronize the re-enabling of animations with
  the browser's paint cycle.

  This change provides a more reliable mechanism to ensure that the pane is
  rendered at its final, resized width *before* animations are turned back on.
  This resolves the race condition that was causing the pane's "enter" animation
  to incorrectly trigger upon releasing the mouse after a resize.
promptSummary: >-
  The user is still experiencing an unwanted "reveal" animation on the side pane
  when they finish resizing it, despite previous fixes.
reasoning:
  - >-
    I understand the problem. My previous fix correctly smoothed out the
    resizing action itself, but the "reveal" animation is still incorrectly
    re-triggering upon releasing the mouse. This indicates a tricky timing issue
    where the application's animation state is being reset just before React has
    a chance to render the component with its new, final width.
  - >-
    The use of `setTimeout(..., 0)` in my last attempt was intended to solve
    this by pushing the "re-enable animations" step to a later task in the
    browser's event loop. However, this is not always reliable enough to
    guarantee that it executes *after* React's render and the browser's
    subsequent paint cycle.
  - >-
    To create a more robust solution, I will replace `setTimeout` with
    `requestAnimationFrame`. This browser API is specifically designed to
    schedule a callback to run just before the next repaint. This guarantees
    that our logic to re-enable animations will only execute after the browser
    has fully rendered the resized pane in its final, non-animated state. This
    should definitively resolve the race condition and prevent the unwanted
    "reveal" animation.
  - 'Here is the change to `src/hooks/useResizablePanes.hook.ts`:'
  - >-
    This single change replaces the less reliable `setTimeout` with the correct
    tool for synchronizing with the browser's render pipeline, ensuring the
    animation state is restored at the precise moment needed to prevent the
    flicker.
operations:
  - type: write
    path: src/hooks/useResizablePanes.hook.ts
    content: >+
      --- src/hooks/useResizablePanes.hook.ts

      +++ src/hooks/useResizablePanes.hook.ts

      @@ -62,10 +62,12 @@
             // When resizing ends, restore the original setting after a brief delay.
             // This ensures the final width is rendered before animations are re-enabled.
             if (originalReducedMotionRef.current !== null) {
      -        setTimeout(() => {

      +        // Use requestAnimationFrame to ensure we re-enable animations
      *after* the browser

      +        // has painted the new, non-animated pane width. This is more
      reliable than setTimeout(0).

      +        requestAnimationFrame(() => {
                 setReducedMotion(originalReducedMotionRef.current!);
                 originalReducedMotionRef.current = null;
      -        }, 0);

      +        });
             }
           }
         }, [isResizingRightPane, setReducedMotion]);

    patchStrategy: standard-diff
snapshot:
  src/hooks/useResizablePanes.hook.ts: |-
    import { useEffect, useRef } from 'react';
    import { gsap } from 'gsap';
    import { useAppShellStore } from '@/store/appShell.store';
    import { BODY_STATES } from '@/lib/utils';

    export function useResizableSidebar(
      sidebarRef: React.RefObject<HTMLDivElement>,
      resizeHandleRef: React.RefObject<HTMLDivElement>
    ) {
      const isResizing = useAppShellStore(s => s.isResizing);
      const { setSidebarWidth, setIsResizing } = useAppShellStore.getState();

      useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
          if (!isResizing) return;

          const newWidth = Math.max(200, Math.min(500, e.clientX));
          setSidebarWidth(newWidth);

          if (sidebarRef.current) {
            gsap.set(sidebarRef.current, { width: newWidth });
          }
          if (resizeHandleRef.current) {
            gsap.set(resizeHandleRef.current, { left: newWidth });
          }
        };

        const handleMouseUp = () => {
          setIsResizing(false);
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        };

        if (isResizing) {
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };
      }, [isResizing, setSidebarWidth, setIsResizing, sidebarRef, resizeHandleRef]);
    }

    export function useResizableRightPane(
      rightPaneRef: React.RefObject<HTMLDivElement>
    ) {
      const isResizingRightPane = useAppShellStore(s => s.isResizingRightPane);
      const bodyState = useAppShellStore(s => s.bodyState);
      const { setSplitPaneWidth, setSidePaneWidth, setIsResizingRightPane, setReducedMotion } = useAppShellStore.getState();
      const finalWidthRef = useRef<number | null>(null);
      const originalReducedMotionRef = useRef<boolean | null>(null);

      // This effect temporarily disables animations during resizing to prevent the
      // pane's enter/exit animation from firing incorrectly.
      useEffect(() => {
        if (isResizingRightPane) {
          // When resizing starts, store the original setting and disable animations.
          if (originalReducedMotionRef.current === null) {
            originalReducedMotionRef.current = useAppShellStore.getState().reducedMotion;
            setReducedMotion(true);
          }
        } else {
          // When resizing ends, restore the original setting after a brief delay.
          // This ensures the final width is rendered before animations are re-enabled.
          if (originalReducedMotionRef.current !== null) {
            setTimeout(() => {
              setReducedMotion(originalReducedMotionRef.current!);
              originalReducedMotionRef.current = null;
            }, 0);
          }
        }
      }, [isResizingRightPane, setReducedMotion]);

      useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
          if (!isResizingRightPane) return;

          const newWidth = window.innerWidth - e.clientX;
          finalWidthRef.current = newWidth;
          if (rightPaneRef.current) {
            gsap.set(rightPaneRef.current, { width: newWidth });
          }
        };

        const handleMouseUp = () => {
          if (finalWidthRef.current !== null) {
            if (bodyState === BODY_STATES.SPLIT_VIEW) {
              setSplitPaneWidth(finalWidthRef.current);
            } else {
              setSidePaneWidth(finalWidthRef.current);
            }
            finalWidthRef.current = null;
          }
          setIsResizingRightPane(false);
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        };

        if (isResizingRightPane) {
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          document.body.style.cursor = '';
        };
      }, [isResizingRightPane, setSplitPaneWidth, setSidePaneWidth, setIsResizingRightPane, bodyState, rightPaneRef]);
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 368
