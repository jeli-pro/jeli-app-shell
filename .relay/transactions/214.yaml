uuid: 440263f1-705a-4b95-a477-96a2f4c39e23
projectId: jeli-app-shell
createdAt: '2025-10-13T07:33:01.499Z'
gitCommitMsg: >-
  feat(routing): make side pane and split view URL-driven

  Refactored the App Shell to control the visibility and content of the side
  pane and split view via URL search parameters (e.g., `?sidePane=...`,
  `?view=split&right=...`).

  - Implemented a `useEffect` in `App.tsx` to synchronize the URL search
  parameters with the AppShell's context state, making the URL the single source
  of truth. - Updated `ViewModeSwitcher`, `EnhancedSidebar`, and other
  navigation controls to manipulate URL search parameters instead of dispatching
  state actions directly. - Reworked the drag-and-drop docking functionality in
  `AppShell.tsx` to construct and navigate to the appropriate URL, preserving
  the view state across reloads. - Removed dependencies on the now-defunct
  `activePage` state from `useAppStore` in favor of deriving the current page
  from `react-router-dom`'s `useLocation` hook.
promptSummary: >-
  The user asked me to execute Part 4 of a multi-part refactoring plan. The goal
  of Part 4 is to make the application's side pane and split view features
  driven by URL search parameters instead of internal state. This involved
  modifying several components to read from and write to the URL using React
  Router hooks (`useSearchParams`, `useNavigate`, `useLocation`), ensuring that
  complex UI layouts are shareable and persistent.
reasoning:
  - >-
    Executing Part 4 of the plan to make the side pane and split view
    URL-driven.
  - '### Step 1 & 2: Sync URL Params and Update Navigation Actions'
  - >-
    I'll begin by updating `src/App.tsx` to read search parameters from the URL
    and synchronize the `AppShell`'s state accordingly. This makes the URL the
    source of truth. At the same time, I will modify the UI components
    (`EnhancedSidebar`, `ViewModeSwitcher`, and the `ComposedApp` itself) to
    manipulate the URL's search parameters instead of dispatching state changes
    directly, ensuring a unidirectional data flow from URL to state.
  - >-
    Next, I'll update the `AppMenuItem` in the sidebar. When an item that opens
    in a side pane is clicked, it will now toggle a `sidePane` search parameter
    in the URL.
  - >-
    The `ViewModeSwitcher` component requires a significant refactor. It will
    now derive the active page from the URL and use `useNavigate` and
    `useSearchParams` to manage view states, removing its dependency on the
    `useAppStore` for navigation.
  - '### Step 3: Update Drag-and-Drop for URL State'
  - >-
    Finally, I'll update the drag-and-drop logic in `AppShell.tsx`. Instead of
    dispatching actions to change the layout state, the drop handlers will now
    construct the target URL (with appropriate search parameters for split view)
    and use `navigate` to apply the new state. This ensures that even complex
    drag-and-drop actions result in a shareable, persistent URL.
  - '---'
  - '**Final Step**'
operations:
  - type: write
    path: src/App.tsx
    content: >+
      --- src/App.tsx

      +++ src/App.tsx

      @@ -4,8 +4,9 @@
         RouterProvider,
         Outlet,
         Navigate,
      -  useLocation,
         useNavigate,
      +  useLocation,

      +  useSearchParams,
       } from "react-router-dom";
       
       import { AppShell } from "./components/layout/AppShell";
      @@ -213,10 +214,35 @@
       
       // The main App component that composes the shell
       function ComposedApp() {
      -  const { sidePaneContent, closeSidePane, bodyState, toggleSplitView } =

      -    useAppShell();

      +  const {

      +    sidePaneContent,

      +    closeSidePane,

      +    bodyState,

      +    openSidePane,

      +    dispatch,

      +  } = useAppShell();
         const navigate = useNavigate();
      +  const location = useLocation();

      +  const [searchParams, setSearchParams] = useSearchParams();
       
      +  useEffect(() => {

      +    const pane = searchParams.get('sidePane') as 'settings' |
      'notifications' | null;

      +    const view = searchParams.get('view');

      +    const right = searchParams.get('right');

      +

      +    if (pane) {

      +      if (bodyState !== BODY_STATES.SIDE_PANE || sidePaneContent !==
      pane) {

      +        openSidePane(pane);

      +      }

      +    } else if (view === 'split' && right) {

      +      if (bodyState !== BODY_STATES.SPLIT_VIEW || sidePaneContent !==
      right) {

      +        dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: right as any
      });

      +        dispatch({ type: 'SET_BODY_STATE', payload:
      BODY_STATES.SPLIT_VIEW });

      +      }

      +    } else if (bodyState !== BODY_STATES.NORMAL) {

      +      closeSidePane();

      +    }

      +  }, [searchParams, bodyState, sidePaneContent, openSidePane,
      closeSidePane, dispatch]);

      +  
         const isOverlaySidePane = bodyState === BODY_STATES.SIDE_PANE;
       
         const contentMap = {
      @@ -282,11 +308,24 @@
       
         const handleMaximize = () => {
           if ("page" in currentContent && currentContent.page) {
      -      navigate(`/${currentContent.page}`);

      -    }

      -    closeSidePane();

      +      navigate(`/${currentContent.page}`, { replace: true });

      +    } else {

      +      setSearchParams({}, { replace: true });

      +    }
         };
       
      +  const handleToggleSplitView = () => {

      +    if (bodyState === BODY_STATES.SIDE_PANE) {

      +      const newParams = new URLSearchParams(location.search);

      +      newParams.set('view', 'split');

      +      newParams.set('right', sidePaneContent);

      +      newParams.delete('sidePane');

      +      setSearchParams(newParams, { replace: true });

      +    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {

      +      setSearchParams({ sidePane: sidePaneContent }, { replace: true });

      +    }

      +  };

      +
         const rightPaneHeader =
           bodyState !== BODY_STATES.SPLIT_VIEW ? (
             <>
      @@ -299,7 +338,7 @@
                 {(bodyState === BODY_STATES.SIDE_PANE ||
                   bodyState === BODY_STATES.SPLIT_VIEW) && (
                   <button
      -              onClick={toggleSplitView}

      +              onClick={handleToggleSplitView}
                     className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors"
                     title={
                       bodyState === BODY_STATES.SIDE_PANE

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/EnhancedSidebar.tsx
    content: |+
      --- src/components/layout/EnhancedSidebar.tsx
      +++ src/components/layout/EnhancedSidebar.tsx
      @@ -190,12 +190,11 @@
           if (page) {
             if (opensInSidePane) {
               if (paneContentForPage) {
      +          const newParams = new URLSearchParams(searchParams);
                 if (searchParams.get('sidePane') === paneContentForPage) {
      -            searchParams.delete('sidePane');
      +            newParams.delete('sidePane');
                 } else {
      -            searchParams.set('sidePane', paneContentForPage);
      +            newParams.set('sidePane', paneContentForPage);
                 }
      -          setSearchParams(searchParams, { replace: true });
      +          setSearchParams(newParams, { replace: true });
               }
             } else {
               navigate(`/${page}`);

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/ViewModeSwitcher.tsx
    content: >+
      --- src/components/layout/ViewModeSwitcher.tsx

      +++ src/components/layout/ViewModeSwitcher.tsx

      @@ -1,7 +1,7 @@
       import { useState, useRef, useEffect } from 'react';
       import { gsap } from 'gsap';
      +import { useLocation, useNavigate, useSearchParams } from
      'react-router-dom';
       import { cn } from '@/lib/utils'
       import { useAppShell } from '@/context/AppShellContext'
      -import { useAppStore, type ActivePage } from '@/store/appStore'

      +import { type ActivePage } from '@/store/appStore'
       import { BODY_STATES } from '@/lib/utils'
       import { type AppShellState } from '@/context/AppShellContext'
       import {
      @@ -28,14 +28,15 @@
           sidePaneContent,
           openSidePane,
           closeSidePane,
           toggleFullscreen,
      -    toggleSplitView,
           fullscreenTarget,
           dispatch,
         } = useAppShell()
      -  const { activePage: currentActivePage, setActivePage } = useAppStore()

      +  const location = useLocation();

      +  const navigate = useNavigate();

      +  const [, setSearchParams] = useSearchParams();

      +  const currentActivePage = (location.pathname.split('/')[1] ||
      'dashboard') as ActivePage;
       
         const activePage = targetPage || currentActivePage;
         const [isExpanded, setIsExpanded] = useState(false);
      @@ -93,49 +94,62 @@
       
         const handleSidePaneClick = () => {
           const paneContent = pageToPaneMap[activePage] || 'details';
           if (pane === 'right') return;
      -    if (bodyState === BODY_STATES.SIDE_PANE && sidePaneContent ===
      paneContent) {

      -      closeSidePane();

      -    } else {

      -      openSidePane(paneContent);

      -    }

      +

      +    const newSearchParams = new URLSearchParams(location.search);

      +    if (bodyState === BODY_STATES.SIDE_PANE && sidePaneContent ===
      paneContent) {

      +      newSearchParams.delete('sidePane');

      +      newSearchParams.delete('view');

      +      newSearchParams.delete('right');

      +    } else {

      +      newSearchParams.set('sidePane', paneContent);

      +      newSearchParams.delete('view');

      +      newSearchParams.delete('right');

      +    }

      +    setSearchParams(newSearchParams, { replace: true });
         };
         
         const handleSplitViewClick = () => {
      -      const paneContent = pageToPaneMap[activePage] || 'details';

      -      if (pane === 'right') return;

      -      toggleSplitView(paneContent);

      +    const paneContent = pageToPaneMap[activePage] || 'details';

      +    if (pane === 'right') return;

      +

      +    const newSearchParams = new URLSearchParams(location.search);

      +    if (bodyState === BODY_STATES.SPLIT_VIEW) {

      +        // from split to overlay

      +        newSearchParams.set('sidePane', sidePaneContent);

      +        newSearchParams.delete('view');

      +        newSearchParams.delete('right');

      +    } else {

      +        // from normal/overlay to split

      +        newSearchParams.set('view', 'split');

      +        newSearchParams.set('right', bodyState === BODY_STATES.SIDE_PANE
      ? sidePaneContent : paneContent);

      +        newSearchParams.delete('sidePane');

      +    }

      +    setSearchParams(newSearchParams, { replace: true });
         }
       
         const handleSwitchPanes = () => {
           if (bodyState !== BODY_STATES.SPLIT_VIEW) return;
      -    const newSidePaneContent = pageToPaneMap[activePage];

      +    const newSidePaneContent = pageToPaneMap[currentActivePage];
           const newActivePage = Object.entries(pageToPaneMap).find(
             ([, value]) => value === sidePaneContent
           )?.[0] as ActivePage | undefined;
       
           if (newActivePage && newSidePaneContent) {
      -      setActivePage(newActivePage);

      -      dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload:
      newSidePaneContent });

      +     
      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, {
      replace: true });
           }
         };
       
         const handleClosePane = () => {
           if (bodyState !== BODY_STATES.SPLIT_VIEW) return;
           if (pane === 'right') {
      -      closeSidePane();

      +      setSearchParams({}, { replace: true });
           } else if (pane === 'main') {
             const pageToBecomeActive = Object.entries(pageToPaneMap).find(
               ([, value]) => value === sidePaneContent
             )?.[0] as ActivePage | undefined;
             
             if (pageToBecomeActive) {
      -        setActivePage(pageToBecomeActive);

      +        navigate(`/${pageToBecomeActive}`, { replace: true });

      +      } else {

      +        setSearchParams({}, { replace: true });
             }
      -      closeSidePane();
           }
         }
       
         const handleNormalViewClick = () => {
      -    if (bodyState === BODY_STATES.SIDE_PANE || bodyState ===
      BODY_STATES.SPLIT_VIEW) {

      -      closeSidePane();

      -    }
           if (isFullscreen) {
             toggleFullscreen();
           }
      -    if (targetPage) {

      -      setActivePage(targetPage);

      +    if (targetPage && targetPage !== currentActivePage) {

      +      navigate(`/${targetPage}`, { replace: true });
           } else {
      +      setSearchParams({}, { replace: true });
           }
         }
       
         const buttons = [
      @@ -165,8 +179,8 @@
           {
             id: 'fullscreen',
             onClick: () => {
      -        if (targetPage && targetPage !== currentActivePage) {

      -          setActivePage(targetPage);

      +        if (targetPage && targetPage !== currentActivePage ) {

      +          navigate(`/${targetPage}`);
                 setTimeout(() => toggleFullscreen(pane), 50);
               } else {
                 toggleFullscreen(pane);

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/AppShell.tsx
    content: >+
      --- src/components/layout/AppShell.tsx

      +++ src/components/layout/AppShell.tsx

      @@ -1,13 +1,13 @@
       import React, { useRef, type ReactElement, useCallback, useEffect, useLayoutEffect } from 'react'
      +import { useLocation, useNavigate } from 'react-router-dom';
       import { cn } from '@/lib/utils'
       import { gsap } from 'gsap';
       import { CommandPalette } from '@/components/global/CommandPalette';
      -import { useAppStore } from '@/store/appStore';

      +import { useAppStore } from '@/store/appStore'
       import { useAppShell } from '@/context/AppShellContext';
       import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'
       import { useResizableSidebar, useResizableRightPane } from '@/hooks/useResizablePanes.hook'
       import { useSidebarAnimations, useBodyStateAnimations } from '@/hooks/useAppShellAnimations.hook'
       import { ViewModeSwitcher } from './ViewModeSwitcher';
       
       interface AppShellProps {
      @@ -18,10 +18,11 @@
         commandPalette?: ReactElement;
       }
       
      -const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
      'notifications'> = {

      +const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
      'notifications' | 'dataDemo'> = {
         dashboard: 'main',
         settings: 'settings',
         toaster: 'toaster',
         notifications: 'notifications',
      +  'data-demo': 'dataDemo',
       };
       
       // Helper hook to get the previous value of a prop or state
      @@ -43,7 +44,6 @@
           peekSidebar,
           draggedPage,
           dragHoverTarget,
      -    toggleSplitView,
           bodyState,
           sidePaneContent,
           closeSidePane,
      @@ -53,7 +53,10 @@
         
         const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
       
      -  const { isDarkMode, toggleDarkMode, handleNavigation, activePage } =
      useAppStore();

      +  const { isDarkMode, toggleDarkMode } = useAppStore();

      +  const navigate = useNavigate();

      +  const location = useLocation();

      +  const activePage = location.pathname.split('/')[1] || 'dashboard';
         const appRef = useRef<HTMLDivElement>(null)
         const sidebarRef = useRef<HTMLDivElement>(null)
         const mainContentRef = useRef<HTMLDivElement>(null)
      @@ -128,32 +131,30 @@
       
         const handleDropLeft = useCallback(() => {
           if (!draggedPage) return;
      -    

      -    const originalActivePage = activePage;

      -    const originalActivePagePaneContent =
      pageToPaneMap[originalActivePage];
       
           // If we drop the page that's already in the side pane, just make it the main view.
           const paneContentOfDraggedPage = pageToPaneMap[draggedPage];
           if (paneContentOfDraggedPage === sidePaneContent && (bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {
      -      closeSidePane();

      -      handleNavigation(draggedPage);

      +      navigate(`/${draggedPage}`, { replace: true });
           } 
           // New context-aware logic: if we are in normal view and drop a NEW page on the left
      -    else if (bodyState === BODY_STATES.NORMAL && draggedPage !==
      originalActivePage) {

      +    else if (bodyState === BODY_STATES.NORMAL && draggedPage !==
      activePage) {

      +        const originalActivePagePaneContent = pageToPaneMap[activePage];
               if (originalActivePagePaneContent) {
      -            // 1. Set the right pane content to be the original page

      -            dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload:
      originalActivePagePaneContent });

      -            // 2. Set the main page to be the new dragged page

      -            handleNavigation(draggedPage);

      -            // 3. Switch to split view

      -            dispatch({ type: 'SET_BODY_STATE', payload:
      BODY_STATES.SPLIT_VIEW });

      +           
      navigate(`/${draggedPage}?view=split&right=${originalActivePagePaneContent}`,
      { replace: true });
               } else {
                   // Fallback for pages that can't be in a pane
      -            handleNavigation(draggedPage);

      +            navigate(`/${draggedPage}`, { replace: true });
               }
           } else { // Default behavior: just make the dropped page the main one
      -      handleNavigation(draggedPage);

      +      // If in split view, replace the main content and keep the right
      pane

      +      if (bodyState === BODY_STATES.SPLIT_VIEW) {

      +        const rightPane = location.search.split('right=')[1];

      +        if (rightPane) {

      +          navigate(`/${draggedPage}?view=split&right=${rightPane}`, {
      replace: true });

      +          return;

      +        }

      +      }

      +      navigate(`/${draggedPage}`, { replace: true });
           }
           
           dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
      @@ -171,22 +172,17 @@
           if (!draggedPage) return;
           const pane = pageToPaneMap[draggedPage as keyof typeof pageToPaneMap];
           if (pane) {
      +      let mainPage = activePage;
             // If dropping the currently active page to the right,
             // set a default page (e.g., dashboard) as the new active page.
             if (draggedPage === activePage) {
      -        handleNavigation('dashboard');

      -      }

      -

      -      // Set the right pane content and ensure split view

      -      dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: pane });

      -      if (bodyState === BODY_STATES.NORMAL) {

      -        toggleSplitView(pane);

      -      } else if (bodyState === BODY_STATES.SIDE_PANE) {

      -        toggleSplitView();

      -      }

      +        mainPage = 'dashboard';

      +      }

      +

      +      navigate(`/${mainPage}?view=split&right=${pane}`, { replace: true
      });
           }
           dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
           dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      -  }, [draggedPage, toggleSplitView, dispatch, bodyState, activePage,
      handleNavigation]);

      +  }, [draggedPage, dispatch, bodyState, activePage, navigate]);
       
         return (
           <div 

    patchStrategy: standard-diff
snapshot:
  src/App.tsx: |-
    import React, { useEffect } from "react";
    import {
      createBrowserRouter,
      RouterProvider,
      Outlet,
      Navigate,
      useLocation,
      useNavigate,
    } from "react-router-dom";

    import { AppShell } from "./components/layout/AppShell";
    import { AppShellProvider, useAppShell } from "./context/AppShellContext";
    import { useAppStore } from "./store/appStore";
    import { useAuthStore } from "./store/authStore";
    import "./index.css";

    // Import library components
    import { EnhancedSidebar } from "./components/layout/EnhancedSidebar";
    import { MainContent } from "./components/layout/MainContent";
    import { RightPane } from "./components/layout/RightPane";
    import { TopBar } from "./components/layout/TopBar";
    import { CommandPalette } from "./components/global/CommandPalette";
    import { ToasterProvider } from "./components/ui/toast";

    // Import page/content components
    import { DashboardContent } from "./pages/Dashboard";
    import { SettingsPage } from "./pages/Settings";
    import { ToasterDemo } from "./pages/ToasterDemo";
    import { NotificationsPage } from "./pages/Notifications";
    import DataDemoPage from "./pages/DataDemo";
    import { SettingsContent } from "./features/settings/SettingsContent";
    import { LoginPage } from "./components/auth/LoginPage";

    // Import icons
    import {
      LayoutDashboard,
      Settings,
      Component,
      Bell,
      SlidersHorizontal,
      ChevronsLeftRight,
      Search,
      Filter,
      Plus,
      ChevronRight,
      Rocket,
      Layers,
      SplitSquareHorizontal,
      Database,
    } from "lucide-react";
    import { BODY_STATES } from "./lib/utils";
    import { cn } from "./lib/utils";

    // Wrapper for LoginPage to provide auth handlers
    function LoginPageWrapper() {
      const { login, forgotPassword } = useAuthStore();
      const navigate = useNavigate();

      const handleLogin = async (email: string, password: string) => {
        try {
          await login(email, password);
          navigate("/");
        } catch (error) {
          console.error("Login failed:", error);
          // In a real app, you'd show an error message to the user
        }
      };

      const handleForgotPassword = async (email: string) => {
        try {
          await forgotPassword(email);
        } catch (error)
          console.error("Forgot password failed:", error);
        }
      };

      const handleSignUp = () => {
        // In a real app, navigate to sign up page
        console.log("Navigate to sign up page");
      };

      return (
        <LoginPage
          onLogin={handleLogin}
          onForgotPassword={handleForgotPassword}
          onSignUp={handleSignUp}
        />
      );
    }

    // Checks for authentication and redirects to login if needed
    function ProtectedRoute() {
      const { isAuthenticated } = useAuthStore();
      if (!isAuthenticated) {
        return <Navigate to="/login" replace />;
      }
      return <Outlet />;
    }

    // The main layout for authenticated parts of the application
    function ProtectedLayout() {
      const isDarkMode = useAppStore((state) => state.isDarkMode);

      useEffect(() => {
        document.documentElement.classList.toggle("dark", isDarkMode);
      }, [isDarkMode]);

      return (
        <div className="h-screen w-screen overflow-hidden bg-background">
          <AppShellProvider
            appName="Jeli App"
            appLogo={
              <div className="p-2 bg-primary/20 rounded-lg">
                <Rocket className="w-5 h-5 text-primary" />
              </div>
            }
          >
            <ComposedApp />
          </AppShellProvider>
        </div>
      );
    }

    // Content for the Top Bar (will be fully refactored in Part 2)
    function AppTopBar() {
      const { searchTerm, setSearchTerm } = useAppStore();
      const { openSidePane } = useAppShell();
      const [isSearchFocused, setIsSearchFocused] = React.useState(false);
      const location = useLocation();
      const activePage = location.pathname.split('/').filter(Boolean).pop()?.replace('-', ' ') || 'dashboard';

      return (
        <div className="flex items-center gap-3 flex-1">
          <div
            className={cn(
              "hidden md:flex items-center gap-2 text-sm transition-opacity",
              {
                "opacity-0 pointer-events-none":
                  isSearchFocused && activePage === "dashboard",
              },
            )}
          >
            <a
              href="#"
              className="text-muted-foreground hover:text-foreground transition-colors"
            >
              Home
            </a>
            <ChevronRight className="w-4 h-4 text-muted-foreground" />
            <span className="font-medium text-foreground capitalize">
              {activePage}
            </span>
          </div>

          <div className="flex-1" />

          {/* Page-specific: Dashboard search and actions */}
          {activePage === "dashboard" && (
            <div className="flex items-center gap-2 flex-1 justify-end">
              <div
                className={cn(
                  "relative transition-all duration-300 ease-in-out",
                  isSearchFocused ? "flex-1 max-w-lg" : "w-auto",
                )}
              >
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4 pointer-events-none" />
                <input
                  type="text"
                  placeholder="Search..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  onFocus={() => setIsSearchFocused(true)}
                  onBlur={() => setIsSearchFocused(false)}
                  className={cn(
                    "pl-9 pr-4 py-2 h-10 border-none rounded-lg bg-card focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all duration-300 ease-in-out w-full",
                    isSearchFocused ? "bg-background" : "w-48",
                  )}
                />
              </div>
              <button className="h-10 w-10 flex-shrink-0 flex items-center justify-center hover:bg-accent rounded-full transition-colors">
                <Filter className="w-5 h-5" />
              </button>
              <button className="bg-primary text-primary-foreground px-4 py-2 rounded-full hover:bg-primary/90 transition-colors flex items-center gap-2 h-10 flex-shrink-0">
                <Plus className="w-5 h-5" />
                <span
                  className={cn(isSearchFocused ? "hidden sm:inline" : "inline")}
                >
                  New Project
                </span>
              </button>
            </div>
          )}
        </div>
      );
    }

    // The main App component that composes the shell
    function ComposedApp() {
      const { sidePaneContent, closeSidePane, bodyState, toggleSplitView } =
        useAppShell();
      const navigate = useNavigate();

      const isOverlaySidePane = bodyState === BODY_STATES.SIDE_PANE;

      const contentMap = {
        main: {
          title: "Dashboard",
          icon: LayoutDashboard,
          page: "dashboard",
          content: <DashboardContent isInSidePane={isOverlaySidePane} />,
        },
        settings: {
          title: "Settings",
          icon: Settings,
          page: "settings",
          content: isOverlaySidePane ? (
            <div className="p-6">
              <SettingsContent />
            </div>
          ) : (
            <SettingsPage />
          ),
        },
        toaster: {
          title: "Toaster Demo",
          icon: Component,
          page: "toaster",
          content: <ToasterDemo isInSidePane={isOverlaySidePane} />,
        },
        notifications: {
          title: "Notifications",
          icon: Bell,
          page: "notifications",
          content: <NotificationsPage isInSidePane={isOverlaySidePane} />,
        },
        dataDemo: {
          title: "Data Showcase",
          icon: Database,
          page: "data-demo",
          content: <DataDemoPage isInSidePane={isOverlaySidePane} />,
        },
        details: {
          title: "Details Panel",
          icon: SlidersHorizontal,
          content: (
            <div className="p-6">
              <p className="text-muted-foreground">
                This is the side pane. It can be used to display contextual
                information, forms, or actions related to the main content.
              </p>
            </div>
          ),
        },
      } as const;

      const currentContent =
        contentMap[sidePaneContent as keyof typeof contentMap] ||
        contentMap.details;
      const CurrentIcon = currentContent.icon;

      const handleMaximize = () => {
        if ("page" in currentContent && currentContent.page) {
          navigate(`/${currentContent.page}`);
        }
        closeSidePane();
      };

      const rightPaneHeader =
        bodyState !== BODY_STATES.SPLIT_VIEW ? (
          <>
            <div className="flex items-center gap-2">
              <CurrentIcon className="w-5 h-5" />
              <h2 className="text-lg font-semibold whitespace-nowrap">
                {currentContent.title}
              </h2>
            </div>
            <div className="flex items-center">
              {(bodyState === BODY_STATES.SIDE_PANE ||
                bodyState === BODY_STATES.SPLIT_VIEW) && (
                <button
                  onClick={toggleSplitView}
                  className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors"
                  title={
                    bodyState === BODY_STATES.SIDE_PANE
                      ? "Switch to Split View"
                      : "Switch to Overlay View"
                  }
                >
                  {bodyState === BODY_STATES.SPLIT_VIEW ? (
                    <Layers className="w-5 h-5" />
                  ) : (
                    <SplitSquareHorizontal className="w-5 h-5" />
                  )}
                </button>
              )}
              {"page" in currentContent && currentContent.page && (
                <button
                  onClick={handleMaximize}
                  className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors mr-2"
                  title="Move to Main View"
                >
                  <ChevronsLeftRight className="w-5 h-5" />
                </button>
              )}
            </div>
          </>
        ) : undefined;

      return (
        <AppShell
          sidebar={<EnhancedSidebar />}
          topBar={
            <TopBar>
              <AppTopBar />
            </TopBar>
          }
          mainContent={
            <MainContent>
              <Outlet />
            </MainContent>
          }
          rightPane={
            <RightPane header={rightPaneHeader}>{currentContent.content}</RightPane>
          }
          commandPalette={<CommandPalette />}
        />
      );
    }

    function App() {
      const router = createBrowserRouter([
        {
          path: "/login",
          element: <LoginPageWrapper />,
        },
        {
          path: "/",
          element: <ProtectedRoute />,
          children: [
            {
              path: "/",
              element: <ProtectedLayout />,
              children: [
                { index: true, element: <Navigate to="/dashboard" replace /> },
                { path: "dashboard", element: <DashboardContent /> },
                { path: "settings", element: <SettingsPage /> },
                { path: "toaster", element: <ToasterDemo /> },
                { path: "notifications", element: <NotificationsPage /> },
                { path: "data-demo", element: <DataDemoPage /> },
              ],
            },
          ],
        },
      ]);

      return (
        <ToasterProvider>
          <RouterProvider router={router} />
        </ToasterProvider>
      );
    }

    export default App;
  src/components/layout/EnhancedSidebar.tsx: >-
    import React from 'react';

    import {
      Home,
      Settings,
      HelpCircle,
      Component,
      Rocket,
      MoreHorizontal,
      Bell,
      Search,
      FileText,
      Star,
      Trash2,
      FolderOpen,
      Mail,
      Bookmark,
      Download,
      User,
      Plus,
      Database
    } from 'lucide-react';

    import { useLocation, useNavigate, useSearchParams } from
    'react-router-dom';

    import { useAppStore, type ActivePage } from '@/store/appStore';

    import { useAppShell } from '@/context/AppShellContext';

    import { BODY_STATES } from '@/lib/utils';

    import {
      Workspaces,
      WorkspaceTrigger,
      WorkspaceContent,
      type Workspace,
    } from './WorkspaceSwitcher';

    import {
      DropdownMenu,
      DropdownMenuContent,
      DropdownMenuItem,
      DropdownMenuTrigger,
    } from '@/components/ui/dropdown-menu';

    import {
      Sidebar,
      SidebarContent,
      SidebarHeader,
      SidebarTitle,
      SidebarBody,
      SidebarFooter,
      SidebarSection,
      SidebarMenuItem,
      SidebarMenuButton,
      SidebarMenuAction,
      SidebarLabel,
      SidebarBadge,
      SidebarTooltip,
      SidebarIcon,
      useSidebar,
    } from './Sidebar';

    import { ViewModeSwitcher } from './ViewModeSwitcher';

    import { cn } from '@/lib/utils';


    interface MyWorkspace extends Workspace {
      logo: string;
      plan: string;
    }


    const mockWorkspaces: MyWorkspace[] = [
      { id: 'ws1', name: 'Acme Inc.', logo: 'https://avatar.vercel.sh/acme.png', plan: 'Pro' },
      { id: 'ws2', name: 'Monsters Inc.', logo: 'https://avatar.vercel.sh/monsters.png', plan: 'Free' },
      { id: 'ws3', name: 'Stark Industries', logo: 'https://avatar.vercel.sh/stark.png', plan: 'Enterprise' },
    ];


    const SidebarWorkspaceTrigger = () => {
      const { isCollapsed, compactMode } = useSidebar();

      return (
        <WorkspaceTrigger
          collapsed={isCollapsed}
          className={cn(
            'rounded-xl transition-colors hover:bg-accent/50 w-full',
            isCollapsed ? 'p-2' : 'p-3 bg-accent/50',
          )}
          avatarClassName={cn(compactMode ? 'h-8 w-8' : 'h-10 w-10')}
        />
      );
    };


    interface SidebarProps {
      onMouseEnter?: () => void;
      onMouseLeave?: () => void;
    }


    export const EnhancedSidebar = React.forwardRef<HTMLDivElement,
    SidebarProps>(
      ({ onMouseEnter, onMouseLeave }, ref) => {
        const { sidebarWidth, compactMode, appName, appLogo } = useAppShell();
        const [selectedWorkspace, setSelectedWorkspace] = React.useState(mockWorkspaces[0]);

        return (
          <Sidebar
            ref={ref}
            style={{ width: sidebarWidth }}
            onMouseEnter={onMouseEnter}
            onMouseLeave={onMouseLeave}
          >
            <SidebarContent>
              <SidebarHeader>
                {appLogo || (
                  <div className="p-2 bg-primary/20 rounded-lg">
                    <Rocket className="w-5 h-5 text-primary" />
                  </div>
                )}
                <SidebarTitle>{appName}</SidebarTitle>
              </SidebarHeader>

              <SidebarBody>
                <SidebarSection title="Main">
                  <AppMenuItem icon={Home} label="Dashboard" page="dashboard" />
                  <AppMenuItem icon={Database} label="Data Demo" page="data-demo" />
                  <AppMenuItem icon={Search} label="Search" />
                  <AppMenuItem icon={Bell} label="Notifications" badge={3} page="notifications" opensInSidePane />
                </SidebarSection>
                
                <SidebarSection title="Workspace" collapsible defaultExpanded>
                  <AppMenuItem icon={FileText} label="Documents" hasActions>
                    <AppMenuItem icon={FileText} label="Recent" isSubItem />
                    <AppMenuItem icon={Star} label="Starred" isSubItem />
                    <AppMenuItem icon={Trash2} label="Trash" isSubItem />
                  </AppMenuItem>
                  <AppMenuItem icon={FolderOpen} label="Projects" hasActions />
                  <AppMenuItem icon={Mail} label="Messages" badge={12} />
                </SidebarSection>
                
                <SidebarSection title="Personal" collapsible>
                  <AppMenuItem icon={Bookmark} label="Bookmarks" />
                  <AppMenuItem icon={Star} label="Favorites" />
                  <AppMenuItem icon={Download} label="Downloads" />
                </SidebarSection>

                <SidebarSection title="Components" collapsible defaultExpanded>
                  <AppMenuItem icon={Component} label="Toaster" page="toaster" />
                </SidebarSection>
              </SidebarBody>

              <SidebarFooter>
                <SidebarSection>
                  <AppMenuItem icon={User} label="Profile" />
                  <AppMenuItem icon={Settings} label="Settings" page="settings" />
                  <AppMenuItem icon={HelpCircle} label="Help" />
                </SidebarSection>

                <div className={cn(compactMode ? 'mt-4' : 'mt-6')}>
                  <Workspaces
                    workspaces={mockWorkspaces}
                    selectedWorkspaceId={selectedWorkspace.id}
                    onWorkspaceChange={setSelectedWorkspace}
                  >
                    <SidebarWorkspaceTrigger />
                    <WorkspaceContent>
                      <button className="flex w-full items-center gap-2 rounded-sm px-2 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground focus:outline-none">
                        <Plus className="h-4 w-4" />
                        <span>Create Workspace</span>
                      </button>
                    </WorkspaceContent>
                  </Workspaces>
                </div>
              </SidebarFooter>
            </SidebarContent>
          </Sidebar>
        );
      },
    );

    EnhancedSidebar.displayName = 'EnhancedSidebar';



    // Example of a reusable menu item component built with the new Sidebar
    primitives

    interface AppMenuItemProps {
      icon: React.ElementType;
      label: string;
      badge?: number;
      hasActions?: boolean;
      children?: React.ReactNode;
      isSubItem?: boolean;
      page?: ActivePage;
      opensInSidePane?: boolean;
    }


    const AppMenuItem: React.FC<AppMenuItemProps> = ({ icon: Icon, label, badge,
    hasActions, children, isSubItem = false, page, opensInSidePane = false }) =>
    {
      const { compactMode, bodyState, sidePaneContent, openSidePane, dispatch } = useAppShell()
      const { isCollapsed } = useSidebar();
      const navigate = useNavigate();
      const location = useLocation();
      const [searchParams, setSearchParams] = useSearchParams();

      const pageToPaneMap: { [key in ActivePage]?: 'main' | 'settings' | 'toaster' | 'notifications' | 'data-demo' } = {
        dashboard: 'main',
        settings: 'settings',
        toaster: 'toaster',
        notifications: 'notifications',
        'data-demo': 'main',
      };
      const paneContentForPage = page ? pageToPaneMap[page] : undefined;

      const isActive = (
        (!opensInSidePane && page && location.pathname === `/${page}`)
      ) || (
        opensInSidePane && paneContentForPage && searchParams.get('sidePane') === paneContentForPage
      );

      const handleClick = () => {
        if (page) {
          if (opensInSidePane) {
            if (paneContentForPage) {
              if (searchParams.get('sidePane') === paneContentForPage) {
                searchParams.delete('sidePane');
              } else {
                searchParams.set('sidePane', paneContentForPage);
              }
              setSearchParams(searchParams, { replace: true });
            }
          } else {
            navigate(`/${page}`);
          }
        }
      };

      return (
        <div className={isSubItem ? (compactMode ? 'ml-4' : 'ml-6') : ''}>
          <SidebarMenuItem>
            <SidebarMenuButton
              onClick={handleClick}
              isActive={isActive}
              draggable={!!page}
              onDragStart={(_e) => {
                if (page) {
                  // set dragged page in AppShell context
                  dispatch({ type: 'SET_DRAGGED_PAGE', payload: page });
                }
              }}
              onDragEnd={() => {
                dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
                dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
              }}
            >
              <SidebarIcon>
                <Icon className={isSubItem ? "w-3 h-3" : "w-4 h-4"}/>
              </SidebarIcon>
              <SidebarLabel>{label}</SidebarLabel>
              {badge && <SidebarBadge>{badge}</SidebarBadge>}
              <SidebarTooltip label={label} badge={badge} />
            </SidebarMenuButton>

            {page && !isCollapsed && ( // Always render switcher if there's a page
              <div className={cn(
                "absolute top-1/2 -translate-y-1/2 z-10",
                "opacity-0 group-hover/item:opacity-100 group-focus-within/item:opacity-100",
                "transition-opacity pointer-events-none group-hover/item:pointer-events-auto",
                // If there are actions, move left to make space for the action button
                hasActions ? "right-10" : "right-2"
              )}>
                <ViewModeSwitcher targetPage={page} />
              </div>
            )}

            {hasActions && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <SidebarMenuAction>
                    <MoreHorizontal className="h-4 w-4" />
                  </SidebarMenuAction>
                </DropdownMenuTrigger>
                <DropdownMenuContent side="right" align="start">
                  <DropdownMenuItem>
                    <span>Edit {label}</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem>
                    <span>Delete {label}</span>
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </SidebarMenuItem>
          {!isCollapsed && children && (
            <div className="space-y-1 mt-1">{children}</div>
          )}
        </div>
      );
    };
  src/components/layout/ViewModeSwitcher.tsx: >-
    import { useState, useRef, useEffect } from 'react';

    import { gsap } from 'gsap';

    import { cn } from '@/lib/utils'

    import { useAppShell } from '@/context/AppShellContext'

    import { useAppStore, type ActivePage } from '@/store/appStore'

    import { BODY_STATES } from '@/lib/utils'

    import { type AppShellState } from '@/context/AppShellContext'

    import {
      Columns,
      PanelRightOpen,
      SplitSquareHorizontal,
      Maximize,
      Minimize,
      Layers,
      X,
      ArrowLeftRight
    } from 'lucide-react'


    const pageToPaneMap: Record<ActivePage, AppShellState['sidePaneContent']> =
    {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
      'data-demo': 'dataDemo',
    };


    export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
    'right', targetPage?: ActivePage }) {
      const {
        bodyState,
        sidePaneContent,
        openSidePane,
        closeSidePane,
        toggleFullscreen,
        toggleSplitView,
        fullscreenTarget,
        dispatch,
      } = useAppShell()
      const { activePage: currentActivePage, setActivePage } = useAppStore()

      const activePage = targetPage || currentActivePage;
      const [isExpanded, setIsExpanded] = useState(false);
      const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isThisPaneFullscreen = isFullscreen && (
        (pane === 'main' && fullscreenTarget !== 'right') ||
        (pane === 'right' && fullscreenTarget === 'right') ||
        (!pane && !fullscreenTarget) // Global switcher, global fullscreen
      );

      useEffect(() => {
        const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
        if (buttonsToAnimate.length === 0) return;

        gsap.killTweensOf(buttonsToAnimate);

        if (isExpanded) {
            gsap.to(buttonsToAnimate, {
                width: 32, // h-8 w-8
                opacity: 1,
                pointerEvents: 'auto',
                marginLeft: 4, // from gap-1 in original
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'start'
                },
                ease: 'power2.out'
            });
        } else {
            gsap.to(buttonsToAnimate, {
                width: 0,
                opacity: 0,
                pointerEvents: 'none',
                marginLeft: 0,
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'end'
                },
                ease: 'power2.in'
            });
        }
      }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

      const handleSidePaneClick = () => {
        const paneContent = pageToPaneMap[activePage] || 'details';
        if (pane === 'right') return;
        if (bodyState === BODY_STATES.SIDE_PANE && sidePaneContent === paneContent) {
          closeSidePane();
        } else {
          openSidePane(paneContent);
        }
      };
      
      const handleSplitViewClick = () => {
          const paneContent = pageToPaneMap[activePage] || 'details';
          if (pane === 'right') return;
          toggleSplitView(paneContent);
      }

      const handleSwitchPanes = () => {
        if (bodyState !== BODY_STATES.SPLIT_VIEW) return;
        const newSidePaneContent = pageToPaneMap[activePage];
        const newActivePage = Object.entries(pageToPaneMap).find(
          ([, value]) => value === sidePaneContent
        )?.[0] as ActivePage | undefined;

        if (newActivePage && newSidePaneContent) {
          setActivePage(newActivePage);
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: newSidePaneContent });
        }
      };

      const handleClosePane = () => {
        if (bodyState !== BODY_STATES.SPLIT_VIEW) return;
        if (pane === 'right') {
          closeSidePane();
        } else if (pane === 'main') {
          const pageToBecomeActive = Object.entries(pageToPaneMap).find(
            ([, value]) => value === sidePaneContent
          )?.[0] as ActivePage | undefined;
          
          if (pageToBecomeActive) {
            setActivePage(pageToBecomeActive);
          }
          closeSidePane();
        }
      }

      const handleNormalViewClick = () => {
        if (bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW) {
          closeSidePane();
        }
        if (isFullscreen) {
          toggleFullscreen();
        }
        if (targetPage) {
          setActivePage(targetPage);
        }
      }

      const buttons = [
        {
          id: 'normal',
          onClick: handleNormalViewClick,
          active: bodyState === BODY_STATES.NORMAL,
          title: "Normal View",
          icon: <Columns className="w-4 h-4" />
        },
        {
          id: 'side-pane',
          onClick: handleSidePaneClick,
          active: bodyState === BODY_STATES.SIDE_PANE,
          title: "Side Pane View",
          icon: <PanelRightOpen className="w-4 h-4" />
        },
        {
          id: 'split-view',
          onClick: handleSplitViewClick,
          active: bodyState === BODY_STATES.SPLIT_VIEW,
          title: bodyState === BODY_STATES.SPLIT_VIEW ? 'Switch to Overlay View' : 'Switch to Split View',
          icon: bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-4 h-4" /> : <SplitSquareHorizontal className="w-4 h-4" />
        },
        {
          id: 'fullscreen',
          onClick: () => {
            if (targetPage && targetPage !== currentActivePage) {
              setActivePage(targetPage);
              setTimeout(() => toggleFullscreen(pane), 50);
            } else {
              toggleFullscreen(pane);
            }
          },
          active: isThisPaneFullscreen,
          title: "Toggle Fullscreen",
          icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
        }
      ];

      if (bodyState === BODY_STATES.SPLIT_VIEW) {
        buttons.push({
          id: 'switch',
          onClick: handleSwitchPanes,
          active: false,
          title: "Switch Panes",
          icon: <ArrowLeftRight className="w-4 h-4" />
        });
        buttons.push({
          id: 'close',
          onClick: handleClosePane,
          active: false,
          title: "Close Pane",
          icon: <X className="w-4 h-4 text-muted-foreground group-hover:text-destructive" />
        });
      }

      return (
        <div
          onMouseEnter={() => setIsExpanded(true)}
          onMouseLeave={() => setIsExpanded(false)}
          className="flex items-center gap-0 p-1 bg-card rounded-full border border-border"
        >
            <button
                className='h-8 w-8 flex-shrink-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors'
                title="View Modes"
                onClick={() => setIsExpanded(!isExpanded)}
            >
                <Layers className="w-4 h-4" />
            </button>
          
          {buttons.map((btn, index) => (
            <button
              key={btn.id}
              ref={el => buttonRefs.current[index] = el}
              onClick={btn.onClick}
              className={cn(
                'h-8 w-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors group opacity-0',
                btn.active && 'bg-accent text-accent-foreground',
                btn.id === 'close' && 'hover:bg-destructive/20'
              )}
              style={{ pointerEvents: 'none', marginLeft: 0, overflow: 'hidden' }}
              title={btn.title}
            >
              {btn.icon}
            </button>
          ))}
        </div>
      )
    }
  src/components/layout/AppShell.tsx: >-
    import React, { useRef, type ReactElement, useCallback, useEffect,
    useLayoutEffect } from 'react'

    import { cn } from '@/lib/utils'

    import { gsap } from 'gsap';

    import { CommandPalette } from '@/components/global/CommandPalette';

    import { useAppStore } from '@/store/appStore';

    import { useAppShell } from '@/context/AppShellContext';

    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'

    import { useResizableSidebar, useResizableRightPane } from
    '@/hooks/useResizablePanes.hook'

    import { useSidebarAnimations, useBodyStateAnimations } from
    '@/hooks/useAppShellAnimations.hook'

    import { ViewModeSwitcher } from './ViewModeSwitcher';


    interface AppShellProps {
      sidebar: ReactElement;
      topBar: ReactElement;
      mainContent: ReactElement;
      rightPane: ReactElement;
      commandPalette?: ReactElement;
    }


    const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
    'notifications'> = {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
    };


    // Helper hook to get the previous value of a prop or state

    function usePrevious<T>(value: T): T | undefined {
      const ref = useRef<T>();
      useEffect(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }



    export function AppShell({ sidebar, topBar, mainContent, rightPane,
    commandPalette }: AppShellProps) {
      const {
        sidebarState,
        dispatch,
        autoExpandSidebar,
        toggleSidebar,
        hoveredPane,
        peekSidebar,
        draggedPage,
        dragHoverTarget,
        toggleSplitView,
        bodyState,
        sidePaneContent,
        closeSidePane,
        reducedMotion,
        isTopBarVisible,
      } = useAppShell();
      
      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;

      const { isDarkMode, toggleDarkMode, handleNavigation, activePage } = useAppStore();
      const appRef = useRef<HTMLDivElement>(null)
      const sidebarRef = useRef<HTMLDivElement>(null)
      const mainContentRef = useRef<HTMLDivElement>(null)
      const rightPaneRef = useRef<HTMLDivElement>(null)
      const resizeHandleRef = useRef<HTMLDivElement>(null)
      const topBarContainerRef = useRef<HTMLDivElement>(null)
      const mainAreaRef = useRef<HTMLDivElement>(null)

      const prevActivePage = usePrevious(activePage);
      const prevSidePaneContent = usePrevious(sidePaneContent);

      const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;

      // Custom hooks for logic
      useResizableSidebar(sidebarRef, resizeHandleRef);
      useResizableRightPane();
      useSidebarAnimations(sidebarRef, resizeHandleRef);
      useBodyStateAnimations(appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef);
      
      // Animation for pane swapping
      useLayoutEffect(() => {
        if (reducedMotion || bodyState !== BODY_STATES.SPLIT_VIEW || !prevActivePage || !prevSidePaneContent) {
          return;
        }

        const pageForPrevSidePane = Object.keys(pageToPaneMap).find(
          key => pageToPaneMap[key as keyof typeof pageToPaneMap] === prevSidePaneContent
        );

        // Check if a swap occurred by comparing current state with previous state
        if (activePage === pageForPrevSidePane && sidePaneContent === pageToPaneMap[prevActivePage as keyof typeof pageToPaneMap]) {
          const mainEl = mainAreaRef.current;
          const rightEl = rightPaneRef.current;

          if (mainEl && rightEl) {
            const mainWidth = mainEl.offsetWidth;
            const rightWidth = rightEl.offsetWidth;

            const tl = gsap.timeline();
            
            // Animate main content FROM where right pane was TO its new place
            tl.from(mainEl, {
              x: rightWidth, duration: 0.4, ease: 'power3.inOut'
            });

            // Animate right pane FROM where main content was TO its new place
            tl.from(rightEl, {
              x: -mainWidth, duration: 0.4, ease: 'power3.inOut'
            }, 0); // Start at the same time
          }
        }
      }, [activePage, sidePaneContent, bodyState, prevActivePage, prevSidePaneContent, reducedMotion]);
      
      const sidebarWithProps = React.cloneElement(sidebar, { 
        ref: sidebarRef,
        onMouseEnter: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.COLLAPSED) {
            peekSidebar()
          }
        },
        onMouseLeave: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.PEEK) {
            dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
          }
        }
      });

      const topBarWithProps = React.cloneElement(topBar, {
        onToggleSidebar: toggleSidebar,
        onToggleDarkMode: toggleDarkMode,
      });

      const mainContentWithProps = React.cloneElement(mainContent, {
        ref: mainContentRef,
      });

      const rightPaneWithProps = React.cloneElement(rightPane, { ref: rightPaneRef });

      // Drag and drop handlers for docking
      const handleDragOverLeft = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'left') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'left' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropLeft = useCallback(() => {
        if (!draggedPage) return;
        
        const originalActivePage = activePage;
        const originalActivePagePaneContent = pageToPaneMap[originalActivePage];

        // If we drop the page that's already in the side pane, just make it the main view.
        const paneContentOfDraggedPage = pageToPaneMap[draggedPage];
        if (paneContentOfDraggedPage === sidePaneContent && (bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {
          closeSidePane();
          handleNavigation(draggedPage);
        } 
        // New context-aware logic: if we are in normal view and drop a NEW page on the left
        else if (bodyState === BODY_STATES.NORMAL && draggedPage !== originalActivePage) {
            if (originalActivePagePaneContent) {
                // 1. Set the right pane content to be the original page
                dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: originalActivePagePaneContent });
                // 2. Set the main page to be the new dragged page
                handleNavigation(draggedPage);
                // 3. Switch to split view
                dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
            } else {
                // Fallback for pages that can't be in a pane
                handleNavigation(draggedPage);
            }
        } else { // Default behavior: just make the dropped page the main one
          handleNavigation(draggedPage);
        }
        
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, activePage, bodyState, sidePaneContent, handleNavigation, dispatch, closeSidePane]);

      const handleDragOverRight = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'right') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'right' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropRight = useCallback(() => {
        if (!draggedPage) return;
        const pane = pageToPaneMap[draggedPage as keyof typeof pageToPaneMap];
        if (pane) {
          // If dropping the currently active page to the right,
          // set a default page (e.g., dashboard) as the new active page.
          if (draggedPage === activePage) {
            handleNavigation('dashboard');
          }

          // Set the right pane content and ensure split view
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: pane });
          if (bodyState === BODY_STATES.NORMAL) {
            toggleSplitView(pane);
          } else if (bodyState === BODY_STATES.SIDE_PANE) {
            toggleSplitView();
          }
        }
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, toggleSplitView, dispatch, bodyState, activePage, handleNavigation]);

      return (
        <div 
          ref={appRef}
          className={cn(
            "relative h-screen w-screen overflow-hidden bg-background transition-colors duration-300",
            isDarkMode && "dark"
          )}
        >
          <div className="flex h-screen overflow-hidden">
            {/* Enhanced Sidebar */}
            {sidebarWithProps}

            {/* Resize Handle */}
            {sidebarState !== SIDEBAR_STATES.HIDDEN && (
              <div
                ref={resizeHandleRef}
                className={cn(
                  "absolute top-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
                )}
                onMouseDown={(e) => {
                  e.preventDefault()
                  dispatch({ type: 'SET_IS_RESIZING', payload: true });
                }}
              >
                <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
              </div>
            )}

            {/* Main area wrapper */}
            <div className="flex-1 flex flex-col overflow-hidden relative">
              <div
                ref={topBarContainerRef}
                className={cn(
                  "absolute top-0 left-0 right-0 z-30",
                  isFullscreen && "z-0"
                )}
                onMouseEnter={() => { if (isSplitView) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
              >
                {topBarWithProps}
              </div>

              <div className="flex flex-1 min-h-0">
                <div
                  ref={mainAreaRef}
                  className="relative flex-1 overflow-hidden bg-background"
                  onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'left' }); }}
                  onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                >
                  {/* Left drop overlay */}
                  <div
                    className={cn(
                      "absolute inset-y-0 left-0 z-40 border-2 border-transparent transition-all",
                      draggedPage
                        ? cn("pointer-events-auto", isSplitView ? 'w-full' : 'w-1/2')
                        : "pointer-events-none w-0",
                      dragHoverTarget === 'left' && "bg-primary/10 border-primary"
                    )}
                    onDragOver={handleDragOverLeft}
                    onDrop={handleDropLeft}
                    onDragLeave={() => {
                      if (dragHoverTarget === 'left') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                    }}
                  >
                    {draggedPage && dragHoverTarget === 'left' && (
                      <div className="absolute inset-0 flex items-center justify-center text-sm font-medium text-primary-foreground/80 pointer-events-none">
                        <span className="px-3 py-1 rounded-md bg-primary/70">{isSplitView ? 'Drop to Replace' : 'Drop to Left'}</span>
                      </div>
                    )}
                  </div>
                  {mainContentWithProps}
                  {isSplitView && hoveredPane === 'left' && !draggedPage && (
                    <div className={cn("absolute right-4 z-50 transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                      <ViewModeSwitcher pane="main" />
                    </div>
                  )}
                  {/* Right drop overlay (over main area, ONLY when NOT in split view) */}
                  {!isSplitView && (
                    <div
                      className={cn(
                        "absolute inset-y-0 right-0 z-40 border-2 border-transparent",
                        draggedPage ? "pointer-events-auto w-1/2" : "pointer-events-none",
                        dragHoverTarget === 'right' && "bg-primary/10 border-primary"
                      )}
                      onDragOver={handleDragOverRight}
                      onDrop={handleDropRight}
                      onDragLeave={() => {
                        if (dragHoverTarget === 'right') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                      }}
                    >
                      {draggedPage && dragHoverTarget === 'right' && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                          <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">Drop to Right</span>
                        </div>
                      )}
                    </div>
                  )}
                </div>
                {isSplitView ? (
                  <div
                    className="relative"
                    onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'right' }); }}
                    onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                    onDragOver={handleDragOverRight}
                  >
                    {rightPaneWithProps}
                    {draggedPage && (
                      <div
                        className={cn(
                          'absolute inset-0 z-50 transition-all',
                          dragHoverTarget === 'right'
                            ? 'bg-primary/10 border-2 border-primary'
                            : 'pointer-events-none'
                        )}
                        onDragLeave={() => {
                          if (dragHoverTarget === 'right')
                            dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                        }}
                        onDrop={handleDropRight}
                        onDragOver={(e) => e.preventDefault()}
                      >
                        {dragHoverTarget === 'right' && (
                          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">
                              Drop to Replace
                            </span>
                          </div>
                        )}
                      </div>
                    )}
                    {hoveredPane === 'right' && !draggedPage && (
                      <div className={cn("absolute right-4 z-[70] transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                        <ViewModeSwitcher pane="right" />
                      </div>
                    )}
                  </div>
                ) : rightPaneWithProps}
              </div>
            </div>
          </div>
          {commandPalette || <CommandPalette />}
        </div>
      )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 214
