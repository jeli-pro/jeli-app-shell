uuid: 4a2f8d83-c215-46aa-83a5-8a8b13d2f232
projectId: jeli-app-shell
createdAt: '2025-10-21T11:00:12.954Z'
gitCommitMsg: >-
  fix(types): resolve typescript errors from generic refactor

  This commit resolves a series of TypeScript compilation errors that arose
  after refactoring the DynamicView system to be end-to-end type-safe with
  generics.

  The fixes include: - Correcting core type definitions in `types.ts` to
  properly utilize generic parameters and handle readonly properties. - Updating
  the `dataDemo` store and `useAppViewManager` hook to provide the necessary
  type arguments for the new generic types. - Making component props and
  callbacks in `DetailPanel`, `CalendarView`, and `ViewControls` fully generic
  to ensure type safety and resolve inference failures.
promptSummary: >-
  The user executed a large refactoring plan and received 25 TypeScript errors.
  The request is to fix all of them.
reasoning:
  - >-
    I've analyzed the TypeScript errors, and they stem from the large-scale
    refactoring to introduce generics. The core issues are missing type
    arguments for the new generic types, type inference failures in callbacks,
    and mismatches between `readonly` and mutable array types.
  - >-
    I will now apply a series of targeted fixes across the affected files to
    resolve these compilation errors and complete the type-safety refactoring.
  - '### Part 1: Fix Foundational Types & Configuration'
  - >-
    First, I'll correct the core `types.ts` file. This is the source of several
    downstream errors. The `ViewConfig` was not using its `TItem` generic
    parameter, and it was expecting a mutable array for `fields`, which
    conflicted with the `as const` assertion in the configuration file.
  - >-
    With the base types corrected, the error in `DataDemo.config.tsx` should be
    resolved without any changes to that file. The `readonly` modifier on the
    `fields` array now matches the type inferred from the `as const` assertion.
  - '### Part 2: Repair the Data Store and URL State Manager'
  - >-
    Next, I'll fix the `dataDemo` store and the `useAppViewManager` hook. They
    were using the new generic types without providing the necessary type
    arguments and had some definition mismatches.
  - '### Part 3: Update Components with Correct Generic Usage'
  - >-
    Finally, I'll patch the components that were failing due to missing generics
    or implicit `any` types in their callbacks. I'll make the components fully
    generic and provide explicit types where inference is failing.
  - >-
    The fix to the store should resolve the final error in `DataDemo/index.tsx`
    without needing changes to that file.
  - >-
    These changes should resolve all 25 TypeScript errors and complete the
    refactoring.
operations:
  - type: write
    path: src/features/dynamic-view/types.ts
    content: >+
      --- src/features/dynamic-view/types.ts

      +++ src/features/dynamic-view/types.ts

      @@ -14,26 +14,26 @@
         | 'thumbnail'
         | 'custom';
       
      -export interface BaseFieldDefinition<TFieldId extends string> {

      +export interface BaseFieldDefinition<TFieldId extends string, TItem
      extends GenericItem> {
         id: TFieldId; // Corresponds to a key in GenericItem
         label: string;
         type: FieldType;
         // Optional custom render function for ultimate flexibility.
      -  render?: (item: GenericItem, options?: Record<string, any>) =>
      ReactNode;

      +  render?: (item: TItem, options?: Record<string, any>) => ReactNode;
       }
       
      -export interface BadgeFieldDefinition<TFieldId extends string>

      -  extends BaseFieldDefinition<TFieldId> {

      +export interface BadgeFieldDefinition<TFieldId extends string, TItem
      extends GenericItem>

      +  extends BaseFieldDefinition<TFieldId, TItem> {
         type: 'badge';
         colorMap?: Record<string, string>; // e.g., { 'active': 'bg-green-500', 'pending': 'bg-yellow-500' }
         indicatorColorMap?: Record<string, string>; // e.g., { 'critical': 'bg-red-500' }
       }
       
       // Add other specific field types if they need unique properties
       // For now, most can be handled by the base definition.
       
      -export type FieldDefinition<TFieldId extends string> =

      -  | BaseFieldDefinition<TFieldId>

      -  | BadgeFieldDefinition<TFieldId>;

      +export type FieldDefinition<TFieldId extends string, TItem extends
      GenericItem> =

      +  | BaseFieldDefinition<TFieldId, TItem>

      +  | BadgeFieldDefinition<TFieldId, TItem>;
       
       // --- VIEW CONFIGURATION ---
       // The master configuration object that defines the entire view.
      @@ -107,7 +107,7 @@
         TFieldId extends string,
         TItem extends GenericItem,
       > {
      -  fields: FieldDefinition<TFieldId>[];

      +  fields: readonly FieldDefinition<TFieldId, TItem>[];
         sortableFields: ControlOption<TFieldId>[];
         groupableFields: ControlOption<TFieldId | 'none'>[];
         filterableFields: FilterableFieldConfig<TFieldId>[];

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/store/dataDemo.store.tsx
    content: >+
      --- src/pages/DataDemo/store/dataDemo.store.tsx

      +++ src/pages/DataDemo/store/dataDemo.store.tsx

      @@ -4,13 +4,14 @@
       import type {
         GenericItem,
         GroupableField,
         FilterConfig,
      +  SortConfig,
       } from "@/features/dynamic-view/types";
       
       import type { DataDemoItem } from "../data/DataDemoItem";
       // --- State and Actions ---
       interface DataDemoState {
      -  items: GenericItem[];

      +  items: DataDemoItem[];
         hasMore: boolean;
         isLoading: boolean;
         isInitialLoading: boolean;
      @@ -19,8 +20,8 @@
       
       interface DataDemoActions {
         loadData: (params: {
      -  items: DataDemoItem[];

      -    groupBy: GroupableField | "none";

      +    page: number;

      +    groupBy: GroupableField<string> | "none";
           filters: FilterConfig;
           sortConfig: SortConfig<string> | null;
           isFullLoad?: boolean;
      @@ -63,11 +64,10 @@
       
               if (sortConfig) {
                 filteredItems.sort((a, b) => {
      -            // eslint-disable-next-line
      @typescript-eslint/no-explicit-any

      -            const getNestedValue = (obj: DataDemoItem, path: string): any
      =>

      +            const getNestedValue = (obj: DataDemoItem, path: string):
      unknown =>
                     path.split(".").reduce((o: any, k) => (o || {})[k], obj);
       
                   const aValue = getNestedValue(a, sortConfig.key);
                   const bValue = getNestedValue(b, sortConfig.key);
       
                   if (aValue === undefined || bValue === undefined) return 0;

    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: "--- src/hooks/useAppViewManager.hook.ts\n+++ src/hooks/useAppViewManager.hook.ts\n@@ -94,52 +94,52 @@\n \n   // DataDemo specific state\n   const viewMode = useMemo(() => (searchParams.get('dataView') as ViewMode) || 'list', [searchParams]);\n-\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n-\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField | 'none') || 'none', [searchParams]);\n+\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n+\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField<string> | 'none') || 'none', [searchParams]);\n \tconst activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n \tconst filters = useMemo<FilterConfig>(\n \t\t() => ({\n \t\t\tsearchTerm: q || '',\n-\t\t\tstatus: (status?.split(',') || []).filter(Boolean) as Status[],\n-\t\t\tpriority: (priority?.split(',') || []).filter(Boolean) as Priority[],\n+\t\t\tstatus: (status?.split(',') || []).filter(Boolean),\n+\t\t\tpriority: (priority?.split(',') || []).filter(Boolean),\n \t\t}),\n \t\t[q, status, priority],\n \t);\n-\tconst sortConfig = useMemo<SortConfig | null>(() => {\n+\tconst sortConfig = useMemo<SortConfig<string> | null>(() => {\n \t\tconst sortParam = sort;\n \t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n \t\tif (sortParam === 'default') return null;\n \n \t\tconst [key, direction] = sortParam.split('-');\n-\t\treturn { key: key as string, direction: direction as 'asc' | 'desc' };\n+\t\treturn { key, direction: direction as 'asc' | 'desc' };\n \t}, [sort]);\n-  const calendarDateProp = useMemo(() => (calDate || 'dueDate') as CalendarDateProp, [calDate]);\n+  const calendarDateProp = useMemo(() => (calDate || 'dueDate') as CalendarDateProp<string>, [calDate]);\n   const calendarDisplayProps = useMemo(\n     () => {\n       if (calDisplay === null) return []; // Default is now nothing\n       if (calDisplay === '') return []; // Explicitly empty is also nothing\n-      return calDisplay.split(',') as CalendarDisplayProp[];\n+      return calDisplay.split(',') as CalendarDisplayProp<string>[];\n     },\n     [calDisplay]\n   );\n   const calendarItemLimit = useMemo(() => {\n     const limit = parseInt(calLimit || '3', 10);\n     if (calLimit === 'all') return 'all';\n     return isNaN(limit) ? 3 : limit;\n   }, [calLimit]);\n-  const calendarColorProp = useMemo(() => (calColor || 'none') as CalendarColorProp, [calColor]);\n+  const calendarColorProp = useMemo(() => (calColor || 'none') as CalendarColorProp<string>, [calColor]);\n \n   // --- MUTATOR ACTIONS ---\n \n   const handleParamsChange = useCallback(\n-\t\t(newParams: Record<string, string | string[] | null | undefined>, resetPage = false) => {\n+\t\t(newParams: Record<string, string | number | string[] | null | undefined>, resetPage = false) => {\n \t\t\tsetSearchParams(\n \t\t\t\t(prev) => {\n \t\t\t\t\tconst updated = new URLSearchParams(prev);\n \t\t\t\t\t\n \t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n \t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n \t\t\t\t\t\t\tupdated.delete(key);\n \t\t\t\t\t\t} else if (Array.isArray(value)) {\n \t\t\t\t\t\t\tupdated.set(key, value.join(','));\n@@ -253,7 +253,7 @@\n   const setFilters = (newFilters: FilterConfig) => {\n     handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority }, true);\n   }\n-  const setSort = (config: SortConfig | null) => {\n+  const setSort = (config: SortConfig<string> | null) => {\n     if (!config) {\n       handleParamsChange({ sort: null }, true);\n     } else {\n@@ -271,13 +271,13 @@\n   const setPage = (newPage: number) => handleParamsChange({ page: newPage > 1 ? newPage.toString() : null });\n \n   // Calendar specific actions\n-  const setCalendarDateProp = (prop: CalendarDateProp) => handleParamsChange({ calDate: prop === 'dueDate' ? null : prop });\n-  const setCalendarDisplayProps = (props: CalendarDisplayProp[]) => {\n+  const setCalendarDateProp = (prop: CalendarDateProp<string>) => handleParamsChange({ calDate: prop === 'dueDate' ? null : prop });\n+  const setCalendarDisplayProps = (props: CalendarDisplayProp<string>[]) => {\n     // Check for default state to keep URL clean\n     const isDefault = props.length === 0;\n     handleParamsChange({ calDisplay: isDefault ? null : props.join(',') });\n   };\n   const setCalendarItemLimit = (limit: number | 'all') => handleParamsChange({ calLimit: limit === 3 ? null : String(limit) });\n-  const setCalendarColorProp = (prop: CalendarColorProp) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n+  const setCalendarColorProp = (prop: CalendarColorProp<string>) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n \n   const onItemSelect = useCallback((item: GenericItem) => {\n \t\tnavigate(`/data-demo/${item.id}${location.search}`);\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/components/shared/DetailPanel.tsx
    content: >+
      --- src/features/dynamic-view/components/shared/DetailPanel.tsx

      +++ src/features/dynamic-view/components/shared/DetailPanel.tsx

      @@ -5,14 +5,14 @@
         BarChart3,
       } from 'lucide-react'
       import type { GenericItem, DetailViewConfig } from '../../types'
      -import { useStaggeredAnimation } from
      '@/hooks/useStaggeredAnimation.motion.hook'

      +import { useStaggeredAnimation } from
      '@/hooks/useStaggeredAnimation.motion.hook';
       import { FieldRenderer } from '@/features/dynamic-view/components/shared/FieldRenderer'
       import { getNestedValue } from '@/lib/utils'
       
      -interface DetailPanelProps {

      -  item: GenericItem

      -  config: DetailViewConfig

      +interface DetailPanelProps<TFieldId extends string, TItem extends
      GenericItem> {

      +  item: TItem;

      +  config: DetailViewConfig<TFieldId>;
       }
       
       const SECTION_ICONS: Record<string, React.ElementType> = {
      @@ -22,7 +22,7 @@
         "Timeline": Clock,
       };
       
      -export function DetailPanel({ item, config }: DetailPanelProps) {

      +export function DetailPanel<TFieldId extends string, TItem extends
      GenericItem>({ item, config }: DetailPanelProps<TFieldId, TItem>) {
         const contentRef = useRef<HTMLDivElement>(null)
         useStaggeredAnimation(contentRef, [item]);
       
      @@ -52,8 +52,8 @@
               </div>
       
               {/* Status badges */}
      -        <div className="flex items-center gap-2 flex-wrap mb-4">

      -          {header.badgeFields.map(fieldId => (

      +        <div className="flex items-center gap-2 flex-wrap mb-4">

      +          {header.badgeFields.map((fieldId: TFieldId) => (
                   <FieldRenderer key={fieldId} item={item} fieldId={fieldId} />
                 ))}
               </div>
      @@ -64,11 +64,11 @@
             {/* Content */}
             <div className="flex-1 overflow-y-auto">
               <div className="p-6 space-y-6">
      -          {body.sections.map(section => {

      +          {body.sections.map((section) => {
                   const IconComponent = SECTION_ICONS[section.title];
                   // Render section only if at least one of its fields has a value
      -            const hasContent = section.fields.some(fieldId => {

      -              const value = getNestedValue(item, fieldId);

      +            const hasContent = section.fields.some((fieldId: TFieldId) =>
      {

      +              const value = getNestedValue(item, fieldId as string);
                     return value !== null && typeof value !== 'undefined';
                   });
       
      @@ -81,8 +81,8 @@
                         <h3 className="font-semibold text-sm">{section.title}</h3>
                       </div>
                       <div className="space-y-3">
      -                  {section.fields.map(fieldId => (

      +                  {section.fields.map((fieldId: TFieldId) => (
                           <FieldRenderer key={fieldId} item={item} fieldId={fieldId} options={{ avatarClassName: "w-12 h-12" }} />
                         ))}
                       </div>
                     </div>
      -            )

      -          })}

      +            );

      +          })}
               </div>
             </div>
           </div>

    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/components/controls/ViewControls.tsx
    content: >+
      --- src/features/dynamic-view/components/controls/ViewControls.tsx

      +++ src/features/dynamic-view/components/controls/ViewControls.tsx

      @@ -170,10 +170,10 @@
               calendarColorProp, onCalendarColorPropChange,
           } = useDynamicView<string, GenericItem>();
       
      -    const handleDisplayPropChange = (prop: CalendarDisplayProp, checked:
      boolean) => {

      +    const handleDisplayPropChange = (prop: CalendarDisplayProp<string>,
      checked: boolean) => {
               const newProps = checked 
                   ? [...(calendarDisplayProps || []), prop] 
      -            : (calendarDisplayProps || []).filter(p => p !== prop);

      +            : (calendarDisplayProps || []).filter((p) => p !== prop);
               onCalendarDisplayPropsChange?.(newProps);
           };
       

    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/components/views/CalendarView.tsx
    content: >+
      --- src/features/dynamic-view/components/views/CalendarView.tsx

      +++ src/features/dynamic-view/components/views/CalendarView.tsx

      @@ -64,10 +64,10 @@
           item: GenericItem; 
           isSelected: boolean;
           isDragging: boolean;
      -    onDragStart: (e: React.DragEvent<HTMLDivElement>, itemId: string) =>
      void;

      -    colorProp: CalendarColorProp;

      -}) {

      +    onDragStart: (e: React.DragEvent<HTMLDivElement>, itemId: string) =>
      void

      +    colorProp: CalendarColorProp<string>;

      +  }) {
         const { config, onItemSelect } = useDynamicView<string, GenericItem>();
         const { calendarView: viewConfig } = config;
       
      @@ -113,7 +113,7 @@
           );
       }
       
      -const datePropLabels: Record<CalendarDateProp, string> = {

      +const datePropLabels: Record<CalendarDateProp<string>, string> = {
         dueDate: 'due dates',
         createdAt: 'creation dates',
         updatedAt: 'update dates',

    patchStrategy: standard-diff
snapshot:
  src/features/dynamic-view/types.ts: >-
    import type { ReactNode } from 'react';


    // --- GENERIC DATA & ITEM ---

    export type GenericItem = Record<string, any> & { id: string };


    // --- FIELD DEFINITIONS ---

    // Describes a single piece of data within a GenericItem.

    export type FieldType =
      | 'string'
      | 'longtext'
      | 'badge'
      | 'avatar'
      | 'progress'
      | 'date'
      | 'tags'
      | 'metrics'
      | 'thumbnail'
      | 'custom';

    export interface BaseFieldDefinition<TFieldId extends string> {
      id: TFieldId; // Corresponds to a key in GenericItem
      label: string;
      type: FieldType;
      // Optional custom render function for ultimate flexibility.
      render?: (item: GenericItem, options?: Record<string, any>) => ReactNode;
    }


    export interface BadgeFieldDefinition<TFieldId extends string>
      extends BaseFieldDefinition<TFieldId> {
      type: 'badge';
      colorMap?: Record<string, string>; // e.g., { 'active': 'bg-green-500', 'pending': 'bg-yellow-500' }
      indicatorColorMap?: Record<string, string>; // e.g., { 'critical': 'bg-red-500' }
    }


    // Add other specific field types if they need unique properties

    // For now, most can be handled by the base definition.


    export type FieldDefinition<TFieldId extends string> =
      | BaseFieldDefinition<TFieldId>
      | BadgeFieldDefinition<TFieldId>;

    // --- VIEW CONFIGURATION ---

    // The master configuration object that defines the entire view.


    export type ViewMode = 'list' | 'cards' | 'grid' | 'table' | 'kanban' |
    'calendar';


    export interface ListViewConfig<TFieldId extends string> {
      iconField: TFieldId;
      titleField: TFieldId;
      metaFields: Array<{
        fieldId: TFieldId;
        className?: string;
      }>;
    }


    export interface CardViewConfig<TFieldId extends string> {
      thumbnailField: TFieldId;
      titleField: TFieldId;
      descriptionField: TFieldId;
      headerFields: TFieldId[];
      // Specific fields to recreate the original layout
      statusField: TFieldId;
      categoryField: TFieldId;
      tagsField: TFieldId;
      progressField: TFieldId;
      assigneeField: TFieldId;
      metricsField: TFieldId;
      dateField: TFieldId;
    }


    export interface TableColumnConfig<TFieldId extends string> {
      fieldId: TFieldId;
      label: string;
      isSortable: boolean;
    }


    export interface TableViewConfig<TFieldId extends string> {
      columns: TableColumnConfig<TFieldId>[];
    }


    export interface KanbanViewConfig<TFieldId extends string> {
      groupByField: TFieldId; // Field ID to group by (e.g., 'status')
      cardFields: {
        titleField: TFieldId;
        descriptionField: TFieldId;
        priorityField: TFieldId;
        tagsField: TFieldId;
        // footer fields
        dateField: TFieldId;
        metricsField: TFieldId; // for comments/attachments
        assigneeField: TFieldId;
      };
    }


    export interface CalendarViewConfig<TFieldId extends string> {
      dateField: TFieldId;
      titleField: TFieldId;
      displayFields: TFieldId[];
      colorByField?: TFieldId; // Field ID to color events by (e.g., 'priority', 'status')
    }


    export interface ControlOption<TId extends string> {
      id: TId;
      label: string;
    }


    export interface FilterableFieldConfig<TFieldId extends string> {
      id: TFieldId; // fieldId
      label: string;
      options: ControlOption<string>[];
    }


    export interface ViewConfig<
      TFieldId extends string,
      TItem extends GenericItem,
    > {
      fields: FieldDefinition<TFieldId>[];
      sortableFields: ControlOption<TFieldId>[];
      groupableFields: ControlOption<TFieldId | 'none'>[];
      filterableFields: FilterableFieldConfig<TFieldId>[];

      // Layouts for each view mode
      listView: ListViewConfig<TFieldId>;
      cardView: CardViewConfig<TFieldId>;
      tableView: TableViewConfig<TFieldId>;
      kanbanView: KanbanViewConfig<TFieldId>;
      calendarView: CalendarViewConfig<TFieldId>;
      detailView: DetailViewConfig<TFieldId>;
    }


    // --- DETAIL VIEW ---

    export interface DetailViewSection<TFieldId extends string> {
      title: string;
      fields: TFieldId[];
    }


    export interface DetailViewConfig<TFieldId extends string> {
      header: {
        thumbnailField: TFieldId;
        titleField: TFieldId;
        descriptionField: TFieldId;
        badgeFields: TFieldId[];
        progressField: TFieldId;
      };
      body: {
        sections: DetailViewSection<TFieldId>[];
      };
    }


    // --- GENERIC CONTROL & DATA TYPES ---


    export type Status = 'active' | 'pending' | 'completed' | 'archived';

    export type Priority = 'low' | 'medium' | 'high' | 'critical';


    export interface FilterConfig {
      searchTerm: string;
      [key: string]: any; // For dynamic filter keys like status, priority
    }


    export interface SortConfig<TFieldId extends string> {
      key: TFieldId;
      direction: 'asc' | 'desc';
    }


    export type GroupableField<TFieldId extends string> = TFieldId | 'none';


    export type CalendarDateProp<TFieldId extends string> = TFieldId;

    export type CalendarDisplayProp<TFieldId extends string> = TFieldId;

    export type CalendarColorProp<TFieldId extends string> = TFieldId | 'none';


    // --- STATS ---

    export type StatItem = {
      title: string;
      value: string;
      icon: ReactNode;
      change: string;
      trend: 'up' | 'down';
      chartData?: number[];
    };
  src/pages/DataDemo/store/dataDemo.store.tsx: |
    import { create } from "zustand";
    import { mockDataItems } from "@/pages/DataDemo/data/mockData";
    import type {
      GenericItem,
      GroupableField,
      FilterConfig,
    } from "@/features/dynamic-view/types";

    import type { DataDemoItem } from "../data/DataDemoItem";
    // --- State and Actions ---
    interface DataDemoState {
      items: GenericItem[];
      hasMore: boolean;
      isLoading: boolean;
      isInitialLoading: boolean;
      totalItemCount: number;
    }

    interface DataDemoActions {
      loadData: (params: {
      items: DataDemoItem[];
        groupBy: GroupableField | "none";
        filters: FilterConfig;
        sortConfig: SortConfig | null;
        isFullLoad?: boolean;
      }) => void;
      updateItem: (itemId: string, updates: Partial<DataDemoItem>) => void;
    }

    const defaultState: DataDemoState = {
      items: [],
      hasMore: true,
      isLoading: true,
      isInitialLoading: true,
      totalItemCount: 0,
    };

    // --- Store Implementation ---
    export const useDataDemoStore = create<DataDemoState & DataDemoActions>(
      (set) => ({
        ...defaultState,

        loadData: ({ page, groupBy, filters, sortConfig, isFullLoad }) => {
          set({ isLoading: true, ...(page === 1 && { isInitialLoading: true }) });
          const isFirstPage = page === 1;

          const filteredAndSortedData = (() => {
            const filteredItems = mockDataItems.filter((item) => {
              const searchTermMatch =
                item.title
                  .toLowerCase()
                  .includes(filters.searchTerm.toLowerCase()) ||
                item.description
                  .toLowerCase()
                  .includes(filters.searchTerm.toLowerCase());
              const statusMatch =
                filters.status.length === 0 || filters.status.includes(item.status);
              const priorityMatch =
                filters.priority.length === 0 ||
                filters.priority.includes(item.priority);
              return searchTermMatch && statusMatch && priorityMatch;
            });

            if (sortConfig) {
              filteredItems.sort((a, b) => {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const getNestedValue = (obj: DataDemoItem, path: string): any =>
                  path.split(".").reduce((o: any, k) => (o || {})[k], obj);

                const aValue = getNestedValue(a, sortConfig.key);
                const bValue = getNestedValue(b, sortConfig.key);

                if (aValue === undefined || bValue === undefined) return 0;
                if (typeof aValue === "string" && typeof bValue === "string") {
                  return sortConfig.direction === "asc"
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
                }
                if (typeof aValue === "number" && typeof bValue === "number") {
                  return sortConfig.direction === "asc"
                    ? aValue - bValue
                    : bValue - aValue;
                }
                if (
                  sortConfig.key === "updatedAt" ||
                  sortConfig.key === "createdAt"
                ) {
                  if (typeof aValue === "string" && typeof bValue === "string") {
                    return sortConfig.direction === "asc"
                      ? new Date(aValue).getTime() - new Date(bValue).getTime()
                      : new Date(bValue).getTime() - new Date(aValue).getTime();
                  }
                }
                return 0;
              });
            }
            return filteredItems;
          })();

          const totalItemCount = filteredAndSortedData.length;

          setTimeout(
            () => {
              if (groupBy !== "none" || isFullLoad) {
                set({
                  items: filteredAndSortedData,
                  hasMore: false,
                  isLoading: false,
                  isInitialLoading: false,
                  totalItemCount,
                });
                return;
              }

              const pageSize = 12;
              const newItems = filteredAndSortedData.slice(
                (page - 1) * pageSize,
                page * pageSize,
              );

              set((state) => ({
                items: isFirstPage ? newItems : [...state.items, ...newItems],
                hasMore: totalItemCount > page * pageSize,
                isLoading: false,
                isInitialLoading: false,
                totalItemCount,
              }));
            },
            isFirstPage ? 1500 : 500,
          );
        },

        updateItem: (itemId, updates) => {
          // In a real app, this would be an API call. Here we update the mock source.
          const itemIndex = mockDataItems.findIndex((i) => i.id === itemId);
          if (itemIndex > -1) {
            mockDataItems[itemIndex] = { ...mockDataItems[itemIndex], ...updates };
          }

          // Also update the currently loaded items in the store's state for UI consistency
          set((state) => ({
            items: state.items.map((item) =>
              item.id === itemId ? { ...item, ...updates } : item,
            ),
          }));
        },
      }),
    );

    export const useSelectedItem = (itemId?: string) => {
      if (!itemId) return null;
      return (
        (mockDataItems.find((item) => item.id === itemId) as DataDemoItem) ?? null
      );
    };
  src/hooks/useAppViewManager.hook.ts: "import { useMemo, useCallback, useEffect, useRef } from 'react';\nimport { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\nimport type { GenericItem, ViewMode, SortConfig, GroupableField, Status, Priority, CalendarDateProp, CalendarDisplayProp, CalendarColorProp, FilterConfig } from '@/features/dynamic-view/types';\nimport type { TaskView } from '@/pages/Messaging/types';\nimport { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n\nconst pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n  dashboard: 'main',\n  settings: 'settings',\n  toaster: 'toaster',\n  notifications: 'notifications',\n  'data-demo': 'dataDemo',\n  messaging: 'messaging',\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n/**\n * A centralized hook to manage and synchronize all URL-based view states.\n * This is the single source of truth for view modes, side panes, split views,\n * and page-specific parameters.\n */\nexport function useAppViewManager() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const params = useParams<{ itemId: string; conversationId: string }>();\n  const { itemId, conversationId } = params;\n  const { setSidebarState, sidebarState } = useAppShellStore();\n\n  // --- DERIVED STATE FROM URL ---\n\n  const view = searchParams.get('view');\n  const sidePane = searchParams.get('sidePane');\n  const right = searchParams.get('right');\n  const messagingView = searchParams.get('messagingView') as TaskView | null;\n  const q = searchParams.get('q');\n  const status = searchParams.get('status');\n  const priority = searchParams.get('priority');\n  const sort = searchParams.get('sort');\n  const calDate = searchParams.get('calDate');\n  const calDisplay = searchParams.get('calDisplay');\n  const calLimit = searchParams.get('calLimit');\n  const calColor = searchParams.get('calColor');\n\n  const { bodyState, sidePaneContent } = useMemo(() => {\n    const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo', 'messaging'];\n    \n    // 1. Priority: Explicit side pane overlay via URL param\n    if (sidePane && validPanes.includes(sidePane as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n    }\n\n    // 2. Data item detail view (can be overlay or split)\n    if (itemId) {\n      if (view === 'split') {\n        return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n      }\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n    }\n\n    // 3. Messaging conversation view (always split)\n    if (conversationId) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'messaging' as const };\n    }\n\n    // 4. Generic split view via URL param\n    if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: right as AppShellState['sidePaneContent'] };\n    }\n\n    return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n  }, [itemId, conversationId, view, sidePane, right]);\n  \n  const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n  const prevActivePage = usePrevious(currentActivePage);\n\n  // --- SIDE EFFECTS ---\n  useEffect(() => {\n    // On navigating to messaging page, collapse sidebar if it's expanded.\n    // This ensures a good default view but allows the user to expand it again if they wish.\n    if (currentActivePage === 'messaging' && prevActivePage !== 'messaging' && sidebarState === SIDEBAR_STATES.EXPANDED) {\n      setSidebarState(SIDEBAR_STATES.COLLAPSED);\n    }\n  }, [currentActivePage, prevActivePage, sidebarState, setSidebarState]);\n\n  // DataDemo specific state\n  const viewMode = useMemo(() => (searchParams.get('dataView') as ViewMode) || 'list', [searchParams]);\n\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField | 'none') || 'none', [searchParams]);\n\tconst activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n\tconst filters = useMemo<FilterConfig>(\n\t\t() => ({\n\t\t\tsearchTerm: q || '',\n\t\t\tstatus: (status?.split(',') || []).filter(Boolean) as Status[],\n\t\t\tpriority: (priority?.split(',') || []).filter(Boolean) as Priority[],\n\t\t}),\n\t\t[q, status, priority],\n\t);\n\tconst sortConfig = useMemo<SortConfig | null>(() => {\n\t\tconst sortParam = sort;\n\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n\t\tif (sortParam === 'default') return null;\n\n\t\tconst [key, direction] = sortParam.split('-');\n\t\treturn { key: key as string, direction: direction as 'asc' | 'desc' };\n\t}, [sort]);\n  const calendarDateProp = useMemo(() => (calDate || 'dueDate') as CalendarDateProp, [calDate]);\n  const calendarDisplayProps = useMemo(\n    () => {\n      if (calDisplay === null) return []; // Default is now nothing\n      if (calDisplay === '') return []; // Explicitly empty is also nothing\n      return calDisplay.split(',') as CalendarDisplayProp[];\n    },\n    [calDisplay]\n  );\n  const calendarItemLimit = useMemo(() => {\n    const limit = parseInt(calLimit || '3', 10);\n    if (calLimit === 'all') return 'all';\n    return isNaN(limit) ? 3 : limit;\n  }, [calLimit]);\n  const calendarColorProp = useMemo(() => (calColor || 'none') as CalendarColorProp, [calColor]);\n\n  // --- MUTATOR ACTIONS ---\n\n  const handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | string[] | null | undefined>, resetPage = false) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\t\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resetPage) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n  const navigateTo = useCallback((page: string, params?: Record<string, string | null>) => {\n    const targetPath = page.startsWith('/') ? page : `/${page}`;\n    const isSamePage = location.pathname === targetPath;\n    \n    const newSearchParams = new URLSearchParams(isSamePage ? searchParams : undefined);\n\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n          newSearchParams.delete(key);\n        } else {\n          newSearchParams.set(key, value);\n        }\n      }\n    }\n\n    navigate({ pathname: targetPath, search: newSearchParams.toString() });\n  }, [navigate, location.pathname, searchParams]);\n\n  const openSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (location.pathname === `/${Object.keys(pageToPaneMap).find(key => pageToPaneMap[key] === pane)}`) {\n        navigate({ pathname: '/dashboard', search: `?sidePane=${pane}` }, { replace: true });\n    } else {\n        handleParamsChange({ sidePane: pane, view: null, right: null });\n    }\n  }, [handleParamsChange, navigate, location.pathname]);\n\n  const closeSidePane = useCallback(() => {\n    if (itemId) {\n      navigate('/data-demo');\n    } else {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n    }\n  }, [itemId, navigate, handleParamsChange]);\n\n  const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (sidePane === pane) {\n      closeSidePane();\n    } else {\n      openSidePane(pane);\n    }\n  }, [sidePane, openSidePane, closeSidePane]);\n\n  const toggleSplitView = useCallback(() => {\n    if (bodyState === BODY_STATES.SIDE_PANE) {\n      handleParamsChange({ view: 'split', right: sidePane, sidePane: null });\n    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {\n      handleParamsChange({ sidePane: right, view: null, right: null });\n    } else { // From normal\n      const paneContent = pageToPaneMap[currentActivePage] || 'details';\n      handleParamsChange({ view: 'split', right: paneContent, sidePane: null });\n    }\n  }, [bodyState, sidePane, right, currentActivePage, handleParamsChange]);\n  \n  const setNormalView = useCallback(() => {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const switchSplitPanes = useCallback(() => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    const newSidePaneContent = pageToPaneMap[currentActivePage];\n    const newActivePage = Object.entries(pageToPaneMap).find(\n      ([, value]) => value === sidePaneContent\n    )?.[0] as ActivePage | undefined;\n\n    if (newActivePage && newSidePaneContent) {\n      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const closeSplitPane = useCallback((paneToClose: 'main' | 'right') => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    if (paneToClose === 'right') {\n      navigate(`/${currentActivePage}`, { replace: true });\n    } else { // Closing main pane\n      const pageToBecomeActive = Object.entries(pageToPaneMap).find(\n        ([, value]) => value === sidePaneContent\n      )?.[0] as ActivePage | undefined;\n      \n      if (pageToBecomeActive) {\n        navigate(`/${pageToBecomeActive}`, { replace: true });\n      } else {\n        navigate(`/dashboard`, { replace: true });\n      }\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  // DataDemo actions\n  const setViewMode = (mode: ViewMode) => handleParamsChange({ dataView: mode === 'list' ? null : mode });\n  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val }, true);\n  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n  const setFilters = (newFilters: FilterConfig) => {\n    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority }, true);\n  }\n  const setSort = (config: SortConfig | null) => {\n    if (!config) {\n      handleParamsChange({ sort: null }, true);\n    } else {\n      handleParamsChange({ sort: `${config.key}-${config.direction}` }, true);\n    }\n  }\n  const setTableSort = (field: string) => {\n    let newSort: string | null = `${field}-desc`;\n    if (sortConfig && sortConfig.key === field) {\n      if (sortConfig.direction === 'desc') newSort = `${field}-asc`;\n      else if (sortConfig.direction === 'asc') newSort = null;\n    }\n    handleParamsChange({ sort: newSort }, true);\n  };\n  const setPage = (newPage: number) => handleParamsChange({ page: newPage > 1 ? newPage.toString() : null });\n\n  // Calendar specific actions\n  const setCalendarDateProp = (prop: CalendarDateProp) => handleParamsChange({ calDate: prop === 'dueDate' ? null : prop });\n  const setCalendarDisplayProps = (props: CalendarDisplayProp[]) => {\n    // Check for default state to keep URL clean\n    const isDefault = props.length === 0;\n    handleParamsChange({ calDisplay: isDefault ? null : props.join(',') });\n  };\n  const setCalendarItemLimit = (limit: number | 'all') => handleParamsChange({ calLimit: limit === 3 ? null : String(limit) });\n  const setCalendarColorProp = (prop: CalendarColorProp) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n\n  const onItemSelect = useCallback((item: GenericItem) => {\n\t\tnavigate(`/data-demo/${item.id}${location.search}`);\n\t}, [navigate, location.search]);\n\n  const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n\n\n  return useMemo(() => ({\n    // State\n    bodyState,\n    sidePaneContent,\n    currentActivePage,\n    itemId,\n    messagingView,\n    // DataDemo State\n    viewMode,\n    page,\n    groupBy,\n    activeGroupTab,\n    filters,\n    sortConfig,\n    calendarDateProp,\n    calendarDisplayProps,\n    calendarItemLimit,\n    calendarColorProp,\n    // Actions\n    navigateTo,\n    openSidePane,\n    closeSidePane,\n    toggleSidePane,\n    toggleSplitView,\n    setNormalView,\n    switchSplitPanes,\n    setMessagingView,\n    closeSplitPane,\n    // DataDemo Actions\n    onItemSelect,\n    setViewMode,\n    setGroupBy,\n    setActiveGroupTab,\n    setFilters,\n    setSort,\n    setTableSort,\n    setPage,\n    setCalendarDateProp,\n    setCalendarDisplayProps,\n    setCalendarItemLimit,\n    setCalendarColorProp,\n  }), [\n    bodyState, sidePaneContent, currentActivePage, itemId, messagingView, viewMode,\n    page, groupBy, activeGroupTab, filters, sortConfig, calendarDateProp,\n    calendarDisplayProps, calendarItemLimit, calendarColorProp,\n    navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, setNormalView, setMessagingView,\n    switchSplitPanes, closeSplitPane, onItemSelect, setViewMode, setGroupBy, setActiveGroupTab, setFilters,\n    setSort, setTableSort, setPage, setCalendarDateProp, setCalendarDisplayProps, setCalendarItemLimit, setCalendarColorProp\n  ]);\n}"
  src/features/dynamic-view/components/shared/DetailPanel.tsx: >-
    import React, { useRef } from 'react'

    import {
      Clock, 
      Tag,
      User,
      BarChart3,
    } from 'lucide-react'

    import type { GenericItem, DetailViewConfig } from '../../types'

    import { useStaggeredAnimation } from
    '@/hooks/useStaggeredAnimation.motion.hook'

    import { FieldRenderer } from
    '@/features/dynamic-view/components/shared/FieldRenderer'

    import { getNestedValue } from '@/lib/utils'


    interface DetailPanelProps {
      item: GenericItem
      config: DetailViewConfig
    }


    const SECTION_ICONS: Record<string, React.ElementType> = {
      "Assigned to": User,
      "Engagement Metrics": BarChart3,
      "Tags": Tag,
      "Timeline": Clock,
    };


    export function DetailPanel({ item, config }: DetailPanelProps) {
      const contentRef = useRef<HTMLDivElement>(null)
      useStaggeredAnimation(contentRef, [item]);

      if (!item) {
        return null
      }
      
      const { header, body } = config;

      return (
        <div ref={contentRef} className="h-full flex flex-col">
          {/* Header */}
          <div className="p-6 border-b border-border/50 bg-gradient-to-r from-card/50 to-card/30 backdrop-blur-sm">
            <div className="flex items-start gap-4 mb-4">
              <div className="w-16 h-16 bg-gradient-to-br from-primary/20 to-primary/10 rounded-2xl flex items-center justify-center text-3xl flex-shrink-0">
                <FieldRenderer item={item} fieldId={header.thumbnailField} />
              </div>
              <div className="flex-1 min-w-0">
                <h1 className="text-2xl font-bold mb-2 leading-tight">
                  <FieldRenderer item={item} fieldId={header.titleField} />
                </h1>
                <p className="text-muted-foreground">
                  <FieldRenderer item={item} fieldId={header.descriptionField} />
                </p>
              </div>
            </div>

            {/* Status badges */}
            <div className="flex items-center gap-2 flex-wrap mb-4">
              {header.badgeFields.map(fieldId => (
                <FieldRenderer key={fieldId} item={item} fieldId={fieldId} />
              ))}
            </div>

            {/* Progress */}
            <FieldRenderer item={item} fieldId={header.progressField} options={{ showPercentage: true }} />
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto">
            <div className="p-6 space-y-6">
              {body.sections.map(section => {
                const IconComponent = SECTION_ICONS[section.title];
                // Render section only if at least one of its fields has a value
                const hasContent = section.fields.some(fieldId => {
                  const value = getNestedValue(item, fieldId);
                  return value !== null && typeof value !== 'undefined';
                });

                if (!hasContent) return null;

                return (
                  <div key={section.title} className="bg-card/30 rounded-2xl p-4 border border-border/30">
                    <div className="flex items-center gap-1 mb-3">
                      {IconComponent && <IconComponent className="w-4 h-4 text-muted-foreground" />}
                      <h3 className="font-semibold text-sm">{section.title}</h3>
                    </div>
                    <div className="space-y-3">
                      {section.fields.map(fieldId => (
                        <FieldRenderer key={fieldId} item={item} fieldId={fieldId} options={{ avatarClassName: "w-12 h-12" }} />
                      ))}
                    </div>
                  </div>
                )
              })}
            </div>
          </div>
        </div>
      )
    }
  src/features/dynamic-view/components/controls/ViewControls.tsx: >-
    import * as React from 'react'

    import { Check, ListFilter, Search, SortAsc, ChevronsUpDown, Settings } from
    'lucide-react'


    import { cn } from '@/lib/utils'

    import { Button } from '@/components/ui/button'

    import { Input } from '@/components/ui/input'

    import { Badge } from '@/components/ui/badge'

    import { Popover, PopoverContent, PopoverTrigger } from
    '@/components/ui/popover'

    import {
      DropdownMenu,
      DropdownMenuContent,
      DropdownMenuRadioGroup,
      DropdownMenuRadioItem,
      DropdownMenuSeparator,
      DropdownMenuLabel,
      DropdownMenuTrigger,
    } from '@/components/ui/dropdown-menu'

    import {
      Command,
      CommandEmpty,
      CommandGroup,
      CommandInput,
      CommandItem,
      CommandList,
      CommandSeparator,
    } from '@/components/ui/command'

    import { Label } from "@/components/ui/label";

    import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";

    import { Checkbox } from "@/components/ui/checkbox";

    import { Switch } from "@/components/ui/switch";

    import { Separator } from "@/components/ui/separator";


    import type { FilterConfig, CalendarDateProp, CalendarDisplayProp,
    CalendarColorProp, GenericItem } from '../../types'

    import { useDynamicView } from '../../DynamicViewContext';


    export interface DataViewControlsProps {
      // groupOptions will now come from config
    }


    export function ViewControls() {
      const {
        config,
        filters,
        onFiltersChange,
        sortConfig,
        onSortChange,
        groupBy,
        onGroupByChange,
        viewMode,
      } = useDynamicView<string, GenericItem>();
      const sortOptions = config.sortableFields;
      const groupOptions = config.groupableFields;
      const filterableFields = config.filterableFields;

      const handleSearchChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        onFiltersChange({ ...filters, searchTerm: event.target.value });
      }
      
      const activeFilterCount = filterableFields.reduce((acc, field) => acc + (filters[field.id]?.length || 0), 0)

      return (
        <div className="flex flex-col sm:flex-row items-center gap-2 w-full">
          {/* Search */}
          <div className="relative w-full sm:w-auto">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search projects..."
              className="pl-9 w-full sm:w-64"
              value={filters.searchTerm}
              onChange={handleSearchChange}
            />
          </div>

          {/* Filters */}
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" size="sm" className="h-9 w-full sm:w-auto justify-start border-dashed">
                <ListFilter className="mr-2 h-4 w-4" />
                Filters
                {activeFilterCount > 0 && (
                  <>
                    <div className="mx-2 h-4 w-px bg-muted-foreground/50" />
                    <Badge variant="secondary" className="rounded-sm px-1 font-normal">
                      {activeFilterCount}
                    </Badge>
                  </>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-[240px] p-0" align="start">
              <CombinedFilter filters={filters} onFiltersChange={onFiltersChange} filterableFields={filterableFields} />
            </PopoverContent>
          </Popover>

          {activeFilterCount > 0 && (
            <Button variant="ghost" size="sm" onClick={() => onFiltersChange({ searchTerm: filters.searchTerm, status: [], priority: [] })}>Reset</Button>
          )}

          {/* Spacer */}
          <div className="hidden md:block flex-grow" />

          {viewMode === 'calendar' ? (
            <CalendarSpecificControls />
          ) : (
            <>
              {/* Sorter */}
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm" className="h-9 w-full sm:w-auto justify-start">
                    <SortAsc className="mr-2 h-4 w-4" />
                    Sort by: {sortOptions.find(o => o.id === sortConfig?.key)?.label || 'Default'}
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-[200px]">
                  <DropdownMenuLabel>Sort by</DropdownMenuLabel>
                  <DropdownMenuRadioGroup
                    value={`${sortConfig?.key || 'default'}-${sortConfig?.direction || ''}`}
                    onValueChange={(value) => {
                      if (value.startsWith('default')) {
                        onSortChange(null);
                      } else {
                        const [key, direction] = value.split('-')
                        onSortChange({ key: key, direction: direction as 'asc' | 'desc' });
                      }
                    }}
                  >
                    <DropdownMenuRadioItem value="default-">Default</DropdownMenuRadioItem>
                    <DropdownMenuSeparator />
                    {sortOptions.map(option => (
                      <React.Fragment key={option.id}>
                        <DropdownMenuRadioItem value={`${option.id}-desc`}>{option.label} (Desc)</DropdownMenuRadioItem>
                        <DropdownMenuRadioItem value={`${option.id}-asc`}>{option.label} (Asc)</DropdownMenuRadioItem>
                      </React.Fragment>
                    ))}
                  </DropdownMenuRadioGroup>
                </DropdownMenuContent>
              </DropdownMenu>

              {/* Group By Dropdown */}
              <div className="flex items-center gap-2 shrink-0 w-full sm:w-auto">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="outline" size="sm" className="h-9 w-full justify-between">
                      Group by: {groupOptions.find(o => o.id === groupBy)?.label}
                      <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent className="w-[180px]">
                    <DropdownMenuRadioGroup value={groupBy} onValueChange={onGroupByChange}>
                      {groupOptions.map(option => (
                        <DropdownMenuRadioItem key={option.id} value={option.id}>
                          {option.label}
                        </DropdownMenuRadioItem>
                      ))}
                    </DropdownMenuRadioGroup>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </>
          )}
        </div>
      )
    }


    function CalendarSpecificControls() {
        const {
            calendarDateProp, onCalendarDatePropChange,
            calendarDisplayProps, onCalendarDisplayPropsChange,
            calendarItemLimit, onCalendarItemLimitChange,
            calendarColorProp, onCalendarColorPropChange,
        } = useDynamicView<string, GenericItem>();

        const handleDisplayPropChange = (prop: CalendarDisplayProp, checked: boolean) => {
            const newProps = checked 
                ? [...(calendarDisplayProps || []), prop] 
                : (calendarDisplayProps || []).filter(p => p !== prop);
            onCalendarDisplayPropsChange?.(newProps);
        };

        return (
            <Popover>
                <PopoverTrigger asChild>
                    <Button variant="outline" size="icon" className="h-9 w-9">
                        <Settings className="h-4 w-4" />
                    </Button>
                </PopoverTrigger>
                <PopoverContent className="w-80 p-4" align="end">
                    <div className="space-y-4">
                        <div className="space-y-1">
                            <h4 className="font-medium leading-none">Calendar Settings</h4>
                            <p className="text-sm text-muted-foreground">
                                Customize the calendar view.
                            </p>
                        </div>
                        <Separator />
                        <div className="space-y-3">
                            <Label className="font-semibold">Item Background Color</Label>
                            <RadioGroup value={calendarColorProp} onValueChange={(v) => onCalendarColorPropChange?.(v as CalendarColorProp<string>)} className="gap-2">
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="none" id="color-none" />
                                    <Label htmlFor="color-none" className="font-normal">None</Label>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="priority" id="color-priority" />
                                    <Label htmlFor="color-priority" className="font-normal">By Priority</Label>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="status" id="color-status" />
                                    <Label htmlFor="color-status" className="font-normal">By Status</Label>
                                </div>
                                 <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="category" id="color-category" />
                                    <Label htmlFor="color-category" className="font-normal">By Category</Label>
                                </div>
                            </RadioGroup>
                        </div>
                        <Separator />
                        <div className="space-y-3">
                            <Label className="font-semibold">Date Property</Label>
                            <RadioGroup value={calendarDateProp} onValueChange={(v) => onCalendarDatePropChange?.(v as CalendarDateProp<string>)} className="gap-2">
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="dueDate" id="dueDate" />
                                    <Label htmlFor="dueDate" className="font-normal">Due Date</Label>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="createdAt" id="createdAt" />
                                    <Label htmlFor="createdAt" className="font-normal">Created Date</Label>
                                </div>
                                <div className="flex items-center space-x-2">
                                    <RadioGroupItem value="updatedAt" id="updatedAt" />
                                    <Label htmlFor="updatedAt" className="font-normal">Updated Date</Label>
                                </div>
                            </RadioGroup>
                        </div>
                        <div className="space-y-3">
                            <Label className="font-semibold">Card Details</Label>
                            <div className="space-y-2">
                                {(['priority', 'assignee', 'tags'] as CalendarDisplayProp<string>[]).map(prop => (
                                    <div key={prop} className="flex items-center space-x-2">
                                        <Checkbox id={prop} checked={(calendarDisplayProps || []).includes(prop)} onCheckedChange={(c) => handleDisplayPropChange(prop, !!c)} />
                                        <Label htmlFor={prop} className="capitalize font-normal">{prop}</Label>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <Separator />
                        <div className="flex items-center justify-between">
                             <div className="space-y-0.5">
                                <Label htmlFor="show-all" className="font-semibold">Show all items</Label>
                                <p className="text-xs text-muted-foreground">Display all items on a given day.</p>
                            </div>
                            <Switch id="show-all" checked={calendarItemLimit === 'all'} onCheckedChange={(c) => onCalendarItemLimitChange?.(c ? 'all' : 3)} />
                        </div>
                    </div>
                </PopoverContent>
            </Popover>
        );
    }


    function CombinedFilter({
      filters,
      onFiltersChange,
      filterableFields,
    }: {
      filters: FilterConfig;
      onFiltersChange: (filters: FilterConfig) => void;
      filterableFields: { id: string; label: string; options: { id: string; label: string }[] }[];
    }) {
      const handleSelect = (fieldId: string, value: string) => {
        const currentValues = new Set(filters[fieldId] || []);
        currentValues.has(value) ? currentValues.delete(value) : currentValues.add(value);
        
        onFiltersChange({ ...filters, [fieldId]: Array.from(currentValues) });
      };

      const hasActiveFilters = filterableFields.some(field => (filters[field.id] || []).length > 0);

      const clearFilters = () => {
        const clearedFilters: Partial<FilterConfig> = {};
        filterableFields.forEach(field => {
          clearedFilters[field.id as keyof Omit<FilterConfig, 'searchTerm'>] = [];
        });
        onFiltersChange({ searchTerm: filters.searchTerm, ...clearedFilters });
      }

      return (
        <Command>
          <CommandInput placeholder="Filter by..." />
          <CommandList>
            <CommandEmpty>No results found.</CommandEmpty>
            
            {filterableFields.map((field, index) => (
              <React.Fragment key={field.id}>
                <CommandGroup heading={field.label}>
                  {field.options.map((option) => {
                const isSelected = (filters[field.id] || []).includes(option.id);
                return (
                  <CommandItem
                    key={option.id}
                    onSelect={() => handleSelect(field.id, option.id)}
                  >
                    <div
                      className={cn(
                        'mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary',
                        isSelected ? 'bg-primary text-primary-foreground' : 'opacity-50 [&_svg]:invisible'
                      )}
                    >
                      <Check className={cn('h-4 w-4')} />
                    </div>
                    <span>{option.label}</span>
                  </CommandItem>
                );
              })}
                </CommandGroup>
                {index < filterableFields.length - 1 && <CommandSeparator />}
              </React.Fragment>
            ))}

            {hasActiveFilters && (
              <>
                <CommandSeparator />
                <CommandGroup>
                  <CommandItem
                    onSelect={clearFilters}
                    className="justify-center text-center text-sm"
                  >
                    Clear filters
                  </CommandItem>
                </CommandGroup>
              </>
            )}
          </CommandList>
        </Command>
      )
    }
  src/features/dynamic-view/components/views/CalendarView.tsx: >-
    import { useState, useMemo, useRef, useLayoutEffect } from "react";

    import { format, addMonths, subMonths, startOfMonth, endOfMonth,
    startOfWeek, endOfWeek, eachDayOfInterval, isSameMonth, isToday, isSameDay,
    } from "date-fns";

    import { ChevronLeft, ChevronRight } from "lucide-react";

    import { gsap } from "gsap";


    import { Button } from "@/components/ui/button";

    import { cn } from "@/lib/utils";

    import type { GenericItem } from '../../types';

    import type { CalendarDateProp, CalendarColorProp, Status, Priority } from
    '../../types';

    import { useResizeObserver } from "@/hooks/useResizeObserver.hook";

    import { useDynamicView } from '../../DynamicViewContext'

    import { FieldRenderer } from '../shared/FieldRenderer'


    interface CalendarViewProps {
      data: GenericItem[];
    }


    const PRIORITY_BG_COLORS: Record<Priority, string> = {
      low: 'bg-blue-500/80 border-blue-600/80 text-white',
      medium: 'bg-yellow-500/80 border-yellow-600/80 text-yellow-950',
      high: 'bg-orange-500/80 border-orange-600/80 text-white',
      critical: 'bg-red-600/80 border-red-700/80 text-white',
    };


    const STATUS_BG_COLORS: Record<Status, string> = {
      active: 'bg-sky-500/80 border-sky-600/80 text-white',
      pending: 'bg-amber-500/80 border-amber-600/80 text-amber-950',
      completed: 'bg-emerald-600/80 border-emerald-700/80 text-white',
      archived: 'bg-zinc-500/80 border-zinc-600/80 text-white',
    };


    const CATEGORY_BG_COLORS = [
      'bg-rose-500/80 border-rose-600/80 text-white',
      'bg-fuchsia-500/80 border-fuchsia-600/80 text-white',
      'bg-indigo-500/80 border-indigo-600/80 text-white',
      'bg-teal-500/80 border-teal-600/80 text-white',
      'bg-lime-500/80 border-lime-600/80 text-lime-950',
    ];


    const getCategoryBgColor = (category: string) => {
      let hash = 0;
      for (let i = 0; i < category.length; i++) {
        hash = category.charCodeAt(i) + ((hash << 5) - hash);
      }
      const index = Math.abs(hash % CATEGORY_BG_COLORS.length);
      return CATEGORY_BG_COLORS[index];
    };


    function CalendarHeader({ currentDate, onPrevMonth, onNextMonth, onToday }:
    {
      currentDate: Date;
      onPrevMonth: () => void;
      onNextMonth: () => void;
      onToday: () => void;
    }) {
      return (
        <div className="flex items-center justify-between gap-4 mb-6">
          <h2 className="text-xl font-bold md:text-2xl tracking-tight">
            {format(currentDate, "MMMM yyyy")}
          </h2>
          <div className="flex items-center gap-2">
            <Button variant="outline" size="sm" onClick={onToday}>Today</Button>
            <div className="flex items-center">
              <Button variant="outline" size="icon" className="h-9 w-9" onClick={onPrevMonth}>
                <ChevronLeft className="h-4 w-4" />
              </Button>
              <Button variant="outline" size="icon" className="h-9 w-9" onClick={onNextMonth}>
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </div>
      );
    }


    function CalendarEvent({ item, isSelected, isDragging, onDragStart,
    colorProp }: { 
        item: GenericItem; 
        isSelected: boolean;
        isDragging: boolean;
        onDragStart: (e: React.DragEvent<HTMLDivElement>, itemId: string) => void;
        colorProp: CalendarColorProp;
    }) {
      const { config, onItemSelect } = useDynamicView<string, GenericItem>();
      const { calendarView: viewConfig } = config;

        const colorClass = useMemo(() => {
          switch (colorProp) {
            case 'priority': return PRIORITY_BG_COLORS[item.priority as Priority];
            case 'status': return STATUS_BG_COLORS[item.status as Status];
            case 'category': return getCategoryBgColor(item.category as string);
            default: return null;
          }
        }, [colorProp, item]);

        return (
            <div
                draggable
                onDragStart={(e) => onDragStart(e, item.id)}
                onClick={() => onItemSelect(item)}
                className={cn(
                    "p-2 rounded-lg cursor-grab transition-all duration-200 border space-y-1",
                    isSelected && "ring-2 ring-primary ring-offset-background ring-offset-2",
                    isDragging && "opacity-50 ring-2 ring-primary cursor-grabbing",
                    colorClass 
                      ? `${colorClass} hover:brightness-95 dark:hover:brightness-110`
                      : "bg-card/60 dark:bg-neutral-800/60 backdrop-blur-sm hover:bg-card/80 dark:hover:bg-neutral-700/70"
                )}
            >
                <div className={cn(
                  "font-semibold text-sm leading-tight line-clamp-2",
                  colorClass ? "text-inherit" : "text-card-foreground/90"
                )}>
                  <FieldRenderer item={item} fieldId={viewConfig.titleField} />
                </div>

                {viewConfig.displayFields.includes('tags') && <FieldRenderer item={item} fieldId="tags" />}

                {(viewConfig.displayFields.includes('priority') || viewConfig.displayFields.includes('assignee')) && (
                    <div className={cn(
                        "flex items-center justify-between pt-1 border-t",
                        colorClass ? "border-black/10 dark:border-white/10" : "border-border/30 dark:border-neutral-700/50"
                    )}>
                        <div>
                          {viewConfig.displayFields.includes('priority') && <FieldRenderer item={item} fieldId="priority" />}
                        </div>
                        <div>
                          {viewConfig.displayFields.includes('assignee') && <FieldRenderer item={item} fieldId="assignee" options={{ compact: true, avatarClassName: 'w-5 h-5' }}/>}
                        </div>
                    </div>
                )}
            </div>
        );
    }


    const datePropLabels: Record<CalendarDateProp, string> = {
      dueDate: 'due dates',
      createdAt: 'creation dates',
      updatedAt: 'update dates',
    };


    export function CalendarView({ data }: CalendarViewProps) {
      const [currentDate, setCurrentDate] = useState(new Date());
      const {
        selectedItemId,
        onItemUpdate,
        calendarDateProp = 'dueDate', // Provide default
        calendarItemLimit = 3, // Provide default
        calendarColorProp = 'none', // Provide default
      } = useDynamicView<string, GenericItem>();
      
      // Drag & Drop State
      const [draggedItemId, setDraggedItemId] = useState<string | null>(null);
      const [dropTargetDate, setDropTargetDate] = useState<Date | null>(null);

      // GSAP animation state
      const [direction, setDirection] = useState(0); // 0: initial, 1: next, -1: prev

      // Responsive Calendar State
      const calendarContainerRef = useRef<HTMLDivElement>(null);
      const { width } = useResizeObserver(calendarContainerRef);
      const MIN_DAY_WIDTH = 160; // px
      const numColumns = useMemo(() => {
        if (width === 0) return 7;
        const cols = Math.floor(width / MIN_DAY_WIDTH);
        return Math.max(3, Math.min(7, cols));
      }, [width]);

      const gridRef = useRef<HTMLDivElement>(null);
      const itemsByDateProp = useMemo(() => data.filter(item => !!item[calendarDateProp]), [data, calendarDateProp]);

      const eventsByDate = useMemo(() => {
        const eventsMap = new Map<string, GenericItem[]>();
        itemsByDateProp.forEach(item => {
          const dateValue = item[calendarDateProp];
          if (!dateValue) return;
          const date = new Date(dateValue as string);
          const dateKey = format(date, "yyyy-MM-dd");
          if (!eventsMap.has(dateKey)) {
            eventsMap.set(dateKey, []);
          }
          eventsMap.get(dateKey)?.push(item);
        });
        return eventsMap;
      }, [itemsByDateProp, calendarDateProp]);

      const monthStart = startOfMonth(currentDate);
      const monthEnd = endOfMonth(monthStart);
      const startDate = startOfWeek(monthStart, { weekStartsOn: 0 }); // Sunday
      const endDate = endOfWeek(monthEnd, { weekStartsOn: 0 });

      const days = eachDayOfInterval({ start: startDate, end: endDate });
      const weekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      
      // D&D Handlers
      const handleDragStart = (e: React.DragEvent, itemId: string) => {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', itemId);
        setDraggedItemId(itemId);
      };
      
      const handleDragEnd = () => {
        setDraggedItemId(null);
        setDropTargetDate(null);
      };

      const handleDragOver = (e: React.DragEvent, day: Date) => {
        e.preventDefault();
        if (dropTargetDate === null || !isSameDay(day, dropTargetDate)) {
            setDropTargetDate(day);
        }
      };

      const handleDragLeave = () => {
        setDropTargetDate(null);
      };

      const handleDrop = (e: React.DragEvent, day: Date) => {
        e.preventDefault();
        const itemIdToUpdate = e.dataTransfer.getData('text/plain');
        if (itemIdToUpdate) {
            const originalItem = itemsByDateProp.find(i => i.id === itemIdToUpdate);
            if (originalItem && originalItem[calendarDateProp]) {
                const originalDate = new Date(originalItem[calendarDateProp] as string);
                // Preserve the time, only change the date part
                const newDueDate = new Date(day);
                newDueDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());
                onItemUpdate?.(itemIdToUpdate, { [calendarDateProp]: newDueDate.toISOString() });
            }
        }
        handleDragEnd(); // Reset state
      };
      
      const handlePrevMonth = () => {
        setDirection(-1);
        setCurrentDate(subMonths(currentDate, 1));
      };
      const handleNextMonth = () => {
        setDirection(1);
        setCurrentDate(addMonths(currentDate, 1));
      };
      const handleToday = () => {
        setDirection(0); // No animation for 'Today'
        setCurrentDate(new Date());
      };

      useLayoutEffect(() => {
        if (direction === 0 || !gridRef.current) return;
        gsap.fromTo(gridRef.current, 
          { opacity: 0, x: 30 * direction }, 
          { opacity: 1, x: 0, duration: 0.3, ease: 'power2.out' }
        );
      }, [currentDate]);

      return (
        <div ref={calendarContainerRef} className="-mx-4 md:-mx-6">
          <div className="px-4 md:px-6 pb-2">
            <CalendarHeader currentDate={currentDate} onPrevMonth={handlePrevMonth} onNextMonth={handleNextMonth} onToday={handleToday} />
          </div>
          {itemsByDateProp.length === 0 ? (
            <div className="flex items-center justify-center h-96 text-muted-foreground rounded-lg border bg-card/30 mx-4 md:mx-6">
              No items with {datePropLabels[calendarDateProp]} to display on the calendar.
            </div>
          ) : (
            <div className="px-2" onDragEnd={handleDragEnd}>
              {numColumns === 7 && (
                <div className="grid grid-cols-7">
                  {weekdays.map(day => (
                    <div key={day} className="py-2 px-3 text-center text-xs font-semibold text-muted-foreground">
                      {day}
                    </div>
                  ))}
                </div>
              )}

                <div
                  ref={gridRef}
                  style={{
                    display: 'grid',
                    gridTemplateColumns: `repeat(${numColumns}, minmax(0, 1fr))`,
                    gap: '0.5rem',
                  }}
                >
                  {days.map(day => {
                    const dateKey = format(day, "yyyy-MM-dd");
                    const dayEvents = eventsByDate.get(dateKey) || [];
                    const visibleEvents = calendarItemLimit === 'all' 
                        ? dayEvents 
                        : dayEvents.slice(0, calendarItemLimit as number);
                    const hiddenEventsCount = dayEvents.length - visibleEvents.length;
                    const isCurrentMonthDay = isSameMonth(day, currentDate);
                    const isDropTarget = dropTargetDate && isSameDay(day, dropTargetDate);
                    return (
                      <div
                        key={day.toString()}
                        onDragOver={(e) => handleDragOver(e, day)}
                        onDragLeave={handleDragLeave}
                        onDrop={(e) => handleDrop(e, day)}
                        className={cn(
                          "relative min-h-[150px] rounded-2xl p-2 flex flex-col gap-2 transition-all duration-300 border",
                          isCurrentMonthDay ? "bg-card/40 dark:bg-neutral-900/40 border-transparent" : "bg-muted/30 dark:bg-neutral-800/20 border-transparent text-muted-foreground/60",
                          isDropTarget ? "border-primary/50 bg-primary/10" : "hover:border-primary/20 hover:bg-card/60"
                        )}
                      >
                        <div className="font-semibold text-sm">
                          {isToday(day) ? (
                            <div className="flex items-center justify-center w-7 h-7 rounded-full bg-primary text-primary-foreground">
                              {format(day, 'd')}
                            </div>
                          ) : (
                            <div className="flex items-baseline gap-1.5 px-1 py-0.5">
                              {numColumns < 7 && <span className="text-xs opacity-70">{format(day, 'eee')}</span>}
                              <span>{format(day, 'd')}</span>
                            </div>
                          )}
                        </div>
                        <div className="space-y-2 overflow-y-auto flex-grow custom-scrollbar">
                          {visibleEvents.map(item => (
                            <CalendarEvent
                              key={item.id} 
                              item={item} 
                              isSelected={selectedItemId === item.id}
                              isDragging={draggedItemId === item.id}
                              onDragStart={handleDragStart}
                              colorProp={calendarColorProp}
                            />
                          ))}
                        </div>
                        {hiddenEventsCount > 0 && (
                          <div className="absolute bottom-1 right-2 text-xs font-bold text-muted-foreground">
                            +{hiddenEventsCount} more
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
            </div>
          )}
        </div>
      );
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 538
