uuid: 15b13993-41bb-4e6f-b2fd-4a7b7ac75b77
projectId: jeli-app-shell
createdAt: '2025-10-21T07:33:05.511Z'
gitCommitMsg: >-
  refactor(dynamic-view): Create controlled component and encapsulate
  presentation logic

  This commit implements the first two major parts of the dynamic-view
  encapsulation refactor.

  - A new top-level controlled component, `<DynamicView />`, is introduced. It
  accepts all state and data as props and communicates changes via callbacks,
  establishing a clean, one-way data flow.

  - The `DynamicViewContext` has been updated to propagate this comprehensive
  controlled state to all child components within the feature.

  - All presentation logic, including view-switching, loading skeletons, and
  empty states, has been moved from the `DataDemo` page into the new
  `DynamicView` component.

  - The `DataDemo` page is refactored into a lean "controller," using
  `useAppViewManager` to manage URL-based state and driving the presentational
  `<DynamicView />` component via props.
promptSummary: >-
  Execute a large-scale refactor to encapsulate the `dynamic-view` feature.


  **Part 1: Foundational Changes**

  - Create a new top-level controlled component:
  `src/features/dynamic-view/DynamicView.tsx`.

  - This component will accept all view state (filters, sorting, view mode) and
  data as props.

  - It will also accept callbacks for user interactions (e.g.,
  `onViewModeChange`).

  - Refactor `DynamicViewContext.tsx` to accept and provide this comprehensive,
  controlled state to all child components within the feature.


  **Part 2: Integration and Logic Consolidation**

  - Move all presentation logic (view switching, loading skeletons, empty
  states) from `src/pages/DataDemo/index.tsx` into the new `DynamicView.tsx`
  component.

  - Refactor `DataDemo/index.tsx` to act as a "controller". It will use the
  `useAppViewManager` hook to manage URL state and pass that state down to the
  `<DynamicView />` component.

  - The `DataDemo` page will now be much simpler, delegating all rendering to
  the self-contained `<DynamicView />`.
reasoning:
  - >-
    This is an excellent architectural refactor. The goal is to transform the
    `dynamic-view` feature from a collection of components tightly coupled with
    application-level state into a fully encapsulated, reusable, "controlled"
    component. This enhances modularity and makes the feature much easier to
    maintain and use elsewhere.
  - Here is the implementation of the first two parts of your plan.
  - '### Part 1: Establish the Controlled `DynamicView` Component'
  - >-
    First, I'll create the new `<DynamicView />` component. This component will
    be the public API for the feature, receiving all its state via props. I will
    also refactor the `DynamicViewContext` to propagate these props to all child
    components.
  - '### Part 2: Encapsulate Presentation and Integrate Controller'
  - >-
    Now, I will integrate the new `<DynamicView />` component into the
    `DataDemo` page. The `DataDemo` page will act as the "controller," managing
    state via `useAppViewManager` and passing it down as props. This removes all
    direct presentation logic from the page, simplifying it significantly.
operations:
  - type: write
    path: src/features/dynamic-view/DynamicView.tsx
    content: >-
      import { useMemo, useCallback, type ReactNode } from 'react';

      import { DynamicViewProvider } from
      '@/features/dynamic-view/DynamicViewContext';

      import type { ViewConfig, GenericItem, ViewMode, FilterConfig, SortConfig
      } from './types';

      import { ViewControls } from './components/controls/ViewControls';

      import { ViewModeSelector } from './components/controls/ViewModeSelector';

      import { AnimatedLoadingSkeleton } from
      './components/shared/AnimatedLoadingSkeleton';

      import { ListView } from './components/views/ListView';

      import { CardView } from './components/views/CardView';

      import { TableView } from './components/views/TableView';

      import { KanbanView } from './components/views/KanbanView';

      import { CalendarView } from './components/views/CalendarView';

      import { EmptyState } from './components/shared/EmptyState';


      // Define the props for the controlled DynamicView component

      export interface DynamicViewProps {
        // Config
        viewConfig: ViewConfig;
        
        // Data & State
        items: GenericItem[];
        isLoading: boolean;
        isInitialLoading: boolean;
        totalItemCount: number;
        hasMore: boolean;
        
        // Controlled State Props
        viewMode: ViewMode;
        filters: FilterConfig;
        sortConfig: SortConfig | null;
        groupBy: string;
        activeGroupTab: string;
        page: number;
        selectedItemId?: string;

        // State Change Callbacks
        onViewModeChange: (mode: ViewMode) => void;
        onFiltersChange: (filters: FilterConfig) => void;
        onSortChange: (sort: SortConfig | null) => void;
        onGroupByChange: (group: string) => void;
        onActiveGroupTabChange: (tab: string) => void;
        onPageChange: (page: number) => void;
        onItemSelect: (item: GenericItem) => void;
        
        // Custom Renderers
        renderHeaderControls?: () => ReactNode;
        renderStats?: () => ReactNode;
        renderCta?: (viewMode: ViewMode) => ReactNode;
      }


      export function DynamicView({ viewConfig, ...rest }: DynamicViewProps) {
        
        const { viewMode, isInitialLoading, items, groupBy } = rest;

        const groupedData = useMemo(() => {
          if (groupBy === 'none' || viewMode !== 'kanban') {
              return null;
          }
          return items.reduce((acc, item) => {
              const groupKey = String(item[groupBy as keyof GenericItem]) || 'N/A';
              if (!acc[groupKey]) {
                  acc[groupKey] = [] as GenericItem[];
              }
              acc[groupKey].push(item);
              return acc;
          }, {} as Record<string, GenericItem[]>);
        }, [items, groupBy, viewMode]);

        const renderViewForData = useCallback((data: GenericItem[]) => {
          switch (viewMode) {
              case 'table': return <TableView data={data} />;
              case 'cards': return <CardView data={data} />;
              case 'grid': return <CardView data={data} isGrid />;
              case 'list': default: return <ListView data={data} />;
          }
        }, [viewMode]);

        const renderContent = () => {
          if (isInitialLoading) {
            return <AnimatedLoadingSkeleton viewMode={viewMode} />;
          }

          if (viewMode === 'calendar') {
              return <CalendarView data={items} />;
          }

          if (viewMode === 'kanban') {
              return groupedData ? (
                <KanbanView data={groupedData} />
              ) : (
                <div className="flex items-center justify-center h-96 text-muted-foreground">
                  Group data by a metric to use the Kanban view.
                </div>
              );
          }
          
          if (items.length === 0 && !isInitialLoading) {
              return <EmptyState />;
          }
          
          // This will be expanded later to handle group tabs
          return renderViewForData(items);
        };

        return (
          <DynamicViewProvider viewConfig={viewConfig} {...rest}>
            <div className="space-y-6">
                <div className="space-y-4">
                    <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-4">
                        <div className="flex-1">
                            {rest.renderHeaderControls ? rest.renderHeaderControls() : (
                                <>
                                    <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                                    <p className="text-muted-foreground">
                                        {isInitialLoading 
                                            ? "Loading projects..." 
                                            : `Showing ${items.length} of ${rest.totalItemCount} item(s)`}
                                    </p>
                                </>
                            )}
                        </div>
                        <ViewModeSelector />
                    </div>
                    <ViewControls />
                </div>

                {rest.renderStats && !isInitialLoading && rest.renderStats()}
                
                <div className="min-h-[500px]">
                    {renderContent()}
                </div>
            </div>
          </DynamicViewProvider>
        );
      }
    patchStrategy: replace
  - type: write
    path: src/features/dynamic-view/DynamicViewContext.tsx
    content: >+
      --- src/features/dynamic-view/DynamicViewContext.tsx

      +++ src/features/dynamic-view/DynamicViewContext.tsx

      @@ -1,40 +1,50 @@
       import { createContext, useContext, useMemo, type ReactNode } from 'react';
      -import type { ViewConfig, GenericItem } from './types';

      +import type { ViewConfig, GenericItem, ViewMode, FilterConfig, SortConfig
      } from './types';
       
      -interface DynamicViewContextProps {

      +export interface DynamicViewContextProps {
         config: ViewConfig;
         data: GenericItem[];
         getFieldDef: (fieldId: string) => ViewConfig['fields'][number] | undefined;
      +

      +  // Data & State from parent

      +  items: GenericItem[];

      +  isLoading: boolean;

      +  isInitialLoading: boolean;

      +  totalItemCount: number;

      +  hasMore: boolean;

      +

      +  // Controlled State Props from parent

      +  viewMode: ViewMode;

      +  filters: FilterConfig;

      +  sortConfig: SortConfig | null;

      +  groupBy: string;

      +  activeGroupTab: string;

      +  page: number;

      +  selectedItemId?: string;

      +

      +  // Callbacks to parent

      +  onViewModeChange: (mode: ViewMode) => void;

      +  onFiltersChange: (filters: FilterConfig) => void;

      +  onSortChange: (sort: SortConfig | null) => void;

      +  onGroupByChange: (group: string) => void;

      +  onActiveGroupTabChange: (tab: string) => void;

      +  onPageChange: (page: number) => void;

      +  onItemSelect: (item: GenericItem) => void;
       }
       
       const DynamicViewContext = createContext<DynamicViewContextProps | null>(null);
       
      -interface DynamicViewProviderProps {

      -  viewConfig: ViewConfig;

      -  data: GenericItem[];

      +interface DynamicViewProviderProps extends Omit<DynamicViewContextProps,
      'getFieldDef' | 'config' | 'data'> {

      +  viewConfig: ViewConfig,
         children: ReactNode;
       }
       
      -export function DynamicViewProvider({ viewConfig, data, children }:
      DynamicViewProviderProps) {

      +export function DynamicViewProvider({ viewConfig, children, ...rest }:
      DynamicViewProviderProps) {
         const fieldDefsById = useMemo(() => {
           return new Map(viewConfig.fields.map(field => [field.id, field]));
         }, [viewConfig.fields]);
       
         const getFieldDef = (fieldId: string) => {
           return fieldDefsById.get(fieldId);
         };
       
      -  const value = useMemo(() => ({

      -    config: viewConfig,

      -    data,

      -    getFieldDef,

      -  }), [viewConfig, data, getFieldDef]);

      +  const value = useMemo(() => ({

      +    ...rest,

      +    config: viewConfig,

      +    data: rest.items, // alias for convenience

      +    getFieldDef,

      +  }), [viewConfig, getFieldDef, rest]);
       
         return (
           <DynamicViewContext.Provider value={value}>

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ -9,22 +9,13 @@
         CheckCircle,
         Clock,
         Archive,
      -  PlusCircle

      +  PlusCircle,
       } from 'lucide-react'
       import { gsap } from 'gsap'
      -import { DynamicViewProvider } from
      '@/features/dynamic-view/DynamicViewContext'

      +import { DynamicView } from '@/features/dynamic-view/DynamicView'
       import { PageLayout } from '@/components/shared/PageLayout'
       import { useScrollToBottom } from '@/hooks/useScrollToBottom.hook';
       import { ScrollToBottomButton } from '@/components/shared/ScrollToBottomButton';
      -import { ListView } from
      '@/features/dynamic-view/components/views/ListView'

      -import { CardView } from
      '@/features/dynamic-view/components/views/CardView'

      -import { TableView } from
      '@/features/dynamic-view/components/views/TableView'

      -import { KanbanView } from
      '@/features/dynamic-view/components/views/KanbanView'

      -import { CalendarView } from
      '@/features/dynamic-view/components/views/CalendarView'

      -import { ViewModeSelector } from
      '@/features/dynamic-view/components/controls/ViewModeSelector'

      -import { AnimatedTabs } from '@/components/ui/animated-tabs'
       import { StatCard } from '@/components/shared/StatCard'
      -import { AnimatedLoadingSkeleton } from
      '@/features/dynamic-view/components/shared/AnimatedLoadingSkeleton'

      -import { ViewControls } from
      '@/features/dynamic-view/components/controls/ViewControls'
       import { mockDataItems } from './data/mockData'
      -import type { GroupableField, GenericItem } from
      '@/features/dynamic-view/types'

      +import type { GenericItem } from '@/features/dynamic-view/types'
       import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
       import { useAutoAnimateStats } from './hooks/useAutoAnimateStats.hook'
       import { useDataDemoStore } from './store/dataDemo.store'
      -import { capitalize, cn } from '@/lib/utils';

      -import { Badge } from '@/components/ui/badge';
       import { 
       } from './store/dataDemo.store'
       
      @@ -51,6 +42,7 @@
           viewMode,
           groupBy,
           activeGroupTab,
      +    setActiveGroupTab,
           setGroupBy,
           setSort,
           setActiveGroupTab,
      @@ -58,6 +50,9 @@
           filters,
           sortConfig,
           setPage,
      +    setFilters,

      +    setViewMode,

      +    onItemSelect,
         } = useAppViewManager();
       
         const { items: allItems, hasMore, isLoading, isInitialLoading, totalItemCount, loadData } = useDataDemoStore(state => ({
      @@ -69,59 +64,12 @@
           loadData: state.loadData,
         }));
       
      -  // --- Start of logic moved from store selectors ---

      -  const groupTabs = useMemo(() => {

      -    if (groupBy === 'none' || !allItems.length) return [];

      -    

      -    const groupCounts = allItems.reduce((acc, item) => {

      -        const groupKey = String(item[groupBy as GroupableField]);

      -        acc[groupKey] = (acc[groupKey] || 0) + 1;

      -        return acc;

      -    }, {} as Record<string, number>);

      -

      -    const sortedGroups = Object.keys(groupCounts).sort((a, b) =>
      a.localeCompare(b));

      -

      -    const createLabel = (text: string, count: number, isActive: boolean):
      ReactNode => (

      -        <>

      -            {text}

      -            <Badge variant={isActive ? 'default' : 'secondary'}
      className={cn('transition-colors duration-300 text-xs font-semibold',
      !isActive && 'group-hover:bg-accent group-hover:text-accent-foreground')}>

      -                {count}

      -            </Badge>

      -        </>

      -    );

      -    

      -    const totalCount = allItems.length;

      -

      -    return [

      -        { id: 'all', label: createLabel('All', totalCount, activeGroupTab
      === 'all') },

      -        ...sortedGroups.map((g) => ({

      -            id: g,

      -            label: createLabel(capitalize(g), groupCounts[g],
      activeGroupTab === g),

      -        })),

      -    ];

      -  }, [allItems, groupBy, activeGroupTab]);

      -

      -  const groupedData = useMemo(() => {

      -    if (groupBy === 'none') {

      -        return null;

      -    }

      -    return allItems.reduce((acc, item) => {

      -        const groupKey = String(item[groupBy as GroupableField]) ||
      'N/A';

      -        if (!acc[groupKey]) {

      -            acc[groupKey] = [] as GenericItem[];

      -        }

      -        acc[groupKey].push(item);

      -        return acc;

      -    }, {} as Record<string, GenericItem[]>);

      -  }, [allItems, groupBy]);

      -  const dataToRender = useMemo(() => {

      -    if (groupBy === 'none' || activeGroupTab === 'all' || !groupedData) {

      -      return allItems;

      -    }

      -    return groupedData[activeGroupTab] || [];

      -  }, [groupBy, activeGroupTab, allItems, groupedData]);

      -  // --- End of logic moved from store selectors ---

      -

      -
         const statsRef = useRef<HTMLDivElement>(null)
         const scrollRef = useRef<HTMLDivElement>(null);
       
         // Note: The `DynamicViewProvider` needs `GenericItem[]`. 
         // Our store uses `GenericItem` so no cast is needed.
      -  const genericItems: GenericItem[] = allItems;
         // Auto-hide stats container on scroll down
         useAutoAnimateStats(scrollRef, statsRef);
       
      @@ -235,82 +183,49 @@
           [isLoading, hasMore, page, setPage],
         );
         
      -  // Auto-group by status when switching to kanban view for the first
      time
         useEffect(() => {
      +    // Auto-group by status when switching to kanban view for the first
      time
           if (viewMode === 'kanban' && groupBy === 'none') {
             setGroupBy('status');
             setSort(null); // Kanban is manually sorted, so disable programmatic sort
           }
           // For calendar view, we don't want grouping.
      -    if (viewMode === 'calendar' && groupBy !== 'none') {

      +    else if (viewMode === 'calendar' && groupBy !== 'none') {
             setGroupBy('none');
           }
         }, [viewMode, groupBy, setGroupBy, setSort]);
       
      -  const renderViewForData = useCallback((data: GenericItem[]) => {

      -    const items = data as GenericItem[];

      -    switch (viewMode) {

      -        case 'table': return <TableView data={items} />;

      -        case 'cards': return <CardView data={items} />;

      -        case 'calendar': return null; // Calendar has its own render path
      below

      -        case 'kanban': return null; // Kanban has its own render path
      below

      -        case 'grid': return <CardView data={items} isGrid />;

      -        case 'list': default: return <ListView data={items} />;

      -    }

      -  }, [viewMode]);

      -

      -  const isGroupedView = useMemo(() => 

      -    groupBy !== 'none' && groupTabs.length > 1 && groupedData,

      -  [groupBy, groupTabs.length, groupedData]);

      -

      -
         return (
      -    <DynamicViewProvider viewConfig={dataDemoViewConfig}
      data={genericItems}>

      -      <PageLayout

      -        scrollRef={scrollRef}

      -        onScroll={handleScroll}

      -      >

      -        <div className="space-y-6">

      -          {/* Header */}

      -          <div className="space-y-4">

      -            <div className="flex flex-col md:flex-row md:items-start
      md:justify-between gap-4">

      -              <div className="flex-1">

      -                <h1 className="text-2xl font-bold tracking-tight">Data
      Showcase</h1>

      -                <p className="text-muted-foreground">

      -                  {isInitialLoading 

      -                    ? "Loading projects..." 

      -                    : `Showing ${dataToRender.length} of
      ${totalItemCount} item(s)`}

      -                </p>

      -              </div>

      -              <ViewModeSelector />

      -            </div>

      -            <ViewControls />

      -          </div>

      -

      -          {/* Stats Section */}

      -          {!isInitialLoading && (

      -            <div ref={statsRef} className="flex overflow-x-auto gap-6
      pb-4 no-scrollbar">

      -              {stats.map((stat) => (

      -                <StatCard

      -                  className="w-64 md:w-72 flex-shrink-0"

      -                  key={stat.title}

      -                  title={stat.title}

      -                  value={stat.value}

      -                  change={stat.change}

      -                  trend={stat.trend}

      -                  icon={stat.icon}

      -                  chartData={stat.type === 'chart' ? stat.chartData :
      undefined}

      -                />

      -              ))}

      -            </div>

      -          )}

      -

      -        <div className="min-h-[500px]">

      -          {isInitialLoading ? (

      -            <AnimatedLoadingSkeleton viewMode={viewMode} />

      -          ) : viewMode === 'calendar' ? (

      -            <CalendarView data={genericItems} />

      -          ) : viewMode === 'kanban' ? (

      -            isGroupedView ? (

      -              <KanbanView data={groupedData as Record<string,
      GenericItem[]>} />

      -            ) : (

      -              <div className="flex items-center justify-center h-96
      text-muted-foreground">

      -                Group data by a metric to use the Kanban view.

      -              </div>

      -            )

      -          ) : !isGroupedView ? (

      -            renderViewForData(allItems)

      -          ) : (

      -            // Grouped view with AnimatedTabs

      -            <div className="relative">

      -              <AnimatedTabs

      -                tabs={groupTabs}

      -                activeTab={activeGroupTab}

      -                onTabChange={setActiveGroupTab}

      -                wrapperClassName="flex flex-col"

      -                className="border-b"

      -                contentClassName="pt-6 flex-grow"

      -              >

      -                {groupTabs.map(tab => (

      -                  <div key={tab.id} className="min-h-[440px]">

      -                    {renderViewForData(

      -                      tab.id === 'all' ? allItems : groupedData?.[tab.id]
      || []

      -                    )}

      -                  </div>

      -                ))}

      -              </AnimatedTabs>

      -            </div>

      -          )}

      -        </div>

      +    <PageLayout

      +      scrollRef={scrollRef}

      +      onScroll={handleScroll}

      +    >

      +      <DynamicView

      +        viewConfig={dataDemoViewConfig}

      +        items={allItems as GenericItem[]}

      +        isLoading={isLoading}

      +        isInitialLoading={isInitialLoading}

      +        totalItemCount={totalItemCount}

      +        hasMore={hasMore}

      +        // Controlled state

      +        viewMode={viewMode}

      +        filters={filters}

      +        sortConfig={sortConfig}

      +        groupBy={groupBy}

      +        activeGroupTab={activeGroupTab}

      +        page={page}

      +        // Callbacks

      +        onViewModeChange={setViewMode}

      +        onFiltersChange={setFilters}

      +        onSortChange={setSort}

      +        onGroupByChange={setGroupBy}

      +        onActiveGroupTabChange={setActiveGroupTab}

      +        onPageChange={setPage}

      +        onItemSelect={onItemSelect}

      +        // Custom Renderers

      +        renderStats={() => (

      +          <div ref={statsRef} className="flex overflow-x-auto gap-6 pb-4
      no-scrollbar">

      +            {stats.map((stat) => (

      +              <StatCard

      +                className="w-64 md:w-72 flex-shrink-0"

      +                key={stat.title}

      +                title={stat.title}

      +                value={stat.value}

      +                change={stat.change}

      +                trend={stat.trend}

      +                icon={stat.icon}

      +                chartData={stat.type === 'chart' ? stat.chartData :
      undefined}

      +              />

      +            ))}

      +          </div>

      +        )}

      +      />
       
               {/* Loader for infinite scroll */}
               <div ref={loaderRef} className="flex justify-center items-center py-6">
      @@ -321,12 +236,10 @@
                     <span>Loading more...</span>
                   </div>
                 )}
      -          {!isLoading && !hasMore && dataToRender.length > 0 &&
      !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' &&
      viewMode !== 'kanban' && (

      +          {!isLoading && !hasMore && allItems.length > 0 &&
      !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' &&
      viewMode !== 'kanban' && (
                   <p className="text-muted-foreground">You've reached the end.</p>
                 )}
               </div>
      -      </div>

      -        <ScrollToBottomButton isVisible={showScrollToBottom}
      onClick={scrollToBottom} />

      -      </PageLayout>

      -    </DynamicViewProvider>

      +      <ScrollToBottomButton isVisible={showScrollToBottom}
      onClick={scrollToBottom} />

      +    </PageLayout>
         );
       }
    patchStrategy: standard-diff
snapshot:
  src/features/dynamic-view/DynamicView.tsx: null
  src/pages/DataDemo/index.tsx: >-
    import { useRef, useEffect, useCallback, useMemo, type ReactNode } from
    'react'

    import {
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      Loader2,
      TrendingUp,
      CheckCircle,
      Clock,
      Archive,
      PlusCircle
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { DynamicViewProvider } from
    '@/features/dynamic-view/DynamicViewContext'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { useScrollToBottom } from '@/hooks/useScrollToBottom.hook';

    import { ScrollToBottomButton } from
    '@/components/shared/ScrollToBottomButton';

    import { ListView } from '@/features/dynamic-view/components/views/ListView'

    import { CardView } from '@/features/dynamic-view/components/views/CardView'

    import { TableView } from
    '@/features/dynamic-view/components/views/TableView'

    import { KanbanView } from
    '@/features/dynamic-view/components/views/KanbanView'

    import { CalendarView } from
    '@/features/dynamic-view/components/views/CalendarView'

    import { ViewModeSelector } from
    '@/features/dynamic-view/components/controls/ViewModeSelector'

    import { AnimatedTabs } from '@/components/ui/animated-tabs'

    import { StatCard } from '@/components/shared/StatCard'

    import { AnimatedLoadingSkeleton } from
    '@/features/dynamic-view/components/shared/AnimatedLoadingSkeleton'

    import { ViewControls } from
    '@/features/dynamic-view/components/controls/ViewControls'

    import { mockDataItems } from './data/mockData'

    import type { GroupableField, GenericItem } from
    '@/features/dynamic-view/types'

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook'

    import { useAutoAnimateStats } from './hooks/useAutoAnimateStats.hook'

    import { useDataDemoStore } from './store/dataDemo.store'

    import { capitalize, cn } from '@/lib/utils';

    import { Badge } from '@/components/ui/badge';

    import { 

    } from './store/dataDemo.store'


    import { dataDemoViewConfig } from './DataDemo.config';


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    export default function DataDemoPage() {
      const {
        viewMode,
        groupBy,
        activeGroupTab,
        setGroupBy,
        setSort,
        setActiveGroupTab,
        page,
        filters,
        sortConfig,
        setPage,
      } = useAppViewManager();

      const { items: allItems, hasMore, isLoading, isInitialLoading, totalItemCount, loadData } = useDataDemoStore(state => ({
        items: state.items,
        hasMore: state.hasMore,
        isLoading: state.isLoading,
        isInitialLoading: state.isInitialLoading,
        totalItemCount: state.totalItemCount,
        loadData: state.loadData,
      }));

      // --- Start of logic moved from store selectors ---
      const groupTabs = useMemo(() => {
        if (groupBy === 'none' || !allItems.length) return [];
        
        const groupCounts = allItems.reduce((acc, item) => {
            const groupKey = String(item[groupBy as GroupableField]);
            acc[groupKey] = (acc[groupKey] || 0) + 1;
            return acc;
        }, {} as Record<string, number>);

        const sortedGroups = Object.keys(groupCounts).sort((a, b) => a.localeCompare(b));

        const createLabel = (text: string, count: number, isActive: boolean): ReactNode => (
            <>
                {text}
                <Badge variant={isActive ? 'default' : 'secondary'} className={cn('transition-colors duration-300 text-xs font-semibold', !isActive && 'group-hover:bg-accent group-hover:text-accent-foreground')}>
                    {count}
                </Badge>
            </>
        );
        
        const totalCount = allItems.length;

        return [
            { id: 'all', label: createLabel('All', totalCount, activeGroupTab === 'all') },
            ...sortedGroups.map((g) => ({
                id: g,
                label: createLabel(capitalize(g), groupCounts[g], activeGroupTab === g),
            })),
        ];
      }, [allItems, groupBy, activeGroupTab]);

      const groupedData = useMemo(() => {
        if (groupBy === 'none') {
            return null;
        }
        return allItems.reduce((acc, item) => {
            const groupKey = String(item[groupBy as GroupableField]) || 'N/A';
            if (!acc[groupKey]) {
                acc[groupKey] = [] as GenericItem[];
            }
            acc[groupKey].push(item);
            return acc;
        }, {} as Record<string, GenericItem[]>);
      }, [allItems, groupBy]);
      const dataToRender = useMemo(() => {
        if (groupBy === 'none' || activeGroupTab === 'all' || !groupedData) {
          return allItems;
        }
        return groupedData[activeGroupTab] || [];
      }, [groupBy, activeGroupTab, allItems, groupedData]);
      // --- End of logic moved from store selectors ---


      const statsRef = useRef<HTMLDivElement>(null)
      const scrollRef = useRef<HTMLDivElement>(null);

      // Note: The `DynamicViewProvider` needs `GenericItem[]`. 
      // Our store uses `GenericItem` so no cast is needed.
      const genericItems: GenericItem[] = allItems;
      // Auto-hide stats container on scroll down
      useAutoAnimateStats(scrollRef, statsRef);

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const { showScrollToBottom, scrollToBottom, handleScroll } = useScrollToBottom(scrollRef);

      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78],
        },
        {
          title: "Completion Rate",
          value: "88%",
          icon: <CheckCircle className="w-5 h-5" />,
          change: "+1.5% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [80, 82, 81, 84, 85, 87, 88],
        },
        {
          title: "Overdue Items",
          value: "8",
          icon: <Clock className="w-5 h-5" />,
          change: "-3 this week",
          trend: "down" as const,
        },
        {
          title: "New This Week",
          value: "12",
          icon: <PlusCircle className="w-5 h-5" />,
          change: "+2 from last week",
          trend: "up" as const,
        },
        {
          title: "Archived Projects",
          value: "153",
          icon: <Archive className="w-5 h-5" />,
          change: "+20 this month",
          trend: "up" as const,
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.5,
              y: 0,
              opacity: 1,
              stagger: 0.08,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading]);

      useEffect(() => {
        loadData({
          page,
          groupBy,
          filters,
          sortConfig,
          isFullLoad: viewMode === 'calendar' || viewMode === 'kanban',
        });
      }, [page, groupBy, filters, sortConfig, loadData, viewMode]);

      const observer = useRef<IntersectionObserver>();
      const loaderRef = useCallback(
        (node: Element | null) => {
          if (isLoading) return;
          if (observer.current) observer.current.disconnect();

          observer.current = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore) {
              setPage(page + 1);
            }
          });
          if (node) observer.current.observe(node);
        },
        [isLoading, hasMore, page, setPage],
      );
      
      // Auto-group by status when switching to kanban view for the first time
      useEffect(() => {
        if (viewMode === 'kanban' && groupBy === 'none') {
          setGroupBy('status');
          setSort(null); // Kanban is manually sorted, so disable programmatic sort
        }
        // For calendar view, we don't want grouping.
        if (viewMode === 'calendar' && groupBy !== 'none') {
          setGroupBy('none');
        }
      }, [viewMode, groupBy, setGroupBy, setSort]);

      const renderViewForData = useCallback((data: GenericItem[]) => {
        const items = data as GenericItem[];
        switch (viewMode) {
            case 'table': return <TableView data={items} />;
            case 'cards': return <CardView data={items} />;
            case 'calendar': return null; // Calendar has its own render path below
            case 'kanban': return null; // Kanban has its own render path below
            case 'grid': return <CardView data={items} isGrid />;
            case 'list': default: return <ListView data={items} />;
        }
      }, [viewMode]);

      const isGroupedView = useMemo(() => 
        groupBy !== 'none' && groupTabs.length > 1 && groupedData,
      [groupBy, groupTabs.length, groupedData]);


      return (
        <DynamicViewProvider viewConfig={dataDemoViewConfig} data={genericItems}>
          <PageLayout
            scrollRef={scrollRef}
            onScroll={handleScroll}
          >
            <div className="space-y-6">
              {/* Header */}
              <div className="space-y-4">
                <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-4">
                  <div className="flex-1">
                    <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                    <p className="text-muted-foreground">
                      {isInitialLoading 
                        ? "Loading projects..." 
                        : `Showing ${dataToRender.length} of ${totalItemCount} item(s)`}
                    </p>
                  </div>
                  <ViewModeSelector />
                </div>
                <ViewControls />
              </div>

              {/* Stats Section */}
              {!isInitialLoading && (
                <div ref={statsRef} className="flex overflow-x-auto gap-6 pb-4 no-scrollbar">
                  {stats.map((stat) => (
                    <StatCard
                      className="w-64 md:w-72 flex-shrink-0"
                      key={stat.title}
                      title={stat.title}
                      value={stat.value}
                      change={stat.change}
                      trend={stat.trend}
                      icon={stat.icon}
                      chartData={stat.type === 'chart' ? stat.chartData : undefined}
                    />
                  ))}
                </div>
              )}

            <div className="min-h-[500px]">
              {isInitialLoading ? (
                <AnimatedLoadingSkeleton viewMode={viewMode} />
              ) : viewMode === 'calendar' ? (
                <CalendarView data={genericItems} />
              ) : viewMode === 'kanban' ? (
                isGroupedView ? (
                  <KanbanView data={groupedData as Record<string, GenericItem[]>} />
                ) : (
                  <div className="flex items-center justify-center h-96 text-muted-foreground">
                    Group data by a metric to use the Kanban view.
                  </div>
                )
              ) : !isGroupedView ? (
                renderViewForData(allItems)
              ) : (
                // Grouped view with AnimatedTabs
                <div className="relative">
                  <AnimatedTabs
                    tabs={groupTabs}
                    activeTab={activeGroupTab}
                    onTabChange={setActiveGroupTab}
                    wrapperClassName="flex flex-col"
                    className="border-b"
                    contentClassName="pt-6 flex-grow"
                  >
                    {groupTabs.map(tab => (
                      <div key={tab.id} className="min-h-[440px]">
                        {renderViewForData(
                          tab.id === 'all' ? allItems : groupedData?.[tab.id] || []
                        )}
                      </div>
                    ))}
                  </AnimatedTabs>
                </div>
              )}
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && viewMode !== 'kanban' && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && dataToRender.length > 0 && !isInitialLoading && groupBy === 'none' && viewMode !== 'calendar' && viewMode !== 'kanban' && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>
            <ScrollToBottomButton isVisible={showScrollToBottom} onClick={scrollToBottom} />
          </PageLayout>
        </DynamicViewProvider>
      );
    }
  src/features/dynamic-view/DynamicViewContext.tsx: >-
    import { createContext, useContext, useMemo, type ReactNode } from 'react';

    import type { ViewConfig, GenericItem } from './types';


    interface DynamicViewContextProps {
      config: ViewConfig;
      data: GenericItem[];
      getFieldDef: (fieldId: string) => ViewConfig['fields'][number] | undefined;
    }


    const DynamicViewContext = createContext<DynamicViewContextProps |
    null>(null);


    interface DynamicViewProviderProps {
      viewConfig: ViewConfig;
      data: GenericItem[];
      children: ReactNode;
    }


    export function DynamicViewProvider({ viewConfig, data, children }:
    DynamicViewProviderProps) {
      const fieldDefsById = useMemo(() => {
        return new Map(viewConfig.fields.map(field => [field.id, field]));
      }, [viewConfig.fields]);

      const getFieldDef = (fieldId: string) => {
        return fieldDefsById.get(fieldId);
      };

      const value = useMemo(() => ({
        config: viewConfig,
        data,
        getFieldDef,
      }), [viewConfig, data, getFieldDef]);

      return (
        <DynamicViewContext.Provider value={value}>
          {children}
        </DynamicViewContext.Provider>
      );
    }


    export function useDynamicView() {
      const context = useContext(DynamicViewContext);
      if (!context) {
        throw new Error('useDynamicView must be used within a DynamicViewProvider');
      }
      return context;
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 525
