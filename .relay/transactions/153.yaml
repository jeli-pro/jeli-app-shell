uuid: d896dfa3-2895-46aa-a182-3d75fd4735c0
projectId: jeli-app-shell
createdAt: '2025-10-12T04:45:54.885Z'
gitCommitMsg: >-
  fix(layout): Adjust ViewModeSwitcher position in split view

  In split view mode, the per-pane ViewModeSwitcher components were statically
  positioned at `top-4`, causing them to appear inside the top bar when it was
  visible.

  This commit makes their vertical position dynamic. They are now positioned
  lower when the top bar is visible (`top-24`) and in their original position
  when it is hidden. A transition is also added to animate this change smoothly,
  improving the user experience. A minor typo in component destructuring was
  also fixed.
promptSummary: I was asked to provide only the final YAML block for the previous change.
reasoning:
  - >-
    Based on your request, I've identified that the per-pane `ViewModeSwitcher`
    components in split view mode are positioned incorrectly, causing them to
    appear within the top bar area. This happens because their vertical position
    is static and doesn't account for the top bar's height.
  - >-
    To fix this, I will make the following changes to
    `src/components/layout/AppShell.tsx`:
  - 1.  I'll access the `isTopBarVisible` state from the `useAppShell` hook.
  - >-
    2.  I'll dynamically adjust the `top` positioning of the pane-specific
    `ViewModeSwitcher`s. They will be positioned lower when the top bar is
    visible and higher up when it's hidden.
  - 3.  I'll add a CSS transition to make this position change smooth.
  - >-
    4.  Finally, I'll correct a minor typo in the destructuring within the same
    component.
  - 'Here is the patch:'
  - >-
    This change ensures the `ViewModeSwitcher` is always positioned correctly
    relative to the visible content area, whether the top bar is shown or
    hidden, providing a much cleaner user experience in split view.
operations:
  - type: write
    path: src/components/layout/AppShell.tsx
    content: >+
      --- src/components/layout/AppShell.tsx

      +++ src/components/layout/AppShell.tsx

      @@ -29,12 +29,13 @@
           hoveredPane,
           peekSidebar,
           draggedPage,
           dragHoverTarget,
      -    toggleSplitView,    bodyState,

      +    toggleSplitView,

      +    bodyState,
           sidePaneContent,
           closeSidePane,
           reducedMotion,
      +    isTopBarVisible,
         } = useAppShell();
         
         const { isDarkMode, toggleDarkMode, handleNavigation, activePage } = useAppStore();
      @@ -213,9 +214,9 @@
                       )}
                     </div>
                     {mainContentWithProps}
                     {isSplitView && hoveredPane === 'left' && !draggedPage && (
      -                <div className="absolute top-4 right-4 z-50">

      +                <div className={cn("absolute right-4 z-50
      transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                         <ViewModeSwitcher pane="main" />
                       </div>
                     )}
                     {/* Right drop overlay (over main area, ONLY when NOT in split view) */}
      @@ -257,9 +258,9 @@
                           )}
                         </div>
                       )}
                       {hoveredPane === 'right' && !draggedPage && (
      -                  <div className="absolute top-4 right-4 z-[70]">

      +                  <div className={cn("absolute right-4 z-[70]
      transition-all", isTopBarVisible ? 'top-24' : 'top-4')}>
                           <ViewModeSwitcher pane="right" />
                         </div>
                       )}
                     </div>

    patchStrategy: standard-diff
snapshot:
  src/components/layout/AppShell.tsx: >-
    import React, { useRef, type ReactElement, useCallback, useEffect,
    useLayoutEffect } from 'react'

    import { cn } from '@/lib/utils'

    import { gsap } from 'gsap';

    import { CommandPalette } from '@/components/global/CommandPalette';

    import { useAppStore } from '@/store/appStore';

    import { useAppShell } from '@/context/AppShellContext';

    import { SIDEBAR_STATES, BODY_STATES } from '@/lib/utils'

    import { useResizableSidebar, useResizableRightPane } from
    '@/hooks/useResizablePanes.hook'

    import { useSidebarAnimations, useBodyStateAnimations } from
    '@/hooks/useAppShellAnimations.hook'

    import { ViewModeSwitcher } from './ViewModeSwitcher';


    interface AppShellProps {
      sidebar: ReactElement;
      topBar: ReactElement;
      mainContent: ReactElement;
      rightPane: ReactElement;
      commandPalette?: ReactElement;
    }


    const pageToPaneMap: Record<string, 'main' | 'settings' | 'toaster' |
    'notifications'> = {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
    };


    // Helper hook to get the previous value of a prop or state

    function usePrevious<T>(value: T): T | undefined {
      const ref = useRef<T>();
      useEffect(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }



    export function AppShell({ sidebar, topBar, mainContent, rightPane,
    commandPalette }: AppShellProps) {
      const {
        sidebarState,
        dispatch,
        autoExpandSidebar,
        toggleSidebar,
        hoveredPane,
        peekSidebar,
        draggedPage,
        dragHoverTarget,
        toggleSplitView,    bodyState,
        sidePaneContent,
        closeSidePane,
        reducedMotion,
      } = useAppShell();
      
      const { isDarkMode, toggleDarkMode, handleNavigation, activePage } = useAppStore();
      const appRef = useRef<HTMLDivElement>(null)
      const sidebarRef = useRef<HTMLDivElement>(null)
      const mainContentRef = useRef<HTMLDivElement>(null)
      const rightPaneRef = useRef<HTMLDivElement>(null)
      const resizeHandleRef = useRef<HTMLDivElement>(null)
      const topBarContainerRef = useRef<HTMLDivElement>(null)
      const mainAreaRef = useRef<HTMLDivElement>(null)

      const prevActivePage = usePrevious(activePage);
      const prevSidePaneContent = usePrevious(sidePaneContent);

      const isSplitView = bodyState === BODY_STATES.SPLIT_VIEW;

      // Custom hooks for logic
      useResizableSidebar(sidebarRef, resizeHandleRef);
      useResizableRightPane();
      useSidebarAnimations(sidebarRef, resizeHandleRef);
      useBodyStateAnimations(appRef, mainContentRef, rightPaneRef, topBarContainerRef, mainAreaRef);
      
      // Animation for pane swapping
      useLayoutEffect(() => {
        if (reducedMotion || bodyState !== BODY_STATES.SPLIT_VIEW || !prevActivePage || !prevSidePaneContent) {
          return;
        }

        const pageForPrevSidePane = Object.keys(pageToPaneMap).find(
          key => pageToPaneMap[key as keyof typeof pageToPaneMap] === prevSidePaneContent
        );

        // Check if a swap occurred by comparing current state with previous state
        if (activePage === pageForPrevSidePane && sidePaneContent === pageToPaneMap[prevActivePage as keyof typeof pageToPaneMap]) {
          const mainEl = mainAreaRef.current;
          const rightEl = rightPaneRef.current;

          if (mainEl && rightEl) {
            const mainWidth = mainEl.offsetWidth;
            const rightWidth = rightEl.offsetWidth;

            const tl = gsap.timeline();
            
            // Animate main content FROM where right pane was TO its new place
            tl.from(mainEl, {
              x: rightWidth, duration: 0.4, ease: 'power3.inOut'
            });

            // Animate right pane FROM where main content was TO its new place
            tl.from(rightEl, {
              x: -mainWidth, duration: 0.4, ease: 'power3.inOut'
            }, 0); // Start at the same time
          }
        }
      }, [activePage, sidePaneContent, bodyState, prevActivePage, prevSidePaneContent, reducedMotion]);
      
      const sidebarWithProps = React.cloneElement(sidebar, { 
        ref: sidebarRef,
        onMouseEnter: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.COLLAPSED) {
            peekSidebar()
          }
        },
        onMouseLeave: () => {
          if (autoExpandSidebar && sidebarState === SIDEBAR_STATES.PEEK) {
            dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
          }
        }
      });

      const topBarWithProps = React.cloneElement(topBar, {
        onToggleSidebar: toggleSidebar,
        onToggleDarkMode: toggleDarkMode,
      });

      const mainContentWithProps = React.cloneElement(mainContent, {
        ref: mainContentRef,
      });

      const rightPaneWithProps = React.cloneElement(rightPane, { ref: rightPaneRef });

      // Drag and drop handlers for docking
      const handleDragOverLeft = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'left') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'left' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropLeft = useCallback(() => {
        if (!draggedPage) return;
        
        const originalActivePage = activePage;
        const originalActivePagePaneContent = pageToPaneMap[originalActivePage];

        // If we drop the page that's already in the side pane, just make it the main view.
        const paneContentOfDraggedPage = pageToPaneMap[draggedPage];
        if (paneContentOfDraggedPage === sidePaneContent && (bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW)) {
          closeSidePane();
          handleNavigation(draggedPage);
        } 
        // New context-aware logic: if we are in normal view and drop a NEW page on the left
        else if (bodyState === BODY_STATES.NORMAL && draggedPage !== originalActivePage) {
            if (originalActivePagePaneContent) {
                // 1. Set the right pane content to be the original page
                dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: originalActivePagePaneContent });
                // 2. Set the main page to be the new dragged page
                handleNavigation(draggedPage);
                // 3. Switch to split view
                dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
            } else {
                // Fallback for pages that can't be in a pane
                handleNavigation(draggedPage);
            }
        } else { // Default behavior: just make the dropped page the main one
          handleNavigation(draggedPage);
        }
        
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, activePage, bodyState, sidePaneContent, handleNavigation, dispatch, closeSidePane]);

      const handleDragOverRight = useCallback((e: React.DragEvent) => {
        if (!draggedPage) return;
        e.preventDefault();
        if (dragHoverTarget !== 'right') {
          dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: 'right' });
        }
      }, [draggedPage, dragHoverTarget, dispatch]);

      const handleDropRight = useCallback(() => {
        if (!draggedPage) return;
        const pane = pageToPaneMap[draggedPage as keyof typeof pageToPaneMap];
        if (pane) {
          // If dropping the currently active page to the right,
          // set a default page (e.g., dashboard) as the new active page.
          if (draggedPage === activePage) {
            handleNavigation('dashboard');
          }

          // Set the right pane content and ensure split view
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: pane });
          if (bodyState === BODY_STATES.NORMAL) {
            toggleSplitView(pane);
          } else if (bodyState === BODY_STATES.SIDE_PANE) {
            toggleSplitView();
          }
        }
        dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
        dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
      }, [draggedPage, toggleSplitView, dispatch, bodyState, activePage, handleNavigation]);

      return (
        <div 
          ref={appRef}
          className={cn(
            "relative h-screen w-screen overflow-hidden bg-background transition-colors duration-300",
            isDarkMode && "dark"
          )}
        >
          <div className="flex h-screen overflow-hidden">
            {/* Enhanced Sidebar */}
            {sidebarWithProps}

            {/* Resize Handle */}
            {sidebarState !== SIDEBAR_STATES.HIDDEN && (
              <div
                ref={resizeHandleRef}
                className={cn(
                  "absolute top-0 w-2 h-full bg-transparent hover:bg-primary/20 cursor-col-resize z-50 transition-colors duration-200 group -translate-x-1/2"
                )}
                onMouseDown={(e) => {
                  e.preventDefault()
                  dispatch({ type: 'SET_IS_RESIZING', payload: true });
                }}
              >
                <div className="w-0.5 h-full bg-border group-hover:bg-primary transition-colors duration-200 mx-auto" />
              </div>
            )}

            {/* Main area wrapper */}
            <div className="flex-1 flex flex-col overflow-hidden relative">
              <div
                ref={topBarContainerRef}
                className="absolute top-0 left-0 right-0 z-30"
                onMouseEnter={() => { if (isSplitView) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
              >
                {topBarWithProps}
              </div>

              <div className="flex flex-1 min-h-0">
                <div
                  ref={mainAreaRef}
                  className="relative flex-1 overflow-hidden bg-background"
                  onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'left' }); }}
                  onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                >
                  {/* Left drop overlay */}
                  <div
                    className={cn(
                      "absolute inset-y-0 left-0 z-40 border-2 border-transparent transition-all",
                      draggedPage
                        ? cn("pointer-events-auto", isSplitView ? 'w-full' : 'w-1/2')
                        : "pointer-events-none w-0",
                      dragHoverTarget === 'left' && "bg-primary/10 border-primary"
                    )}
                    onDragOver={handleDragOverLeft}
                    onDrop={handleDropLeft}
                    onDragLeave={() => {
                      if (dragHoverTarget === 'left') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                    }}
                  >
                    {draggedPage && dragHoverTarget === 'left' && (
                      <div className="absolute inset-0 flex items-center justify-center text-sm font-medium text-primary-foreground/80 pointer-events-none">
                        <span className="px-3 py-1 rounded-md bg-primary/70">{isSplitView ? 'Drop to Replace' : 'Drop to Left'}</span>
                      </div>
                    )}
                  </div>
                  {mainContentWithProps}
                  {isSplitView && hoveredPane === 'left' && !draggedPage && (
                    <div className="absolute top-4 right-4 z-50">
                      <ViewModeSwitcher pane="main" />
                    </div>
                  )}
                  {/* Right drop overlay (over main area, ONLY when NOT in split view) */}
                  {!isSplitView && (
                    <div
                      className={cn(
                        "absolute inset-y-0 right-0 z-40 border-2 border-transparent",
                        draggedPage ? "pointer-events-auto w-1/2" : "pointer-events-none",
                        dragHoverTarget === 'right' && "bg-primary/10 border-primary"
                      )}
                      onDragOver={handleDragOverRight}
                      onDrop={handleDropRight}
                      onDragLeave={() => {
                        if (dragHoverTarget === 'right') dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                      }}
                    >
                      {draggedPage && dragHoverTarget === 'right' && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                          <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">Drop to Right</span>
                        </div>
                      )}
                    </div>
                  )}
                </div>
                {isSplitView ? (
                  <div
                    className="relative"
                    onMouseEnter={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: 'right' }); }}
                    onMouseLeave={() => { if (isSplitView && !draggedPage) dispatch({ type: 'SET_HOVERED_PANE', payload: null }); }}
                    onDragOver={handleDragOverRight}
                  >
                    {rightPaneWithProps}
                    {draggedPage && (
                      <div
                        className={cn(
                          'absolute inset-0 z-50 transition-all',
                          dragHoverTarget === 'right'
                            ? 'bg-primary/10 border-2 border-primary'
                            : 'pointer-events-none'
                        )}
                        onDragLeave={() => {
                          if (dragHoverTarget === 'right')
                            dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
                        }}
                        onDrop={handleDropRight}
                        onDragOver={(e) => e.preventDefault()}
                      >
                        {dragHoverTarget === 'right' && (
                          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <span className="px-3 py-1 rounded-md bg-primary/70 text-sm font-medium text-primary-foreground/80">
                              Drop to Replace
                            </span>
                          </div>
                        )}
                      </div>
                    )}
                    {hoveredPane === 'right' && !draggedPage && (
                      <div className="absolute top-4 right-4 z-[70]">
                        <ViewModeSwitcher pane="right" />
                      </div>
                    )}
                  </div>
                ) : rightPaneWithProps}
              </div>
            </div>
          </div>
          {commandPalette || <CommandPalette />}
        </div>
      )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-10-12T04:55:36.866Z'
status: committed
id: 153
