uuid: 7d9e2f1a-5b4c-4d3e-9f8a-1b2c3d4e5f6b
projectId: jeli-app-shell
createdAt: '2025-10-21T11:10:32.015Z'
gitCommitMsg: 'fix(dynamic-view): resolve type errors in generic refactor'
promptSummary: >-
  Fix type errors in DynamicView refactor (generics, readonly config, and strict
  data types).
reasoning:
  - >-
    Hello! It looks like we're 90% of the way there, but the strict type checks
    have caught a few loose ends. This is exactly what we wanted â€” finding these
    issues now rather than at runtime.
  - Here are the fixes to get everything compiling perfectly.
  - '### 1. Update `ViewConfig` Types to accept `readonly` arrays'
  - >-
    To make `as const` work seamlessly in our config files (which is the best
    way to infer narrow types for field IDs), we need to ensure our master
    `ViewConfig` type accepts `readonly` arrays for its lists.
  - '### 2. Fix `FieldRenderer` Generics'
  - >-
    We need to make `FieldRenderer` fully generic so it can correctly cast the
    `BadgeFieldDefinition` with both required type arguments.
  - '### 3. Fix `DataDemo.config.tsx` with `as const`'
  - >-
    We'll apply `as const` to the entire configuration object. This tells
    TypeScript to treat all string literals (like field IDs) as their exact
    values rather than widening them to `string`, which fixes the type
    incompatibility errors.
  - '### 4. Fix `dataDemo.store.tsx` Types'
  - >-
    We'll remove the unused import, add the missing generic to `SortConfig`, and
    most importantly, cast the imported `mockDataItems` to `DataDemoItem[]`.
    This is necessary because the mock data file itself likely doesn't have the
    strict `DataDemoItem` type applied to it yet.
  - '### 5. Clean up `useAppViewManager.hook.ts`'
  - Just removing the unused imports to keep the linter happy.
  - '### Final checks'
  - 'These changes address all the reported errors:'
  - '- `FieldRenderer` is now fully generic.'
  - >-
    - `DataDemo.config.tsx` uses `as const` and `ViewConfig` accepts readonly
    arrays.
  - >-
    - `dataDemo.store.tsx` correctly types the mock data, fixing the assignment
    errors.
  - '- Unused imports are gone.'
  - >-
    The `useRightPaneContent.hook.tsx` error should also be resolved because we
    are likely fixing the root cause of `GenericItem[]` not being assignable to
    `DataDemoItem[]` by ensuring we use `DataDemoItem` consistently where that
    data is involved. If `useRightPaneContent` imports `mockDataItems` directly,
    you might need to apply a similar cast there, but I can't see that file to
    fix it directly.
operations:
  - type: write
    path: src/features/dynamic-view/types.ts
    content: |
      @@ -117,10 +117,10 @@
         TItem extends GenericItem,
       > {
         fields: readonly FieldDefinition<TFieldId, TItem>[];
      -  sortableFields: ControlOption<TFieldId>[];
      -  groupableFields: ControlOption<TFieldId | 'none'>[];
      -  filterableFields: FilterableFieldConfig<TFieldId>[];
      +  sortableFields: readonly ControlOption<TFieldId>[];
      +  groupableFields: readonly ControlOption<TFieldId | 'none'>[];
      +  filterableFields: readonly FilterableFieldConfig<TFieldId>[];
       
         // Layouts for each view mode
         listView: ListViewConfig<TFieldId>;
    patchStrategy: standard-diff
  - type: write
    path: src/features/dynamic-view/components/shared/FieldRenderer.tsx
    content: >
      @@ -1,5 +1,5 @@
       import { useDynamicView } from '../../DynamicViewContext';
      -import type { GenericItem, BadgeFieldDefinition } from '../../types';

      +import type { GenericItem, BadgeFieldDefinition, FieldDefinition } from
      '../../types';
       import { cn, getNestedValue } from '@/lib/utils';
       import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
       import { Badge } from '@/components/ui/badge';
      @@ -7,13 +7,13 @@
       
      -interface FieldRendererProps {

      -  item: GenericItem;

      -  fieldId: string;

      +interface FieldRendererProps<TFieldId extends string, TItem extends
      GenericItem> {

      +  item: TItem;

      +  fieldId: TFieldId;
         className?: string;
         options?: Record<string, any>; // For extra props like 'compact' for avatar
       }
       
      -export function FieldRenderer({ item, fieldId, className, options }:
      FieldRendererProps) {

      -  const { getFieldDef } = useDynamicView<string, GenericItem>();

      +export function FieldRenderer<TFieldId extends string, TItem extends
      GenericItem>({ item, fieldId, className, options }:
      FieldRendererProps<TFieldId, TItem>) {

      +  const { getFieldDef } = useDynamicView<TFieldId, TItem>();
         const fieldDef = getFieldDef(fieldId);
         const value = getNestedValue(item, fieldId);
      @@ -22,7 +22,7 @@
         // Custom render function takes precedence
         if (fieldDef?.render) {
      -    return <>{fieldDef.render(item, options)}</>;

      +    return <>{(fieldDef as FieldDefinition<TFieldId,
      TItem>).render?.(item, options)}</>;
         }
       
      @@ -41,7 +41,7 @@
             return <span className={cn("text-xl", className)}>{String(value)}</span>;
       
           case 'badge': {
      -      const { colorMap, indicatorColorMap } = fieldDef as
      BadgeFieldDefinition<string>;

      +      const { colorMap, indicatorColorMap } = fieldDef as
      BadgeFieldDefinition<TFieldId, TItem>;
             
             if (options?.displayAs === 'indicator' && indicatorColorMap) {
    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/DataDemo.config.tsx
    content: |
      @@ -171,7 +171,7 @@
             ],
           },
         },
      -};
      +} as const;
       
       // Infer the field IDs from the const-asserted array.
       type DataDemoFieldId = (typeof config.fields)[number]["id"];
    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/store/dataDemo.store.tsx
    content: >
      @@ -3,8 +3,6 @@
       import type {
      -  GenericItem,
         GroupableField,
         FilterConfig,
         SortConfig,
      @@ -24,7 +22,7 @@
           page: number;
           groupBy: GroupableField<string> | "none";
           filters: FilterConfig;
      -    sortConfig: SortConfig | null;

      +    sortConfig: SortConfig<string> | null;
           isFullLoad?: boolean;
         }) => void;
         updateItem: (itemId: string, updates: Partial<DataDemoItem>) => void;
      @@ -38,6 +36,9 @@
         totalItemCount: 0,
       };
       
      +// Cast the mock data to our strict type to satisfy the store's
      requirements

      +const typedMockData = mockDataItems as DataDemoItem[];

      +
       // --- Store Implementation ---
       export const useDataDemoStore = create<DataDemoState & DataDemoActions>(
         (set) => ({
      @@ -48,7 +49,7 @@
             const isFirstPage = page === 1;
       
             const filteredAndSortedData = (() => {
      -        const filteredItems = mockDataItems.filter((item) => {

      +        const filteredItems = typedMockData.filter((item) => {
                 const searchTermMatch =
                   item.title
                     .toLowerCase()
      @@ -134,9 +135,9 @@
       
           updateItem: (itemId, updates) => {
             // In a real app, this would be an API call. Here we update the mock source.
      -      const itemIndex = mockDataItems.findIndex((i) => i.id === itemId);

      +      const itemIndex = typedMockData.findIndex((i) => i.id === itemId);
             if (itemIndex > -1) {
      -        mockDataItems[itemIndex] = { ...mockDataItems[itemIndex],
      ...updates };

      +        typedMockData[itemIndex] = { ...typedMockData[itemIndex],
      ...updates };
             }
       
             // Also update the currently loaded items in the store's state for UI consistency
      @@ -152,6 +153,6 @@
       export const useSelectedItem = (itemId?: string) => {
         if (!itemId) return null;
         return (
      -    (mockDataItems.find((item) => item.id === itemId) as DataDemoItem) ??
      null

      +    (typedMockData.find((item) => item.id === itemId) as DataDemoItem) ??
      null
         );
       };
    patchStrategy: standard-diff
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: >
      @@ -1,7 +1,7 @@
       import { useMemo, useCallback, useEffect, useRef } from 'react';
       import { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';
       import { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';
      -import type { GenericItem, ViewMode, SortConfig, GroupableField, Status,
      Priority, CalendarDateProp, CalendarDisplayProp, CalendarColorProp,
      FilterConfig } from '@/features/dynamic-view/types';

      +import type { GenericItem, ViewMode, SortConfig, GroupableField,
      CalendarDateProp, CalendarDisplayProp, CalendarColorProp, FilterConfig }
      from '@/features/dynamic-view/types';
       import type { TaskView } from '@/pages/Messaging/types';
       import { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';
    patchStrategy: standard-diff
snapshot:
  src/features/dynamic-view/components/shared/FieldRenderer.tsx: >-
    import { useDynamicView } from '../../DynamicViewContext';

    import type { GenericItem, BadgeFieldDefinition } from '../../types';

    import { cn, getNestedValue } from '@/lib/utils';

    import { Avatar, AvatarFallback, AvatarImage } from
    '@/components/ui/avatar';

    import { Badge } from '@/components/ui/badge';

    import { Clock, Eye, Heart, Share } from 'lucide-react';


    interface FieldRendererProps {
      item: GenericItem;
      fieldId: string;
      className?: string;
      options?: Record<string, any>; // For extra props like 'compact' for avatar
    }


    export function FieldRenderer({ item, fieldId, className, options }:
    FieldRendererProps) {
      const { getFieldDef } = useDynamicView<string, GenericItem>();
      const fieldDef = getFieldDef(fieldId);
      const value = getNestedValue(item, fieldId);

      // Custom render function takes precedence
      if (fieldDef?.render) {
        return <>{fieldDef.render(item, options)}</>;
      }

      if (!fieldDef) {
        console.warn(`[FieldRenderer] No field definition found for ID: ${fieldId}`);
        return <span className="text-red-500">?</span>;
      }

      if (value === null || typeof value === 'undefined') {
        return null; // Or some placeholder like 'N/A'
      }
      
      switch (fieldDef.type) {
        case 'string':
        case 'longtext':
          return <span className={cn("truncate", className)}>{String(value)}</span>;
        
        case 'thumbnail':
          return <span className={cn("text-xl", className)}>{String(value)}</span>;

        case 'badge': {
          const { colorMap, indicatorColorMap } = fieldDef as BadgeFieldDefinition<string>;
          
          if (options?.displayAs === 'indicator' && indicatorColorMap) {
            const indicatorColorClass = indicatorColorMap[String(value)] || 'bg-muted-foreground';
            return (
              <div className={cn("w-3 h-3 rounded-full", indicatorColorClass, className)} />
            );
          }

          const colorClass = colorMap?.[String(value)] || '';
          return (
            <Badge variant="outline" className={cn("font-medium capitalize", colorClass, className)}>
              {String(value)}
            </Badge>
          );
        }
        
        case 'avatar': {
          const { compact = false, avatarClassName = "w-8 h-8" } = options || {};
          const avatarUrl = getNestedValue(value, 'avatar');
          const name = getNestedValue(value, 'name');
          const email = getNestedValue(value, 'email');
          const fallback = name?.split(' ').map((n: string) => n[0]).join('') || '?';

          const avatarEl = (
            <Avatar className={cn("border-2 border-transparent group-hover:border-primary/50 transition-colors", avatarClassName)}>
              <AvatarImage src={avatarUrl} alt={name} />
              <AvatarFallback>{fallback}</AvatarFallback>
            </Avatar>
          );
          if (compact) return avatarEl;

          return (
            <div className={cn("flex items-center gap-2 group", className)}>
              {avatarEl}
              <div className="min-w-0 hidden sm:block">
                <p className="font-medium text-sm truncate">{name}</p>
                <p className="text-xs text-muted-foreground truncate">{email}</p>
              </div>
            </div>
          );
        }
        
        case 'progress': {
          const { showPercentage = false } = options || {};
          const bar = (
            <div className="w-full bg-muted rounded-full h-2.5">
              <div
                className="bg-gradient-to-r from-primary to-primary/80 h-2.5 rounded-full transition-all duration-500"
                style={{ width: `${value}%` }}
              />
            </div>
          );
          if (!showPercentage) return bar;
          
          return (
            <div className="flex items-center gap-3">
              <div className="flex-1 min-w-0">{bar}</div>
              <span className="text-sm font-medium text-muted-foreground">{value}%</span>
            </div>
          );
        }

        case 'date':
          return (
            <div className={cn("flex items-center gap-1.5 text-sm", className)}>
              <Clock className="w-4 h-4" />
              <span>{new Date(value).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</span>
            </div>
          );

        case 'tags': {
          const MAX_TAGS = 2;
          const tags = Array.isArray(value) ? value : [];
          const remainingTags = tags.length - MAX_TAGS;
          return (
            <div className={cn("flex items-center gap-1.5 flex-wrap", className)}>
              {tags.slice(0, MAX_TAGS).map(tag => (
                <Badge key={tag} variant="secondary" className="text-xs">{tag}</Badge>
              ))}
              {remainingTags > 0 && (
                <Badge variant="outline" className="text-xs">+{remainingTags}</Badge>
              )}
            </div>
          );
        }

        case 'metrics': {
          const views = getNestedValue(value, 'views') || 0;
          const likes = getNestedValue(value, 'likes') || 0;
          const shares = getNestedValue(value, 'shares') || 0;
          return (
            <div className={cn("flex items-center gap-3 text-sm", className)}>
              <div className="flex items-center gap-1"><Eye className="w-4 h-4" /> {views}</div>
              <div className="flex items-center gap-1"><Heart className="w-4 h-4" /> {likes}</div>
              <div className="flex items-center gap-1"><Share className="w-4 h-4" /> {shares}</div>
            </div>
          );
        }
          
        default:
          return <>{String(value)}</>;
      }
    }
  src/pages/DataDemo/DataDemo.config.tsx: >
    import { FieldRenderer } from
    "@/features/dynamic-view/components/shared/FieldRenderer";

    import type { ViewConfig } from "@/features/dynamic-view/types";

    import type { DataDemoItem } from "./data/DataDemoItem";


    const config = {
      // 1. Field Definitions
      fields: [
        { id: "id", label: "ID", type: "string" },
        { id: "title", label: "Title", type: "string" },
        { id: "description", label: "Description", type: "longtext" },
        { id: "thumbnail", label: "Thumbnail", type: "thumbnail" },
        { id: "category", label: "Category", type: "badge" },
        {
          id: "status",
          label: "Status",
          type: "badge",
          colorMap: {
            active: "bg-sky-500/10 text-sky-600 border-sky-500/20",
            pending: "bg-amber-500/10 text-amber-600 border-amber-500/20",
            completed: "bg-emerald-600/10 text-emerald-700 border-emerald-600/20",
            archived: "bg-zinc-500/10 text-zinc-600 border-zinc-500/20",
          },
        },
        {
          id: "priority",
          label: "Priority",
          type: "badge",
          colorMap: {
            critical: "bg-red-600/10 text-red-700 border-red-600/20",
            high: "bg-orange-500/10 text-orange-600 border-orange-500/20",
            medium: "bg-blue-500/10 text-blue-600 border-blue-500/20",
            low: "bg-green-500/10 text-green-600 border-green-500/20",
          },
          indicatorColorMap: {
            critical: "bg-red-500",
            high: "bg-orange-500",
            medium: "bg-blue-500",
            low: "bg-green-500",
          },
        },
        { id: "assignee", label: "Assignee", type: "avatar" },
        { id: "tags", label: "Tags", type: "tags" },
        { id: "metrics", label: "Engagement", type: "metrics" },
        { id: "metrics.completion", label: "Progress", type: "progress" },
        { id: "dueDate", label: "Due Date", type: "date" },
        { id: "createdAt", label: "Created At", type: "date" },
        { id: "updatedAt", label: "Last Updated", type: "date" },
        // A custom field to replicate the composite "Project" column in the table view
        {
          id: "project_details",
          label: "Project",
          type: "custom",
          render: (item: DataDemoItem) => (
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 bg-gradient-to-br from-primary/20 to-primary/10 rounded-lg flex items-center justify-center text-lg flex-shrink-0">
                <FieldRenderer item={item} fieldId="thumbnail" />
              </div>
              <div className="min-w-0 flex-1">
                <h4 className="font-medium group-hover:text-primary transition-colors truncate">
                  <FieldRenderer item={item} fieldId="title" />
                </h4>
                <p className="text-sm text-muted-foreground truncate">
                  <FieldRenderer item={item} fieldId="category" />
                </p>
              </div>
            </div>
          ),
        },
      ] as const,
      // 2. Control Definitions
      sortableFields: [
        { id: "updatedAt", label: "Last Updated" },
        { id: "title", label: "Title" },
        { id: "status", label: "Status" },
        { id: "priority", label: "Priority" },
        { id: "metrics.completion", label: "Progress" },
      ],
      groupableFields: [
        { id: "none", label: "None" },
        { id: "status", label: "Status" },
        { id: "priority", label: "Priority" },
        { id: "category", label: "Category" },
      ],
      filterableFields: [
        {
          id: "status",
          label: "Status",
          options: [
            { id: "active", label: "Active" },
            { id: "pending", label: "Pending" },
            { id: "completed", label: "Completed" },
            { id: "archived", label: "Archived" },
          ],
        },
        {
          id: "priority",
          label: "Priority",
          options: [
            { id: "critical", label: "Critical" },
            { id: "high", label: "High" },
            { id: "medium", label: "Medium" },
            { id: "low", label: "Low" },
          ],
        },
      ],
      // 3. View Layouts
      listView: {
        iconField: "thumbnail",
        titleField: "title",
        metaFields: [
          { fieldId: "status", className: "hidden sm:flex" },
          { fieldId: "tags", className: "hidden lg:flex" },
          { fieldId: "updatedAt", className: "hidden md:flex" },
          { fieldId: "assignee" },
          { fieldId: "priority", className: "hidden xs:flex" },
        ],
      },
      cardView: {
        thumbnailField: "thumbnail",
        titleField: "title",
        descriptionField: "description",
        headerFields: ["priority"],
        statusField: "status",
        categoryField: "category",
        tagsField: "tags",
        progressField: "metrics.completion",
        assigneeField: "assignee",
        metricsField: "metrics",
        dateField: "updatedAt",
      },
      tableView: {
        columns: [
          { fieldId: "project_details", label: "Project", isSortable: true },
          { fieldId: "status", label: "Status", isSortable: true },
          { fieldId: "priority", label: "Priority", isSortable: true },
          { fieldId: "assignee", label: "Assignee", isSortable: true },
          { fieldId: "metrics.completion", label: "Progress", isSortable: true },
          { fieldId: "metrics", label: "Engagement", isSortable: true },
          { fieldId: "updatedAt", label: "Last Updated", isSortable: true },
        ],
      },
      kanbanView: {
        groupByField: "status",
        cardFields: {
          titleField: "title",
          descriptionField: "description",
          priorityField: "priority",
          tagsField: "tags",
          dateField: "dueDate",
          metricsField: "metrics",
          assigneeField: "assignee",
        },
      },
      calendarView: {
        dateField: "dueDate",
        titleField: "title",
        displayFields: ["tags", "priority", "assignee"],
        colorByField: "priority",
      },
      detailView: {
        header: {
          thumbnailField: "thumbnail",
          titleField: "title",
          descriptionField: "description",
          badgeFields: ["status", "priority", "category"],
          progressField: "metrics.completion",
        },
        body: {
          sections: [
            { title: "Assigned to", fields: ["assignee"] },
            { title: "Engagement Metrics", fields: ["metrics"] },
            { title: "Tags", fields: ["tags"] },
            {
              title: "Timeline",
              fields: ["createdAt", "updatedAt", "dueDate"],
            },
          ],
        },
      },
    };


    // Infer the field IDs from the const-asserted array.

    type DataDemoFieldId = (typeof config.fields)[number]["id"];


    // This line validates the entire config object against the generic
    ViewConfig type.

    export const dataDemoViewConfig: ViewConfig<DataDemoFieldId, DataDemoItem> =
    config;
  src/features/dynamic-view/types.ts: >-
    import type { ReactNode } from 'react';


    // --- GENERIC DATA & ITEM ---

    export type GenericItem = Record<string, any> & { id: string };


    // --- FIELD DEFINITIONS ---

    // Describes a single piece of data within a GenericItem.

    export type FieldType =
      | 'string'
      | 'longtext'
      | 'badge'
      | 'avatar'
      | 'progress'
      | 'date'
      | 'tags'
      | 'metrics'
      | 'thumbnail'
      | 'custom';

    export interface BaseFieldDefinition<TFieldId extends string, TItem extends
    GenericItem> {
      id: TFieldId; // Corresponds to a key in GenericItem
      label: string;
      type: FieldType;
      // Optional custom render function for ultimate flexibility.
      render?: (item: TItem, options?: Record<string, any>) => ReactNode;
    }


    export interface BadgeFieldDefinition<TFieldId extends string, TItem extends
    GenericItem>
      extends BaseFieldDefinition<TFieldId, TItem> {
      type: 'badge';
      colorMap?: Record<string, string>; // e.g., { 'active': 'bg-green-500', 'pending': 'bg-yellow-500' }
      indicatorColorMap?: Record<string, string>; // e.g., { 'critical': 'bg-red-500' }
    }


    // Add other specific field types if they need unique properties

    // For now, most can be handled by the base definition.


    export type FieldDefinition<TFieldId extends string, TItem extends
    GenericItem> =
      | BaseFieldDefinition<TFieldId, TItem>
      | BadgeFieldDefinition<TFieldId, TItem>;

    // --- VIEW CONFIGURATION ---

    // The master configuration object that defines the entire view.


    export type ViewMode = 'list' | 'cards' | 'grid' | 'table' | 'kanban' |
    'calendar';


    export interface ListViewConfig<TFieldId extends string> {
      iconField: TFieldId;
      titleField: TFieldId;
      metaFields: Array<{
        fieldId: TFieldId;
        className?: string;
      }>;
    }


    export interface CardViewConfig<TFieldId extends string> {
      thumbnailField: TFieldId;
      titleField: TFieldId;
      descriptionField: TFieldId;
      headerFields: TFieldId[];
      // Specific fields to recreate the original layout
      statusField: TFieldId;
      categoryField: TFieldId;
      tagsField: TFieldId;
      progressField: TFieldId;
      assigneeField: TFieldId;
      metricsField: TFieldId;
      dateField: TFieldId;
    }


    export interface TableColumnConfig<TFieldId extends string> {
      fieldId: TFieldId;
      label: string;
      isSortable: boolean;
    }


    export interface TableViewConfig<TFieldId extends string> {
      columns: TableColumnConfig<TFieldId>[];
    }


    export interface KanbanViewConfig<TFieldId extends string> {
      groupByField: TFieldId; // Field ID to group by (e.g., 'status')
      cardFields: {
        titleField: TFieldId;
        descriptionField: TFieldId;
        priorityField: TFieldId;
        tagsField: TFieldId;
        // footer fields
        dateField: TFieldId;
        metricsField: TFieldId; // for comments/attachments
        assigneeField: TFieldId;
      };
    }


    export interface CalendarViewConfig<TFieldId extends string> {
      dateField: TFieldId;
      titleField: TFieldId;
      displayFields: TFieldId[];
      colorByField?: TFieldId; // Field ID to color events by (e.g., 'priority', 'status')
    }


    export interface ControlOption<TId extends string> {
      id: TId;
      label: string;
    }


    export interface FilterableFieldConfig<TFieldId extends string> {
      id: TFieldId; // fieldId
      label: string;
      options: ControlOption<string>[];
    }


    export interface ViewConfig<
      TFieldId extends string,
      TItem extends GenericItem,
    > {
      fields: readonly FieldDefinition<TFieldId, TItem>[];
      sortableFields: ControlOption<TFieldId>[];
      groupableFields: ControlOption<TFieldId | 'none'>[];
      filterableFields: FilterableFieldConfig<TFieldId>[];

      // Layouts for each view mode
      listView: ListViewConfig<TFieldId>;
      cardView: CardViewConfig<TFieldId>;
      tableView: TableViewConfig<TFieldId>;
      kanbanView: KanbanViewConfig<TFieldId>;
      calendarView: CalendarViewConfig<TFieldId>;
      detailView: DetailViewConfig<TFieldId>;
    }


    // --- DETAIL VIEW ---

    export interface DetailViewSection<TFieldId extends string> {
      title: string;
      fields: TFieldId[];
    }


    export interface DetailViewConfig<TFieldId extends string> {
      header: {
        thumbnailField: TFieldId;
        titleField: TFieldId;
        descriptionField: TFieldId;
        badgeFields: TFieldId[];
        progressField: TFieldId;
      };
      body: {
        sections: DetailViewSection<TFieldId>[];
      };
    }


    // --- GENERIC CONTROL & DATA TYPES ---


    export type Status = 'active' | 'pending' | 'completed' | 'archived';

    export type Priority = 'low' | 'medium' | 'high' | 'critical';


    export interface FilterConfig {
      searchTerm: string;
      [key: string]: any; // For dynamic filter keys like status, priority
    }


    export interface SortConfig<TFieldId extends string> {
      key: TFieldId;
      direction: 'asc' | 'desc';
    }


    export type GroupableField<TFieldId extends string> = TFieldId | 'none';


    export type CalendarDateProp<TFieldId extends string> = TFieldId;

    export type CalendarDisplayProp<TFieldId extends string> = TFieldId;

    export type CalendarColorProp<TFieldId extends string> = TFieldId | 'none';


    // --- STATS ---

    export type StatItem = {
      title: string;
      value: string;
      icon: ReactNode;
      change: string;
      trend: 'up' | 'down';
      chartData?: number[];
    };
  src/pages/DataDemo/store/dataDemo.store.tsx: |
    import { create } from "zustand";
    import { mockDataItems } from "@/pages/DataDemo/data/mockData";
    import type {
      GenericItem,
      GroupableField,
      FilterConfig,
      SortConfig,
    } from "@/features/dynamic-view/types";

    import type { DataDemoItem } from "../data/DataDemoItem";
    // --- State and Actions ---
    interface DataDemoState {
      items: DataDemoItem[];
      hasMore: boolean;
      isLoading: boolean;
      isInitialLoading: boolean;
      totalItemCount: number;
    }

    interface DataDemoActions {
      loadData: (params: {
        page: number;
        groupBy: GroupableField<string> | "none";
        filters: FilterConfig;
        sortConfig: SortConfig | null;
        isFullLoad?: boolean;
      }) => void;
      updateItem: (itemId: string, updates: Partial<DataDemoItem>) => void;
    }

    const defaultState: DataDemoState = {
      items: [],
      hasMore: true,
      isLoading: true,
      isInitialLoading: true,
      totalItemCount: 0,
    };

    // --- Store Implementation ---
    export const useDataDemoStore = create<DataDemoState & DataDemoActions>(
      (set) => ({
        ...defaultState,

        loadData: ({ page, groupBy, filters, sortConfig, isFullLoad }) => {
          set({ isLoading: true, ...(page === 1 && { isInitialLoading: true }) });
          const isFirstPage = page === 1;

          const filteredAndSortedData = (() => {
            const filteredItems = mockDataItems.filter((item) => {
              const searchTermMatch =
                item.title
                  .toLowerCase()
                  .includes(filters.searchTerm.toLowerCase()) ||
                item.description
                  .toLowerCase()
                  .includes(filters.searchTerm.toLowerCase());
              const statusMatch =
                filters.status.length === 0 || filters.status.includes(item.status);
              const priorityMatch =
                filters.priority.length === 0 ||
                filters.priority.includes(item.priority);
              return searchTermMatch && statusMatch && priorityMatch;
            });

            if (sortConfig) {
              filteredItems.sort((a, b) => {
                const getNestedValue = (obj: DataDemoItem, path: string): unknown =>
                  path.split(".").reduce((o: any, k) => (o || {})[k], obj);

                const aValue = getNestedValue(a, sortConfig.key);
                const bValue = getNestedValue(b, sortConfig.key);

                if (aValue === undefined || bValue === undefined) return 0;
                if (typeof aValue === "string" && typeof bValue === "string") {
                  return sortConfig.direction === "asc"
                    ? aValue.localeCompare(bValue)
                    : bValue.localeCompare(aValue);
                }
                if (typeof aValue === "number" && typeof bValue === "number") {
                  return sortConfig.direction === "asc"
                    ? aValue - bValue
                    : bValue - aValue;
                }
                if (
                  sortConfig.key === "updatedAt" ||
                  sortConfig.key === "createdAt"
                ) {
                  if (typeof aValue === "string" && typeof bValue === "string") {
                    return sortConfig.direction === "asc"
                      ? new Date(aValue).getTime() - new Date(bValue).getTime()
                      : new Date(bValue).getTime() - new Date(aValue).getTime();
                  }
                }
                return 0;
              });
            }
            return filteredItems;
          })();

          const totalItemCount = filteredAndSortedData.length;

          setTimeout(
            () => {
              if (groupBy !== "none" || isFullLoad) {
                set({
                  items: filteredAndSortedData,
                  hasMore: false,
                  isLoading: false,
                  isInitialLoading: false,
                  totalItemCount,
                });
                return;
              }

              const pageSize = 12;
              const newItems = filteredAndSortedData.slice(
                (page - 1) * pageSize,
                page * pageSize,
              );

              set((state) => ({
                items: isFirstPage ? newItems : [...state.items, ...newItems],
                hasMore: totalItemCount > page * pageSize,
                isLoading: false,
                isInitialLoading: false,
                totalItemCount,
              }));
            },
            isFirstPage ? 1500 : 500,
          );
        },

        updateItem: (itemId, updates) => {
          // In a real app, this would be an API call. Here we update the mock source.
          const itemIndex = mockDataItems.findIndex((i) => i.id === itemId);
          if (itemIndex > -1) {
            mockDataItems[itemIndex] = { ...mockDataItems[itemIndex], ...updates };
          }

          // Also update the currently loaded items in the store's state for UI consistency
          set((state) => ({
            items: state.items.map((item) =>
              item.id === itemId ? { ...item, ...updates } : item,
            ),
          }));
        },
      }),
    );

    export const useSelectedItem = (itemId?: string) => {
      if (!itemId) return null;
      return (
        (mockDataItems.find((item) => item.id === itemId) as DataDemoItem) ?? null
      );
    };
  src/hooks/useAppViewManager.hook.ts: "import { useMemo, useCallback, useEffect, useRef } from 'react';\nimport { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport { useAppShellStore, type AppShellState, type ActivePage } from '@/store/appShell.store';\nimport type { GenericItem, ViewMode, SortConfig, GroupableField, Status, Priority, CalendarDateProp, CalendarDisplayProp, CalendarColorProp, FilterConfig } from '@/features/dynamic-view/types';\nimport type { TaskView } from '@/pages/Messaging/types';\nimport { BODY_STATES, SIDEBAR_STATES } from '@/lib/utils';\n\nconst pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n  dashboard: 'main',\n  settings: 'settings',\n  toaster: 'toaster',\n  notifications: 'notifications',\n  'data-demo': 'dataDemo',\n  messaging: 'messaging',\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\n/**\n * A centralized hook to manage and synchronize all URL-based view states.\n * This is the single source of truth for view modes, side panes, split views,\n * and page-specific parameters.\n */\nexport function useAppViewManager() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const params = useParams<{ itemId: string; conversationId: string }>();\n  const { itemId, conversationId } = params;\n  const { setSidebarState, sidebarState } = useAppShellStore();\n\n  // --- DERIVED STATE FROM URL ---\n\n  const view = searchParams.get('view');\n  const sidePane = searchParams.get('sidePane');\n  const right = searchParams.get('right');\n  const messagingView = searchParams.get('messagingView') as TaskView | null;\n  const q = searchParams.get('q');\n  const status = searchParams.get('status');\n  const priority = searchParams.get('priority');\n  const sort = searchParams.get('sort');\n  const calDate = searchParams.get('calDate');\n  const calDisplay = searchParams.get('calDisplay');\n  const calLimit = searchParams.get('calLimit');\n  const calColor = searchParams.get('calColor');\n\n  const { bodyState, sidePaneContent } = useMemo(() => {\n    const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo', 'messaging'];\n    \n    // 1. Priority: Explicit side pane overlay via URL param\n    if (sidePane && validPanes.includes(sidePane as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n    }\n\n    // 2. Data item detail view (can be overlay or split)\n    if (itemId) {\n      if (view === 'split') {\n        return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n      }\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n    }\n\n    // 3. Messaging conversation view (always split)\n    if (conversationId) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'messaging' as const };\n    }\n\n    // 4. Generic split view via URL param\n    if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: right as AppShellState['sidePaneContent'] };\n    }\n\n    return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n  }, [itemId, conversationId, view, sidePane, right]);\n  \n  const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n  const prevActivePage = usePrevious(currentActivePage);\n\n  // --- SIDE EFFECTS ---\n  useEffect(() => {\n    // On navigating to messaging page, collapse sidebar if it's expanded.\n    // This ensures a good default view but allows the user to expand it again if they wish.\n    if (currentActivePage === 'messaging' && prevActivePage !== 'messaging' && sidebarState === SIDEBAR_STATES.EXPANDED) {\n      setSidebarState(SIDEBAR_STATES.COLLAPSED);\n    }\n  }, [currentActivePage, prevActivePage, sidebarState, setSidebarState]);\n\n  // DataDemo specific state\n  const viewMode = useMemo(() => (searchParams.get('dataView') as ViewMode) || 'list', [searchParams]);\n\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField<string> | 'none') || 'none', [searchParams]);\n\tconst activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n\tconst filters = useMemo<FilterConfig>(\n\t\t() => ({\n\t\t\tsearchTerm: q || '',\n\t\t\tstatus: (status?.split(',') || []).filter(Boolean),\n\t\t\tpriority: (priority?.split(',') || []).filter(Boolean),\n\t\t}),\n\t\t[q, status, priority],\n\t);\n\tconst sortConfig = useMemo<SortConfig<string> | null>(() => {\n\t\tconst sortParam = sort;\n\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n\t\tif (sortParam === 'default') return null;\n\n\t\tconst [key, direction] = sortParam.split('-');\n\t\treturn { key, direction: direction as 'asc' | 'desc' };\n\t}, [sort]);\n  const calendarDateProp = useMemo(() => (calDate || 'dueDate') as CalendarDateProp<string>, [calDate]);\n  const calendarDisplayProps = useMemo(\n    () => {\n      if (calDisplay === null) return []; // Default is now nothing\n      if (calDisplay === '') return []; // Explicitly empty is also nothing\n      return calDisplay.split(',') as CalendarDisplayProp<string>[];\n    },\n    [calDisplay]\n  );\n  const calendarItemLimit = useMemo(() => {\n    const limit = parseInt(calLimit || '3', 10);\n    if (calLimit === 'all') return 'all';\n    return isNaN(limit) ? 3 : limit;\n  }, [calLimit]);\n  const calendarColorProp = useMemo(() => (calColor || 'none') as CalendarColorProp<string>, [calColor]);\n\n  // --- MUTATOR ACTIONS ---\n\n  const handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | number | string[] | null | undefined>, resetPage = false) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\t\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resetPage) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n  const navigateTo = useCallback((page: string, params?: Record<string, string | null>) => {\n    const targetPath = page.startsWith('/') ? page : `/${page}`;\n    const isSamePage = location.pathname === targetPath;\n    \n    const newSearchParams = new URLSearchParams(isSamePage ? searchParams : undefined);\n\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        if (value === null || value === undefined) {\n          newSearchParams.delete(key);\n        } else {\n          newSearchParams.set(key, value);\n        }\n      }\n    }\n\n    navigate({ pathname: targetPath, search: newSearchParams.toString() });\n  }, [navigate, location.pathname, searchParams]);\n\n  const openSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (location.pathname === `/${Object.keys(pageToPaneMap).find(key => pageToPaneMap[key] === pane)}`) {\n        navigate({ pathname: '/dashboard', search: `?sidePane=${pane}` }, { replace: true });\n    } else {\n        handleParamsChange({ sidePane: pane, view: null, right: null });\n    }\n  }, [handleParamsChange, navigate, location.pathname]);\n\n  const closeSidePane = useCallback(() => {\n    if (itemId) {\n      navigate('/data-demo');\n    } else {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n    }\n  }, [itemId, navigate, handleParamsChange]);\n\n  const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (sidePane === pane) {\n      closeSidePane();\n    } else {\n      openSidePane(pane);\n    }\n  }, [sidePane, openSidePane, closeSidePane]);\n\n  const toggleSplitView = useCallback(() => {\n    if (bodyState === BODY_STATES.SIDE_PANE) {\n      handleParamsChange({ view: 'split', right: sidePane, sidePane: null });\n    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {\n      handleParamsChange({ sidePane: right, view: null, right: null });\n    } else { // From normal\n      const paneContent = pageToPaneMap[currentActivePage] || 'details';\n      handleParamsChange({ view: 'split', right: paneContent, sidePane: null });\n    }\n  }, [bodyState, sidePane, right, currentActivePage, handleParamsChange]);\n  \n  const setNormalView = useCallback(() => {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const switchSplitPanes = useCallback(() => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    const newSidePaneContent = pageToPaneMap[currentActivePage];\n    const newActivePage = Object.entries(pageToPaneMap).find(\n      ([, value]) => value === sidePaneContent\n    )?.[0] as ActivePage | undefined;\n\n    if (newActivePage && newSidePaneContent) {\n      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const closeSplitPane = useCallback((paneToClose: 'main' | 'right') => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    if (paneToClose === 'right') {\n      navigate(`/${currentActivePage}`, { replace: true });\n    } else { // Closing main pane\n      const pageToBecomeActive = Object.entries(pageToPaneMap).find(\n        ([, value]) => value === sidePaneContent\n      )?.[0] as ActivePage | undefined;\n      \n      if (pageToBecomeActive) {\n        navigate(`/${pageToBecomeActive}`, { replace: true });\n      } else {\n        navigate(`/dashboard`, { replace: true });\n      }\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  // DataDemo actions\n  const setViewMode = (mode: ViewMode) => handleParamsChange({ dataView: mode === 'list' ? null : mode });\n  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val }, true);\n  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n  const setFilters = (newFilters: FilterConfig) => {\n    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority }, true);\n  }\n  const setSort = (config: SortConfig<string> | null) => {\n    if (!config) {\n      handleParamsChange({ sort: null }, true);\n    } else {\n      handleParamsChange({ sort: `${config.key}-${config.direction}` }, true);\n    }\n  }\n  const setTableSort = (field: string) => {\n    let newSort: string | null = `${field}-desc`;\n    if (sortConfig && sortConfig.key === field) {\n      if (sortConfig.direction === 'desc') newSort = `${field}-asc`;\n      else if (sortConfig.direction === 'asc') newSort = null;\n    }\n    handleParamsChange({ sort: newSort }, true);\n  };\n  const setPage = (newPage: number) => handleParamsChange({ page: newPage > 1 ? newPage.toString() : null });\n\n  // Calendar specific actions\n  const setCalendarDateProp = (prop: CalendarDateProp<string>) => handleParamsChange({ calDate: prop === 'dueDate' ? null : prop });\n  const setCalendarDisplayProps = (props: CalendarDisplayProp<string>[]) => {\n    // Check for default state to keep URL clean\n    const isDefault = props.length === 0;\n    handleParamsChange({ calDisplay: isDefault ? null : props.join(',') });\n  };\n  const setCalendarItemLimit = (limit: number | 'all') => handleParamsChange({ calLimit: limit === 3 ? null : String(limit) });\n  const setCalendarColorProp = (prop: CalendarColorProp<string>) => handleParamsChange({ calColor: prop === 'none' ? null : prop });\n\n  const onItemSelect = useCallback((item: GenericItem) => {\n\t\tnavigate(`/data-demo/${item.id}${location.search}`);\n\t}, [navigate, location.search]);\n\n  const setMessagingView = (view: TaskView) => handleParamsChange({ messagingView: view });\n\n\n  return useMemo(() => ({\n    // State\n    bodyState,\n    sidePaneContent,\n    currentActivePage,\n    itemId,\n    messagingView,\n    // DataDemo State\n    viewMode,\n    page,\n    groupBy,\n    activeGroupTab,\n    filters,\n    sortConfig,\n    calendarDateProp,\n    calendarDisplayProps,\n    calendarItemLimit,\n    calendarColorProp,\n    // Actions\n    navigateTo,\n    openSidePane,\n    closeSidePane,\n    toggleSidePane,\n    toggleSplitView,\n    setNormalView,\n    switchSplitPanes,\n    setMessagingView,\n    closeSplitPane,\n    // DataDemo Actions\n    onItemSelect,\n    setViewMode,\n    setGroupBy,\n    setActiveGroupTab,\n    setFilters,\n    setSort,\n    setTableSort,\n    setPage,\n    setCalendarDateProp,\n    setCalendarDisplayProps,\n    setCalendarItemLimit,\n    setCalendarColorProp,\n  }), [\n    bodyState, sidePaneContent, currentActivePage, itemId, messagingView, viewMode,\n    page, groupBy, activeGroupTab, filters, sortConfig, calendarDateProp,\n    calendarDisplayProps, calendarItemLimit, calendarColorProp,\n    navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, setNormalView, setMessagingView,\n    switchSplitPanes, closeSplitPane, onItemSelect, setViewMode, setGroupBy, setActiveGroupTab, setFilters,\n    setSort, setTableSort, setPage, setCalendarDateProp, setCalendarDisplayProps, setCalendarItemLimit, setCalendarColorProp\n  ]);\n}"
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 542
