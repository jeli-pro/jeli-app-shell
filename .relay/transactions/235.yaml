uuid: 44b74a3f-3c08-4177-ad6b-8e10e19a4fc6
projectId: jeli-app-shell
createdAt: '2025-10-13T15:53:25.396Z'
gitCommitMsg: >-
  feat(DataDemo): Implement horizontal tabbed view for grouping results

  Refactors the data grouping feature on the DataDemo page to display grouped
  data in a horizontal, tabbed interface, as per user feedback.

  - The "Group By" selector now controls a secondary set of animated tabs
    representing the actual groups (e.g., "Active", "Pending").
  - Clicking a group tab displays the corresponding items below, with
    smooth GSAP animations on content change.
  - State management in `DataDemoPage` is overhauled to handle active
    group selection and data flow.
  - `DataTableView` and `ViewProps` types are simplified, as they now
    only need to handle flat arrays for the selected group's data.
  - The previous vertical `GroupWrapper` implementation has been removed.
promptSummary: >-
  The user clarified they want the grouping *results* to be displayed in
  horizontal tabs, not just the grouping criteria selector. This required a
  significant refactor of the DataDemoPage to support a two-tiered tab system
  and adjust data flow accordingly.
reasoning:
  - >-
    I understand. You want the grouping results to be displayed as a set of
    horizontal tabs, where clicking a tab shows the items for that specific
    group. This is a great UX pattern. I'll refactor the implementation to
    achieve this.
  - >-
    My previous change introduced the "Group By" selector but displayed the
    results in vertical sections. I will now pivot to your desired horizontal
    tabbed view for the results. This involves:
  - >-
    1.  **Reverting** the `DataTableView` and `types` to handle simple flat
    arrays again, as each tab will now display a simple list of items.
  - '2.  **Overhauling `DataDemoPage`** to:'
  - >-
    *   Add state to manage the currently active *group tab* (e.g., "Active",
    "Pending").
  - >-
    *   Render a second `AnimatedTabs` component dynamically based on the
    results of the grouping (e.g., one tab for each status).
  - >-
    *   Ensure the view below the tabs updates with just the data for the
    selected group.
  - >-
    *   Use keys to re-trigger animations in the view components for a fluid
    experience when switching between group tabs.
  - Let's implement this refined user experience.
  - '### Step 1: Revert Data Type Definitions'
  - >-
    First, I'll simplify the `ViewProps` type in `types.ts`. The view components
    will no longer receive a complex grouped object, only a straightforward
    array of items for the currently selected group.
  - '### Step 2: Revert Data Table View'
  - >-
    Next, I'll remove the group-rendering logic from `DataTableView`. It will
    now only be responsible for rendering rows from a simple `DataItem[]` array,
    which simplifies the component significantly and aligns with the new UX.
  - '### Step 3: Implement Horizontal Tabbed Grouping in Data Demo Page'
  - >-
    This is the core of the change. I'll refactor `DataDemoPage` to implement
    the new horizontal tabbed layout for grouped data. This involves significant
    changes to state management, data processing, and the render logic.
  - '---'
operations:
  - type: write
    path: src/pages/DataDemo/types.ts
    content: |+
      --- src/pages/DataDemo/types.ts
      +++ src/pages/DataDemo/types.ts
      @@ -28,7 +28,7 @@
       }
       
       export interface ViewProps {
      -  data: DataItem[] | Record<string, DataItem[]>
      +  data: DataItem[]
         onItemSelect: (item: DataItem) => void
         selectedItem: DataItem | null
         isGrid?: boolean

    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/components/DataTableView.tsx
    content: >
      --- src/pages/DataDemo/components/DataTableView.tsx

      +++ src/pages/DataDemo/components/DataTableView.tsx

      @@ -23,17 +23,14 @@
       
         useLayoutEffect(() => {
           if (tableRef.current) {
      -      // Only select item rows for animation, not group headers

      -      const newItems = Array.from( 

      -        tableRef.current.querySelectorAll('tbody tr')

      -      ).filter(tr => !tr.dataset.groupHeader)

      -       .slice(animatedItemsCount.current);

      +      const newItems =
      Array.from(tableRef.current.querySelectorAll('tbody tr'))

      +        .slice(animatedItemsCount.current);
             gsap.fromTo(newItems,
               { y: 20, opacity: 0 },
               {
                 duration: 0.5,
                 y: 0,
                 opacity: 1,
      -          stagger: 0.05,

      +          stagger: 0.03,
                 ease: "power2.out",
               },
             );
      @@ -58,7 +55,7 @@
           onSort?.(field)
         }
       
      -  if ((Array.isArray(data) && data.length === 0) || (!Array.isArray(data)
      && Object.keys(data).length === 0)) {

      +  if (data.length === 0) {
           return <EmptyState />
         }
       
      @@ -122,20 +119,9 @@
                   </tr>
                 </thead>
                 <tbody>
      -            {Array.isArray(data)

      -              ? data.map(item => <TableRow key={item.id} item={item}
      isSelected={selectedItem?.id === item.id} onItemSelect={onItemSelect} />)

      -              : Object.entries(data).flatMap(([groupName, items]) => [

      -                  <tr key={groupName} data-group-header="true"
      className="sticky top-0 z-10">

      -                    <td colSpan={8} className="p-2 bg-muted/50
      backdrop-blur-sm">

      -                      <div className="flex items-center gap-2">

      -                        <h3 className="font-semibold
      text-sm">{capitalize(groupName)}</h3>

      -                        <span className="text-xs px-2 py-0.5
      bg-background rounded-full font-medium">{items.length}</span>

      -                      </div>

      -                    </td>

      -                  </tr>,

      -                  ...items.map(item => <TableRow key={item.id}
      item={item} isSelected={selectedItem?.id === item.id}
      onItemSelect={onItemSelect} />)

      -                ])

      -            }

      +            {data.map(item => (

      +              <TableRow key={item.id} item={item}
      isSelected={selectedItem?.id === item.id} onItemSelect={onItemSelect} />

      +            ))}
                 </tbody>
               </table>
             </div>
    patchStrategy: standard-diff
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ -29,6 +29,7 @@
           priority: [],
         })
         const [sortConfig, setSortConfig] = useState<SortConfig | null>({ key: 'updatedAt', direction: 'desc' })
      +  const [activeGroupTab, setActiveGroupTab] = useState<string |
      null>(null)
         const [groupBy, setGroupBy] = useState<GroupableField | 'none'>('none')
         
         const groupOptions: { id: GroupableField | 'none'; label: string }[] = [
      @@ -47,8 +48,7 @@
         }, [itemId])
       
         const isInitialLoading = isLoading && items.length === 0
      -

      -  // Step 1: Centralized data filtering and sorting from the master list

      +  
         const filteredAndSortedData = useMemo(() => {
           let filteredItems = mockDataItems.filter(item => {
             const searchTermMatch =
      @@ -88,7 +88,24 @@
           }
       
           return filteredItems
      -  }, [filters, sortConfig, groupBy])

      +  }, [filters, sortConfig])

      +

      +  const groupedData = useMemo(() => {

      +    if (groupBy === 'none') return null;

      +    

      +    return filteredAndSortedData.reduce((acc, item) => {

      +      const key = item[groupBy as GroupableField] as string

      +      if (!acc[key]) {

      +        acc[key] = []

      +      }

      +      acc[key].push(item)

      +      return acc

      +    }, {} as Record<string, DataItem[]>)

      +  }, [groupBy, filteredAndSortedData])

      +

      +  const handleGroupByChange = (id: string) => {

      +    setGroupBy(id as GroupableField | 'none')

      +  }
       
         // Calculate stats from data
         const totalItems = mockDataItems.length
      @@ -98,23 +115,28 @@
           mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
         ) : 0
       
      -  // Reset pagination when filters or sort change

      +  // Reset pagination when filters, sort, or grouping changes
         useEffect(() => {
           setItems([])
           setPage(0) // This will be incremented to 1 in the loader `useEffect`, triggering a fresh load
           setHasMore(true)
           setIsLoading(true)
      -    // Timeout prevents flicker and ensures loading state is visible for
      new filter/sort/group

      -    setTimeout(() => {

      -      if (groupBy !== 'none') {

      -        setItems(filteredAndSortedData);

      -        setHasMore(false);

      -        setIsLoading(false);

      -      } else {

      -        setPage(1)

      -      }

      -    }, 100);

      -  }, [filteredAndSortedData, groupBy])

      +    setPage(1)

      +  }, [filteredAndSortedData, groupBy]);

      +

      +  // Effect to manage active group tab when grouping changes

      +  useEffect(() => {

      +    if (groupedData) {

      +      // Animate the content out before switching

      +      if (contentRef.current) {

      +        gsap.to(contentRef.current, { opacity: 0, duration: 0.2,
      onComplete: () => {

      +          const firstGroupKey = Object.keys(groupedData)[0]

      +          setActiveGroupTab(firstGroupKey || null)

      +          gsap.to(contentRef.current, { opacity: 1, duration: 0.3, delay:
      0.1 })

      +        }})

      +      }

      +    }

      +  }, [groupedData])
       
         // Infinite scroll logic
         useEffect(() => {
      @@ -132,11 +154,11 @@
             setTimeout(() => {
               // Double-check in case groupBy changed during timeout
               if (groupBy === 'none') {
      -          setItems(prev => (isFirstPage ? newItems : [...prev,
      ...newItems]))

      +          setItems(prev => (isFirstPage ? newItems : [...prev,
      ...newItems]));
                 setHasMore(filteredAndSortedData.length > page * pageSize)
      -          setIsLoading(false)
               }
      -      }, isFirstPage && items.length === 0 ? 1500 : 500)

      +        setIsLoading(false);

      +      }, isFirstPage && items.length === 0 ? 1500 : 500);
           };
       
           if (hasMore) fetchItems();
      @@ -243,22 +265,21 @@
           navigate(`/data-demo/${item.id}`)
         }
       
      -  // Step 2: Group the currently displayed items (paginated or full list)
      for rendering

      +  // Final data to be passed to view components
         const displayedData = useMemo(() => {
      -    if (groupBy === 'none') {

      -      return items;

      -    }

      -    return items.reduce((acc, item) => {

      -      const key = item[groupBy as GroupableField] as string

      -      if (!acc[key]) {

      -        acc[key] = []

      -      }

      -      acc[key].push(item)

      -      return acc

      -    }, {} as Record<string, DataItem[]>)

      -  }, [items, groupBy]);

      +    if (groupBy !== 'none') {

      +      if (groupedData && activeGroupTab) {

      +        return groupedData[activeGroupTab] || []

      +      }

      +      return []

      +    }

      +    return items

      +  }, [items, groupBy, groupedData, activeGroupTab])
       
         const commonViewProps = {
      +    // Add a key to force re-mount and re-trigger animations on tab
      change

      +    key: activeGroupTab || 'all-items', 
           onItemSelect: handleItemSelect,
           selectedItem,
         };
      @@ -302,13 +323,25 @@
                 <span className="text-sm font-medium text-muted-foreground mb-2 sm:mb-0 shrink-0">Group by:</span>
                 <AnimatedTabs
                   tabs={groupOptions}
                   activeTab={groupBy}
      -            onTabChange={(id) => setGroupBy(id as GroupableField |
      'none')}

      +            onTabChange={handleGroupByChange}
                 />
               </div>
       
               <DataToolbar
                 filters={filters}
                 onFiltersChange={handleFilterChange}
                 sortConfig={sortConfig}
                 onSortChange={handleSortChange}
               />
       
      +        {groupBy !== 'none' && groupedData && activeGroupTab && (

      +           <div className="animate-fade-in">

      +             <AnimatedTabs

      +               tabs={Object.entries(groupedData).map(([key, value]) => ({
      id: key, label: `${capitalize(key)} (${value.length})` }))}

      +               activeTab={activeGroupTab}

      +               onTabChange={setActiveGroupTab}

      +             />

      +           </div>

      +        )}

      +
               <div ref={contentRef} className="min-h-[500px]">
                 {isInitialLoading ? <AnimatedLoadingSkeleton viewMode={viewMode} /> : (
                   <div className="space-y-8">
      @@ -320,20 +353,11 @@
                           onSort={handleTableSort} 
                         />
                     ) : groupBy !== 'none' && !Array.isArray(displayedData) ? (
      -                Object.entries(displayedData).map(([groupName,
      groupItems]) => (

      -                  <GroupWrapper key={groupName} title={groupName}
      count={groupItems.length}>

      -                    {viewMode === 'list' && <DataListView
      data={groupItems} {...commonViewProps} />}

      -                    {viewMode === 'cards' && <DataCardView
      data={groupItems} {...commonViewProps} />}

      -                    {viewMode === 'grid' && <DataCardView
      data={groupItems} {...commonViewProps} isGrid />}

      -                  </GroupWrapper>

      -                ))

      -              ) : (

      -                <>

      -                  {viewMode === 'list' && <DataListView
      data={displayedData as DataItem[]} {...commonViewProps} />}

      -                  {viewMode === 'cards' && <DataCardView
      data={displayedData as DataItem[]} {...commonViewProps} />}

      -                  {viewMode === 'grid' && <DataCardView
      data={displayedData as DataItem[]} {...commonViewProps} isGrid />}

      -                </>

      -              )}

      +                null // This case is handled by displayedData now

      +              ) : viewMode === 'list' ? ( <DataListView
      data={displayedData} {...commonViewProps} />

      +              ) : viewMode === 'cards' ? ( <DataCardView
      data={displayedData} {...commonViewProps} />

      +              ) : viewMode === 'grid' ? ( <DataCardView
      data={displayedData} {...commonViewProps} isGrid />

      +              ) : null}
                   </div>
                 )}
               </div>
      @@ -354,26 +376,4 @@
         )
       }
       
      -function GroupWrapper({ title, count, children }: { title: string, count:
      number, children: React.ReactNode }) {

      -  const groupRef = useRef<HTMLDivElement>(null);

      -

      -  useLayoutEffect(() => {

      -    if (groupRef.current) {

      -      gsap.fromTo(groupRef.current, 

      -        { opacity: 0, y: 30 }, 

      -        { opacity: 1, y: 0, duration: 0.6, ease: 'power2.out' }

      -      );

      -    }

      -  }, []);

      -

      -  return (

      -    <div ref={groupRef} className="space-y-4">

      -      <div className="flex items-center gap-3 px-2">

      -        <h2 className="text-lg font-semibold
      tracking-tight">{capitalize(title)}</h2>

      -        <span className="text-sm font-medium px-2.5 py-1 bg-muted
      rounded-full">{count}</span>

      -      </div>

      -      {children}

      -    </div>

      -  );

      -}
    patchStrategy: standard-diff
snapshot:
  src/pages/DataDemo/types.ts: >
    export type ViewMode = 'list' | 'cards' | 'grid' | 'table'


    export type GroupableField = 'status' | 'priority' | 'category'


    export type SortableField = 'title' | 'status' | 'priority' | 'updatedAt' |
    'assignee.name' | 'metrics.views' | 'metrics.completion' | 'createdAt'

    export type SortDirection = 'asc' | 'desc'

    export interface SortConfig {
      key: SortableField
      direction: SortDirection
    }


    export interface DataItem {
      id: string
      title: string
      description: string
      category: string
      status: 'active' | 'pending' | 'completed' | 'archived'
      priority: 'low' | 'medium' | 'high' | 'critical'
      assignee: {
        name: string
        avatar: string
        email: string
      }
      metrics: {
        views: number
        likes: number
        shares: number
        completion: number
      }
      tags: string[]
      createdAt: string
      updatedAt: string
      dueDate?: string
      thumbnail?: string
      content?: {
        summary: string
        details: string
        attachments?: Array<{
          name: string
          type: string
          size: string
          url: string
        }>
      }
    }


    export interface ViewProps {
      data: DataItem[] | Record<string, DataItem[]>
      onItemSelect: (item: DataItem) => void
      selectedItem: DataItem | null
      isGrid?: boolean

      // Props for table view specifically
      sortConfig?: SortConfig | null
      onSort?: (field: SortableField) => void
    }


    export type Status = DataItem['status']

    export type Priority = DataItem['priority']
  src/pages/DataDemo/components/DataTableView.tsx: >-
    import { useState, useRef, useLayoutEffect } from 'react'

    import { gsap } from 'gsap'

    import { cn } from '@/lib/utils'

    import { Badge } from '@/components/ui/badge'

    import { Avatar } from '@/components/ui/avatar'

    import { 
      Calendar, 
      Eye, 
      Heart, 
      Share, 
      ArrowUpDown, 
      ArrowUp, 
      ArrowDown,
      MoreHorizontal,
      ExternalLink
    } from 'lucide-react'

    import type { ViewProps, DataItem, SortableField } from '../types'

    import { getStatusColor, getPriorityColor } from '../utils'

    import { EmptyState } from './EmptyState'

    import { capitalize } from '@/lib/utils'


    export function DataTableView({ data, onItemSelect, selectedItem,
    sortConfig, onSort }: ViewProps) {
      const tableRef = useRef<HTMLTableElement>(null)
      const animatedItemsCount = useRef(0)

      useLayoutEffect(() => {
        if (tableRef.current) {
          // Only select item rows for animation, not group headers
          const newItems = Array.from( 
            tableRef.current.querySelectorAll('tbody tr')
          ).filter(tr => !tr.dataset.groupHeader)
           .slice(animatedItemsCount.current);
          gsap.fromTo(newItems,
            { y: 20, opacity: 0 },
            {
              duration: 0.5,
              y: 0,
              opacity: 1,
              stagger: 0.05,
              ease: "power2.out",
            },
          );
          animatedItemsCount.current = Array.isArray(data) 
            ? data.length 
            : Object.values(data).reduce((sum, items) => sum + items.length, 0);
        }
      }, [data]);

      const SortIcon = ({ field }: { field: SortableField }) => {
        if (sortConfig?.key !== field) {
          return <ArrowUpDown className="w-4 h-4 opacity-50" />
        }
        if (sortConfig.direction === 'asc') {
          return <ArrowUp className="w-4 h-4 text-primary" />
        }
        if (sortConfig.direction === 'desc') {
          return <ArrowDown className="w-4 h-4 text-primary" />
        }
        return <ArrowUpDown className="w-4 h-4 opacity-50" />
      }

      const handleSortClick = (field: SortableField) => {
        onSort?.(field)
      }

      if ((Array.isArray(data) && data.length === 0) || (!Array.isArray(data) && Object.keys(data).length === 0)) {
        return <EmptyState />
      }

      return (
        <div className="relative overflow-hidden rounded-2xl border bg-card/50 backdrop-blur-sm">
          <div className="overflow-x-auto">
            <table ref={tableRef} className="w-full">
              <thead>
                <tr className="border-b border-border/50 bg-muted/20">
                  <th className="text-left p-4 font-semibold text-sm">
                    <button
                      onClick={() => handleSortClick('title')}
                      className="flex items-center gap-2 hover:text-primary transition-colors"
                    >
                      Project
                      <SortIcon field="title" />
                    </button>
                  </th>
                  <th className="text-left p-4 font-semibold text-sm">
                    <button
                      onClick={() => handleSortClick('status')}
                      className="flex items-center gap-2 hover:text-primary transition-colors"
                    >
                      Status
                      <SortIcon field="status" />
                    </button>
                  </th>
                  <th className="text-left p-4 font-semibold text-sm">
                    <button
                      onClick={() => handleSortClick('priority')}
                      className="flex items-center gap-2 hover:text-primary transition-colors"
                    >
                      Priority
                      <SortIcon field="priority" />
                    </button>
                  </th>
                  <th className="text-left p-4 font-semibold text-sm">
                    <button
                      onClick={() => handleSortClick('assignee.name')}
                      className="flex items-center gap-2 hover:text-primary transition-colors"
                    >
                      Assignee
                      <SortIcon field="assignee.name" />
                    </button>
                  </th>
                  <th className="text-left p-4 font-semibold text-sm">
                    <button
                      onClick={() => handleSortClick('metrics.completion')}
                      className="flex items-center gap-2 hover:text-primary transition-colors"
                    >
                      Progress
                      <SortIcon field="metrics.completion" />
                    </button>
                  </th>
                  <th className="text-left p-4 font-semibold text-sm">
                    <button
                      onClick={() => handleSortClick('metrics.views')}
                      className="flex items-center gap-2 hover:text-primary transition-colors"
                    >
                      Engagement
                      <SortIcon field="metrics.views" />
                    </button>
                  </th>
                  <th className="text-left p-4 font-semibold text-sm">Last Updated</th>
                  <th className="text-center p-4 font-semibold text-sm w-16">Actions</th>
                </tr>
              </thead>
              <tbody>
                {Array.isArray(data)
                  ? data.map(item => <TableRow key={item.id} item={item} isSelected={selectedItem?.id === item.id} onItemSelect={onItemSelect} />)
                  : Object.entries(data).flatMap(([groupName, items]) => [
                      <tr key={groupName} data-group-header="true" className="sticky top-0 z-10">
                        <td colSpan={8} className="p-2 bg-muted/50 backdrop-blur-sm">
                          <div className="flex items-center gap-2">
                            <h3 className="font-semibold text-sm">{capitalize(groupName)}</h3>
                            <span className="text-xs px-2 py-0.5 bg-background rounded-full font-medium">{items.length}</span>
                          </div>
                        </td>
                      </tr>,
                      ...items.map(item => <TableRow key={item.id} item={item} isSelected={selectedItem?.id === item.id} onItemSelect={onItemSelect} />)
                    ])
                }
              </tbody>
            </table>
          </div>
        </div>
      )
    }


    function TableRow({ item, isSelected, onItemSelect }: { item: DataItem;
    isSelected: boolean; onItemSelect: (item: DataItem) => void }) {
      return (
        <tr
          onClick={() => onItemSelect(item)}
          className={cn(
            "group border-b border-border/30 transition-all duration-200 cursor-pointer",
            "hover:bg-accent/20 hover:border-primary/20",
            isSelected && "bg-primary/5 border-primary/30"
          )}
        >
          {/* Project Column */}
          <td className="p-4">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 bg-gradient-to-br from-primary/20 to-primary/10 rounded-lg flex items-center justify-center text-lg flex-shrink-0">
                {item.thumbnail}
              </div>
              <div className="min-w-0 flex-1">
                <h4 className="font-medium group-hover:text-primary transition-colors truncate">
                  {item.title}
                </h4>
                <p className="text-sm text-muted-foreground truncate">
                  {item.category}
                </p>
              </div>
            </div>
          </td>

          {/* Status Column */}
          <td className="p-4">
            <Badge variant="outline" className={getStatusColor(item.status)}>
              {item.status}
            </Badge>
          </td>

          {/* Priority Column */}
          <td className="p-4">
            <Badge variant="outline" className={getPriorityColor(item.priority)}>
              {item.priority}
            </Badge>
          </td>

          {/* Assignee Column */}
          <td className="p-4">
            <div className="flex items-center gap-2">
              <Avatar className="w-8 h-8 text-sm">
                {item.assignee.avatar}
              </Avatar>
              <div className="min-w-0">
                <p className="text-sm font-medium truncate">
                  {item.assignee.name}
                </p>
              </div>
            </div>
          </td>

          {/* Progress Column */}
          <td className="p-4">
            <div className="flex items-center gap-3">
              <div className="flex-1 min-w-0">
                <div className="w-full bg-muted rounded-full h-2">
                  <div 
                    className="bg-gradient-to-r from-primary to-primary/80 h-2 rounded-full transition-all duration-500"
                    style={{ width: `${item.metrics.completion}%` }}
                  />
                </div>
              </div>
              <span className="text-sm font-medium text-muted-foreground">
                {item.metrics.completion}%
              </span>
            </div>
          </td>

          {/* Engagement Column */}
          <td className="p-4">
            <div className="flex items-center gap-4 text-xs text-muted-foreground">
              <div className="flex items-center gap-1">
                <Eye className="w-3 h-3" />
                {item.metrics.views}
              </div>
              <div className="flex items-center gap-1">
                <Heart className="w-3 h-3" />
                {item.metrics.likes}
              </div>
              <div className="flex items-center gap-1">
                <Share className="w-3 h-3" />
                {item.metrics.shares}
              </div>
            </div>
          </td>

          {/* Date Column */}
          <td className="p-4">
            <div className="flex items-center gap-1 text-sm text-muted-foreground">
              <Calendar className="w-3 h-3" />
              {new Date(item.updatedAt).toLocaleDateString()}
            </div>
          </td>

          {/* Actions Column */}
          <td className="p-4">
            <button 
              onClick={(e) => {
                e.stopPropagation()
                onItemSelect(item)
              }}
              className="flex items-center justify-center w-8 h-8 rounded-lg hover:bg-accent transition-colors"
              title="View details"
            >
              <ExternalLink className="w-4 h-4" />
            </button>
          </td>
        </tr>
      )
    }
  src/pages/DataDemo/index.tsx: >-
    import { useState, useRef, useEffect, useCallback, useMemo, useLayoutEffect
    } from 'react'

    import { useParams, useNavigate } from 'react-router-dom'

    import { 
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      TrendingUp,
      Loader2
    } from 'lucide-react'

    import { gsap } from 'gsap'

    import { capitalize } from '@/lib/utils'

    import { PageLayout } from '@/components/shared/PageLayout'

    import { DataListView } from './components/DataListView'

    import { DataCardView } from './components/DataCardView'

    import { DataTableView } from './components/DataTableView'

    import { DataViewModeSelector } from './components/DataViewModeSelector'

    import { AnimatedTabs } from '@/components/ui/animated-tabs'

    import { AnimatedLoadingSkeleton } from
    './components/AnimatedLoadingSkeleton'

    import { StatChartCard } from './components/StatChartCard'

    import { DataToolbar, FilterConfig } from './components/DataToolbar'

    import { mockDataItems } from './data/mockData'

    import type { DataItem, ViewMode, SortConfig, SortableField, GroupableField
    } from './types'


    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };


    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };


    type StatItem = Stat | ChartStat;


    export default function DataDemoPage() {
      const [viewMode, setViewMode] = useState<ViewMode>('list')
      const [filters, setFilters] = useState<FilterConfig>({
        searchTerm: '',
        status: [],
        priority: [],
      })
      const [sortConfig, setSortConfig] = useState<SortConfig | null>({ key: 'updatedAt', direction: 'desc' })
      const [groupBy, setGroupBy] = useState<GroupableField | 'none'>('none')
      
      const groupOptions: { id: GroupableField | 'none'; label: string }[] = [
        { id: 'none', label: 'None' }, { id: 'status', label: 'Status' }, { id: 'priority', label: 'Priority' }, { id: 'category', label: 'Category' }
      ]
      const [items, setItems] = useState<DataItem[]>([])
      const [page, setPage] = useState(0) // Start at 0 to trigger initial load effect
      const [hasMore, setHasMore] = useState(true)
      const [isLoading, setIsLoading] = useState(true)
      const contentRef = useRef<HTMLDivElement>(null)
      const statsRef = useRef<HTMLDivElement>(null)
      const observer = useRef<IntersectionObserver>()
      const navigate = useNavigate()
      const { itemId } = useParams<{ itemId: string }>()

      const selectedItem = useMemo(() => {
        if (!itemId) return null
        return mockDataItems.find(item => item.id === itemId) ?? null
      }, [itemId])

      const isInitialLoading = isLoading && items.length === 0

      // Step 1: Centralized data filtering and sorting from the master list
      const filteredAndSortedData = useMemo(() => {
        let filteredItems = mockDataItems.filter(item => {
          const searchTermMatch =
            item.title.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
            item.description.toLowerCase().includes(filters.searchTerm.toLowerCase())

          const statusMatch = filters.status.length === 0 || filters.status.includes(item.status)
          const priorityMatch = filters.priority.length === 0 || filters.priority.includes(item.priority)

          return searchTermMatch && statusMatch && priorityMatch
        })

        if (sortConfig) {
          filteredItems.sort((a, b) => {
            let aValue: any
            let bValue: any

            const getNestedValue = (obj: any, path: string) => path.split('.').reduce((o, k) => (o || {})[k], obj)

            aValue = getNestedValue(a, sortConfig.key)
            bValue = getNestedValue(b, sortConfig.key)

            if (aValue === undefined || bValue === undefined) return 0;

            if (typeof aValue === 'string' && typeof bValue === 'string') {
              return sortConfig.direction === 'asc'
                ? aValue.localeCompare(bValue)
                : bValue.localeCompare(aValue)
            }
            if (typeof aValue === 'number' && typeof bValue === 'number') {
              return sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue
            }
            // Date sorting (assuming ISO strings)
            if (sortConfig.key === 'updatedAt' || sortConfig.key === 'createdAt') {
                return sortConfig.direction === 'asc'
                    ? new Date(aValue).getTime() - new Date(aValue).getTime()
                    : new Date(bValue).getTime() - new Date(bValue).getTime()
            }
            return 0
          })
        }

        return filteredItems
      }, [filters, sortConfig, groupBy])

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      // Reset pagination when filters or sort change
      useEffect(() => {
        setItems([])
        setPage(0) // This will be incremented to 1 in the loader `useEffect`, triggering a fresh load
        setHasMore(true)
        setIsLoading(true)
        // Timeout prevents flicker and ensures loading state is visible for new filter/sort/group
        setTimeout(() => {
          if (groupBy !== 'none') {
            setItems(filteredAndSortedData);
            setHasMore(false);
            setIsLoading(false);
          } else {
            setPage(1)
          }
        }, 100);
      }, [filteredAndSortedData, groupBy])

      // Infinite scroll logic
      useEffect(() => {
        if (page === 0) return;
        if (groupBy !== 'none') return; // Pagination is disabled when grouping

        const fetchItems = () => {
          setIsLoading(true);
          const isFirstPage = page === 1
          
          const pageSize = 12;
          const newItems = filteredAndSortedData.slice((page - 1) * pageSize, page * pageSize);
          
          // Simulate network delay, longer for initial load to showcase skeleton
          setTimeout(() => {
            // Double-check in case groupBy changed during timeout
            if (groupBy === 'none') {
              setItems(prev => (isFirstPage ? newItems : [...prev, ...newItems]))
              setHasMore(filteredAndSortedData.length > page * pageSize)
              setIsLoading(false)
            }
          }, isFirstPage && items.length === 0 ? 1500 : 500)
        };

        if (hasMore) fetchItems();
      }, [page, groupBy, filteredAndSortedData, hasMore]);

      const loaderRef = useCallback(node => {
        if (isLoading) return;
        if (observer.current) observer.current.disconnect();
        
        observer.current = new IntersectionObserver(entries => {
          if (entries[0].isIntersecting && hasMore) {
            setPage(prevPage => prevPage + 1);
          }
        });
        if (node) observer.current.observe(node);
      }, [isLoading, hasMore]);

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78]
        }
      ]

      useEffect(() => {
        // Animate stats cards in
        if (!isInitialLoading && statsRef.current) {
          gsap.fromTo(statsRef.current.children,
            { y: 30, opacity: 0 },
            {
              duration: 0.6,
              y: 0,
              opacity: 1,
              stagger: 0.1,
              ease: "power2.out"
            }
          )
        }
      }, [isInitialLoading])

      const handleSortChange = (config: SortConfig | null) => {
        setSortConfig(config)
      }

      // For table view header clicks
      const handleTableSort = (field: SortableField) => {
        if (sortConfig?.key === field) {
          if (sortConfig.direction === 'desc') {
            // Cycle: desc -> asc
            setSortConfig({ key: field, direction: 'asc' })
          } else {
            // Cycle: asc -> default
            setSortConfig(null)
          }
        } else {
          // New field, default to desc
          setSortConfig({ key: field, direction: 'desc' })
        }
      }

      const handleFilterChange = (newFilters: FilterConfig) => {
        setFilters(newFilters)
      }
      
      // Handle item selection and open side panel
      const handleItemSelect = (item: DataItem) => {
        navigate(`/data-demo/${item.id}`)
      }

      // Step 2: Group the currently displayed items (paginated or full list) for rendering
      const displayedData = useMemo(() => {
        if (groupBy === 'none') {
          return items;
        }
        return items.reduce((acc, item) => {
          const key = item[groupBy as GroupableField] as string
          if (!acc[key]) {
            acc[key] = []
          }
          acc[key].push(item)
          return acc
        }, {} as Record<string, DataItem[]>)
      }, [items, groupBy]);

      const commonViewProps = {
        onItemSelect: handleItemSelect,
        selectedItem,
      };

      const totalItemCount = filteredAndSortedData.length;

      return (
        <PageLayout
          // Note: Search functionality is handled by a separate SearchBar in the TopBar
        >
          <div className="space-y-8">
            {/* Header */}
            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
              <div className="flex-1">
                <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                <p className="text-muted-foreground">
                  {isInitialLoading 
                    ? "Loading projects..." 
                    : `Showing ${totalItemCount} item(s)`}
                </p>
              </div>
              <DataViewModeSelector viewMode={viewMode} onChange={setViewMode} />
            </div>

            {/* Stats Section */}
            {!isInitialLoading && (
              <div ref={statsRef} className="grid grid-cols-[repeat(auto-fit,minmax(250px,1fr))] gap-6">
                {stats.map((stat) =>
                  stat.type === 'chart' ? (
                    <StatChartCard
                      key={stat.title}
                      title={stat.title}
                      value={stat.value}
                      change={stat.change}
                      trend={stat.trend}
                      icon={stat.icon}
                      chartData={stat.chartData}
                    />
                  ) : null
                )}
              </div>
            )}

            <div className="flex flex-col sm:flex-row sm:items-center sm:gap-4">
              <span className="text-sm font-medium text-muted-foreground mb-2 sm:mb-0 shrink-0">Group by:</span>
              <AnimatedTabs
                tabs={groupOptions}
                activeTab={groupBy}
                onTabChange={(id) => setGroupBy(id as GroupableField | 'none')}
              />
            </div>

            <DataToolbar
              filters={filters}
              onFiltersChange={handleFilterChange}
              sortConfig={sortConfig}
              onSortChange={handleSortChange}
            />

            <div ref={contentRef} className="min-h-[500px]">
              {isInitialLoading ? <AnimatedLoadingSkeleton viewMode={viewMode} /> : (
                <div className="space-y-8">
                  {viewMode === 'table' ? (
                     <DataTableView 
                        data={displayedData} 
                        {...commonViewProps}
                        sortConfig={sortConfig} 
                        onSort={handleTableSort} 
                      />
                  ) : groupBy !== 'none' && !Array.isArray(displayedData) ? (
                    Object.entries(displayedData).map(([groupName, groupItems]) => (
                      <GroupWrapper key={groupName} title={groupName} count={groupItems.length}>
                        {viewMode === 'list' && <DataListView data={groupItems} {...commonViewProps} />}
                        {viewMode === 'cards' && <DataCardView data={groupItems} {...commonViewProps} />}
                        {viewMode === 'grid' && <DataCardView data={groupItems} {...commonViewProps} isGrid />}
                      </GroupWrapper>
                    ))
                  ) : (
                    <>
                      {viewMode === 'list' && <DataListView data={displayedData as DataItem[]} {...commonViewProps} />}
                      {viewMode === 'cards' && <DataCardView data={displayedData as DataItem[]} {...commonViewProps} />}
                      {viewMode === 'grid' && <DataCardView data={displayedData as DataItem[]} {...commonViewProps} isGrid />}
                    </>
                  )}
                </div>
              )}
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && !isInitialLoading && groupBy === 'none' && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && totalItemCount > 0 && !isInitialLoading && groupBy === 'none' && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>
        </PageLayout>
      )
    }


    function GroupWrapper({ title, count, children }: { title: string, count:
    number, children: React.ReactNode }) {
      const groupRef = useRef<HTMLDivElement>(null);

      useLayoutEffect(() => {
        if (groupRef.current) {
          gsap.fromTo(groupRef.current, 
            { opacity: 0, y: 30 }, 
            { opacity: 1, y: 0, duration: 0.6, ease: 'power2.out' }
          );
        }
      }, []);

      return (
        <div ref={groupRef} className="space-y-4">
          <div className="flex items-center gap-3 px-2">
            <h2 className="text-lg font-semibold tracking-tight">{capitalize(title)}</h2>
            <span className="text-sm font-medium px-2.5 py-1 bg-muted rounded-full">{count}</span>
          </div>
          {children}
        </div>
      );
    }
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 235
