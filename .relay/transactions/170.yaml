uuid: 440317e0-63eb-46f0-b74a-4e35793e820f
projectId: jeli-app-shell
createdAt: '2025-10-12T10:09:06.842Z'
gitCommitMsg: >-
  feat(DataDemo): add animated skeleton loader for initial data fetch

  Introduces an animated loading skeleton component for the Data Demo page to
  improve user experience during initial data loading.

  - Creates a new `AnimatedLoadingSkeleton` component that uses GSAP to animate
  a search icon over a responsive grid of placeholder cards. - The skeleton
  layout adapts to the selected view mode (list, cards, grid). - Updates the
  `DataDemoPage` to display this skeleton during the initial fetch, with an
  increased delay to showcase the animation. - Refactors the data loading logic
  to differentiate between initial load and infinite scroll loading.
promptSummary: I need a cool loading state for the data demo page.
reasoning:
  - >-
    I've analyzed the request to create an engaging loading state for the data
    demonstration page. I will implement a new `AnimatedLoadingSkeleton`
    component that uses GSAP for smooth animations, as requested. This component
    will be responsive and adapt its layout based on the current view mode
    (`list`, `cards`, etc.).
  - 'Here''s my plan:'
  - >-
    1.  **Create `AnimatedLoadingSkeleton.tsx`**: A new component will be
    created in `src/pages/DataDemo/components/` to display a skeleton loader. It
    will feature:
  - >-
    *   Shimmering placeholder cards that mimic the layout of the actual data
    views.
  - >-
    *   A decorative `Search` icon that animates between the skeleton cards,
    adding a dynamic "searching for data" feel.
  - >-
    *   Responsiveness to adapt the number of skeleton cards based on screen
    size.
  - >-
    2.  **Update `DataDemoPage` (`index.tsx`)**: The main page component will be
    modified to:
  - '*   Show the new `AnimatedLoadingSkeleton` during the initial data fetch.'
  - >-
    *   Introduce a slightly longer simulated delay for the initial load to
    better showcase the new loading animation.
  - >-
    *   Update the logic to distinguish between the initial load and subsequent
    loads for infinite scrolling.
  - '*   Refine the UI text to indicate that data is being loaded.'
  - >-
    This approach will replace the current blank state with a visually appealing
    and informative loading experience.
  - '### 1. Create the Animated Loading Skeleton Component'
  - >-
    First, I'll create the new file for the loading skeleton component. It will
    contain the logic for rendering different skeleton layouts and animating the
    icon with GSAP.
  - '### 2. Integrate the Skeleton Loader into the Page'
  - >-
    Next, I'll modify the `DataDemoPage` to use the new loading component and
    adjust the data fetching logic.
operations:
  - type: write
    path: src/pages/DataDemo/components/AnimatedLoadingSkeleton.tsx
    content: >-
      import React, { useEffect, useRef, useState } from 'react'

      import { gsap } from 'gsap'

      import { Search } from 'lucide-react'

      import { cn } from '@/lib/utils'

      import type { ViewMode } from '../types'


      interface GridConfig {
        numCards: number
        cols: number
      }


      const AnimatedLoadingSkeleton = ({ viewMode }: { viewMode: ViewMode }) =>
      {
        const [windowWidth, setWindowWidth] = useState(0)
        const containerRef = useRef<HTMLDivElement>(null)
        const iconRef = useRef<HTMLDivElement>(null)
        const timelineRef = useRef<gsap.core.Timeline | null>(null)

        const getGridConfig = (width: number): GridConfig => {
          if (viewMode === 'list' || viewMode === 'table') {
            return { numCards: 5, cols: 1 }
          }
          const cols = width >= 1280 ? 4 : width >= 1024 ? 3 : width >= 768 ? 2 : 1
          return { numCards: Math.max(8, cols * 2), cols }
        }

        useEffect(() => {
          const handleResize = () => setWindowWidth(window.innerWidth)
          handleResize()
          window.addEventListener('resize', handleResize)
          return () => window.removeEventListener('resize', handleResize)
        }, [])

        useEffect(() => {
          if (timelineRef.current) {
            timelineRef.current.kill()
          }
          if (!iconRef.current || !containerRef.current || windowWidth === 0) return

          // Allow DOM to update with new skeleton cards
          const timeoutId = setTimeout(() => {
            const cards = Array.from(containerRef.current!.children)
            if (cards.length === 0) return

            const shuffledCards = gsap.utils.shuffle(cards)

            const getCardPosition = (card: Element) => {
              const rect = card.getBoundingClientRect()
              const containerRect = containerRef.current!.getBoundingClientRect()
              const iconRect = iconRef.current!.getBoundingClientRect()

              return {
                x: rect.left - containerRect.left + rect.width / 2 - iconRect.width / 2,
                y: rect.top - containerRect.top + rect.height / 2 - iconRect.height / 2,
              }
            }
            
            const tl = gsap.timeline({
              repeat: -1,
              repeatDelay: 0.5,
              defaults: { duration: 1, ease: 'power2.inOut' }
            });
            timelineRef.current = tl

            // Animate to a few random cards
            shuffledCards.slice(0, 5).forEach(card => {
              const pos = getCardPosition(card)
              tl.to(iconRef.current, { 
                x: pos.x,
                y: pos.y,
                scale: 1.2,
                duration: 0.8
              }).to(iconRef.current, {
                scale: 1,
                duration: 0.2
              })
            });

            // Loop back to the start
            const firstPos = getCardPosition(shuffledCards[0]);
            tl.to(iconRef.current, { x: firstPos.x, y: firstPos.y, duration: 0.8 });
          }, 100) // Small delay to ensure layout is calculated

          return () => {
            clearTimeout(timeoutId)
            if (timelineRef.current) {
              timelineRef.current.kill()
            }
          }

        }, [windowWidth, viewMode])

        const config = getGridConfig(windowWidth)

        const renderSkeletonCard = (key: number) => {
          if (viewMode === 'list' || viewMode === 'table') {
            return (
              <div key={key} className="bg-card/30 border border-border/30 rounded-2xl p-6 flex items-start gap-4 animate-pulse">
                <div className="w-14 h-14 bg-muted rounded-xl flex-shrink-0"></div>
                <div className="flex-1 space-y-3">
                  <div className="h-4 bg-muted rounded w-3/4"></div>
                  <div className="h-3 bg-muted rounded w-full"></div>
                  <div className="h-3 bg-muted rounded w-5/6"></div>
                  <div className="flex gap-2 pt-2">
                    <div className="h-6 bg-muted rounded-full w-20"></div>
                    <div className="h-6 bg-muted rounded-full w-20"></div>
                  </div>
                </div>
              </div>
            )
          }

          return (
            <div 
              key={key} 
              className={cn(
                "bg-card/30 border border-border/30 rounded-3xl p-6 space-y-4 animate-pulse",
                viewMode === 'grid' && "break-inside-avoid mb-6"
              )}
            >
              <div className="flex items-start justify-between">
                <div className="w-16 h-16 bg-muted rounded-2xl"></div>
                <div className="w-4 h-4 bg-muted rounded-full"></div>
              </div>
              <div className="h-4 bg-muted rounded w-3/4"></div>
              <div className="h-3 bg-muted rounded w-full"></div>
              <div className="h-3 bg-muted rounded w-5/6"></div>
              <div className="h-2 w-full bg-muted rounded-full my-4"></div>
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 bg-muted rounded-full"></div>
                <div className="flex-1 space-y-2">
                  <div className="h-3 bg-muted rounded w-1/2"></div>
                  <div className="h-2 bg-muted rounded w-1/3"></div>
                </div>
              </div>
            </div>
          )
        }

        const gridClasses = {
          list: "space-y-4",
          table: "space-y-4",
          cards: "grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4 gap-6",
          grid: "columns-1 sm:columns-2 lg:columns-3 xl:columns-4 gap-6 space-y-6"
        }

        return (
          <div className="relative overflow-hidden rounded-lg min-h-[500px]">
            <div 
              ref={iconRef}
              className="absolute z-10 p-3 bg-primary/20 rounded-full backdrop-blur-sm"
              style={{ willChange: 'transform' }}
            >
              <Search className="w-6 h-6 text-primary" />
            </div>

            <div 
              ref={containerRef}
              className={cn(gridClasses[viewMode])}
            >
              {[...Array(config.numCards)].map((_, i) => renderSkeletonCard(i))}
            </div>
          </div>
        )
      }


      export default AnimatedLoadingSkeleton;
    patchStrategy: replace
  - type: write
    path: src/pages/DataDemo/index.tsx
    content: >+
      --- src/pages/DataDemo/index.tsx

      +++ src/pages/DataDemo/index.tsx

      @@ -7,6 +7,7 @@
       import { DataCardView } from './components/DataCardView'
       import { DataTableView } from './components/DataTableView'
       import { DataDetailPanel } from './components/DataDetailPanel'
      +import { AnimatedLoadingSkeleton } from
      './components/AnimatedLoadingSkeleton'
       import { StatChartCard } from './components/StatChartCard'
       import { useAppShell } from '@/context/AppShellContext'
       import { mockDataItems } from './data/mockData'
      @@ -34,7 +35,7 @@
         const [items, setItems] = useState<DataItem[]>([])
         const [page, setPage] = useState(0) // Start at 0 to trigger initial load effect
         const [hasMore, setHasMore] = useState(true)
      -  const [isLoading, setIsLoading] = useState(false)

      +  const [isLoading, setIsLoading] = useState(true)
         const contentRef = useRef<HTMLDivElement>(null)
         const observer = useRef<IntersectionObserver>()
         const { openSidePane } = useAppShell()
      @@ -49,30 +50,27 @@
         ) : 0
       
         // Infinite scroll logic
      -  useEffect(() => {

      -    // This effect handles fetching data when page changes

      -    if (page === 0 || isLoading || !hasMore) return;

      +  useEffect(() => { // eslint-disable-line react-hooks/exhaustive-deps

      +    if (page === 0) return;
       
           const fetchItems = async () => {
             setIsLoading(true);
      -      await new Promise(resolve => setTimeout(resolve, 500)); // Simulate
      network delay

      +      // Add a longer delay for the initial load to showcase the skeleton

      +      const delay = page === 1 ? 1500 : 500

      +      await new Promise(resolve => setTimeout(resolve, delay)); //
      Simulate network delay
             
             const pageSize = 12;
             const newItems = mockDataItems.slice((page - 1) * pageSize, page * pageSize);
             
             if (newItems.length > 0) {
               setItems(prev => [...prev, ...newItems]);
             }
      -      if (newItems.length < pageSize) {

      +      if (items.length + newItems.length >= mockDataItems.length) {
               setHasMore(false);
             }
             setIsLoading(false);
           };
       
      -    fetchItems();

      +    if (hasMore) fetchItems();
         }, [page]);
       
         const loaderRef = useCallback(node => {
      @@ -140,6 +138,8 @@
           openSidePane('data-details')
         }
       
      +  const isInitialLoading = isLoading && items.length === 0

      +
         const renderView = () => {
           const commonProps = {
             data: items,
      @@ -168,7 +168,9 @@
                 <div>
                   <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                   <p className="text-muted-foreground">
      -              Showing {items.length} of {mockDataItems.length} items

      +              {isInitialLoading 

      +                ? "Loading projects..." 

      +                : `Showing ${items.length} of ${mockDataItems.length}
      items`}
                   </p>
                 </div>
                 <DataViewModeSelector 
      @@ -211,18 +213,18 @@
               </div>
       
               <div ref={contentRef} className="min-h-[500px]">
      -          {renderView()}

      +          {isInitialLoading ? <AnimatedLoadingSkeleton
      viewMode={viewMode} /> : renderView()}
               </div>
       
               {/* Loader for infinite scroll */}
               <div ref={loaderRef} className="flex justify-center items-center py-6">
      -          {isLoading && (

      +          {isLoading && !isInitialLoading && (
                   <div className="flex items-center gap-2 text-muted-foreground">
                     <Loader2 className="w-5 h-5 animate-spin" />
                     <span>Loading more...</span>
                   </div>
                 )}
      -          {!isLoading && !hasMore && items.length > 0 && (

      +          {!isLoading && !hasMore && items.length > 0 &&
      !isInitialLoading && (
                   <p className="text-muted-foreground">You've reached the end.</p>
                 )}
               </div>

    patchStrategy: standard-diff
snapshot:
  src/pages/DataDemo/components/AnimatedLoadingSkeleton.tsx: null
  src/pages/DataDemo/index.tsx: |-
    import { useState, useRef, useEffect, useCallback } from 'react'
    import { 
      Layers, 
      AlertTriangle, 
      PlayCircle, 
      TrendingUp,
      Loader2
    } from 'lucide-react'
    import { cn } from '@/lib/utils'
    import { PageLayout } from '@/components/shared/PageLayout'
    import { DataViewModeSelector } from './components/DataViewModeSelector'
    import { DataListView } from './components/DataListView'
    import { DataCardView } from './components/DataCardView'
    import { DataTableView } from './components/DataTableView'
    import { DataDetailPanel } from './components/DataDetailPanel'
    import { StatChartCard } from './components/StatChartCard'
    import { useAppShell } from '@/context/AppShellContext'
    import { mockDataItems } from './data/mockData'
    import { Card } from '@/components/ui/card'
    import type { DataItem, ViewMode } from './types'

    type Stat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type?: 'card';
    };

    type ChartStat = {
      title: string;
      value: string;
      icon: React.ReactNode;
      change: string;
      trend: 'up' | 'down';
      type: 'chart';
      chartData: number[];
    };

    type StatItem = Stat | ChartStat;

    export default function DataDemoPage() {
      const [viewMode, setViewMode] = useState<ViewMode>('list')
      const [selectedItem, setSelectedItem] = useState<DataItem | null>(null)  
      const [items, setItems] = useState<DataItem[]>([])
      const [page, setPage] = useState(0) // Start at 0 to trigger initial load effect
      const [hasMore, setHasMore] = useState(true)
      const [isLoading, setIsLoading] = useState(false)
      const contentRef = useRef<HTMLDivElement>(null)
      const observer = useRef<IntersectionObserver>()
      const { openSidePane } = useAppShell()

      // Calculate stats from data
      const totalItems = mockDataItems.length
      const activeItems = mockDataItems.filter(item => item.status === 'active').length
      const highPriorityItems = mockDataItems.filter(item => item.priority === 'high' || item.priority === 'critical').length
      const avgCompletion = totalItems > 0 ? Math.round(
        mockDataItems.reduce((acc, item) => acc + item.metrics.completion, 0) / totalItems
      ) : 0

      // Infinite scroll logic
      useEffect(() => {
        // This effect handles fetching data when page changes
        if (page === 0 || isLoading || !hasMore) return;

        const fetchItems = async () => {
          setIsLoading(true);
          await new Promise(resolve => setTimeout(resolve, 500)); // Simulate network delay
          
          const pageSize = 12;
          const newItems = mockDataItems.slice((page - 1) * pageSize, page * pageSize);
          
          if (newItems.length > 0) {
            setItems(prev => [...prev, ...newItems]);
          }
          if (newItems.length < pageSize) {
            setHasMore(false);
          }
          setIsLoading(false);
        };

        fetchItems();
      }, [page]);

      const loaderRef = useCallback(node => {
        if (isLoading) return;
        if (observer.current) observer.current.disconnect();
        
        observer.current = new IntersectionObserver(entries => {
          if (entries[0].isIntersecting && hasMore) {
            setPage(prevPage => prevPage + 1);
          }
        });
        if (node) observer.current.observe(node);
      }, [isLoading, hasMore]);

      const stats: StatItem[] = [
        {
          title: "Total Projects",
          value: totalItems.toString(),
          icon: <Layers className="w-5 h-5" />,
          change: "+5.2% this month",
          trend: "up" as const,
          type: 'chart',
          chartData: [120, 125, 122, 130, 135, 138, 142]
        },
        {
          title: "Active Projects",
          value: activeItems.toString(),
          icon: <PlayCircle className="w-5 h-5" />,
          change: "+2 this week", 
          trend: "up" as const,
          type: 'chart',
          chartData: [45, 50, 48, 55, 53, 60, 58]
        },
        {
          title: "High Priority",
          value: highPriorityItems.toString(),
          icon: <AlertTriangle className="w-5 h-5" />,
          change: "-1 from last week",
          trend: "down" as const,
          type: 'chart',
          chartData: [25, 26, 28, 27, 26, 24, 23]
        },
        {
          title: "Avg. Completion",
          value: `${avgCompletion}%`,
          icon: <TrendingUp className="w-5 h-5" />,
          change: "+3.2%",
          trend: "up" as const,
          type: 'chart',
          chartData: [65, 68, 70, 69, 72, 75, 78]
        }
      ]

      useEffect(() => {
        // Initial load by setting page to 1
        setPage(1);
      }, []);

      // Handle item selection and open side panel
      const handleItemSelect = (item: DataItem) => {
        setSelectedItem(item)
        openSidePane('data-details')
      }

      const renderView = () => {
        const commonProps = {
          data: items,
          onItemSelect: handleItemSelect,
          selectedItem
        }

        switch (viewMode) {
          case 'list':
            return <DataListView {...commonProps} />
          case 'cards':
            return <DataCardView {...commonProps} />
          case 'grid':
            return <DataCardView {...commonProps} isGrid />
          case 'table':
            return <DataTableView {...commonProps} />
          default:
            return <DataListView {...commonProps} />
        }
      }

      return (
        <PageLayout
          // Note: Search functionality is handled by a separate SearchBar in the TopBar
        >
          <div className="space-y-8">
            {/* Header */}
            <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
              <div>
                <h1 className="text-2xl font-bold tracking-tight">Data Showcase</h1>
                <p className="text-muted-foreground">
                  Showing {items.length} of {mockDataItems.length} items
                </p>
              </div>
              <DataViewModeSelector 
                viewMode={viewMode} 
                onChange={setViewMode}
              />
            </div>

            {/* Stats Section */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
              {stats.map((stat) => {
                if (stat.type === 'chart') {
                  return (
                    <StatChartCard
                      key={stat.title}
                      title={stat.title}
                      value={stat.value}
                      change={stat.change}
                      trend={stat.trend}
                      icon={stat.icon}
                      chartData={stat.chartData}
                    />
                  )
                }
                return (
                  <Card
                    key={stat.title}
                    className="p-6 border-border/50 hover:border-primary/30 transition-all duration-300 group cursor-pointer"
                  >
                    <div className="flex items-center justify-between">
                      <div className="p-3 bg-primary/10 rounded-full group-hover:bg-primary/20 transition-colors">
                        {stat.icon}
                      </div>
                      <div className={cn("text-sm font-medium", stat.trend === 'up' ? "text-green-600" : "text-red-600")}>
                        {stat.change}
                      </div>
                    </div>
                    <div className="mt-4">
                      <h3 className="text-2xl font-bold">{stat.value}</h3>
                      <p className="text-sm text-muted-foreground mt-1">{stat.title}</p>
                    </div>
                  </Card>
                )
              })}
            </div>

            <div ref={contentRef} className="min-h-[500px]">
              {renderView()}
            </div>

            {/* Loader for infinite scroll */}
            <div ref={loaderRef} className="flex justify-center items-center py-6">
              {isLoading && (
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Loader2 className="w-5 h-5 animate-spin" />
                  <span>Loading more...</span>
                </div>
              )}
              {!isLoading && !hasMore && items.length > 0 && (
                <p className="text-muted-foreground">You've reached the end.</p>
              )}
            </div>
          </div>

          {/* Detail Panel */}
          <DataDetailPanel 
            item={selectedItem}
            onClose={() => setSelectedItem(null)}
          />
        </PageLayout>
      )
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 170
