uuid: c224d03d-82b5-4127-9c98-63945417ab90
projectId: jeli-app-shell
createdAt: '2025-10-15T15:23:03.765Z'
gitCommitMsg: >-
  feat: Persist user theme and prevent flicker

  Implemented theme persistence using Zustand's `persist` middleware to store
  user preferences (dark mode, layout settings) in localStorage.

  To prevent the "flash of incorrect theme" on page load, a synchronous,
  blocking script has been added to the `<head>` of `index.html`. This script
  reads the theme from localStorage and applies the `.dark` class before the
  initial render, ensuring a seamless user experience. The script safely falls
  back to the user's system preference if no setting is stored.
promptSummary: >-
  The user wants to persist dark/light mode on refresh and prevent the initial
  theme flicker.
reasoning:
  - >-
    Excellent, this is a critical piece of polish for any modern web
    application. Persisting user preferences like dark mode and ensuring a
    flicker-free experience is a hallmark of quality engineering. Here is the
    implementation to achieve just that.
  - '### Part 1: Implement Persistence in App Shell Store'
  - >-
    First, I'll modify the `appShell.store.ts` file to use Zustand's `persist`
    middleware. This will automatically save user preferences to `localStorage`.
    I will be selective about which pieces of state are persisted, focusing on
    user settings like theme and layout, while omitting transient state like
    `isResizing`.
  - '### Part 2: Prevent Initial Theme Flicker'
  - >-
    Next, I'll inject a small, synchronous script into the `<head>` of
    `index.html`. This script runs before React, reads the theme from
    `localStorage`, and applies the correct class to the `<html>` element
    instantly. This completely eliminates the "flash of incorrect theme" on page
    load.
  - >-
    With these changes, your application will now remember the user's theme
    preference across sessions and load it instantly without any visual flicker.
  - '---'
operations:
  - type: write
    path: src/store/appShell.store.ts
    content: >
      --- src/store/appShell.store.ts

      +++ src/store/appShell.store.ts

      @@ -1,4 +1,5 @@
       import { create } from 'zustand';
      +import { persist } from 'zustand/middleware';
       import { type ReactElement } from 'react';
       import { SIDEBAR_STATES, BODY_STATES, type SidebarState, type BodyState } from '@/lib/utils';
       
      @@ -107,117 +108,131 @@
       };
       
       
      -export const useAppShellStore = create<AppShellState &
      AppShellActions>((set, get) => ({

      -  ...defaultState,

      -

      -  init: ({ appName, appLogo, defaultSplitPaneWidth }) => set(state => ({

      -    ...state,

      -    ...(appName && { appName }),

      -    ...(appLogo && { appLogo }),

      -    ...(defaultSplitPaneWidth && { splitPaneWidth: defaultSplitPaneWidth
      }),

      -  })),

      -  

      -  setSidebarState: (payload) => set({ sidebarState: payload }),

      -  setBodyState: (payload) => {

      -    // If we're leaving fullscreen, reset the target and previous state

      -    if (get().bodyState === BODY_STATES.FULLSCREEN && payload !==
      BODY_STATES.FULLSCREEN) {

      -      set({ bodyState: payload, fullscreenTarget: null,
      previousBodyState: BODY_STATES.NORMAL });

      -    } else {

      -      set({ bodyState: payload });

      -    }

      -  },

      -  setSidePaneContent: (payload) => set({ sidePaneContent: payload }),

      -  setSidebarWidth: (payload) => set({ sidebarWidth: Math.max(200,
      Math.min(500, payload)) }),

      -  setSidePaneWidth: (payload) => set({ sidePaneWidth: Math.max(300,
      Math.min(window.innerWidth * 0.8, payload)) }),

      -  setDefaultPaneWidths: () => {

      -    if (get().defaultWidthsSet) return;

      -    set(state => ({

      -        defaultSidePaneWidth: state.sidePaneWidth,

      -        defaultSplitPaneWidth: state.splitPaneWidth,

      -        defaultWidthsSet: true,

      -    }));

      -  },

      -  resetPaneWidths: () => set(state => ({

      -    sidePaneWidth: state.defaultSidePaneWidth,

      -    splitPaneWidth: state.defaultSplitPaneWidth,

      -  })),

      -  setSplitPaneWidth: (payload) => set({ splitPaneWidth: Math.max(300,
      Math.min(window.innerWidth * 0.8, payload)) }),

      -  setIsResizing: (payload) => set({ isResizing: payload }),

      -  setFullscreenTarget: (payload) => set({ fullscreenTarget: payload }),

      -  setIsResizingRightPane: (payload) => set({ isResizingRightPane: payload
      }),

      -  setTopBarVisible: (payload) => set({ isTopBarVisible: payload }),

      -  setAutoExpandSidebar: (payload) => set({ autoExpandSidebar: payload }),

      -  setReducedMotion: (payload) => set({ reducedMotion: payload }),

      -  setCompactMode: (payload) => set({ compactMode: payload }),

      -  setPrimaryColor: (payload) => {

      -    if (typeof document !== 'undefined') {

      -        document.documentElement.style.setProperty('--primary-hsl',
      payload);

      -    }

      -    set({ primaryColor: payload });

      -  },

      -  setDraggedPage: (payload) => set({ draggedPage: payload }),

      -  setCommandPaletteOpen: (open) => set({ isCommandPaletteOpen: open }),

      -  toggleDarkMode: () => set((state) => ({ isDarkMode: !state.isDarkMode
      })),

      -  setDragHoverTarget: (payload) => set({ dragHoverTarget: payload }),

      -  setTopBarHovered: (isHovered) => set({ isTopBarHovered: isHovered }),

      -  setHoveredPane: (payload) => set({ hoveredPane: payload }),

      -  

      -  toggleSidebar: () => {

      -    const current = get().sidebarState;

      -    if (current === SIDEBAR_STATES.HIDDEN) set({ sidebarState:
      SIDEBAR_STATES.COLLAPSED });

      -    else if (current === SIDEBAR_STATES.COLLAPSED) set({ sidebarState:
      SIDEBAR_STATES.EXPANDED });

      -    else if (current === SIDEBAR_STATES.EXPANDED) set({ sidebarState:
      SIDEBAR_STATES.COLLAPSED });

      -  },

      -  hideSidebar: () => set({ sidebarState: SIDEBAR_STATES.HIDDEN }),

      -  showSidebar: () => set({ sidebarState: SIDEBAR_STATES.EXPANDED }),

      -  peekSidebar: () => set({ sidebarState: SIDEBAR_STATES.PEEK }),

      -  

      -  toggleFullscreen: (target = null) => {

      -    const { bodyState, previousBodyState } = get();

      -    if (bodyState === BODY_STATES.FULLSCREEN) {

      -      set({ 

      -        bodyState: previousBodyState || BODY_STATES.NORMAL,

      -        fullscreenTarget: null,

      -        previousBodyState: BODY_STATES.NORMAL,

      -      });

      -    } else {

      -      set({ 

      -        previousBodyState: bodyState, 

      -        bodyState: BODY_STATES.FULLSCREEN, 

      -        fullscreenTarget: target 

      -      });

      -    }

      -  },

      -  

      -  resetToDefaults: () => {

      -    // Preserve props passed to provider and session defaults

      -    set(state => {

      -      const currentPrimaryColor = defaultState.primaryColor;

      -      if (typeof document !== 'undefined') {

      -        document.documentElement.style.setProperty('--primary-hsl',
      currentPrimaryColor);

      -      }

      -      return {

      -        ...defaultState,

      -        primaryColor: currentPrimaryColor,

      -        appName: state.appName,

      -        appLogo: state.appLogo,

      -        defaultSidePaneWidth: state.defaultSidePaneWidth,

      -        defaultSplitPaneWidth: state.defaultSplitPaneWidth,

      -        defaultWidthsSet: state.defaultWidthsSet,

      -        // Also reset current widths to the defaults

      -        sidePaneWidth: state.defaultSidePaneWidth,

      -        splitPaneWidth: state.defaultSplitPaneWidth,

      -      };

      -    });

      -  },

      -}));

      +export const useAppShellStore = create<AppShellState &
      AppShellActions>()(

      +  persist(

      +    (set, get) => ({

      +      ...defaultState,

      +

      +      init: ({ appName, appLogo, defaultSplitPaneWidth }) => set(state =>
      ({

      +        ...state,

      +        ...(appName && { appName }),

      +        ...(appLogo && { appLogo }),

      +        ...(defaultSplitPaneWidth && { splitPaneWidth:
      defaultSplitPaneWidth }),

      +      })),

      +      

      +      setSidebarState: (payload) => set({ sidebarState: payload }),

      +      setBodyState: (payload) => {

      +        // If we're leaving fullscreen, reset the target and previous
      state

      +        if (get().bodyState === BODY_STATES.FULLSCREEN && payload !==
      BODY_STATES.FULLSCREEN) {

      +          set({ bodyState: payload, fullscreenTarget: null,
      previousBodyState: BODY_STATES.NORMAL });

      +        } else {

      +          set({ bodyState: payload });

      +        }

      +      },

      +      setSidePaneContent: (payload) => set({ sidePaneContent: payload }),

      +      setSidebarWidth: (payload) => set({ sidebarWidth: Math.max(200,
      Math.min(500, payload)) }),

      +      setSidePaneWidth: (payload) => set({ sidePaneWidth: Math.max(300,
      Math.min(window.innerWidth * 0.8, payload)) }),

      +      setDefaultPaneWidths: () => {

      +        if (get().defaultWidthsSet) return;

      +        set(state => ({

      +            defaultSidePaneWidth: state.sidePaneWidth,

      +            defaultSplitPaneWidth: state.splitPaneWidth,

      +            defaultWidthsSet: true,

      +        }));

      +      },

      +      resetPaneWidths: () => set(state => ({

      +        sidePaneWidth: state.defaultSidePaneWidth,

      +        splitPaneWidth: state.defaultSplitPaneWidth,

      +      })),

      +      setSplitPaneWidth: (payload) => set({ splitPaneWidth: Math.max(300,
      Math.min(window.innerWidth * 0.8, payload)) }),

      +      setIsResizing: (payload) => set({ isResizing: payload }),

      +      setFullscreenTarget: (payload) => set({ fullscreenTarget: payload
      }),

      +      setIsResizingRightPane: (payload) => set({ isResizingRightPane:
      payload }),

      +      setTopBarVisible: (payload) => set({ isTopBarVisible: payload }),

      +      setAutoExpandSidebar: (payload) => set({ autoExpandSidebar: payload
      }),

      +      setReducedMotion: (payload) => set({ reducedMotion: payload }),

      +      setCompactMode: (payload) => set({ compactMode: payload }),

      +      setPrimaryColor: (payload) => {

      +        if (typeof document !== 'undefined') {

      +            document.documentElement.style.setProperty('--primary-hsl',
      payload);

      +        }

      +        set({ primaryColor: payload });

      +      },

      +      setDraggedPage: (payload) => set({ draggedPage: payload }),

      +      setCommandPaletteOpen: (open) => set({ isCommandPaletteOpen: open
      }),

      +      toggleDarkMode: () => set((state) => ({ isDarkMode:
      !state.isDarkMode })),

      +      setDragHoverTarget: (payload) => set({ dragHoverTarget: payload }),

      +      setTopBarHovered: (isHovered) => set({ isTopBarHovered: isHovered
      }),

      +      setHoveredPane: (payload) => set({ hoveredPane: payload }),

      +      

      +      toggleSidebar: () => {

      +        const current = get().sidebarState;

      +        if (current === SIDEBAR_STATES.HIDDEN) set({ sidebarState:
      SIDEBAR_STATES.COLLAPSED });

      +        else if (current === SIDEBAR_STATES.COLLAPSED) set({
      sidebarState: SIDEBAR_STATES.EXPANDED });

      +        else if (current === SIDEBAR_STATES.EXPANDED) set({ sidebarState:
      SIDEBAR_STATES.COLLAPSED });

      +      },

      +      hideSidebar: () => set({ sidebarState: SIDEBAR_STATES.HIDDEN }),

      +      showSidebar: () => set({ sidebarState: SIDEBAR_STATES.EXPANDED }),

      +      peekSidebar: () => set({ sidebarState: SIDEBAR_STATES.PEEK }),

      +      

      +      toggleFullscreen: (target = null) => {

      +        const { bodyState, previousBodyState } = get();

      +        if (bodyState === BODY_STATES.FULLSCREEN) {

      +          set({ 

      +            bodyState: previousBodyState || BODY_STATES.NORMAL,

      +            fullscreenTarget: null,

      +            previousBodyState: BODY_STATES.NORMAL,

      +          });

      +        } else {

      +          set({ 

      +            previousBodyState: bodyState, 

      +            bodyState: BODY_STATES.FULLSCREEN, 

      +            fullscreenTarget: target 

      +          });

      +        }

      +      },

      +      

      +      resetToDefaults: () => {

      +        // Preserve props passed to provider and session defaults

      +        set(state => {

      +          const currentPrimaryColor = defaultState.primaryColor;

      +          if (typeof document !== 'undefined') {

      +            document.documentElement.style.setProperty('--primary-hsl',
      currentPrimaryColor);

      +          }

      +          return {

      +            ...defaultState,

      +            primaryColor: currentPrimaryColor,

      +            appName: state.appName,

      +            appLogo: state.appLogo,

      +            defaultSidePaneWidth: state.defaultSidePaneWidth,

      +            defaultSplitPaneWidth: state.defaultSplitPaneWidth,

      +            defaultWidthsSet: state.defaultWidthsSet,

      +            // Also reset current widths to the defaults

      +            sidePaneWidth: state.defaultSidePaneWidth,

      +            splitPaneWidth: state.defaultSplitPaneWidth,

      +          };

      +        });

      +      },

      +    }),

      +    {

      +      name: 'app-shell-storage',

      +      partialize: (state) => ({

      +        isDarkMode: state.isDarkMode,

      +        sidebarState: state.sidebarState,

      +        sidebarWidth: state.sidebarWidth,

      +        sidePaneWidth: state.sidePaneWidth,

      +        splitPaneWidth: state.splitPaneWidth,

      +        autoExpandSidebar: state.autoExpandSidebar,

      +        reducedMotion: state.reducedMotion,

      +        compactMode: state.compactMode,

      +        primaryColor: state.primaryColor,

      +      }),

      +    }

      +  )

      +);
       
       // Add a selector for the derived rightPaneWidth
       export const useRightPaneWidth = () => useAppShellStore(state => 
       
    patchStrategy: standard-diff
  - type: write
    path: index.html
    content: >+
      --- index.html

      +++ index.html

      @@ -4,6 +4,24 @@
           <link rel="icon" type="image/svg+xml" href="/vite.svg" />
           <meta name="viewport" content="width=device-width, initial-scale=1.0" />
           <title>Jeli App Shell</title>
      +    <script>

      +      (function() {

      +        try {

      +          const storageKey = 'app-shell-storage';

      +          const storageValue = localStorage.getItem(storageKey);

      +          let isDarkMode;

      +

      +          if (storageValue) {

      +            isDarkMode = JSON.parse(storageValue)?.state?.isDarkMode;

      +          }

      +          

      +          if (typeof isDarkMode !== 'boolean') {

      +            isDarkMode = window.matchMedia('(prefers-color-scheme:
      dark)').matches;

      +          }

      +          

      +          document.documentElement.classList.toggle('dark', isDarkMode);

      +        } catch (e) { /* Fails safely */ }

      +      })();

      +    </script>
         </head>
         <body>
           <div id="root"></div>

    patchStrategy: standard-diff
snapshot:
  src/store/appShell.store.ts: >-
    import { create } from 'zustand';

    import { type ReactElement } from 'react';

    import { SIDEBAR_STATES, BODY_STATES, type SidebarState, type BodyState }
    from '@/lib/utils';


    export type ActivePage = 'dashboard' | 'settings' | 'toaster' |
    'notifications' | 'data-demo' | 'messaging';


    // --- State and Action Types ---


    export interface AppShellState {
      sidebarState: SidebarState;
      bodyState: BodyState;
      sidePaneContent: 'details' | 'settings' | 'main' | 'toaster' | 'notifications' | 'dataDemo' | 'dataItem' | 'messaging';
      sidebarWidth: number;
      sidePaneWidth: number;
      splitPaneWidth: number;
      defaultSidePaneWidth: number;
      defaultSplitPaneWidth: number;
      defaultWidthsSet: boolean;
      previousBodyState: BodyState;
      fullscreenTarget: 'main' | 'right' | null;
      isResizing: boolean;
      isResizingRightPane: boolean;
      isTopBarVisible: boolean;
      isTopBarHovered: boolean;
      autoExpandSidebar: boolean;
      reducedMotion: boolean;
      compactMode: boolean;
      primaryColor: string;
      isCommandPaletteOpen: boolean;
      isDarkMode: boolean;
      appName?: string;
      appLogo?: ReactElement;
      draggedPage: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | 'messaging' | null;
      dragHoverTarget: 'left' | 'right' | null;
      hoveredPane: 'left' | 'right' | null;
    }


    export interface AppShellActions {
        // Initialization
        init: (config: { appName?: string; appLogo?: ReactElement; defaultSplitPaneWidth?: number }) => void;
        
        // Direct state setters
        setSidebarState: (payload: SidebarState) => void;
        setBodyState: (payload: BodyState) => void;
        setSidePaneContent: (payload: AppShellState['sidePaneContent']) => void;
        setSidebarWidth: (payload: number) => void;
        setSidePaneWidth: (payload: number) => void;
        setDefaultPaneWidths: () => void;
        resetPaneWidths: () => void;
        setSplitPaneWidth: (payload: number) => void;
        setIsResizing: (payload: boolean) => void;
        setFullscreenTarget: (payload: 'main' | 'right' | null) => void;
        setIsResizingRightPane: (payload: boolean) => void;
        setTopBarVisible: (payload: boolean) => void;
        setAutoExpandSidebar: (payload: boolean) => void;
        setReducedMotion: (payload: boolean) => void;
        setCompactMode: (payload: boolean) => void;
        setPrimaryColor: (payload: string) => void;
        setDraggedPage: (payload: AppShellState['draggedPage']) => void;
        setCommandPaletteOpen: (open: boolean) => void;
        toggleDarkMode: () => void;
        setDragHoverTarget: (payload: 'left' | 'right' | null) => void;
        setTopBarHovered: (isHovered: boolean) => void;
        setHoveredPane: (payload: 'left' | 'right' | null) => void;
        
        // Composite actions
        toggleSidebar: () => void;
        hideSidebar: () => void;
        showSidebar: () => void;
        peekSidebar: () => void;
        toggleFullscreen: (target?: 'main' | 'right' | null) => void;
        resetToDefaults: () => void;
    }


    const defaultState: AppShellState = {
      sidebarState: SIDEBAR_STATES.EXPANDED,
      bodyState: BODY_STATES.NORMAL,
      sidePaneContent: 'details',
      sidebarWidth: 280,
      sidePaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.6)) : 400,
      splitPaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.35)) : 400,
      defaultSidePaneWidth: 400,
      defaultSplitPaneWidth: 400,
      defaultWidthsSet: false,
      previousBodyState: BODY_STATES.NORMAL,
      fullscreenTarget: null,
      isResizing: false,
      isResizingRightPane: false,
      isTopBarVisible: true,
      isTopBarHovered: false,
      autoExpandSidebar: true,
      reducedMotion: false,
      compactMode: false,
      primaryColor: '220 84% 60%',
      isCommandPaletteOpen: false,
      isDarkMode: false,
      appName: 'Jeli App',
      appLogo: undefined,
      draggedPage: null,
      dragHoverTarget: null,
      hoveredPane: null,
    };



    export const useAppShellStore = create<AppShellState &
    AppShellActions>((set, get) => ({
      ...defaultState,

      init: ({ appName, appLogo, defaultSplitPaneWidth }) => set(state => ({
        ...state,
        ...(appName && { appName }),
        ...(appLogo && { appLogo }),
        ...(defaultSplitPaneWidth && { splitPaneWidth: defaultSplitPaneWidth }),
      })),
      
      setSidebarState: (payload) => set({ sidebarState: payload }),
      setBodyState: (payload) => {
        // If we're leaving fullscreen, reset the target and previous state
        if (get().bodyState === BODY_STATES.FULLSCREEN && payload !== BODY_STATES.FULLSCREEN) {
          set({ bodyState: payload, fullscreenTarget: null, previousBodyState: BODY_STATES.NORMAL });
        } else {
          set({ bodyState: payload });
        }
      },
      setSidePaneContent: (payload) => set({ sidePaneContent: payload }),
      setSidebarWidth: (payload) => set({ sidebarWidth: Math.max(200, Math.min(500, payload)) }),
      setSidePaneWidth: (payload) => set({ sidePaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, payload)) }),
      setDefaultPaneWidths: () => {
        if (get().defaultWidthsSet) return;
        set(state => ({
            defaultSidePaneWidth: state.sidePaneWidth,
            defaultSplitPaneWidth: state.splitPaneWidth,
            defaultWidthsSet: true,
        }));
      },
      resetPaneWidths: () => set(state => ({
        sidePaneWidth: state.defaultSidePaneWidth,
        splitPaneWidth: state.defaultSplitPaneWidth,
      })),
      setSplitPaneWidth: (payload) => set({ splitPaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, payload)) }),
      setIsResizing: (payload) => set({ isResizing: payload }),
      setFullscreenTarget: (payload) => set({ fullscreenTarget: payload }),
      setIsResizingRightPane: (payload) => set({ isResizingRightPane: payload }),
      setTopBarVisible: (payload) => set({ isTopBarVisible: payload }),
      setAutoExpandSidebar: (payload) => set({ autoExpandSidebar: payload }),
      setReducedMotion: (payload) => set({ reducedMotion: payload }),
      setCompactMode: (payload) => set({ compactMode: payload }),
      setPrimaryColor: (payload) => {
        if (typeof document !== 'undefined') {
            document.documentElement.style.setProperty('--primary-hsl', payload);
        }
        set({ primaryColor: payload });
      },
      setDraggedPage: (payload) => set({ draggedPage: payload }),
      setCommandPaletteOpen: (open) => set({ isCommandPaletteOpen: open }),
      toggleDarkMode: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
      setDragHoverTarget: (payload) => set({ dragHoverTarget: payload }),
      setTopBarHovered: (isHovered) => set({ isTopBarHovered: isHovered }),
      setHoveredPane: (payload) => set({ hoveredPane: payload }),
      
      toggleSidebar: () => {
        const current = get().sidebarState;
        if (current === SIDEBAR_STATES.HIDDEN) set({ sidebarState: SIDEBAR_STATES.COLLAPSED });
        else if (current === SIDEBAR_STATES.COLLAPSED) set({ sidebarState: SIDEBAR_STATES.EXPANDED });
        else if (current === SIDEBAR_STATES.EXPANDED) set({ sidebarState: SIDEBAR_STATES.COLLAPSED });
      },
      hideSidebar: () => set({ sidebarState: SIDEBAR_STATES.HIDDEN }),
      showSidebar: () => set({ sidebarState: SIDEBAR_STATES.EXPANDED }),
      peekSidebar: () => set({ sidebarState: SIDEBAR_STATES.PEEK }),
      
      toggleFullscreen: (target = null) => {
        const { bodyState, previousBodyState } = get();
        if (bodyState === BODY_STATES.FULLSCREEN) {
          set({ 
            bodyState: previousBodyState || BODY_STATES.NORMAL,
            fullscreenTarget: null,
            previousBodyState: BODY_STATES.NORMAL,
          });
        } else {
          set({ 
            previousBodyState: bodyState, 
            bodyState: BODY_STATES.FULLSCREEN, 
            fullscreenTarget: target 
          });
        }
      },
      
      resetToDefaults: () => {
        // Preserve props passed to provider and session defaults
        set(state => {
          const currentPrimaryColor = defaultState.primaryColor;
          if (typeof document !== 'undefined') {
            document.documentElement.style.setProperty('--primary-hsl', currentPrimaryColor);
          }
          return {
            ...defaultState,
            primaryColor: currentPrimaryColor,
            appName: state.appName,
            appLogo: state.appLogo,
            defaultSidePaneWidth: state.defaultSidePaneWidth,
            defaultSplitPaneWidth: state.defaultSplitPaneWidth,
            defaultWidthsSet: state.defaultWidthsSet,
            // Also reset current widths to the defaults
            sidePaneWidth: state.defaultSidePaneWidth,
            splitPaneWidth: state.defaultSplitPaneWidth,
          };
        });
      },
    }));


    // Add a selector for the derived rightPaneWidth

    export const useRightPaneWidth = () => useAppShellStore(state => 
        state.bodyState === BODY_STATES.SPLIT_VIEW ? state.splitPaneWidth : state.sidePaneWidth
    );
  index.html: |-
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Jeli App Shell</title>
      </head>
      <body>
        <div id="root"></div>
        <div id="toaster-container"></div>
        <script type="module" src="/src/main.tsx"></script>
      </body>
    </html>
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 325
