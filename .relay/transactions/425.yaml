uuid: 6363690d-5872-4d22-8367-124b102ef75e
projectId: jeli-app-shell
createdAt: '2025-10-17T13:12:02.415Z'
gitCommitMsg: >-
  perf(messaging): optimize initial load performance of task list

  This commit addresses performance issues reported after recent changes to the
  messaging task list, which caused UI lag and slow initial animations.

  The optimizations include:

  1.  The `useMessagingTaskCounts` hook is refactored to calculate task counts
  asynchronously using `requestAnimationFrame`. This defers the computation
  until after the initial render, freeing up the main thread and allowing
  animations to run smoothly.

  2.  In the `TaskList` component, the `TABS` array passed to `AnimatedTabs` is
  now memoized with `useMemo`. This prevents the array from being recreated on
  every render, which stops unnecessary re-renders and effect executions within
  the `AnimatedTabs` component.
promptSummary: >-
  The user reported that the previous changes made the page feel heavy and
  caused animation lag on initial load. This commit optimizes the performance to
  resolve these issues.
reasoning:
  - >-
    I understand. The initial changes, while functionally correct, introduced a
    performance bottleneck on the initial render, making the page feel sluggish
    and causing animations to lag. This is a classic symptom of doing too much
    synchronous work on the main thread during the component mounting phase.
  - 'To fix this, I will implement a two-pronged optimization strategy:'
  - >-
    1.  **Defer Count Calculation**: The new `useMessagingTaskCounts` hook
    calculates counts by iterating through all tasks. I'll modify this hook to
    perform the calculation asynchronously using `requestAnimationFrame`. This
    will ensure the initial render is lightning-fast and animations can begin
    smoothly, with the tab counts appearing a fraction of a second later once
    the main thread is free.
  - >-
    2.  **Memoize Tab Configuration**: In `TaskList.tsx`, the `TABS` array
    passed to `AnimatedTabs` was being recreated on every render. I will memoize
    this array using the `useMemo` hook. This is a crucial optimization because
    `AnimatedTabs` uses this prop in a `useLayoutEffect` dependency array;
    stabilizing it prevents unnecessary effect re-runs and re-renders of the tab
    component.
  - >-
    These changes will significantly improve the perceived performance and
    ensure a smooth, responsive user experience on initial load.
  - >-
    First, I'll update the `useMessagingTaskCounts` hook to defer its
    calculation.
  - Next, I'll apply the memoization optimization to the `TaskList` component.
operations:
  - type: write
    path: src/pages/Messaging/store/messaging.store.ts
    content: >+
      --- src/pages/Messaging/store/messaging.store.ts

      +++ src/pages/Messaging/store/messaging.store.ts

      @@ -1,4 +1,4 @@

      -import { useMemo } from 'react';

      +import { useState, useEffect } from 'react';
       import { create } from 'zustand';
       import { mockTasks, mockContacts, mockAssignees } from '../data/mockData';
       import type { Task, Contact, Channel, Assignee, TaskStatus, TaskPriority, TaskView, Message, JourneyPointType } from '../types';
      @@ -128,29 +128,38 @@
       }));
       
       export const useMessagingTaskCounts = () => {
         const tasks = useMessagingStore(s => s.tasks);
      -

      -  return useMemo(() => {

      -      const counts: Record<TaskView, number> = {

      -          all_open: 0,

      -          unassigned: 0,

      -          me: 0,

      -          done: 0,

      -      };

      -

      -      for (const task of tasks) {

      -          const isOpenOrInProgress = task.status === 'open' ||
      task.status === 'in-progress';

      -

      -          if (isOpenOrInProgress) {

      -              counts.all_open++;

      -              if (!task.assigneeId) {

      -                  counts.unassigned++;

      -              }

      -              if (task.assigneeId === currentUserId) {

      -                  counts.me++;

      -              }

      -          } else if (task.status === 'done') {

      -              counts.done++;

      -          }

      -      }

      -      return counts;

      -  }, [tasks]);

      +  const [counts, setCounts] = useState<Record<TaskView, number>>({

      +    all_open: 0,

      +    unassigned: 0,

      +    me: 0,

      +    done: 0,

      +  });

      +

      +  useEffect(() => {

      +    // Deferring the count calculation until after the first paint.

      +    // This frees up the main thread for initial animations to run
      smoothly.

      +    const animationFrameId = requestAnimationFrame(() => {

      +        const newCounts: Record<TaskView, number> = {

      +            all_open: 0,

      +            unassigned: 0,

      +            me: 0,

      +            done: 0,

      +        };

      +

      +        for (const task of tasks) {

      +            const isOpenOrInProgress = task.status === 'open' ||
      task.status === 'in-progress';

      +

      +            if (isOpenOrInProgress) {

      +                newCounts.all_open++;

      +                if (!task.assigneeId) newCounts.unassigned++;

      +                if (task.assigneeId === currentUserId) newCounts.me++;

      +            } else if (task.status === 'done') {

      +                newCounts.done++;

      +            }

      +        }

      +        setCounts(newCounts);

      +    });

      +

      +    return () => cancelAnimationFrame(animationFrameId);

      +  }, [tasks]);

      +

      +  return counts;
       };

    patchStrategy: standard-diff
  - type: write
    path: src/pages/Messaging/components/TaskList.tsx
    content: |+
      --- src/pages/Messaging/components/TaskList.tsx
      +++ src/pages/Messaging/components/TaskList.tsx
      @@ -1,4 +1,4 @@
      -import { useEffect } from 'react';
      +import { useEffect, useMemo } from 'react';
       import { Search, SlidersHorizontal, Check, Inbox, Clock, Zap, Shield, Eye } from 'lucide-react';
       import { Link, useParams } from 'react-router-dom';
       import { formatDistanceToNow } from 'date-fns';
      @@ -42,6 +42,13 @@
           { value: 'high', label: 'High' }, { value: 'medium', label: 'Medium' }, { value: 'low', label: 'Low' }, { value: 'none', label: 'None' }
       ];
       
      +const TABS_CONFIG: { id: TaskView, label: string }[] = [
      +  { id: 'all_open', label: 'Open' },
      +  { id: 'unassigned', label: 'Unassigned' },
      +  { id: 'me', label: 'Me' },
      +  { id: 'done', label: 'Done' }
      +];
      +
       export const TaskList = () => {
         const { conversationId } = useParams<{ conversationId: string }>(); // This will be taskId later
         const { 
      @@ -60,17 +67,14 @@
         const filteredTasks = getFilteredTasks();
         const activeFilterCount = Object.values(activeFilters).reduce((count, filterArray) => count + filterArray.length, 0);
       
      -  const TABS_CONFIG: { id: TaskView, label: string }[] = [
      -    { id: 'all_open', label: 'Open' },
      -    { id: 'unassigned', label: 'Unassigned' },
      -    { id: 'me', label: 'Me' },
      -    { id: 'done', label: 'Done' }
      -  ];
      -
      -  const TABS = TABS_CONFIG.map(tab => ({
      -    ...tab,
      -    count: taskCounts[tab.id as keyof typeof taskCounts]
      -  }));
      +  const TABS = useMemo(() => 
      +    TABS_CONFIG.map(tab => ({
      +      ...tab,
      +      count: taskCounts[tab.id as keyof typeof taskCounts]
      +    })), 
      +    [taskCounts]
      +  );
       
         return (
           <div className="h-full flex flex-col bg-background/80">

    patchStrategy: standard-diff
snapshot:
  src/pages/Messaging/store/messaging.store.ts: >-
    import { useMemo } from 'react';

    import { create } from 'zustand';

    import { mockTasks, mockContacts, mockAssignees } from '../data/mockData';

    import type { Task, Contact, Channel, Assignee, TaskStatus, TaskPriority,
    TaskView, Message, JourneyPointType } from '../types';


    const currentUserId = 'user-1'; // Mock current user


    interface MessagingState {
      tasks: Task[];
      contacts: Contact[];
      assignees: Assignee[];
      searchTerm: string;
      activeFilters: {
        channels: Channel[];
        tags: string[];
        status: TaskStatus[];
        priority: TaskPriority[];
        assigneeId: string[];
      };
      activeTaskView: TaskView;
    }


    interface MessagingActions {
      getTaskById: (id: string) => (Task & { contact: Contact, assignee: Assignee | null, activeHandler: Assignee | null }) | undefined;
      getFilteredTasks: () => (Task & { contact: Contact, assignee: Assignee | null })[];
      setSearchTerm: (term: string) => void;
      setActiveTaskView: (view: TaskView) => void;
      setFilters: (filters: Partial<MessagingState['activeFilters']>) => void;
      updateTask: (taskId: string, updates: Partial<Omit<Task, 'id'>>) => void;
      takeOverTask: (taskId: string, userId: string) => void;
      requestAndSimulateTakeover: (taskId: string, requestedByUserId: string) => void;
      getAssigneeById: (assigneeId: string) => Assignee | undefined;
      getContactsByCompany: (companyName: string, currentContactId: string) => Contact[];
      getAvailableTags: () => string[];
    }


    export const useMessagingStore = create<MessagingState &
    MessagingActions>((set, get) => ({
      tasks: mockTasks,
      contacts: mockContacts,
      assignees: mockAssignees,
      searchTerm: '',
      activeFilters: {
        channels: [],
        tags: [],
        status: [],
        priority: [],
        assigneeId: [],
      },
      activeTaskView: 'all_open',

      getTaskById: (id) => {
        const task = get().tasks.find(t => t.id === id);
        if (!task) return undefined;

        const contact = get().contacts.find(c => c.id === task.contactId);
        if (!contact) return undefined;

        const assignee = get().assignees.find(a => a.id === task.assigneeId) || null;
        const activeHandler = get().assignees.find(a => a.id === task.activeHandlerId) || null;

        return { ...task, contact, assignee, activeHandler };
      },

      getFilteredTasks: () => {
        const { tasks, contacts, assignees, searchTerm, activeFilters, activeTaskView } = get();
        const lowercasedSearch = searchTerm.toLowerCase();

        const viewFilteredTasks = tasks.filter(task => {
          switch (activeTaskView) {
            case 'all_open':
              return task.status === 'open' || task.status === 'in-progress';
            case 'unassigned':
              return !task.assigneeId && (task.status === 'open' || task.status === 'in-progress');
            case 'me':
              return task.assigneeId === currentUserId && (task.status === 'open' || task.status === 'in-progress');
            case 'done':
              return task.status === 'done';
            default:
              return true;
          }
        });
        const mapped = viewFilteredTasks.map(task => {
          const contact = contacts.find(c => c.id === task.contactId) as Contact;
          const assignee = assignees.find(a => a.id === task.assigneeId) || null;
          return { ...task, contact, assignee };
        });

        const filtered = mapped.filter(task => {
          const searchMatch = task.title.toLowerCase().includes(lowercasedSearch) || task.contact.name.toLowerCase().includes(lowercasedSearch);
          const channelMatch = activeFilters.channels.length === 0 || activeFilters.channels.includes(task.channel);
          const tagMatch = activeFilters.tags.length === 0 || activeFilters.tags.some(tag => task.tags.includes(tag));
          const statusMatch = activeFilters.status.length === 0 || activeFilters.status.includes(task.status);
          const priorityMatch = activeFilters.priority.length === 0 || activeFilters.priority.includes(task.priority);
          const assigneeMatch = activeFilters.assigneeId.length === 0 || (task.assigneeId && activeFilters.assigneeId.includes(task.assigneeId));
          
          return searchMatch && channelMatch && tagMatch && statusMatch && priorityMatch && assigneeMatch;
        });

        return filtered.sort((a, b) => new Date(b.lastActivity.timestamp).getTime() - new Date(a.lastActivity.timestamp).getTime());
      },

      setSearchTerm: (term) => set({ searchTerm: term }),
      
      setActiveTaskView: (view) => set({ activeTaskView: view }),

      setFilters: (newFilters) => set(state => ({
        activeFilters: { ...state.activeFilters, ...newFilters }
      })),

      updateTask: (taskId, updates) => set(state => ({
        tasks: state.tasks.map(task => 
          task.id === taskId 
            ? { ...task, ...updates, lastActivity: { ...task.lastActivity, timestamp: new Date().toISOString() } } 
            : task
        )
      })),

      takeOverTask: (taskId, userId) => set(state => ({
        tasks: state.tasks.map(task => 
          task.id === taskId 
            ? { ...task, activeHandlerId: userId, takeoverRequested: false } 
            : task
        )
      })),

      requestAndSimulateTakeover: (taskId, requestedByUserId) => {
        set(state => ({
          tasks: state.tasks.map(task => 
            task.id === taskId ? { ...task, takeoverRequested: true } : task
          )
        }));
        // Simulate a 2-second delay for the other user to "approve"
        setTimeout(() => get().takeOverTask(taskId, requestedByUserId), 2000);
      },

      getAssigneeById: (assigneeId: string) => {
        return get().assignees.find(a => a.id === assigneeId);
      },

      getContactsByCompany: (companyName, currentContactId) => {
        return get().contacts.filter(
          c => c.company === companyName && c.id !== currentContactId
        );
      },

      getAvailableTags: () => {
        const contactTags = get().contacts.flatMap(c => c.tags);
        const taskTags = get().tasks.flatMap(t => t.tags);
        const allTags = new Set([...contactTags, ...taskTags]);
        return Array.from(allTags);
      }
    }));


    export const useMessagingTaskCounts = () => {
      const tasks = useMessagingStore(s => s.tasks);

      return useMemo(() => {
          const counts: Record<TaskView, number> = {
              all_open: 0,
              unassigned: 0,
              me: 0,
              done: 0,
          };

          for (const task of tasks) {
              const isOpenOrInProgress = task.status === 'open' || task.status === 'in-progress';

              if (isOpenOrInProgress) {
                  counts.all_open++;
                  if (!task.assigneeId) {
                      counts.unassigned++;
                  }
                  if (task.assigneeId === currentUserId) {
                      counts.me++;
                  }
              } else if (task.status === 'done') {
                  counts.done++;
              }
          }
          return counts;
      }, [tasks]);
    };
  src/pages/Messaging/components/TaskList.tsx: >-
    import { useEffect } from 'react';

    import { Search, SlidersHorizontal, Check, Inbox, Clock, Zap, Shield, Eye }
    from 'lucide-react';

    import { Link, useParams } from 'react-router-dom';

    import { formatDistanceToNow } from 'date-fns';

    import { useMessagingStore } from '../store/messaging.store';

    import { Button } from '@/components/ui/button';

    import { Input } from '@/components/ui/input';

    import { Avatar, AvatarFallback, AvatarImage } from
    '@/components/ui/avatar';

    import { Badge } from '@/components/ui/badge';

    import { Popover, PopoverContent, PopoverTrigger } from
    '@/components/ui/popover';

    import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem,
    CommandList, CommandSeparator } from '@/components/ui/command';

    import { cn } from '@/lib/utils';

    import { AnimatedTabs } from '@/components/ui/animated-tabs';

    import type { TaskStatus, TaskPriority, TaskView } from '../types';

    import { useAppViewManager } from '@/hooks/useAppViewManager.hook';

    import { useMessagingTaskCounts } from '../store/messaging.store';


    // Local helpers for styling based on task properties

    const getStatusIcon = (status: TaskStatus) => {
        switch(status) {
            case 'open': return <Inbox className="w-3 h-3 text-blue-500" />;
            case 'in-progress': return <Zap className="w-3 h-3 text-yellow-500" />;
            case 'done': return <Shield className="w-3 h-3 text-green-500" />;
            case 'snoozed': return <Clock className="w-3 h-3 text-gray-500" />;
        }
    };


    const getPriorityIcon = (priority: TaskPriority) => {
        switch(priority) {
            case 'high': return <div className="w-2 h-2 rounded-full bg-red-500" />;
            case 'medium': return <div className="w-2 h-2 rounded-full bg-yellow-500" />;
            case 'low': return <div className="w-2 h-2 rounded-full bg-green-500" />;
            default: return <div className="w-2 h-2 rounded-full bg-gray-400" />;
        }
    };


    const statusOptions: { value: TaskStatus; label: string }[] = [
        { value: 'open', label: 'Open' }, { value: 'in-progress', label: 'In Progress' }, { value: 'done', label: 'Done' }, { value: 'snoozed', label: 'Snoozed' }
    ];

    const priorityOptions: { value: TaskPriority; label: string }[] = [
        { value: 'high', label: 'High' }, { value: 'medium', label: 'Medium' }, { value: 'low', label: 'Low' }, { value: 'none', label: 'None' }
    ];


    export const TaskList = () => {
      const { conversationId } = useParams<{ conversationId: string }>(); // This will be taskId later
      const { 
        getFilteredTasks,
        setSearchTerm,
        activeFilters,
        setActiveTaskView,
        searchTerm,
       } = useMessagingStore();
       const { messagingView, setMessagingView } = useAppViewManager();
       const taskCounts = useMessagingTaskCounts();

      useEffect(() => {
        setActiveTaskView(messagingView || 'all_open');
      }, [messagingView, setActiveTaskView]);

      const filteredTasks = getFilteredTasks();
      const activeFilterCount = Object.values(activeFilters).reduce((count, filterArray) => count + filterArray.length, 0);

      const TABS_CONFIG: { id: TaskView, label: string }[] = [
        { id: 'all_open', label: 'Open' },
        { id: 'unassigned', label: 'Unassigned' },
        { id: 'me', label: 'Me' },
        { id: 'done', label: 'Done' }
      ];

      const TABS = TABS_CONFIG.map(tab => ({
        ...tab,
        count: taskCounts[tab.id as keyof typeof taskCounts]
      }));

      return (
        <div className="h-full flex flex-col bg-background/80">
          {/* Header */}
          <div className="flex-shrink-0 border-b bg-background/80 p-4 space-y-4">
            <h2 className="text-xl font-bold tracking-tight">Inbox</h2>
            <div className="flex gap-2">
                <div className="relative flex-1">
                    <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground" />
                    <Input placeholder="Search tasks..." className="pl-9" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
                </div>
                <Popover>
                    <PopoverTrigger asChild>
                        <Button variant="outline" size="sm" className="h-10 border-dashed gap-2">
                            <SlidersHorizontal className="w-4 h-4" />
                            Filters
                            {activeFilterCount > 0 && <Badge variant="secondary" className="rounded-sm px-1 font-normal">{activeFilterCount}</Badge>}
                        </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-[240px] p-0" align="end">
                        <FilterCommand />
                    </PopoverContent>
                </Popover>
            </div>
          </div>
          <AnimatedTabs
            tabs={TABS}
            activeTab={messagingView || 'all_open'}
            onTabChange={(tabId) => setMessagingView(tabId as TaskView)}
            size="sm"
            className="px-4"
          />

          {/* Task List */}
          <div className="flex-1 overflow-y-auto">
            <nav className="p-2 space-y-1">
              {filteredTasks.map(task => {
                const currentUserId = 'user-1';
                const isHandledByOther = task.activeHandlerId && task.activeHandlerId !== currentUserId;

                return (
                  <Link
                    to={`/messaging/${task.id}`}
                    key={task.id}
                    className={cn(
                      "block p-3 rounded-lg text-left transition-all duration-200 hover:bg-accent/50",
                      "focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 outline-none",
                      conversationId === task.id && "bg-accent"
                    )}
                  >
                    <div className="flex items-start gap-3">
                      <Avatar className="h-9 w-9 mt-1">
                        <AvatarImage src={task.contact.avatar} alt={task.contact.name} />
                        <AvatarFallback>{task.contact.name.charAt(0)}</AvatarFallback>
                      </Avatar>
                      <div className="flex-1 overflow-hidden">
                          <div className="flex justify-between items-center mb-1">
                              <p className="text-sm font-semibold truncate pr-2">
                                {task.contact.name} <span className="text-muted-foreground font-normal">&middot; {task.contact.company}</span>
                              </p>
                              <p className="text-xs text-muted-foreground whitespace-nowrap">{formatDistanceToNow(new Date(task.lastActivity.timestamp), { addSuffix: true })}</p>
                          </div>
                          <p className="text-sm truncate text-foreground">{task.title}</p>
                          <div className="flex items-center gap-3 mt-2 text-xs text-muted-foreground">
                              <div className="flex items-center gap-1.5" title={task.status}>
                                  {getStatusIcon(task.status)}
                                  <span className="capitalize">{task.status.replace('-', ' ')}</span>
                              </div>
                              <div className="flex items-center gap-1.5" title={task.priority}>
                                  {getPriorityIcon(task.priority)}
                                  <span className="capitalize">{task.priority}</span>
                              </div>
                              {task.assignee && (
                                  <div className="flex items-center gap-1.5" title={`Assigned to ${task.assignee.name}`}>
                                      <Avatar className="h-4 w-4"><AvatarImage src={task.assignee.avatar} /></Avatar>
                                  </div>
                              )}
                              {isHandledByOther && <Eye className="w-3.5 h-3.5" title="Being handled by another user" />}
                          </div>
                      </div>
                      {task.unreadCount > 0 && (
                          <div className="flex items-center justify-center self-center ml-auto">
                              <Badge className="bg-primary h-5 w-5 p-0 flex items-center justify-center">{task.unreadCount}</Badge>
                          </div>
                      )}
                    </div>
                  </Link>
                )
              })}
            </nav>
          </div>
        </div>
      );
    };


    // Filter component for popover

    function FilterCommand() {
        const { activeFilters, setFilters, assignees, getAvailableTags } = useMessagingStore();
        const availableTags = getAvailableTags();

        const handleSelect = (type: 'status' | 'priority' | 'assigneeId' | 'tags', value: string) => {
            const current = new Set(activeFilters[type]);
            current.has(value) ? current.delete(value) : current.add(value);
            setFilters({ [type]: Array.from(current) });
        };

        const hasActiveFilters = Object.values(activeFilters).some(arr => arr.length > 0);

        return (
            <Command>
                <CommandInput placeholder="Filter by..." />
                <CommandList>
                    <CommandEmpty>No results found.</CommandEmpty>
                    <CommandGroup heading="Status">
                        {statusOptions.map(o => (
                            <CommandItem key={o.value} onSelect={() => handleSelect('status', o.value)}>
                                <div className={cn('mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary', activeFilters.status.includes(o.value) ? 'bg-primary text-primary-foreground' : 'opacity-50 [&_svg]:invisible')}><Check className="h-4 w-4" /></div>
                                <span>{o.label}</span>
                            </CommandItem>
                        ))}
                    </CommandGroup>
                    <CommandSeparator />
                    <CommandGroup heading="Priority">
                        {priorityOptions.map(o => (
                            <CommandItem key={o.value} onSelect={() => handleSelect('priority', o.value)}>
                                <div className={cn('mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary', activeFilters.priority.includes(o.value) ? 'bg-primary text-primary-foreground' : 'opacity-50 [&_svg]:invisible')}><Check className="h-4 w-4" /></div>
                                <span>{o.label}</span>
                            </CommandItem>
                        ))}
                    </CommandGroup>
                    <CommandSeparator />
                    <CommandGroup heading="Assignee">
                        {assignees.map(a => (
                            <CommandItem key={a.id} onSelect={() => handleSelect('assigneeId', a.id)}>
                                <div className={cn('mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary', activeFilters.assigneeId.includes(a.id) ? 'bg-primary text-primary-foreground' : 'opacity-50 [&_svg]:invisible')}><Check className="h-4 w-4" /></div>
                                <Avatar className="h-5 w-5 mr-2"><AvatarImage src={a.avatar} /><AvatarFallback>{a.name.charAt(0)}</AvatarFallback></Avatar>
                                <span>{a.name}</span>
                            </CommandItem>
                        ))}
                    </CommandGroup>
                    <CommandSeparator />
                    <CommandGroup heading="Tags">
                        {availableTags.map(t => (
                            <CommandItem key={t} onSelect={() => handleSelect('tags', t)}>
                                <div className={cn('mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary', activeFilters.tags.includes(t) ? 'bg-primary text-primary-foreground' : 'opacity-50 [&_svg]:invisible')}><Check className="h-4 w-4" /></div>
                                <span>{t}</span>
                            </CommandItem>
                        ))}
                    </CommandGroup>

                    {hasActiveFilters && (
                        <>
                            <CommandSeparator />
                            <CommandGroup>
                                <CommandItem onSelect={() => setFilters({ status: [], priority: [], assigneeId: [], tags: [], channels: [] })} className="justify-center text-center text-sm">Clear all filters</CommandItem>
                            </CommandGroup>
                        </>
                    )}
                </CommandList>
            </Command>
        );
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-10-17T13:15:25.358Z'
status: committed
id: 425
