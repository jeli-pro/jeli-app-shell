uuid: 1dfb85e0-e8f0-466d-96ab-26017b2046f5
projectId: jeli-app-shell
createdAt: '2025-10-13T08:01:06.844Z'
gitCommitMsg: >-
  fix(routing): enforce URL as single source of truth for pane state

  Removed state-mutating actions (`openSidePane`, `closeSidePane`,
  `toggleSplitView`) from the `AppShellContext`. This change enforces a strict
  one-way data flow where all UI state changes for panes must be driven by
  modifying the URL search parameters.

  This resolves a critical bug where direct context mutations were conflicting
  with the central URL-syncing effect in `App.tsx`, leading to UI "flapping,"
  unresponsiveness, and visual glitches with the side pane overlay. All
  components now correctly manipulate the URL, which serves as the single source
  of truth.
promptSummary: >-
  The user is reporting a persistent bug with the overlay side pane becoming
  unresponsive or getting stuck after rapid clicks, indicating a state
  synchronization issue between the URL and the context.
reasoning:
  - >-
    You've correctly identified a classic and tricky bug that often appears
    after migrating from a manual state-based routing system to a URL-driven
    one. The "flapping" and unresponsiveness are tell-tale signs of a state
    conflict or render loop. The root cause is that some parts of the
    application were still updating the visual state directly, while the main
    component (`App.tsx`) was trying to sync the state from the URL, creating a
    fight.
  - >-
    The solution is to make the data flow strictly one-way: **User Action -> URL
    -> App State -> UI**.
  - >-
    To enforce this, I will remove the state-mutating actions (`openSidePane`,
    `closeSidePane`, etc.) from the `AppShellContext`. This forces all
    components to manage pane state by manipulating the URL's search parameters,
    which is the single source of truth.
  - '### Step 1: Purge State-Mutating Actions from `AppShellContext`'
  - >-
    I will remove the actions that directly modify the body/pane state from the
    context. This is the core of the fix, as it eliminates any possibility of a
    component bypassing the URL to change the UI, thus preventing state
    conflicts.
  - '### Step 2: Clean Up Unused `useAppShell` Destructuring in `AppTopBar`'
  - >-
    Removing the actions from the context would cause a TypeScript error in
    `AppTopBar` which was destructuring `openSidePane` even though it wasn't
    using it. I'll clean this up.
  - >-
    These changes will stabilize the application's routing and side pane
    behavior by ensuring the URL is the single, undisputed source of truth for
    the application's view state.
  - '---'
operations:
  - type: write
    path: src/context/AppShellContext.tsx
    content: >+
      --- src/context/AppShellContext.tsx

      +++ src/context/AppShellContext.tsx

      @@ -140,12 +140,6 @@
         showSidebar: () => void;
         peekSidebar: () => void;
         toggleFullscreen: (target?: 'main' | 'right' | null) => void;
      -  toggleSplitView: (content?: AppShellState['sidePaneContent']) => void;

      -  openSidePane: (content: AppShellState['sidePaneContent']) => void;

      -  closeSidePane: () => void;
         resetToDefaults: () => void;
       }
       
      @@ -192,34 +186,7 @@
           }
         }, [state.bodyState, state.previousBodyState]);
       
      -  const toggleSplitView = useCallback((content?:
      AppShellState['sidePaneContent']) => {

      -    const current = state.bodyState;

      -    if (current === BODY_STATES.SIDE_PANE) {

      -      dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW
      });

      -      if (state.sidebarState === SIDEBAR_STATES.EXPANDED) {

      -        dispatch({ type: 'SET_SIDEBAR_STATE', payload:
      SIDEBAR_STATES.COLLAPSED });

      -      }

      -    } else if (current === BODY_STATES.SPLIT_VIEW) {

      -      dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE
      });

      -    } else if (current === BODY_STATES.NORMAL && content) {

      -      // If we're in normal view, open the pane and switch to split view

      -      dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: content });

      -      dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW
      });

      -    }

      -  }, [state.bodyState, state.sidebarState]);

      -

      -  const openSidePane = useCallback((content:
      AppShellState['sidePaneContent']) => {

      -    if (state.bodyState === BODY_STATES.SIDE_PANE &&
      state.sidePaneContent === content) {

      -      // If it's open with same content, close it.

      -      dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.NORMAL });

      -    } else {

      -      // If closed, or different content, open with new content.

      -      dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: content });

      -      dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE
      });

      -    }

      -  }, [state.bodyState, state.sidePaneContent]);

      -

      -  const closeSidePane = useCallback(() => dispatch({ type:
      'SET_BODY_STATE', payload: BODY_STATES.NORMAL }), []);
         const resetToDefaults = useCallback(() => dispatch({ type: 'RESET_TO_DEFAULTS' }), []);
       
         const rightPaneWidth = useMemo(() => (
      @@ -235,9 +202,6 @@
           showSidebar,
           peekSidebar,
           toggleFullscreen,
      -    toggleSplitView,

      -    openSidePane,

      -    closeSidePane,
           resetToDefaults,
         }), [
           state, 
      @@ -247,9 +211,6 @@
           showSidebar,
           peekSidebar,
           toggleFullscreen,
      -    toggleSplitView,

      -    openSidePane,

      -    closeSidePane,
           resetToDefaults
         ]);
       

    patchStrategy: standard-diff
  - type: write
    path: src/App.tsx
    content: |
      <<<<<<< SEARCH
      // Content for the Top Bar (will be fully refactored in Part 2)
      function AppTopBar() {
        const { searchTerm, setSearchTerm } = useAppStore();
        const { openSidePane } = useAppShell();
        const [isSearchFocused, setIsSearchFocused] = React.useState(false);
        const location = useLocation();
      =======
      // Content for the Top Bar (will be fully refactored in Part 2)
      function AppTopBar() {
        const { searchTerm, setSearchTerm } = useAppStore();
        const [isSearchFocused, setIsSearchFocused] = React.useState(false);
        const location = useLocation();
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  src/context/AppShellContext.tsx: >-
    import {
      createContext,
      useContext,
      useReducer,
      useEffect,
      useMemo,
      useCallback,
      type ReactNode,
      type ReactElement,
      type Dispatch,
    } from 'react';

    import { SIDEBAR_STATES, BODY_STATES, type SidebarState, type BodyState }
    from '@/lib/utils';


    // --- State and Action Types ---


    export interface AppShellState {
      sidebarState: SidebarState;
      bodyState: BodyState;
      sidePaneContent: 'details' | 'settings' | 'main' | 'toaster' | 'notifications' | 'dataDemo';
      sidebarWidth: number;
      sidePaneWidth: number;
      splitPaneWidth: number;
      previousBodyState: BodyState;
      fullscreenTarget: 'main' | 'right' | null;
      isResizing: boolean;
      isResizingRightPane: boolean;
      isTopBarVisible: boolean;
      autoExpandSidebar: boolean;
      reducedMotion: boolean;
      compactMode: boolean;
      primaryColor: string;
      appName?: string;
      appLogo?: ReactElement;
     draggedPage: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | null;
     dragHoverTarget: 'left' | 'right' | null;
     hoveredPane: 'left' | 'right' | null;
    }


    type AppShellAction =
      | { type: 'SET_SIDEBAR_STATE'; payload: SidebarState }
      | { type: 'SET_BODY_STATE'; payload: BodyState }
      | { type: 'SET_SIDE_PANE_CONTENT'; payload: AppShellState['sidePaneContent'] }
      | { type: 'SET_SIDEBAR_WIDTH'; payload: number }
      | { type: 'SET_SIDE_PANE_WIDTH'; payload: number }
      | { type: 'SET_SPLIT_PANE_WIDTH'; payload: number }
      | { type: 'SET_IS_RESIZING'; payload: boolean }
      | { type: 'SET_PREVIOUS_BODY_STATE'; payload: BodyState }
      | { type: 'SET_FULLSCREEN_TARGET'; payload: 'main' | 'right' | null }
      | { type: 'SET_IS_RESIZING_RIGHT_PANE'; payload: boolean }
      | { type: 'SET_TOP_BAR_VISIBLE'; payload: boolean }
      | { type: 'SET_AUTO_EXPAND_SIDEBAR'; payload: boolean }
      | { type: 'SET_REDUCED_MOTION'; payload: boolean }
      | { type: 'SET_COMPACT_MODE'; payload: boolean }
      | { type: 'SET_PRIMARY_COLOR'; payload: string }
      | { type: 'SET_DRAGGED_PAGE'; payload: 'dashboard' | 'settings' | 'toaster' | 'notifications' | 'data-demo' | null }
      | { type: 'SET_DRAG_HOVER_TARGET'; payload: 'left' | 'right' | null }
      | { type: 'SET_HOVERED_PANE'; payload: 'left' | 'right' | null }
      | { type: 'RESET_TO_DEFAULTS' };

    // --- Reducer ---


    const defaultState: AppShellState = {
      sidebarState: SIDEBAR_STATES.EXPANDED,
      bodyState: BODY_STATES.NORMAL,
      sidePaneContent: 'details',
      sidebarWidth: 280,
      sidePaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.6)) : 400,
      splitPaneWidth: typeof window !== 'undefined' ? Math.max(300, Math.round(window.innerWidth * 0.35)) : 400,
      previousBodyState: BODY_STATES.NORMAL,
      fullscreenTarget: null,
      isResizing: false,
      isResizingRightPane: false,
      isTopBarVisible: true,
      autoExpandSidebar: true,
      reducedMotion: false,
      compactMode: false,
      primaryColor: '220 84% 60%',
      appName: 'Jeli App',
      appLogo: undefined,
      draggedPage: null,
      dragHoverTarget: null,
      hoveredPane: null,
    };


    function appShellReducer(state: AppShellState, action: AppShellAction):
    AppShellState {
      switch (action.type) {
        case 'SET_SIDEBAR_STATE': return { ...state, sidebarState: action.payload };
        case 'SET_BODY_STATE':
          // If we're leaving fullscreen, reset the target and previous state
          if (state.bodyState === BODY_STATES.FULLSCREEN && action.payload !== BODY_STATES.FULLSCREEN) {
            return { ...state, bodyState: action.payload, fullscreenTarget: null, previousBodyState: BODY_STATES.NORMAL };
          }
          return { ...state, bodyState: action.payload };
        case 'SET_SIDE_PANE_CONTENT': return { ...state, sidePaneContent: action.payload };
        case 'SET_SIDEBAR_WIDTH': return { ...state, sidebarWidth: Math.max(200, Math.min(500, action.payload)) };
        case 'SET_SIDE_PANE_WIDTH': return { ...state, sidePaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };
        case 'SET_SPLIT_PANE_WIDTH': return { ...state, splitPaneWidth: Math.max(300, Math.min(window.innerWidth * 0.8, action.payload)) };
        case 'SET_IS_RESIZING': return { ...state, isResizing: action.payload };
        case 'SET_PREVIOUS_BODY_STATE': return { ...state, previousBodyState: action.payload };
        case 'SET_FULLSCREEN_TARGET': return { ...state, fullscreenTarget: action.payload };
        case 'SET_IS_RESIZING_RIGHT_PANE': return { ...state, isResizingRightPane: action.payload };
        case 'SET_TOP_BAR_VISIBLE': return { ...state, isTopBarVisible: action.payload };
        case 'SET_AUTO_EXPAND_SIDEBAR': return { ...state, autoExpandSidebar: action.payload };
        case 'SET_REDUCED_MOTION': return { ...state, reducedMotion: action.payload };
        case 'SET_COMPACT_MODE': return { ...state, compactMode: action.payload };
        case 'SET_PRIMARY_COLOR': return { ...state, primaryColor: action.payload };
        case 'SET_DRAGGED_PAGE': return { ...state, draggedPage: action.payload };
        case 'SET_DRAG_HOVER_TARGET': return { ...state, dragHoverTarget: action.payload };
        case 'SET_HOVERED_PANE': return { ...state, hoveredPane: action.payload };
        case 'RESET_TO_DEFAULTS':
          return {
            ...defaultState,
            appName: state.appName, // Preserve props passed to provider
            appLogo: state.appLogo,   // Preserve props passed to provider
          };
        default: return state;
      }
    }


    // --- Context and Provider ---


    interface AppShellContextValue extends AppShellState {
      dispatch: Dispatch<AppShellAction>;
      rightPaneWidth: number;
      // Composite actions for convenience
      toggleSidebar: () => void;
      hideSidebar: () => void;
      showSidebar: () => void;
      peekSidebar: () => void;
      toggleFullscreen: (target?: 'main' | 'right' | null) => void;
      toggleSplitView: (content?: AppShellState['sidePaneContent']) => void;
      openSidePane: (content: AppShellState['sidePaneContent']) => void;
      closeSidePane: () => void;
      resetToDefaults: () => void;
    }


    const AppShellContext = createContext<AppShellContextValue | null>(null);


    interface AppShellProviderProps {
      children: ReactNode;
      appName?: string;
      appLogo?: ReactElement;
      defaultSplitPaneWidth?: number;
    }


    export function AppShellProvider({ children, appName, appLogo,
    defaultSplitPaneWidth }: AppShellProviderProps) {
      const [state, dispatch] = useReducer(appShellReducer, {
        ...defaultState,
        ...(appName && { appName }),
        ...(appLogo && { appLogo }),
        ...(defaultSplitPaneWidth && { splitPaneWidth: defaultSplitPaneWidth }),
      });

      // Side effect for primary color
      useEffect(() => {
        document.documentElement.style.setProperty('--primary-hsl', state.primaryColor);
      }, [state.primaryColor]);

      // Memoized composite actions using useCallback for stable function identities
      const toggleSidebar = useCallback(() => {
        const current = state.sidebarState;
        if (current === SIDEBAR_STATES.HIDDEN) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
        else if (current === SIDEBAR_STATES.COLLAPSED) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.EXPANDED });
        else if (current === SIDEBAR_STATES.EXPANDED) dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
      }, [state.sidebarState]);

      const hideSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.HIDDEN }), []);
      const showSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.EXPANDED }), []);
      const peekSidebar = useCallback(() => dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.PEEK }), []);
      
      const toggleFullscreen = useCallback((target: 'main' | 'right' | null = null) => {
        const current = state.bodyState;
        if (current === BODY_STATES.FULLSCREEN) {
          // Exiting fullscreen, go back to the previous state
          dispatch({ type: 'SET_BODY_STATE', payload: state.previousBodyState || BODY_STATES.NORMAL });
        } else {
          // Entering fullscreen
          dispatch({ type: 'SET_PREVIOUS_BODY_STATE', payload: current });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.FULLSCREEN });
          dispatch({ type: 'SET_FULLSCREEN_TARGET', payload: target });
        }
      }, [state.bodyState, state.previousBodyState]);

      const toggleSplitView = useCallback((content?: AppShellState['sidePaneContent']) => {
        const current = state.bodyState;
        if (current === BODY_STATES.SIDE_PANE) {
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
          if (state.sidebarState === SIDEBAR_STATES.EXPANDED) {
            dispatch({ type: 'SET_SIDEBAR_STATE', payload: SIDEBAR_STATES.COLLAPSED });
          }
        } else if (current === BODY_STATES.SPLIT_VIEW) {
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE });
        } else if (current === BODY_STATES.NORMAL && content) {
          // If we're in normal view, open the pane and switch to split view
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: content });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
        }
      }, [state.bodyState, state.sidebarState]);

      const openSidePane = useCallback((content: AppShellState['sidePaneContent']) => {
        if (state.bodyState === BODY_STATES.SIDE_PANE && state.sidePaneContent === content) {
          // If it's open with same content, close it.
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.NORMAL });
        } else {
          // If closed, or different content, open with new content.
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: content });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE });
        }
      }, [state.bodyState, state.sidePaneContent]);

      const closeSidePane = useCallback(() => dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.NORMAL }), []);
      const resetToDefaults = useCallback(() => dispatch({ type: 'RESET_TO_DEFAULTS' }), []);

      const rightPaneWidth = useMemo(() => (
        state.bodyState === BODY_STATES.SPLIT_VIEW ? state.splitPaneWidth : state.sidePaneWidth
      ), [state.bodyState, state.splitPaneWidth, state.sidePaneWidth]);

      const value = useMemo(() => ({ 
        ...state, 
        dispatch,
        rightPaneWidth,
        toggleSidebar,
        hideSidebar,
        showSidebar,
        peekSidebar,
        toggleFullscreen,
        toggleSplitView,
        openSidePane,
        closeSidePane,
        resetToDefaults,
      }), [
        state, 
        rightPaneWidth,
        toggleSidebar,
        hideSidebar,
        showSidebar,
        peekSidebar,
        toggleFullscreen,
        toggleSplitView,
        openSidePane,
        closeSidePane,
        resetToDefaults
      ]);

      return (
        <AppShellContext.Provider value={value}>
          {children}
        </AppShellContext.Provider>
      );
    }


    // --- Hook ---


    export function useAppShell() {
      const context = useContext(AppShellContext);
      if (!context) {
        throw new Error('useAppShell must be used within an AppShellProvider');
      }
      return context;
    }
  src/App.tsx: |-
    import React, { useEffect } from "react";
    import {
      createBrowserRouter,
      RouterProvider,
      Outlet,
      Navigate,
      useNavigate,
      useLocation,
      useSearchParams,
    } from "react-router-dom";

    import { AppShell } from "./components/layout/AppShell";
    import { AppShellProvider, useAppShell } from "./context/AppShellContext";
    import { useAppStore } from "./store/appStore";
    import { useAuthStore } from "./store/authStore";
    import "./index.css";

    // Import library components
    import { EnhancedSidebar } from "./components/layout/EnhancedSidebar";
    import { MainContent } from "./components/layout/MainContent";
    import { RightPane } from "./components/layout/RightPane";
    import { TopBar } from "./components/layout/TopBar";
    import { CommandPalette } from "./components/global/CommandPalette";
    import { ToasterProvider } from "./components/ui/toast";

    // Import page/content components
    import { DashboardContent } from "./pages/Dashboard";
    import { SettingsPage } from "./pages/Settings";
    import { ToasterDemo } from "./pages/ToasterDemo";
    import { NotificationsPage } from "./pages/Notifications";
    import DataDemoPage from "./pages/DataDemo";
    import { SettingsContent } from "./features/settings/SettingsContent";
    import { LoginPage } from "./components/auth/LoginPage";

    // Import icons
    import {
      LayoutDashboard,
      Settings,
      Component,
      Bell,
      SlidersHorizontal,
      ChevronsLeftRight,
      Search,
      Filter,
      Plus,
      ChevronRight,
      Rocket,
      Layers,
      SplitSquareHorizontal,
      Database,
    } from "lucide-react";
    import { BODY_STATES } from "./lib/utils";
    import { cn } from "./lib/utils";

    // Wrapper for LoginPage to provide auth handlers
    function LoginPageWrapper() {
      const { login, forgotPassword } = useAuthStore();
      const navigate = useNavigate();

      const handleLogin = async (email: string, password: string) => {
        try {
          await login(email, password);
          navigate("/");
        } catch (error) {
          console.error("Login failed:", error);
          // In a real app, you'd show an error message to the user
        }
      };

      const handleForgotPassword = async (email: string) => {
        try {
          await forgotPassword(email);
        } catch (error) {
          console.error("Forgot password failed:", error);
        }
      };

      const handleSignUp = () => {
        // In a real app, navigate to sign up page
        console.log("Navigate to sign up page");
      };

      return (
        <LoginPage
          onLogin={handleLogin}
          onForgotPassword={handleForgotPassword}
          onSignUp={handleSignUp}
        />
      );
    }

    // Checks for authentication and redirects to login if needed
    function ProtectedRoute() {
      const { isAuthenticated } = useAuthStore();
      if (!isAuthenticated) {
        return <Navigate to="/login" replace />;
      }
      return <Outlet />;
    }

    // The main layout for authenticated parts of the application
    function ProtectedLayout() {
      const isDarkMode = useAppStore((state) => state.isDarkMode);

      useEffect(() => {
        document.documentElement.classList.toggle("dark", isDarkMode);
      }, [isDarkMode]);

      return (
        <div className="h-screen w-screen overflow-hidden bg-background">
          <AppShellProvider
            appName="Jeli App"
            appLogo={
              <div className="p-2 bg-primary/20 rounded-lg">
                <Rocket className="w-5 h-5 text-primary" />
              </div>
            }
          >
            <ComposedApp />
          </AppShellProvider>
        </div>
      );
    }

    // Content for the Top Bar (will be fully refactored in Part 2)
    function AppTopBar() {
      const { searchTerm, setSearchTerm } = useAppStore();
      const { openSidePane } = useAppShell();
      const [isSearchFocused, setIsSearchFocused] = React.useState(false);
      const location = useLocation();
      const activePage = location.pathname.split('/').filter(Boolean).pop()?.replace('-', ' ') || 'dashboard';

      return (
        <div className="flex items-center gap-3 flex-1">
          <div
            className={cn(
              "hidden md:flex items-center gap-2 text-sm transition-opacity",
              {
                "opacity-0 pointer-events-none":
                  isSearchFocused && activePage === "dashboard",
              },
            )}
          >
            <a
              href="#"
              className="text-muted-foreground hover:text-foreground transition-colors"
            >
              Home
            </a>
            <ChevronRight className="w-4 h-4 text-muted-foreground" />
            <span className="font-medium text-foreground capitalize">
              {activePage}
            </span>
          </div>

          <div className="flex-1" />

          {/* Page-specific: Dashboard search and actions */}
          {activePage === "dashboard" && (
            <div className="flex items-center gap-2 flex-1 justify-end">
              <div
                className={cn(
                  "relative transition-all duration-300 ease-in-out",
                  isSearchFocused ? "flex-1 max-w-lg" : "w-auto",
                )}
              >
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4 pointer-events-none" />
                <input
                  type="text"
                  placeholder="Search..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  onFocus={() => setIsSearchFocused(true)}
                  onBlur={() => setIsSearchFocused(false)}
                  className={cn(
                    "pl-9 pr-4 py-2 h-10 border-none rounded-lg bg-card focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all duration-300 ease-in-out w-full",
                    isSearchFocused ? "bg-background" : "w-48",
                  )}
                />
              </div>
              <button className="h-10 w-10 flex-shrink-0 flex items-center justify-center hover:bg-accent rounded-full transition-colors">
                <Filter className="w-5 h-5" />
              </button>
              <button className="bg-primary text-primary-foreground px-4 py-2 rounded-full hover:bg-primary/90 transition-colors flex items-center gap-2 h-10 flex-shrink-0">
                <Plus className="w-5 h-5" />
                <span
                  className={cn(isSearchFocused ? "hidden sm:inline" : "inline")}
                >
                  New Project
                </span>
              </button>
            </div>
          )}
        </div>
      );
    }

    // The main App component that composes the shell
    function ComposedApp() {
      const {
        bodyState,
        dispatch,
      } = useAppShell();
      const navigate = useNavigate();
      const location = useLocation();
      const [searchParams, setSearchParams] = useSearchParams();

      useEffect(() => {
        const pane = searchParams.get('sidePane');
        const view = searchParams.get('view');
        const right = searchParams.get('right');

        if (pane) {
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: pane as any });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE });
        } else if (view === 'split' && right) {
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: right as any });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
        } else {
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.NORMAL });
        }
      }, [searchParams, dispatch]);
      
      const isOverlaySidePane = bodyState === BODY_STATES.SIDE_PANE;

      const contentMap = {
        main: {
          title: "Dashboard",
          icon: LayoutDashboard,
          page: "dashboard",
          content: <DashboardContent isInSidePane={isOverlaySidePane} />,
        },
        settings: {
          title: "Settings",
          icon: Settings,
          page: "settings",
          content: isOverlaySidePane ? (
            <div className="p-6">
              <SettingsContent />
            </div>
          ) : (
            <SettingsPage />
          ),
        },
        toaster: {
          title: "Toaster Demo",
          icon: Component,
          page: "toaster",
          content: <ToasterDemo isInSidePane={isOverlaySidePane} />,
        },
        notifications: {
          title: "Notifications",
          icon: Bell,
          page: "notifications",
          content: <NotificationsPage isInSidePane={isOverlaySidePane} />,
        },
        dataDemo: {
          title: "Data Showcase",
          icon: Database,
          page: "data-demo",
          content: <DataDemoPage isInSidePane={isOverlaySidePane} />,
        },
        details: {
          title: "Details Panel",
          icon: SlidersHorizontal,
          content: (
            <div className="p-6">
              <p className="text-muted-foreground">
                This is the side pane. It can be used to display contextual
                information, forms, or actions related to the main content.
              </p>
            </div>
          ),
        },
      } as const;

      // Derive content directly from URL to prevent flashes of incorrect content
      const sidePaneContent = searchParams.get('sidePane') || searchParams.get('right') || 'details';
      const currentContent =
        contentMap[sidePaneContent as keyof typeof contentMap] ||
        contentMap.details;
      const CurrentIcon = currentContent.icon;

      const handleMaximize = () => {
        if ("page" in currentContent && currentContent.page) {
          navigate(`/${currentContent.page}`, { replace: true });
        } else {
          setSearchParams({}, { replace: true });
        }
      };

      const handleCloseSidePane = () => {
        const newParams = new URLSearchParams(searchParams);
        newParams.delete('sidePane');
        setSearchParams(newParams, { replace: true });
      };

      const handleToggleSplitView = () => {
        if (bodyState === BODY_STATES.SIDE_PANE) {
          const newParams = new URLSearchParams(location.search);
          newParams.set('view', 'split');
          newParams.set('right', sidePaneContent);
          newParams.delete('sidePane');
          setSearchParams(newParams, { replace: true });
        } else if (bodyState === BODY_STATES.SPLIT_VIEW) {
          setSearchParams({ sidePane: sidePaneContent }, { replace: true });
        }
      };

      const rightPaneHeader =
        bodyState !== BODY_STATES.SPLIT_VIEW ? (
          <>
            <div className="flex items-center gap-2">
              <CurrentIcon className="w-5 h-5" />
              <h2 className="text-lg font-semibold whitespace-nowrap">
                {currentContent.title}
              </h2>
            </div>
            <div className="flex items-center">
              {(bodyState === BODY_STATES.SIDE_PANE ||
                bodyState === BODY_STATES.SPLIT_VIEW) && (
                <button
                  onClick={handleToggleSplitView}
                  className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors"
                  title={
                    bodyState === BODY_STATES.SIDE_PANE
                      ? "Switch to Split View"
                      : "Switch to Overlay View"
                  }
                >
                  {bodyState === BODY_STATES.SPLIT_VIEW ? (
                    <Layers className="w-5 h-5" />
                  ) : (
                    <SplitSquareHorizontal className="w-5 h-5" />
                  )}
                </button>
              )}
              {"page" in currentContent && currentContent.page && (
                <button
                  onClick={handleMaximize}
                  className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors mr-2"
                  title="Move to Main View"
                >
                  <ChevronsLeftRight className="w-5 h-5" />
                </button>
              )}
            </div>
          </>
        ) : undefined;

      return (
        <AppShell
          sidebar={<EnhancedSidebar />}
          topBar={
            <TopBar>
              <AppTopBar />
            </TopBar>
          }
          mainContent={
            <MainContent>
              <Outlet />
            </MainContent>
          }
          rightPane={
            <RightPane onClose={handleCloseSidePane} header={rightPaneHeader}>{currentContent.content}</RightPane>
          }
          commandPalette={<CommandPalette />}
        />
      );
    }

    function App() {
      const router = createBrowserRouter([
        {
          path: "/login",
          element: <LoginPageWrapper />,
        },
        {
          path: "/",
          element: <ProtectedRoute />,
          children: [
            {
              path: "/",
              element: <ProtectedLayout />,
              children: [
                { index: true, element: <Navigate to="/dashboard" replace /> },
                { path: "dashboard", element: <DashboardContent /> },
                { path: "settings", element: <SettingsPage /> },
                { path: "toaster", element: <ToasterDemo /> },
                { path: "notifications", element: <NotificationsPage /> },
                { path: "data-demo", element: <DataDemoPage /> },
                { path: "data-demo/:itemId", element: <DataDemoPage /> },
              ],
            },
          ],
        },
      ]);

      return (
        <ToasterProvider>
          <RouterProvider router={router} />
        </ToasterProvider>
      );
    }

    export default App;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 220
