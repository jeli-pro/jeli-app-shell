uuid: 44b7ef4d-f2bb-472d-944a-1064d1f5e2d5
projectId: jeli-app-shell
createdAt: '2025-10-14T02:41:32.334Z'
gitCommitMsg: >-
  refactor: centralize URL state management with useAppViewManager hook

  Introduced a new `useAppViewManager` hook to act as the single source of truth
  for all URL-based view state manipulations. This centralizes logic for side
  panes, split views, navigation, and data filtering/sorting.

  - Created `useAppViewManager` to encapsulate all `react-router-dom`
  interactions. - Created `useRightPaneContent` to simplify right-pane rendering
  logic in `App.tsx`. - Refactored `EnhancedSidebar`, `TopBar`,
  `CommandPalette`, `ViewModeSwitcher`, and `useDataManagement` to use the new
  view manager hook, removing duplicated logic. - Deleted the redundant
  `useUrlStateSync` hook. - Simplified the main `App.tsx` component, improving
  readability and separation of concerns.

  This change significantly improves the maintainability and scalability of the
  application's view layer by enforcing a DRY, declarative pattern for state
  management.
promptSummary: >-
  Refactor codebase to be highly DRY, focusing on logic and state management
  without UI/UX regression.
reasoning:
  - >-
    This is a comprehensive refactoring to centralize all URL-based state
    management into a single, declarative hook. This eliminates redundant logic
    across multiple components, making the application's view state easier to
    manage, reason about, and extend.
  - '### Part 1: Create a Centralized View Manager Hook'
  - >-
    I'll start by creating a new `useAppViewManager` hook. This will become the
    single source of truth for all URL manipulations, including opening side
    panes, toggling split view, navigation, and handling data-specific query
    parameters like filters and sorting. It will provide both the derived state
    from the URL and a set of clean, declarative functions to modify it.
  - '### Part 2: Simplify Right Pane Content Logic'
  - >-
    To further clean up the main `App.tsx` component, I'll extract the logic for
    determining the `RightPane`'s content and header into its own dedicated
    hook, `useRightPaneContent`.
  - '### Part 3: Integrate and Refactor Components'
  - >-
    Now, I will replace all instances of direct URL manipulation with calls to
    our new `useAppViewManager` hook. I'll also delete the now-redundant
    `useUrlStateSync` hook and refactor the main `App` component to use
    `useRightPaneContent`.
  - I'll start by deleting the old URL sync hook.
  - >-
    Next, I'll refactor the `useDataManagement` hook to consume state from
    `useAppViewManager`.
  - I'll refactor the `CommandPalette` to be much simpler.
  - The `EnhancedSidebar`'s menu items will now use the new hook.
  - I'll refactor `TopBar` to remove its local URL logic.
  - The `ViewModeSwitcher` will also be greatly simplified.
  - >-
    Finally, I'll update the main `App.tsx` file to tie everything together. It
    will now use the new hooks, sync state to the context, and have much cleaner
    rendering logic for the right pane.
  - >-
    With these changes, the application's view state logic is now robust,
    centralized, and easy to maintain.
operations:
  - type: write
    path: src/hooks/useAppViewManager.hook.ts
    content: "import { useMemo, useCallback } from 'react';\nimport { useSearchParams, useNavigate, useLocation, useParams } from 'react-router-dom';\nimport type { AppShellState } from '@/context/AppShellContext';\nimport type { ActivePage } from '@/store/appStore';\nimport type { ViewMode, SortConfig, SortableField, GroupableField, Status, Priority } from '@/pages/DataDemo/types';\nimport type { FilterConfig } from '@/pages/DataDemo/components/DataToolbar';\nimport { BODY_STATES } from '@/lib/utils';\n\nconst pageToPaneMap: Record<string, AppShellState['sidePaneContent']> = {\n  dashboard: 'main',\n  settings: 'settings',\n  toaster: 'toaster',\n  notifications: 'notifications',\n  'data-demo': 'dataDemo',\n};\n\n/**\n * A centralized hook to manage and synchronize all URL-based view states.\n * This is the single source of truth for view modes, side panes, split views,\n * and page-specific parameters.\n */\nexport function useAppViewManager() {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const { itemId } = useParams<{ itemId: string }>();\n\n  // --- DERIVED STATE FROM URL ---\n\n  const view = searchParams.get('view');\n  const sidePane = searchParams.get('sidePane');\n  const right = searchParams.get('right');\n\n  const { bodyState, sidePaneContent } = useMemo(() => {\n    const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo'];\n    \n    if (itemId) {\n      if (view === 'split') {\n        return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: 'dataItem' as const };\n      }\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: 'dataItem' as const };\n    }\n    \n    if (sidePane && validPanes.includes(sidePane as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SIDE_PANE, sidePaneContent: sidePane as AppShellState['sidePaneContent'] };\n    }\n    \n    if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {\n      return { bodyState: BODY_STATES.SPLIT_VIEW, sidePaneContent: right as AppShellState['sidePaneContent'] };\n    }\n    \n    return { bodyState: BODY_STATES.NORMAL, sidePaneContent: 'details' as const };\n  }, [itemId, view, sidePane, right]);\n  \n  const currentActivePage = useMemo(() => (location.pathname.split('/')[1] || 'dashboard') as ActivePage, [location.pathname]);\n\n  // DataDemo specific state\n  const viewMode = useMemo(() => (searchParams.get('view') as ViewMode) || 'list', [searchParams]);\n\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField | 'none') || 'none', [searchParams]);\n\tconst activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n\tconst filters = useMemo<FilterConfig>(\n\t\t() => ({\n\t\t\tsearchTerm: searchParams.get('q') || '',\n\t\t\tstatus: (searchParams.get('status')?.split(',') || []).filter(Boolean) as Status[],\n\t\t\tpriority: (searchParams.get('priority')?.split(',') || []).filter(Boolean) as Priority[],\n\t\t}),\n\t\t[searchParams],\n\t);\n\tconst sortConfig = useMemo<SortConfig | null>(() => {\n\t\tconst sortParam = searchParams.get('sort');\n\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n\t\tif (sortParam === 'default') return null;\n\n\t\tconst [key, direction] = sortParam.split('-');\n\t\treturn { key: key as SortableField, direction: direction as 'asc' | 'desc' };\n\t}, [searchParams]);\n\n  // --- MUTATOR ACTIONS ---\n\n  const handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | string[] | null | undefined>, resetPage = false) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\t\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (resetPage) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n  const navigateTo = useCallback((page: string) => {\n    navigate(page.startsWith('/') ? page : `/${page}`);\n  }, [navigate]);\n\n  const openSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (location.pathname === `/${Object.keys(pageToPaneMap).find(key => pageToPaneMap[key] === pane)}`) {\n        navigate({ pathname: '/dashboard', search: `?sidePane=${pane}` }, { replace: true });\n    } else {\n        handleParamsChange({ sidePane: pane, view: null, right: null });\n    }\n  }, [handleParamsChange, navigate, location.pathname]);\n\n  const closeSidePane = useCallback(() => {\n    if (itemId) {\n      navigate('/data-demo');\n    } else {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n    }\n  }, [itemId, navigate, handleParamsChange]);\n\n  const toggleSidePane = useCallback((pane: AppShellState['sidePaneContent']) => {\n    if (sidePane === pane) {\n      closeSidePane();\n    } else {\n      openSidePane(pane);\n    }\n  }, [sidePane, openSidePane, closeSidePane]);\n\n  const toggleSplitView = useCallback(() => {\n    if (bodyState === BODY_STATES.SIDE_PANE) {\n      handleParamsChange({ view: 'split', right: sidePane, sidePane: null });\n    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {\n      handleParamsChange({ sidePane: right, view: null, right: null });\n    } else { // From normal\n      const paneContent = pageToPaneMap[currentActivePage] || 'details';\n      handleParamsChange({ view: 'split', right: paneContent, sidePane: null });\n    }\n  }, [bodyState, sidePane, right, currentActivePage, handleParamsChange]);\n  \n  const setNormalView = useCallback(() => {\n      handleParamsChange({ sidePane: null, view: null, right: null });\n  }, [handleParamsChange]);\n\n  const switchSplitPanes = useCallback(() => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    const newSidePaneContent = pageToPaneMap[currentActivePage];\n    const newActivePage = Object.entries(pageToPaneMap).find(\n      ([, value]) => value === sidePaneContent\n    )?.[0] as ActivePage | undefined;\n\n    if (newActivePage && newSidePaneContent) {\n      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  const closeSplitPane = useCallback((paneToClose: 'main' | 'right') => {\n    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;\n    if (paneToClose === 'right') {\n      navigate(`/${currentActivePage}`, { replace: true });\n    } else { // Closing main pane\n      const pageToBecomeActive = Object.entries(pageToPaneMap).find(\n        ([, value]) => value === sidePaneContent\n      )?.[0] as ActivePage | undefined;\n      \n      if (pageToBecomeActive) {\n        navigate(`/${pageToBecomeActive}`, { replace: true });\n      } else {\n        navigate(`/dashboard`, { replace: true });\n      }\n    }\n  }, [bodyState, currentActivePage, sidePaneContent, navigate]);\n  \n  // DataDemo actions\n  const setViewMode = (mode: ViewMode) => handleParamsChange({ view: mode });\n  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val }, true);\n  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n  const setFilters = (newFilters: FilterConfig) => {\n    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority }, true);\n  }\n  const setSort = (config: SortConfig | null) => {\n    if (!config) {\n      handleParamsChange({ sort: 'default' }, true);\n    } else {\n      handleParamsChange({ sort: `${config.key}-${config.direction}` }, true);\n    }\n  }\n  const setTableSort = (field: SortableField) => {\n    let newSort: string | null = `${field}-desc`;\n    if (sortConfig?.key === field) {\n      if (sortConfig.direction === 'desc') newSort = `${field}-asc`;\n      else if (sortConfig.direction === 'asc') newSort = 'default';\n    }\n    handleParamsChange({ sort: newSort }, true);\n  };\n  const setPage = (newPage: number) => handleParamsChange({ page: newPage.toString() });\n\n\n  return useMemo(() => ({\n    // State\n    bodyState,\n    sidePaneContent,\n    currentActivePage,\n    itemId,\n    // DataDemo State\n    viewMode,\n    page,\n    groupBy,\n    activeGroupTab,\n    filters,\n    sortConfig,\n    // Actions\n    navigateTo,\n    openSidePane,\n    closeSidePane,\n    toggleSidePane,\n    toggleSplitView,\n    setNormalView,\n    switchSplitPanes,\n    closeSplitPane,\n    // DataDemo Actions\n    setViewMode,\n    setGroupBy,\n    setActiveGroupTab,\n    setFilters,\n    setSort,\n    setTableSort,\n    setPage,\n  }), [\n    bodyState, sidePaneContent, currentActivePage, itemId,\n    viewMode, page, groupBy, activeGroupTab, filters, sortConfig,\n    navigateTo, openSidePane, closeSidePane, toggleSidePane, toggleSplitView, setNormalView,\n    switchSplitPanes, closeSplitPane, setViewMode, setGroupBy, setActiveGroupTab, setFilters,\n    setSort, setTableSort, setPage\n  ]);\n}"
    patchStrategy: replace
  - type: write
    path: src/hooks/useRightPaneContent.hook.ts
    content: >-
      import { useMemo } from 'react';

      import { useNavigate, useParams } from 'react-router-dom';

      import {
        LayoutDashboard,
        Settings,
        Component,
        Bell,
        SlidersHorizontal,
        Database,
      } from 'lucide-react';


      import { DashboardContent } from "@/pages/Dashboard";

      import { SettingsContent } from "@/features/settings/SettingsContent";

      import { ToasterDemo } from "@/pages/ToasterDemo";

      import { NotificationsPage } from "@/pages/Notifications";

      import DataDemoPage from "@/pages/DataDemo";

      import { DataDetailPanel } from
      "@/pages/DataDemo/components/DataDetailPanel";

      import { mockDataItems } from "@/pages/DataDemo/data/mockData";

      import { AppShellState } from '@/context/AppShellContext';


      export function useRightPaneContent(sidePaneContent:
      AppShellState['sidePaneContent']) {
        const navigate = useNavigate();
        const { itemId } = useParams<{ itemId: string }>();

        const contentMap = useMemo(() => ({
          main: {
            title: "Dashboard",
            icon: LayoutDashboard,
            page: "dashboard",
            content: <DashboardContent isInSidePane />,
          },
          settings: {
            title: "Settings",
            icon: Settings,
            page: "settings",
            content: <div className="p-6"><SettingsContent /></div>
          },
          toaster: {
            title: "Toaster Demo",
            icon: Component,
            page: "toaster",
            content: <ToasterDemo isInSidePane />,
          },
          notifications: {
            title: "Notifications",
            icon: Bell,
            page: "notifications",
            content: <NotificationsPage isInSidePane />,
          },
          dataDemo: {
            title: "Data Showcase",
            icon: Database,
            page: "data-demo",
            content: <DataDemoPage />,
          },
          details: {
            title: "Details Panel",
            icon: SlidersHorizontal,
            content: (
              <div className="p-6">
                <p className="text-muted-foreground">
                  This is the side pane. It can be used to display contextual
                  information, forms, or actions related to the main content.
                </p>
              </div>
            ),
          },
        }), []);

        const selectedItem = useMemo(() => {
          if (!itemId) return null;
          return mockDataItems.find(item => item.id === itemId) ?? null;
        }, [itemId]);

        const { meta, content } = useMemo(() => {
          if (sidePaneContent === 'dataItem' && selectedItem) {
            return {
              meta: { title: "Item Details", icon: Database, page: `data-demo/${itemId}` },
              content: <DataDetailPanel item={selectedItem} onClose={() => navigate('/data-demo')} />,
            };
          }
          const mappedContent = contentMap[sidePaneContent as keyof typeof contentMap] || contentMap.details;
          return {
            meta: mappedContent,
            content: mappedContent.content,
          };
        }, [sidePaneContent, selectedItem, navigate, contentMap, itemId]);

        return { meta, content };
      }
    patchStrategy: replace
  - type: delete
    path: src/hooks/useUrlStateSync.hook.ts
  - type: write
    path: src/pages/DataDemo/hooks/useDataManagement.hook.tsx
    content: "--- src/pages/DataDemo/hooks/useDataManagement.hook.tsx\n+++ src/pages/DataDemo/hooks/useDataManagement.hook.tsx\n@@ -1,78 +1,32 @@\n import { useState, useRef, useEffect, useCallback, useMemo, ReactNode } from 'react';\n-import { useSearchParams } from 'react-router-dom';\n import { capitalize, cn } from '@/lib/utils';\n import { Badge } from '@/components/ui/badge';\n import { mockDataItems } from '../data/mockData';\n-import type { DataItem, ViewMode, SortConfig, SortableField, GroupableField, Status, Priority } from '../types';\n-import type { FilterConfig } from '../components/DataToolbar';\n+import type { DataItem, GroupableField } from '../types';\n+import { useAppViewManager } from '@/hooks/useAppViewManager.hook';\n \n export function useDataManagement() {\n-\tconst [searchParams, setSearchParams] = useSearchParams();\n-\n-\t// Derive state from URL search params\n-\tconst viewMode = useMemo(() => (searchParams.get('view') as ViewMode) || 'list', [searchParams]);\n-\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n-\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField | 'none') || 'none', [searchParams]);\n-\tconst activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n-\n-\tconst filters = useMemo<FilterConfig>(\n-\t\t() => ({\n-\t\t\tsearchTerm: searchParams.get('q') || '',\n-\t\t\tstatus: (searchParams.get('status')?.split(',') || []).filter(Boolean) as Status[],\n-\t\t\tpriority: (searchParams.get('priority')?.split(',') || []).filter(Boolean) as Priority[],\n-\t\t}),\n-\t\t[searchParams],\n-\t);\n-\n-\tconst sortConfig = useMemo<SortConfig | null>(() => {\n-\t\tconst sortParam = searchParams.get('sort');\n-\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n-\t\tif (sortParam === 'default') return null;\n-\n-\t\tconst [key, direction] = sortParam.split('-');\n-\t\treturn { key: key as SortableField, direction: direction as 'asc' | 'desc' };\n-\t}, [searchParams]);\n-\n-\t// Centralized handler for updating URL search params\n-\tconst handleParamsChange = useCallback(\n-\t\t(newParams: Record<string, string | string[] | null | undefined>) => {\n-\t\t\tsetSearchParams(\n-\t\t\t\t(prev) => {\n-\t\t\t\t\tconst updated = new URLSearchParams(prev);\n-\t\t\t\t\tlet pageReset = false;\n-\n-\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n-\t\t\t\t\t\tconst isFilterOrSort = ['q', 'status', 'priority', 'sort', 'groupBy'].includes(key);\n-\n-\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n-\t\t\t\t\t\t\tupdated.delete(key);\n-\t\t\t\t\t\t} else if (Array.isArray(value)) {\n-\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tupdated.set(key, String(value));\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tif (isFilterOrSort) {\n-\t\t\t\t\t\t\tpageReset = true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif (pageReset) {\n-\t\t\t\t\t\tupdated.delete('page');\n-\t\t\t\t\t}\n-\t\t\t\t\tif ('groupBy' in newParams) {\n-\t\t\t\t\t\tupdated.delete('tab');\n-\t\t\t\t\t}\n-\n-\t\t\t\t\treturn updated;\n-\t\t\t\t},\n-\t\t\t\t{ replace: true },\n-\t\t\t);\n-\t\t},\n-\t\t[setSearchParams],\n-\t);\n+\tconst {\n+\t\tviewMode,\n+\t\tpage,\n+\t\tgroupBy,\n+\t\tactiveGroupTab,\n+\t\tfilters,\n+\t\tsortConfig,\n+\t\tsetPage,\n+\t\tsetViewMode,\n+\t\tsetGroupBy,\n+\t\tsetActiveGroupTab,\n+\t\tsetFilters,\n+\t\tsetSort,\n+\t\tsetTableSort,\n+\t} = useAppViewManager();\n \n \tconst [items, setItems] = useState<DataItem[]>([]);\n \tconst [hasMore, setHasMore] = useState(true);\n \tconst [isLoading, setIsLoading] = useState(true);\n \tconst observer = useRef<IntersectionObserver>();\n \n \t// Centralized data filtering and sorting from the master list\n \tconst filteredAndSortedData = useMemo(() => {\n@@ -156,7 +103,7 @@\n \n \t\tloadData();\n \t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n-\t}, [searchParams, filteredAndSortedData]); // Reacts to any URL change\n+\t}, [page, groupBy, filteredAndSortedData]);\n \n \tconst loaderRef = useCallback(\n \t\t(node: Element | null) => {\n@@ -166,12 +113,12 @@\n \t\t\tobserver.current = new IntersectionObserver((entries) => {\n \t\t\t\tif (entries[0].isIntersecting && hasMore) {\n \t\t\t\t\t// Instead of setting local state, we update the URL, which triggers the data loading effect.\n-\t\t\t\t\thandleParamsChange({ page: (page + 1).toString() });\n+\t\t\t\t\tsetPage(page + 1);\n \t\t\t\t}\n \t\t\t});\n \t\t\tif (node) observer.current.observe(node);\n \t\t},\n-\t\t[isLoading, hasMore, page, handleParamsChange],\n+\t\t[isLoading, hasMore, page, setPage],\n \t);\n \n \tconst groupTabs = useMemo(() => {\n@@ -226,38 +173,21 @@\n \tconst totalItemCount = filteredAndSortedData.length;\n \tconst isInitialLoading = isLoading && items.length === 0;\n \n-  const setViewMode = (mode: ViewMode) => handleParamsChange({ view: mode });\n-  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val });\n-  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n-  const setFilters = (newFilters: FilterConfig) => {\n-    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority });\n-  }\n-  const setSort = (config: SortConfig | null) => {\n-    if (!config) {\n-      handleParamsChange({ sort: 'default' });\n-    } else {\n-      handleParamsChange({ sort: `${config.key}-${config.direction}` });\n-    }\n-  }\n-  const setTableSort = (field: SortableField) => {\n-    if (sortConfig?.key === field) {\n-      if (sortConfig.direction === 'desc') {\n-        // Cycle: desc -> asc\n-        handleParamsChange({ sort: `${field}-asc` });\n-      } else {\n-        // Cycle: asc -> default (by removing param)\n-        handleParamsChange({ sort: 'default' });\n-      }\n-    } else {\n-      // New field, default to desc\n-      handleParamsChange({ sort: `${field}-desc` });\n-    }\n-  }\n-\n \treturn {\n \t\tviewMode,\n \t\tgroupBy,\n \t\tactiveGroupTab,\n \t\tfilters,\n \t\tsortConfig,\n \t\thasMore,\n \t\tisLoading,\n \t\tloaderRef,\n@@ -265,11 +195,11 @@\n \t\tdataToRender,\n \t\ttotalItemCount,\n \t\tisInitialLoading,\n-    setViewMode,\n-    setGroupBy,\n-    setActiveGroupTab,\n-    setFilters,\n-    setSort,\n-    setTableSort\n+\t\tsetViewMode,\n+\t\tsetGroupBy,\n+\t\tsetActiveGroupTab,\n+\t\tsetFilters,\n+\t\tsetSort,\n+\t\tsetTableSort,\n \t};\n }\n\n"
    patchStrategy: standard-diff
  - type: write
    path: src/components/global/CommandPalette.tsx
    content: >+
      --- src/components/global/CommandPalette.tsx

      +++ src/components/global/CommandPalette.tsx

      @@ -7,18 +7,16 @@
         CommandSeparator,
         CommandShortcut,
       } from '@/components/ui/command';
      -import { useNavigate, useSearchParams, useLocation } from
      'react-router-dom';
       import { useAppStore } from '@/store/appStore'
       import { useAppShell } from '@/context/AppShellContext'
       import { useCommandPaletteToggle } from '@/hooks/useCommandPaletteToggle.hook'
      +import { useAppViewManager } from '@/hooks/useAppViewManager.hook';
       import { Home, Settings, Moon, Sun, Monitor, Smartphone, PanelRight, Maximize, Component, Bell } from 'lucide-react'
       
       export function CommandPalette() {
         const { dispatch, toggleFullscreen } = useAppShell();
      -  const navigate = useNavigate();

      -  const [searchParams, setSearchParams] = useSearchParams();

      -  const location = useLocation();

      +  const viewManager = useAppViewManager();
         const {
           isCommandPaletteOpen,
           setCommandPaletteOpen,
      @@ -32,38 +30,24 @@
           command()
         }
       
      -  const handleOpenSidePane = (paneContent: 'settings') => {

      -    // This command is to open, not toggle, so we don't handle the close
      case.

      -    if (searchParams.get('sidePane') === paneContent) return;

      -

      -    // Avoid content duplication

      -    if (location.pathname === `/${paneContent}`) {

      -      navigate({ pathname: '/dashboard', search:
      `?sidePane=${paneContent}` }, { replace: true });

      -    } else {

      -      const newParams = new URLSearchParams(searchParams);

      -      newParams.set('sidePane', paneContent);

      -      newParams.delete('view');

      -      newParams.delete('right');

      -      setSearchParams(newParams, { replace: true });

      -    }

      -  }

      -
         return (
           <CommandDialog open={isCommandPaletteOpen} onOpenChange={setCommandPaletteOpen}>
             <CommandInput placeholder="Type a command or search..." />
             <CommandList>
               <CommandEmpty>No results found.</CommandEmpty>
               <CommandGroup heading="Navigation">
      -          <CommandItem onSelect={() => runCommand(() =>
      navigate('/dashboard'))}>

      +          <CommandItem onSelect={() => runCommand(() =>
      viewManager.navigateTo('dashboard'))}>
                   <Home className="mr-2 h-4 w-4" />
                   <span>Go to Dashboard</span>
                   <CommandShortcut>G D</CommandShortcut>
                 </CommandItem>
      -          <CommandItem onSelect={() => runCommand(() =>
      navigate('/settings'))}>

      +          <CommandItem onSelect={() => runCommand(() =>
      viewManager.navigateTo('settings'))}>
                   <Settings className="mr-2 h-4 w-4" />
                   <span>Go to Settings</span>
                   <CommandShortcut>G S</CommandShortcut>
                 </CommandItem>
      -          <CommandItem onSelect={() => runCommand(() =>
      navigate('/toaster'))}>

      +          <CommandItem onSelect={() => runCommand(() =>
      viewManager.navigateTo('toaster'))}>
                   <Component className="mr-2 h-4 w-4" />
                   <span>Go to Toaster Demo</span>
                   <CommandShortcut>G T</CommandShortcut>
                 </CommandItem>
      -          <CommandItem onSelect={() => runCommand(() =>
      navigate('/notifications'))}>

      +          <CommandItem onSelect={() => runCommand(() =>
      viewManager.navigateTo('notifications'))}>
                   <Bell className="mr-2 h-4 w-4" />
                   <span>Go to Notifications</span>
                   <CommandShortcut>G N</CommandShortcut>
      @@ -79,7 +63,7 @@
                   <span>Toggle Fullscreen</span>
                   <CommandShortcut>⌘F</CommandShortcut>
                 </CommandItem>
      -          <CommandItem onSelect={() => runCommand(() =>
      handleOpenSidePane('settings'))}>

      +          <CommandItem onSelect={() => runCommand(() =>
      viewManager.openSidePane('settings'))}>
                   <PanelRight className="mr-2 h-4 w-4" />
                   <span>Open Settings in Side Pane</span>
                   <CommandShortcut>⌥S</CommandShortcut>

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/EnhancedSidebar.tsx
    content: >+
      --- src/components/layout/EnhancedSidebar.tsx

      +++ src/components/layout/EnhancedSidebar.tsx

      @@ -19,7 +19,6 @@
         User,
         Plus,
         Database
       } from 'lucide-react';
      -import { useLocation, useNavigate, useSearchParams } from
      'react-router-dom';
       import { type ActivePage } from '@/store/appStore';
       import { useAppShell } from '@/context/AppShellContext';
       import {
      @@ -43,6 +42,7 @@
       } from './Sidebar';
       import { ViewModeSwitcher } from './ViewModeSwitcher';
       import { cn } from '@/lib/utils';
      +import { useAppViewManager } from '@/hooks/useAppViewManager.hook';
       
       interface MyWorkspace extends Workspace {
         logo: string;
      @@ -165,54 +165,25 @@
       
       const AppMenuItem: React.FC<AppMenuItemProps> = ({ icon: Icon, label, badge, hasActions, children, isSubItem = false, page, opensInSidePane = false }) => {
         const { compactMode, dispatch } = useAppShell()
         const { isCollapsed } = useSidebar();
      -  const navigate = useNavigate();

      -  const location = useLocation();

      -  const [searchParams, setSearchParams] = useSearchParams();

      -

      -  const pageToPaneMap: { [key in ActivePage]?: 'main' | 'settings' |
      'toaster' | 'notifications' | 'data-demo' } = {

      -    dashboard: 'main',

      -    settings: 'settings',

      -    toaster: 'toaster',

      -    notifications: 'notifications',

      -    'data-demo': 'data-demo',

      -  };

      -  const paneContentForPage = page ? pageToPaneMap[page] : undefined;

      +  const viewManager = useAppViewManager();
       
         const isActive = (
      -    (!opensInSidePane && page && location.pathname === `/${page}`)

      +    (!opensInSidePane && page && viewManager.currentActivePage === page)
         ) || (
      -    opensInSidePane && paneContentForPage && searchParams.get('sidePane')
      === paneContentForPage

      +    opensInSidePane && page === 'notifications' &&
      viewManager.sidePaneContent === 'notifications'
         );
       
         const handleClick = () => {
           if (page) {
             if (opensInSidePane) {
      -        if (paneContentForPage) {

      -          setSearchParams(prev => {

      -            const newParams = new URLSearchParams(prev);

      -            const isCurrentlyInSidePane = newParams.get('sidePane') ===
      paneContentForPage;

      -

      -            if (isCurrentlyInSidePane) {

      -              newParams.delete('sidePane');

      -            } else {

      -              // If opening a side pane for a page that is the current
      main view,

      -              // navigate main view to dashboard to avoid content
      duplication.

      -              if (location.pathname === `/${page}`) {

      -                navigate({ pathname: '/dashboard', search:
      `?sidePane=${paneContentForPage}` }, { replace: true });

      -                return newParams; // Don't modify params when navigating

      -              } else {

      -                newParams.set('sidePane', paneContentForPage);

      -                // When setting a side pane, always clear split view
      params to avoid invalid URL state

      -                newParams.delete('view');

      -                newParams.delete('right');

      -              }

      -            }

      -            return newParams;

      -          }, { replace: true });

      -        }

      +        // The only item using this is Notifications

      +        viewManager.toggleSidePane('notifications');
             } else {
      -        navigate(`/${page}`);

      +        viewManager.navigateTo(page);
             }
           }
         };

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/TopBar.tsx
    content: >+
      --- src/components/layout/TopBar.tsx

      +++ src/components/layout/TopBar.tsx

      @@ -7,10 +7,10 @@
         Zap,
       } from 'lucide-react'
       import { cn } from '@/lib/utils'
      -import { useSearchParams, useLocation, useNavigate } from
      'react-router-dom';
       import { BODY_STATES } from '@/lib/utils'
       import { useAppStore } from '@/store/appStore'
       import { useAppShell } from '@/context/AppShellContext'
      +import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
       import { UserDropdown } from './UserDropdown'
       import { ViewModeSwitcher } from './ViewModeSwitcher'
       
      @@ -25,29 +25,11 @@
         children,
       }: TopBarProps) {
         const { bodyState } = useAppShell()
      -  const [, setSearchParams] = useSearchParams();

      -  const location = useLocation();

      -  const navigate = useNavigate();

      +  const viewManager = useAppViewManager();
         const { 
           setCommandPaletteOpen,
           isDarkMode,
         } = useAppStore()
      -

      -  const handleSettingsClick = () => {

      -    if (location.pathname === '/settings') {

      -      navigate({ pathname: '/dashboard', search: '?sidePane=settings' },
      { replace: true });

      -    } else {

      -      setSearchParams(prev => {

      -        const newParams = new URLSearchParams(prev);

      -        if (newParams.get('sidePane') === 'settings') {

      -          newParams.delete('sidePane');

      -        } else {

      -          newParams.set('sidePane', 'settings');

      -          newParams.delete('view');

      -          newParams.delete('right');

      -        }

      -        return newParams;

      -      }, { replace: true });

      -    }

      -  };
       
         return (
           <div className={cn(
      @@ -102,7 +84,7 @@
               </button>
       
               <button
      -          onClick={handleSettingsClick}

      +          onClick={() => viewManager.toggleSidePane('settings')}
                 className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
                 title="Settings"
               >

    patchStrategy: standard-diff
  - type: write
    path: src/components/layout/ViewModeSwitcher.tsx
    content: >+
      --- src/components/layout/ViewModeSwitcher.tsx

      +++ src/components/layout/ViewModeSwitcher.tsx

      @@ -1,10 +1,10 @@
       import { useState, useRef, useEffect } from 'react';
       import { gsap } from 'gsap';
      -import { useLocation, useNavigate, useSearchParams } from
      'react-router-dom';
       import { cn } from '@/lib/utils'
       import { useAppShell } from '@/context/AppShellContext'
       import { type ActivePage } from '@/store/appStore'
       import { BODY_STATES } from '@/lib/utils'
       import { type AppShellState } from '@/context/AppShellContext'
      +import { useAppViewManager } from '@/hooks/useAppViewManager.hook'
       import {
         Columns,
         PanelRightOpen,
      @@ -17,28 +17,21 @@
         ArrowLeftRight
       } from 'lucide-react'
       
      -const pageToPaneMap: Record<ActivePage, AppShellState['sidePaneContent']>
      = {

      -  dashboard: 'main',

      -  settings: 'settings',

      -  toaster: 'toaster',

      -  notifications: 'notifications',

      -  'data-demo': 'dataDemo',

      -};

      -
       export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' | 'right', targetPage?: ActivePage }) {
         const {
           bodyState,
      -    sidePaneContent,
           toggleFullscreen,
           fullscreenTarget,
         } = useAppShell()
      -  const location = useLocation();

      -  const navigate = useNavigate();

      -  const [, setSearchParams] = useSearchParams();

      -  const currentActivePage = (location.pathname.split('/')[1] ||
      'dashboard') as ActivePage;

      +  const {

      +    currentActivePage,

      +    toggleSidePane,

      +    toggleSplitView,

      +    setNormalView,

      +    navigateTo,

      +    switchSplitPanes,

      +    closeSplitPane,

      +  } = useAppViewManager();
       
         const activePage = targetPage || currentActivePage;
         const [isExpanded, setIsExpanded] = useState(false);
      @@ -89,65 +82,22 @@
           }
         }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons
       
      -  const handleSidePaneClick = () => {

      -    const paneContent = pageToPaneMap[activePage] || 'details';

      -    if (pane === 'right') return;

      -

      -    const newSearchParams = new URLSearchParams(location.search);

      -    if (bodyState === BODY_STATES.SIDE_PANE && sidePaneContent ===
      paneContent) {

      -      newSearchParams.delete('sidePane');

      -      newSearchParams.delete('view');

      -      newSearchParams.delete('right');

      -    } else {

      -      newSearchParams.set('sidePane', paneContent);

      -      newSearchParams.delete('view');

      -      newSearchParams.delete('right');

      -    }

      -    setSearchParams(newSearchParams, { replace: true });

      -  };

      -  

      -  const handleSplitViewClick = () => {

      -    const paneContent = pageToPaneMap[activePage] || 'details';

      -    if (pane === 'right') return;

      -

      -    const newSearchParams = new URLSearchParams(location.search);

      -    if (bodyState === BODY_STATES.SPLIT_VIEW) {

      -        // from split to overlay

      -        newSearchParams.set('sidePane', sidePaneContent);

      -        newSearchParams.delete('view');

      -        newSearchParams.delete('right');

      -    } else {

      -        // from normal/overlay to split

      -        newSearchParams.set('view', 'split');

      -        newSearchParams.set('right', bodyState === BODY_STATES.SIDE_PANE
      ? sidePaneContent : paneContent);

      -        newSearchParams.delete('sidePane');

      -    }

      -    setSearchParams(newSearchParams, { replace: true });

      +  const handlePaneClick = (type: 'side-pane' | 'split-view') => {

      +    const pageToPaneMap: Record<ActivePage,
      AppShellState['sidePaneContent']> = {

      +      dashboard: 'main', settings: 'settings', toaster: 'toaster',
      notifications: 'notifications', 'data-demo': 'dataDemo',

      +    };

      +    const paneContent = pageToPaneMap[activePage];

      +    if (type === 'side-pane') toggleSidePane(paneContent);

      +    else toggleSplitView();
         }
       
      -  const handleSwitchPanes = () => {

      -    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;

      -    const newSidePaneContent = pageToPaneMap[currentActivePage];

      -    const newActivePage = Object.entries(pageToPaneMap).find(

      -      ([, value]) => value === sidePaneContent

      -    )?.[0] as ActivePage | undefined;

      -

      -    if (newActivePage && newSidePaneContent) {

      -     
      navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, {
      replace: true });

      -    }

      -  };

      -

      -  const handleClosePane = () => {

      -    if (bodyState !== BODY_STATES.SPLIT_VIEW) return;

      -    if (pane === 'right') {

      -      setSearchParams({}, { replace: true });

      -    } else if (pane === 'main') {

      -      const pageToBecomeActive = Object.entries(pageToPaneMap).find(

      -        ([, value]) => value === sidePaneContent

      -      )?.[0] as ActivePage | undefined;

      -      

      -      if (pageToBecomeActive) {

      -        navigate(`/${pageToBecomeActive}`, { replace: true });

      -      } else {

      -        setSearchParams({}, { replace: true });

      -      }

      -    }

      -  }

      -
         const handleNormalViewClick = () => {
           if (isFullscreen) {
             toggleFullscreen();
           }
           if (targetPage && targetPage !== currentActivePage) {
      -      navigate(`/${targetPage}`, { replace: true });

      -    }

      -      setSearchParams({}, { replace: true });

      +      navigateTo(targetPage);

      +    } else {

      +      setNormalView();

      +    }
         }
       
         const buttons = [
      @@ -160,14 +110,14 @@
           },
           {
             id: 'side-pane',
      -      onClick: handleSidePaneClick,

      +      onClick: () => handlePaneClick('side-pane'),
             active: bodyState === BODY_STATES.SIDE_PANE,
             title: "Side Pane View",
             icon: <PanelRightOpen className="w-4 h-4" />
           },
           {
             id: 'split-view',
      -      onClick: handleSplitViewClick,

      +      onClick: () => handlePaneClick('split-view'),
             active: bodyState === BODY_STATES.SPLIT_VIEW,
             title: bodyState === BODY_STATES.SPLIT_VIEW ? 'Switch to Overlay View' : 'Switch to Split View',
             icon: bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-4 h-4" /> : <SplitSquareHorizontal className="w-4 h-4" />
      @@ -176,7 +126,7 @@
             id: 'fullscreen',
             onClick: () => {
               if (targetPage && targetPage !== currentActivePage ) {
      -          navigate(`/${targetPage}`);

      +          navigateTo(targetPage);
                 setTimeout(() => toggleFullscreen(pane), 50);
               } else {
                 toggleFullscreen(pane);
      @@ -190,14 +140,14 @@
         if (bodyState === BODY_STATES.SPLIT_VIEW) {
           buttons.push({
             id: 'switch',
      -      onClick: handleSwitchPanes,

      +      onClick: switchSplitPanes,
             active: false,
             title: "Switch Panes",
             icon: <ArrowLeftRight className="w-4 h-4" />
           });
           buttons.push({
             id: 'close',
      -      onClick: handleClosePane,

      +      onClick: () => closeSplitPane(pane || 'right'),
             active: false,
             title: "Close Pane",
             icon: <X className="w-4 h-4 text-muted-foreground group-hover:text-destructive" />

    patchStrategy: standard-diff
  - type: write
    path: src/App.tsx
    content: >+
      --- src/App.tsx

      +++ src/App.tsx

      @@ -4,11 +4,8 @@
         RouterProvider,
         Outlet,
         Navigate,
      -  useNavigate,

      +  useNavigate, // used in LoginPageWrapper
         useLocation,
      -  useParams,

      -  useSearchParams,
       } from "react-router-dom";
       
       import { AppShell } from "./components/layout/AppShell";
      @@ -23,13 +20,10 @@
       // --- Page/Content Components for Pages and Panes ---
       import { DashboardContent } from "./pages/Dashboard";
       import { SettingsPage } from "./pages/Settings";
      -import { SettingsContent } from "./features/settings/SettingsContent";
       import { ToasterDemo } from "./pages/ToasterDemo";
       import { NotificationsPage } from "./pages/Notifications";
       import DataDemoPage from "./pages/DataDemo";
      -import { DataDetailPanel } from
      "./pages/DataDemo/components/DataDetailPanel";

      -import { mockDataItems } from "./pages/DataDemo/data/mockData";
       import { LoginPage } from "./components/auth/LoginPage";
       
       // --- Icons ---
      @@ -38,26 +32,22 @@
         Filter,
         Plus,
         ChevronRight,
         Rocket,
      -  LayoutDashboard,

      -  Settings,

      -  Component,

      -  Bell,

      -  SlidersHorizontal,
         ChevronsLeftRight,
         Layers,
         SplitSquareHorizontal,
      -  Database,
       } from "lucide-react";
       
       // --- Utils & Hooks ---
      -import { cn, BODY_STATES } from "./lib/utils";

      -import { useUrlStateSync } from "./hooks/useUrlStateSync.hook";

      +import { cn } from "./lib/utils";

      +import { useAppViewManager } from "./hooks/useAppViewManager.hook";

      +import { useRightPaneContent } from "./hooks/useRightPaneContent.hook";

      +import { BODY_STATES } from "./lib/utils";
       
       // Wrapper for LoginPage to provide auth handlers
       function LoginPageWrapper() {
         const { login, forgotPassword } = useAuthStore();
         const navigate = useNavigate();
         const location = useLocation();
         const from = location.state?.from?.pathname + location.state?.from?.search || "/";
       
      @@ -198,114 +188,44 @@
       
       // The main App component that composes the shell
       function ComposedApp() {
      -  // --- State from Context & Router ---

      -  const { bodyState, sidePaneContent } = useAppShell();

      -  const navigate = useNavigate();

      -  const [searchParams, setSearchParams] = useSearchParams();

      -  const { itemId } = useParams<{ itemId: string }>();

      +  const { dispatch } = useAppShell();

      +  const viewManager = useAppViewManager();
       
      -  // --- Sync URL with App Shell State ---

      -  useUrlStateSync();

      +  // Sync URL state with AppShellContext

      +  useEffect(() => {

      +    dispatch({ type: 'SET_BODY_STATE', payload: viewManager.bodyState });

      +    dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload:
      viewManager.sidePaneContent });

      +  }, [viewManager.bodyState, viewManager.sidePaneContent, dispatch]);
       
      -  // --- Content Mapping for Side/Right Panes ---

      -  const contentMap = useMemo(() => ({

      -    main: {

      -      title: "Dashboard",

      -      icon: LayoutDashboard,

      -      page: "dashboard",

      -      content: <DashboardContent isInSidePane />,

      -    },

      -    settings: {

      -      title: "Settings",

      -      icon: Settings,

      -      page: "settings",

      -      content: <div className="p-6"><SettingsContent /></div>

      -    },

      -    toaster: {

      -      title: "Toaster Demo",

      -      icon: Component,

      -      page: "toaster",

      -      content: <ToasterDemo isInSidePane />,

      -    },

      -    notifications: {

      -      title: "Notifications",

      -      icon: Bell,

      -      page: "notifications",

      -      content: <NotificationsPage isInSidePane />,

      -    },

      -    dataDemo: {

      -      title: "Data Showcase",

      -      icon: Database,

      -      page: "data-demo",

      -      content: <DataDemoPage />,

      -    },

      -    details: {

      -      title: "Details Panel",

      -      icon: SlidersHorizontal,

      -      content: (

      -        <div className="p-6">

      -          <p className="text-muted-foreground">

      -            This is the side pane. It can be used to display contextual

      -            information, forms, or actions related to the main content.

      -          </p>

      -        </div>

      -      ),

      -    },

      -  }), []);

      +  const { meta: rightPaneMeta, content: rightPaneContent } =
      useRightPaneContent(viewManager.sidePaneContent);
       
      -  // --- Derived State for Content ---

      -  const selectedItem = useMemo(() => {

      -    if (!itemId) return null

      -    return mockDataItems.find(item => item.id === itemId) ?? null

      -  }, [itemId]);

      -

      -  const { currentContent, rightPaneContent } = useMemo(() => {

      -    if (sidePaneContent === 'dataItem' && selectedItem) {

      -      return {

      -        currentContent: { title: "Item Details", icon: Database, page:
      `data-demo/${itemId}` },

      -        rightPaneContent: <DataDetailPanel item={selectedItem}
      onClose={() => navigate('/data-demo')} />,

      -      };

      -    }

      -    const mappedContent = contentMap[sidePaneContent as keyof typeof
      contentMap] || contentMap.details;

      -    return {

      -      currentContent: mappedContent,

      -      rightPaneContent: mappedContent.content,

      -    };

      -  }, [sidePaneContent, selectedItem, navigate, contentMap, itemId]);

      -

      -  const CurrentIcon = currentContent.icon;

      -

      -  // --- Callbacks for Right Pane Actions ---
         const handleMaximize = useCallback(() => {
      -    if ("page" in currentContent && currentContent.page) {

      -      navigate(`/${currentContent.page}`, { replace: true });

      -    } else {

      -      setSearchParams({}, { replace: true });

      +    if ("page" in rightPaneMeta && rightPaneMeta.page) {

      +      viewManager.navigateTo(rightPaneMeta.page);
           }
      -  }, [currentContent, navigate, setSearchParams]);

      -

      -  const handleCloseSidePane = useCallback(() => {

      -    if (itemId) {

      -      navigate('/data-demo');

      -    } else {

      -      setSearchParams(prev => {

      -        const newParams = new URLSearchParams(prev);

      -        newParams.delete('sidePane');

      -        newParams.delete('right');

      -        newParams.delete('view');

      -        return newParams;

      -      }, { replace: true });

      -    }

      -  }, [setSearchParams, itemId, navigate]);

      -

      -  const handleToggleSplitView = useCallback(() => {

      -    if (bodyState === BODY_STATES.SIDE_PANE) {

      -      setSearchParams(prev => {

      -        const newParams = new URLSearchParams(prev);

      -        const currentPane = newParams.get('sidePane');

      -        if (currentPane) {

      -          newParams.set('view', 'split');

      -          newParams.set('right', currentPane);

      -          newParams.delete('sidePane');

      -        }

      -        return newParams;

      -      }, { replace: true });

      -    } else if (bodyState === BODY_STATES.SPLIT_VIEW) {

      -      setSearchParams(prev => {

      -        return { sidePane: prev.get('right') || 'details' }

      -      }, { replace: true });

      -    }

      -  }, [bodyState, setSearchParams]);

      +  }, [rightPaneMeta, viewManager]);
       
         // --- Right Pane Header UI ---
         const rightPaneHeader = useMemo(() => (
           <>
      -      {bodyState !== BODY_STATES.SPLIT_VIEW ? (

      +      {viewManager.bodyState !== BODY_STATES.SPLIT_VIEW ? (
               <div className="flex items-center gap-2">
      -          <CurrentIcon className="w-5 h-5" />

      +          {rightPaneMeta.icon && React.createElement(rightPaneMeta.icon,
      { className: "w-5 h-5" })}
                 <h2 className="text-lg font-semibold whitespace-nowrap">
      -            {currentContent.title}

      +            {rightPaneMeta.title}
                 </h2>
               </div>
             ) : <div />} {/* Placeholder to make justify-between work */}
             <div className="flex items-center">
      -        {(bodyState === BODY_STATES.SIDE_PANE || bodyState ===
      BODY_STATES.SPLIT_VIEW) && (

      -          <button onClick={handleToggleSplitView} className="h-10 w-10
      flex items-center justify-center hover:bg-accent rounded-full
      transition-colors" title={bodyState === BODY_STATES.SIDE_PANE ? "Switch to
      Split View" : "Switch to Overlay View"}>

      -            {bodyState === BODY_STATES.SPLIT_VIEW ? <Layers
      className="w-5 h-5" /> : <SplitSquareHorizontal className="w-5 h-5" />}

      +        {(viewManager.bodyState === BODY_STATES.SIDE_PANE ||
      viewManager.bodyState === BODY_STATES.SPLIT_VIEW) && (

      +          <button onClick={viewManager.toggleSplitView} className="h-10
      w-10 flex items-center justify-center hover:bg-accent rounded-full
      transition-colors" title={viewManager.bodyState === BODY_STATES.SIDE_PANE
      ? "Switch to Split View" : "Switch to Overlay View"}>

      +            {viewManager.bodyState === BODY_STATES.SPLIT_VIEW ? <Layers
      className="w-5 h-5" /> : <SplitSquareHorizontal className="w-5 h-5" />}
                 </button>
               )}
      -        {bodyState !== BODY_STATES.SPLIT_VIEW && "page" in currentContent
      && currentContent.page && (

      +        {viewManager.bodyState !== BODY_STATES.SPLIT_VIEW && "page" in
      rightPaneMeta && rightPaneMeta.page && (
                 <button onClick={handleMaximize} className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors mr-2" title="Move to Main View">
                   <ChevronsLeftRight className="w-5 h-5" />
                 </button>
               )}
             </div>
           </>
      -  ), [bodyState, currentContent, CurrentIcon, handleToggleSplitView,
      handleMaximize]);

      +  ), [viewManager.bodyState, rightPaneMeta, handleMaximize,
      viewManager.toggleSplitView]);
       
         return (
           <AppShell
             sidebar={<EnhancedSidebar />}
      -      onOverlayClick={handleCloseSidePane}

      +      onOverlayClick={viewManager.closeSidePane}
             topBar={
               <TopBar>
                 <AppTopBar />
      @@ -317,7 +206,7 @@
               </MainContent>
             }
             rightPane={
      -        <RightPane onClose={handleCloseSidePane}
      header={rightPaneHeader}>

      +        <RightPane onClose={viewManager.closeSidePane}
      header={rightPaneHeader}>
                 {rightPaneContent}
               </RightPane>
             }

    patchStrategy: standard-diff
snapshot:
  src/hooks/useAppViewManager.hook.ts: null
  src/hooks/useRightPaneContent.hook.ts: null
  src/hooks/useUrlStateSync.hook.ts: |-
    import { useEffect } from "react";
    import {
      useParams,
      useSearchParams,
    } from "react-router-dom";
    import { useAppShell } from "@/context/AppShellContext";
    import type { AppShellState } from "@/context/AppShellContext";
    import { BODY_STATES } from "@/lib/utils";

    /**
     * A hook to synchronize the URL state (params and search query) with the AppShellContext.
     * This hook is responsible for setting the body state and side pane content based on the URL.
     * It does not return anything.
     */
    export function useUrlStateSync() {
      const { dispatch } = useAppShell();
      const [searchParams] = useSearchParams();
      const { itemId } = useParams<{ itemId: string }>();

      useEffect(() => {
        const pane = searchParams.get('sidePane');
        const view = searchParams.get('view');
        const right = searchParams.get('right');
        const validPanes: AppShellState['sidePaneContent'][] = ['details', 'settings', 'main', 'toaster', 'notifications', 'dataDemo'];

        if (itemId) {
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: 'dataItem' });
          if (view === 'split') {
            dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
          } else {
            dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE });
          }
        } else if (pane && validPanes.includes(pane as AppShellState['sidePaneContent'])) {
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: pane as AppShellState['sidePaneContent'] });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SIDE_PANE });
        } else if (view === 'split' && right && validPanes.includes(right as AppShellState['sidePaneContent'])) {
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: right as AppShellState['sidePaneContent'] });
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.SPLIT_VIEW });
        } else {
          dispatch({ type: 'SET_BODY_STATE', payload: BODY_STATES.NORMAL });
          dispatch({ type: 'SET_SIDE_PANE_CONTENT', payload: 'details' });
        }
      }, [itemId, searchParams, dispatch]);
    }
  src/pages/DataDemo/hooks/useDataManagement.hook.tsx: "import { useState, useRef, useEffect, useCallback, useMemo, ReactNode } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport { capitalize, cn } from '@/lib/utils';\nimport { Badge } from '@/components/ui/badge';\nimport { mockDataItems } from '../data/mockData';\nimport type { DataItem, ViewMode, SortConfig, SortableField, GroupableField, Status, Priority } from '../types';\nimport type { FilterConfig } from '../components/DataToolbar';\n\nexport function useDataManagement() {\n\tconst [searchParams, setSearchParams] = useSearchParams();\n\n\t// Derive state from URL search params\n\tconst viewMode = useMemo(() => (searchParams.get('view') as ViewMode) || 'list', [searchParams]);\n\tconst page = useMemo(() => parseInt(searchParams.get('page') || '1', 10), [searchParams]);\n\tconst groupBy = useMemo(() => (searchParams.get('groupBy') as GroupableField | 'none') || 'none', [searchParams]);\n\tconst activeGroupTab = useMemo(() => searchParams.get('tab') || 'all', [searchParams]);\n\n\tconst filters = useMemo<FilterConfig>(\n\t\t() => ({\n\t\t\tsearchTerm: searchParams.get('q') || '',\n\t\t\tstatus: (searchParams.get('status')?.split(',') || []).filter(Boolean) as Status[],\n\t\t\tpriority: (searchParams.get('priority')?.split(',') || []).filter(Boolean) as Priority[],\n\t\t}),\n\t\t[searchParams],\n\t);\n\n\tconst sortConfig = useMemo<SortConfig | null>(() => {\n\t\tconst sortParam = searchParams.get('sort');\n\t\tif (!sortParam) return { key: 'updatedAt', direction: 'desc' }; // Default sort\n\t\tif (sortParam === 'default') return null;\n\n\t\tconst [key, direction] = sortParam.split('-');\n\t\treturn { key: key as SortableField, direction: direction as 'asc' | 'desc' };\n\t}, [searchParams]);\n\n\t// Centralized handler for updating URL search params\n\tconst handleParamsChange = useCallback(\n\t\t(newParams: Record<string, string | string[] | null | undefined>) => {\n\t\t\tsetSearchParams(\n\t\t\t\t(prev) => {\n\t\t\t\t\tconst updated = new URLSearchParams(prev);\n\t\t\t\t\tlet pageReset = false;\n\n\t\t\t\t\tfor (const [key, value] of Object.entries(newParams)) {\n\t\t\t\t\t\tconst isFilterOrSort = ['q', 'status', 'priority', 'sort', 'groupBy'].includes(key);\n\n\t\t\t\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || value === '') {\n\t\t\t\t\t\t\tupdated.delete(key);\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\tupdated.set(key, value.join(','));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdated.set(key, String(value));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isFilterOrSort) {\n\t\t\t\t\t\t\tpageReset = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pageReset) {\n\t\t\t\t\t\tupdated.delete('page');\n\t\t\t\t\t}\n\t\t\t\t\tif ('groupBy' in newParams) {\n\t\t\t\t\t\tupdated.delete('tab');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updated;\n\t\t\t\t},\n\t\t\t\t{ replace: true },\n\t\t\t);\n\t\t},\n\t\t[setSearchParams],\n\t);\n\n\tconst [items, setItems] = useState<DataItem[]>([]);\n\tconst [hasMore, setHasMore] = useState(true);\n\tconst [isLoading, setIsLoading] = useState(true);\n\tconst observer = useRef<IntersectionObserver>();\n\n\t// Centralized data filtering and sorting from the master list\n\tconst filteredAndSortedData = useMemo(() => {\n\t\tconst filteredItems = mockDataItems.filter((item) => {\n\t\t\tconst searchTermMatch =\n\t\t\t\titem.title.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||\n\t\t\t\titem.description.toLowerCase().includes(filters.searchTerm.toLowerCase());\n\n\t\t\tconst statusMatch = filters.status.length === 0 || filters.status.includes(item.status);\n\t\t\tconst priorityMatch = filters.priority.length === 0 || filters.priority.includes(item.priority);\n\n\t\t\treturn searchTermMatch && statusMatch && priorityMatch;\n\t\t});\n\n\t\tif (sortConfig) {\n\t\t\tfilteredItems.sort((a, b) => {\n\t\t\t\tconst getNestedValue = (obj: DataItem, path: string): unknown => \n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tpath.split('.').reduce((o: any, k) => (o || {})[k], obj);\n\t\t\t\t\n\t\t\t\tconst aValue = getNestedValue(a, sortConfig.key);\n\t\t\t\tconst bValue = getNestedValue(b, sortConfig.key);\n\n\t\t\t\tif (aValue === undefined || bValue === undefined) return 0;\n\n\t\t\t\tif (typeof aValue === 'string' && typeof bValue === 'string') {\n\t\t\t\t\treturn sortConfig.direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);\n\t\t\t\t}\n\t\t\t\tif (typeof aValue === 'number' && typeof bValue === 'number') {\n\t\t\t\t\treturn sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue;\n\t\t\t\t}\n\t\t\t\t// Date sorting (assuming ISO strings)\n\t\t\t\tif (sortConfig.key === 'updatedAt' || sortConfig.key === 'createdAt') {\n          if (typeof aValue === 'string' && typeof bValue === 'string') {\n\t\t\t\t\t  return sortConfig.direction === 'asc'\n\t\t\t\t\t\t  ? new Date(aValue).getTime() - new Date(bValue).getTime()\n\t\t\t\t\t\t  : new Date(bValue).getTime() - new Date(aValue).getTime();\n          }\n        }\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t}\n\n\t\treturn filteredItems;\n\t}, [filters, sortConfig]);\n\n\t// Data loading effect\n\tuseEffect(() => {\n\t\tsetIsLoading(true);\n\t\tconst isFirstPage = page === 1;\n\n\t\tconst loadData = () => {\n\t\t\tif (groupBy !== 'none') {\n\t\t\t\t// For grouped views, load all data at once, pagination is disabled.\n\t\t\t\tsetItems(filteredAndSortedData);\n\t\t\t\tsetHasMore(false);\n\t\t\t\tsetIsLoading(false);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Handle paginated view\n\t\t\tconst pageSize = 12;\n\t\t\tconst newItems = filteredAndSortedData.slice((page - 1) * pageSize, page * pageSize);\n\n\t\t\tsetTimeout(() => {\n\t\t\t\t// Double-check in case groupBy changed during the timeout\n\t\t\t\tif (groupBy === 'none') {\n\t\t\t\t\tsetItems((prev) => (isFirstPage ? newItems : [...prev, ...newItems]));\n\t\t\t\t\tsetHasMore(filteredAndSortedData.length > page * pageSize);\n\t\t\t\t\tsetIsLoading(false);\n\t\t\t\t}\n\t\t\t}, isFirstPage && items.length === 0 ? 1500 : 500); // Longer delay for initial skeleton\n\t\t};\n\n\t\tloadData();\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [searchParams, filteredAndSortedData]); // Reacts to any URL change\n\n\tconst loaderRef = useCallback(\n\t\t(node: Element | null) => {\n\t\t\tif (isLoading) return;\n\t\t\tif (observer.current) observer.current.disconnect();\n\n\t\t\tobserver.current = new IntersectionObserver((entries) => {\n\t\t\t\tif (entries[0].isIntersecting && hasMore) {\n\t\t\t\t\t// Instead of setting local state, we update the URL, which triggers the data loading effect.\n\t\t\t\t\thandleParamsChange({ page: (page + 1).toString() });\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (node) observer.current.observe(node);\n\t\t},\n\t\t[isLoading, hasMore, page, handleParamsChange],\n\t);\n\n\tconst groupTabs = useMemo(() => {\n\t\tif (groupBy === 'none' || !filteredAndSortedData.length) return [];\n\n\t\tconst groupCounts = filteredAndSortedData.reduce((acc, item) => {\n\t\t\tconst groupKey = String(item[groupBy as GroupableField]);\n\t\t\tacc[groupKey] = (acc[groupKey] || 0) + 1;\n\t\t\treturn acc;\n\t\t}, {} as Record<string, number>);\n\n\t\tconst sortedGroups = Object.keys(groupCounts).sort((a, b) => a.localeCompare(b));\n\n\t\tconst createLabel = (text: string, count: number, isActive: boolean): ReactNode => (\n\t\t\t<>\n\t\t\t\t{text}\n\t\t\t\t<Badge\n\t\t\t\t\tvariant={isActive ? 'default' : 'secondary'}\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t'transition-colors duration-300 text-xs font-semibold',\n\t\t\t\t\t\t!isActive && 'group-hover:bg-accent group-hover:text-accent-foreground',\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t{count}\n\t\t\t\t</Badge>\n\t\t\t</>\n\t\t);\n\n\t\treturn [\n\t\t\t{ id: 'all', label: createLabel('All', filteredAndSortedData.length, activeGroupTab === 'all') },\n\t\t\t...sortedGroups.map((g) => ({\n\t\t\t\tid: g,\n\t\t\t\tlabel: createLabel(capitalize(g), groupCounts[g], activeGroupTab === g),\n\t\t\t})),\n\t\t];\n\t}, [filteredAndSortedData, groupBy, activeGroupTab]);\n\n\t// Data to be rendered in the current view, after grouping and tab selection is applied\n\tconst dataToRender = useMemo(() => {\n\t\tif (groupBy === 'none') {\n\t\t\treturn items; // This is the paginated list.\n\t\t}\n\n\t\t// When grouped, `items` contains ALL filtered/sorted data.\n\t\tif (activeGroupTab === 'all') {\n\t\t\treturn items;\n\t\t}\n\t\treturn items.filter((item) => String(item[groupBy as GroupableField]) === activeGroupTab);\n\t}, [items, groupBy, activeGroupTab]);\n\n\tconst totalItemCount = filteredAndSortedData.length;\n\tconst isInitialLoading = isLoading && items.length === 0;\n\n  const setViewMode = (mode: ViewMode) => handleParamsChange({ view: mode });\n  const setGroupBy = (val: string) => handleParamsChange({ groupBy: val === 'none' ? null : val });\n  const setActiveGroupTab = (tab: string) => handleParamsChange({ tab: tab === 'all' ? null : tab });\n  const setFilters = (newFilters: FilterConfig) => {\n    handleParamsChange({ q: newFilters.searchTerm, status: newFilters.status, priority: newFilters.priority });\n  }\n  const setSort = (config: SortConfig | null) => {\n    if (!config) {\n      handleParamsChange({ sort: 'default' });\n    } else {\n      handleParamsChange({ sort: `${config.key}-${config.direction}` });\n    }\n  }\n  const setTableSort = (field: SortableField) => {\n    if (sortConfig?.key === field) {\n      if (sortConfig.direction === 'desc') {\n        // Cycle: desc -> asc\n        handleParamsChange({ sort: `${field}-asc` });\n      } else {\n        // Cycle: asc -> default (by removing param)\n        handleParamsChange({ sort: 'default' });\n      }\n    } else {\n      // New field, default to desc\n      handleParamsChange({ sort: `${field}-desc` });\n    }\n  }\n\n\treturn {\n\t\tviewMode,\n\t\tgroupBy,\n\t\tactiveGroupTab,\n\t\tfilters,\n\t\tsortConfig,\n\t\thasMore,\n\t\tisLoading,\n\t\tloaderRef,\n\t\tgroupTabs,\n\t\tdataToRender,\n\t\ttotalItemCount,\n\t\tisInitialLoading,\n    setViewMode,\n    setGroupBy,\n    setActiveGroupTab,\n    setFilters,\n    setSort,\n    setTableSort\n\t};\n}"
  src/components/global/CommandPalette.tsx: >-
    import {
      CommandDialog,
      CommandEmpty,
      CommandGroup,
      CommandInput,
      CommandItem,
      CommandList,
      CommandSeparator,
      CommandShortcut,
    } from '@/components/ui/command';

    import { useNavigate, useSearchParams, useLocation } from
    'react-router-dom';

    import { useAppStore } from '@/store/appStore'

    import { useAppShell } from '@/context/AppShellContext'

    import { useCommandPaletteToggle } from
    '@/hooks/useCommandPaletteToggle.hook'

    import { Home, Settings, Moon, Sun, Monitor, Smartphone, PanelRight,
    Maximize, Component, Bell } from 'lucide-react'


    export function CommandPalette() {
      const { dispatch, toggleFullscreen } = useAppShell();
      const navigate = useNavigate();
      const [searchParams, setSearchParams] = useSearchParams();
      const location = useLocation();
      const {
        isCommandPaletteOpen,
        setCommandPaletteOpen,
        isDarkMode,
        toggleDarkMode,
      } = useAppStore()
      useCommandPaletteToggle()
      
      const runCommand = (command: () => void) => {
        setCommandPaletteOpen(false)
        command()
      }

      const handleOpenSidePane = (paneContent: 'settings') => {
        // This command is to open, not toggle, so we don't handle the close case.
        if (searchParams.get('sidePane') === paneContent) return;

        // Avoid content duplication
        if (location.pathname === `/${paneContent}`) {
          navigate({ pathname: '/dashboard', search: `?sidePane=${paneContent}` }, { replace: true });
        } else {
          const newParams = new URLSearchParams(searchParams);
          newParams.set('sidePane', paneContent);
          newParams.delete('view');
          newParams.delete('right');
          setSearchParams(newParams, { replace: true });
        }
      }

      return (
        <CommandDialog open={isCommandPaletteOpen} onOpenChange={setCommandPaletteOpen}>
          <CommandInput placeholder="Type a command or search..." />
          <CommandList>
            <CommandEmpty>No results found.</CommandEmpty>
            <CommandGroup heading="Navigation">
              <CommandItem onSelect={() => runCommand(() => navigate('/dashboard'))}>
                <Home className="mr-2 h-4 w-4" />
                <span>Go to Dashboard</span>
                <CommandShortcut>G D</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => navigate('/settings'))}>
                <Settings className="mr-2 h-4 w-4" />
                <span>Go to Settings</span>
                <CommandShortcut>G S</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => navigate('/toaster'))}>
                <Component className="mr-2 h-4 w-4" />
                <span>Go to Toaster Demo</span>
                <CommandShortcut>G T</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => navigate('/notifications'))}>
                <Bell className="mr-2 h-4 w-4" />
                <span>Go to Notifications</span>
                <CommandShortcut>G N</CommandShortcut>
              </CommandItem>
            </CommandGroup>
            <CommandSeparator />
            <CommandGroup heading="Actions">
              <CommandItem onSelect={() => runCommand(toggleDarkMode)}>
                {isDarkMode ? <Sun className="mr-2 h-4 w-4" /> : <Moon className="mr-2 h-4 w-4" />}
                <span>Toggle Theme</span>
                <CommandShortcut>⌘T</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(toggleFullscreen)}>
                <Maximize className="mr-2 h-4 w-4" />
                <span>Toggle Fullscreen</span>
                <CommandShortcut>⌘F</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => handleOpenSidePane('settings'))}>
                <PanelRight className="mr-2 h-4 w-4" />
                <span>Open Settings in Side Pane</span>
                <CommandShortcut>⌥S</CommandShortcut>
              </CommandItem>
            </CommandGroup>
            <CommandSeparator />
            <CommandGroup heading="Preferences">
              <CommandItem onSelect={() => runCommand(() => dispatch({ type: 'SET_COMPACT_MODE', payload: true }))}>
                <Smartphone className="mr-2 h-4 w-4" />
                <span>Enable Compact Mode</span>
                <CommandShortcut>⌘C</CommandShortcut>
              </CommandItem>
              <CommandItem onSelect={() => runCommand(() => dispatch({ type: 'SET_COMPACT_MODE', payload: false }))}>
                <Monitor className="mr-2 h-4 w-4" />
                <span>Disable Compact Mode</span>
                <CommandShortcut>⇧⌘C</CommandShortcut>
              </CommandItem>
            </CommandGroup>
          </CommandList>
        </CommandDialog>
      )
    }
  src/components/layout/EnhancedSidebar.tsx: >-
    import React from 'react';

    import {
      Home,
      Settings,
      HelpCircle,
      Component,
      Rocket,
      MoreHorizontal,
      Bell,
      Search,
      FileText,
      Star,
      Trash2,
      FolderOpen,
      Mail,
      Bookmark,
      Download,
      User,
      Plus,
      Database
    } from 'lucide-react';

    import { useLocation, useNavigate, useSearchParams } from
    'react-router-dom';

    import { type ActivePage } from '@/store/appStore';

    import { useAppShell } from '@/context/AppShellContext';

    import {
      Workspaces,
      WorkspaceTrigger,
      WorkspaceContent,
      type Workspace,
    } from './WorkspaceSwitcher';

    import {
      DropdownMenu,
      DropdownMenuContent,
      DropdownMenuItem,
      DropdownMenuTrigger,
    } from '@/components/ui/dropdown-menu';

    import {
      Sidebar,
      SidebarContent,
      SidebarHeader,
      SidebarTitle,
      SidebarBody,
      SidebarFooter,
      SidebarSection,
      SidebarMenuItem,
      SidebarMenuButton,
      SidebarMenuAction,
      SidebarLabel,
      SidebarBadge,
      SidebarTooltip,
      SidebarIcon,
      useSidebar,
    } from './Sidebar';

    import { ViewModeSwitcher } from './ViewModeSwitcher';

    import { cn } from '@/lib/utils';


    interface MyWorkspace extends Workspace {
      logo: string;
      plan: string;
    }


    const mockWorkspaces: MyWorkspace[] = [
      { id: 'ws1', name: 'Acme Inc.', logo: 'https://avatar.vercel.sh/acme.png', plan: 'Pro' },
      { id: 'ws2', name: 'Monsters Inc.', logo: 'https://avatar.vercel.sh/monsters.png', plan: 'Free' },
      { id: 'ws3', name: 'Stark Industries', logo: 'https://avatar.vercel.sh/stark.png', plan: 'Enterprise' },
    ];


    const SidebarWorkspaceTrigger = () => {
      const { isCollapsed, compactMode } = useSidebar();

      return (
        <WorkspaceTrigger
          collapsed={isCollapsed}
          className={cn(
            'rounded-xl transition-colors hover:bg-accent/50 w-full',
            isCollapsed ? 'p-2' : 'p-3 bg-accent/50',
          )}
          avatarClassName={cn(compactMode ? 'h-8 w-8' : 'h-10 w-10')}
        />
      );
    };


    interface SidebarProps {
      onMouseEnter?: () => void;
      onMouseLeave?: () => void;
    }


    export const EnhancedSidebar = React.forwardRef<HTMLDivElement,
    SidebarProps>(
      ({ onMouseEnter, onMouseLeave }, ref) => {
        const { sidebarWidth, compactMode, appName, appLogo } = useAppShell();
        const [selectedWorkspace, setSelectedWorkspace] = React.useState(mockWorkspaces[0]);

        return (
          <Sidebar
            ref={ref}
            style={{ width: sidebarWidth }}
            onMouseEnter={onMouseEnter}
            onMouseLeave={onMouseLeave}
          >
            <SidebarContent>
              <SidebarHeader>
                {appLogo || (
                  <div className="p-2 bg-primary/20 rounded-lg">
                    <Rocket className="w-5 h-5 text-primary" />
                  </div>
                )}
                <SidebarTitle>{appName}</SidebarTitle>
              </SidebarHeader>

              <SidebarBody>
                <SidebarSection title="Main">
                  <AppMenuItem icon={Home} label="Dashboard" page="dashboard" />
                  <AppMenuItem icon={Database} label="Data Demo" page="data-demo" />
                  <AppMenuItem icon={Search} label="Search" />
                  <AppMenuItem icon={Bell} label="Notifications" badge={3} page="notifications" opensInSidePane />
                </SidebarSection>
                
                <SidebarSection title="Workspace" collapsible defaultExpanded>
                  <AppMenuItem icon={FileText} label="Documents" hasActions>
                    <AppMenuItem icon={FileText} label="Recent" isSubItem />
                    <AppMenuItem icon={Star} label="Starred" isSubItem />
                    <AppMenuItem icon={Trash2} label="Trash" isSubItem />
                  </AppMenuItem>
                  <AppMenuItem icon={FolderOpen} label="Projects" hasActions />
                  <AppMenuItem icon={Mail} label="Messages" badge={12} />
                </SidebarSection>
                
                <SidebarSection title="Personal" collapsible>
                  <AppMenuItem icon={Bookmark} label="Bookmarks" />
                  <AppMenuItem icon={Star} label="Favorites" />
                  <AppMenuItem icon={Download} label="Downloads" />
                </SidebarSection>

                <SidebarSection title="Components" collapsible defaultExpanded>
                  <AppMenuItem icon={Component} label="Toaster" page="toaster" />
                </SidebarSection>
              </SidebarBody>

              <SidebarFooter>
                <SidebarSection>
                  <AppMenuItem icon={User} label="Profile" />
                  <AppMenuItem icon={Settings} label="Settings" page="settings" />
                  <AppMenuItem icon={HelpCircle} label="Help" />
                </SidebarSection>

                <div className={cn(compactMode ? 'mt-4' : 'mt-6')}>
                  <Workspaces
                    workspaces={mockWorkspaces}
                    selectedWorkspaceId={selectedWorkspace.id}
                    onWorkspaceChange={setSelectedWorkspace}
                  >
                    <SidebarWorkspaceTrigger />
                    <WorkspaceContent>
                      <button className="flex w-full items-center gap-2 rounded-sm px-2 py-2 text-left text-sm hover:bg-accent hover:text-accent-foreground focus:outline-none">
                        <Plus className="h-4 w-4" />
                        <span>Create Workspace</span>
                      </button>
                    </WorkspaceContent>
                  </Workspaces>
                </div>
              </SidebarFooter>
            </SidebarContent>
          </Sidebar>
        );
      },
    );

    EnhancedSidebar.displayName = 'EnhancedSidebar';



    // Example of a reusable menu item component built with the new Sidebar
    primitives

    interface AppMenuItemProps {
      icon: React.ElementType;
      label: string;
      badge?: number;
      hasActions?: boolean;
      children?: React.ReactNode;
      isSubItem?: boolean;
      page?: ActivePage;
      opensInSidePane?: boolean;
    }


    const AppMenuItem: React.FC<AppMenuItemProps> = ({ icon: Icon, label, badge,
    hasActions, children, isSubItem = false, page, opensInSidePane = false }) =>
    {
      const { compactMode, dispatch } = useAppShell()
      const { isCollapsed } = useSidebar();
      const navigate = useNavigate();
      const location = useLocation();
      const [searchParams, setSearchParams] = useSearchParams();

      const pageToPaneMap: { [key in ActivePage]?: 'main' | 'settings' | 'toaster' | 'notifications' | 'data-demo' } = {
        dashboard: 'main',
        settings: 'settings',
        toaster: 'toaster',
        notifications: 'notifications',
        'data-demo': 'data-demo',
      };
      const paneContentForPage = page ? pageToPaneMap[page] : undefined;

      const isActive = (
        (!opensInSidePane && page && location.pathname === `/${page}`)
      ) || (
        opensInSidePane && paneContentForPage && searchParams.get('sidePane') === paneContentForPage
      );

      const handleClick = () => {
        if (page) {
          if (opensInSidePane) {
            if (paneContentForPage) {
              setSearchParams(prev => {
                const newParams = new URLSearchParams(prev);
                const isCurrentlyInSidePane = newParams.get('sidePane') === paneContentForPage;

                if (isCurrentlyInSidePane) {
                  newParams.delete('sidePane');
                } else {
                  // If opening a side pane for a page that is the current main view,
                  // navigate main view to dashboard to avoid content duplication.
                  if (location.pathname === `/${page}`) {
                    navigate({ pathname: '/dashboard', search: `?sidePane=${paneContentForPage}` }, { replace: true });
                    return newParams; // Don't modify params when navigating
                  } else {
                    newParams.set('sidePane', paneContentForPage);
                    // When setting a side pane, always clear split view params to avoid invalid URL state
                    newParams.delete('view');
                    newParams.delete('right');
                  }
                }
                return newParams;
              }, { replace: true });
            }
          } else {
            navigate(`/${page}`);
          }
        }
      };

      return (
        <div className={isSubItem ? (compactMode ? 'ml-4' : 'ml-6') : ''}>
          <SidebarMenuItem>
            <SidebarMenuButton
              onClick={handleClick}
              isActive={isActive}
              draggable={!!page}
              onDragStart={(_e) => {
                if (page) {
                  // set dragged page in AppShell context
                  dispatch({ type: 'SET_DRAGGED_PAGE', payload: page });
                }
              }}
              onDragEnd={() => {
                dispatch({ type: 'SET_DRAGGED_PAGE', payload: null });
                dispatch({ type: 'SET_DRAG_HOVER_TARGET', payload: null });
              }}
            >
              <SidebarIcon>
                <Icon className={isSubItem ? "w-3 h-3" : "w-4 h-4"}/>
              </SidebarIcon>
              <SidebarLabel>{label}</SidebarLabel>
              {badge && <SidebarBadge>{badge}</SidebarBadge>}
              <SidebarTooltip label={label} badge={badge} />
            </SidebarMenuButton>

            {page && !isCollapsed && ( // Always render switcher if there's a page
              <div className={cn(
                "absolute top-1/2 -translate-y-1/2 z-10",
                "opacity-0 group-hover/item:opacity-100 group-focus-within/item:opacity-100",
                "transition-opacity pointer-events-none group-hover/item:pointer-events-auto",
                // If there are actions, move left to make space for the action button
                hasActions ? "right-10" : "right-2"
              )}>
                <ViewModeSwitcher targetPage={page} />
              </div>
            )}

            {hasActions && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <SidebarMenuAction>
                    <MoreHorizontal className="h-4 w-4" />
                  </SidebarMenuAction>
                </DropdownMenuTrigger>
                <DropdownMenuContent side="right" align="start">
                  <DropdownMenuItem>
                    <span>Edit {label}</span>
                  </DropdownMenuItem>
                  <DropdownMenuItem>
                    <span>Delete {label}</span>
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </SidebarMenuItem>
          {!isCollapsed && children && (
            <div className="space-y-1 mt-1">{children}</div>
          )}
        </div>
      );
    };
  src/components/layout/TopBar.tsx: >-
    import {
      Menu, 
      Moon, 
      Sun,
      Settings,
      Command,
      Zap,
    } from 'lucide-react'

    import { cn } from '@/lib/utils'

    import { useSearchParams, useLocation, useNavigate } from
    'react-router-dom';

    import { BODY_STATES } from '@/lib/utils'

    import { useAppStore } from '@/store/appStore'

    import { useAppShell } from '@/context/AppShellContext'

    import { UserDropdown } from './UserDropdown'

    import { ViewModeSwitcher } from './ViewModeSwitcher'


    interface TopBarProps {
      onToggleSidebar?: () => void
      onToggleDarkMode?: () => void
      children?: React.ReactNode
    }


    export function TopBar({
      onToggleSidebar,
      onToggleDarkMode,
      children,
    }: TopBarProps) {
      const { bodyState } = useAppShell()
      const [, setSearchParams] = useSearchParams();
      const location = useLocation();
      const navigate = useNavigate();
      const { 
        setCommandPaletteOpen,
        isDarkMode,
      } = useAppStore()

      const handleSettingsClick = () => {
        if (location.pathname === '/settings') {
          navigate({ pathname: '/dashboard', search: '?sidePane=settings' }, { replace: true });
        } else {
          setSearchParams(prev => {
            const newParams = new URLSearchParams(prev);
            if (newParams.get('sidePane') === 'settings') {
              newParams.delete('sidePane');
            } else {
              newParams.set('sidePane', 'settings');
              newParams.delete('view');
              newParams.delete('right');
            }
            return newParams;
          }, { replace: true });
        }
      };

      return (
        <div className={cn(
          "h-20 bg-background border-b border-border flex items-center justify-between px-6 z-50 gap-4"
        )}>
          {/* Left Section - Sidebar Controls & Breadcrumbs */}
          <div className="flex items-center gap-4">
            {/* Sidebar Controls */}
            <button
              onClick={() => onToggleSidebar?.()}
              className={cn(
                "h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors"
              )}
              title="Toggle Sidebar"
            >
              <Menu className="w-5 h-5" />
            </button>

          </div>

          {/* Right Section - page controls, and global controls */}
          <div className="flex items-center gap-3">
            {children}

            {/* Separator */}
            <div className="w-px h-6 bg-border mx-2" />

            {/* Quick Actions */}
            <div className="flex items-center gap-3">

              <button
                onClick={() => setCommandPaletteOpen(true)}
                className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
                title="Command Palette (Ctrl+K)"
              >
                <Command className="w-5 h-5 group-hover:scale-110 transition-transform" />
              </button>

            <button
              className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
              title="Quick Actions"
            >
              <Zap className="w-5 h-5 group-hover:scale-110 transition-transform" />
            </button>

            {bodyState !== BODY_STATES.SPLIT_VIEW && <ViewModeSwitcher />}

            <div className="w-px h-6 bg-border mx-2" />

            {/* Theme and Settings */}
            <button
              onClick={() => onToggleDarkMode?.()}
              className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
              title="Toggle Dark Mode"
            >
              {isDarkMode ? (
                <Sun className="w-5 h-5 group-hover:scale-110 transition-transform" />
              ) : (
                <Moon className="w-5 h-5 group-hover:scale-110 transition-transform" />
              )}
            </button>

            <button
              onClick={handleSettingsClick}
              className="h-10 w-10 flex items-center justify-center rounded-full hover:bg-accent transition-colors group"
              title="Settings"
            >
              <Settings className="w-5 h-5 group-hover:rotate-90 transition-transform duration-300" />
            </button>
            <UserDropdown />
            </div>
          </div>
        </div>
      )
    }
  src/components/layout/ViewModeSwitcher.tsx: >-
    import { useState, useRef, useEffect } from 'react';

    import { gsap } from 'gsap';

    import { useLocation, useNavigate, useSearchParams } from
    'react-router-dom';

    import { cn } from '@/lib/utils'

    import { useAppShell } from '@/context/AppShellContext'

    import { type ActivePage } from '@/store/appStore'

    import { BODY_STATES } from '@/lib/utils'

    import { type AppShellState } from '@/context/AppShellContext'

    import {
      Columns,
      PanelRightOpen,
      SplitSquareHorizontal,
      Maximize,
      Minimize,
      Layers,
      X,
      ArrowLeftRight
    } from 'lucide-react'


    const pageToPaneMap: Record<ActivePage, AppShellState['sidePaneContent']> =
    {
      dashboard: 'main',
      settings: 'settings',
      toaster: 'toaster',
      notifications: 'notifications',
      'data-demo': 'dataDemo',
    };


    export function ViewModeSwitcher({ pane, targetPage }: { pane?: 'main' |
    'right', targetPage?: ActivePage }) {
      const {
        bodyState,
        sidePaneContent,
        toggleFullscreen,
        fullscreenTarget,
      } = useAppShell()
      const location = useLocation();
      const navigate = useNavigate();
      const [, setSearchParams] = useSearchParams();
      const currentActivePage = (location.pathname.split('/')[1] || 'dashboard') as ActivePage;

      const activePage = targetPage || currentActivePage;
      const [isExpanded, setIsExpanded] = useState(false);
      const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);

      const isFullscreen = bodyState === BODY_STATES.FULLSCREEN;
      const isThisPaneFullscreen = isFullscreen && (
        (pane === 'main' && fullscreenTarget !== 'right') ||
        (pane === 'right' && fullscreenTarget === 'right') ||
        (!pane && !fullscreenTarget) // Global switcher, global fullscreen
      );

      useEffect(() => {
        const buttonsToAnimate = buttonRefs.current.filter(Boolean) as HTMLButtonElement[];
        if (buttonsToAnimate.length === 0) return;

        gsap.killTweensOf(buttonsToAnimate);

        if (isExpanded) {
            gsap.to(buttonsToAnimate, {
                width: 32, // h-8 w-8
                opacity: 1,
                pointerEvents: 'auto',
                marginLeft: 4, // from gap-1 in original
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'start'
                },
                ease: 'power2.out'
            });
        } else {
            gsap.to(buttonsToAnimate, {
                width: 0,
                opacity: 0,
                pointerEvents: 'none',
                marginLeft: 0,
                duration: 0.2,
                stagger: {
                    each: 0.05,
                    from: 'end'
                },
                ease: 'power2.in'
            });
        }
      }, [isExpanded, bodyState]); // re-run if bodyState changes to recalc buttons

      const handleSidePaneClick = () => {
        const paneContent = pageToPaneMap[activePage] || 'details';
        if (pane === 'right') return;

        const newSearchParams = new URLSearchParams(location.search);
        if (bodyState === BODY_STATES.SIDE_PANE && sidePaneContent === paneContent) {
          newSearchParams.delete('sidePane');
          newSearchParams.delete('view');
          newSearchParams.delete('right');
        } else {
          newSearchParams.set('sidePane', paneContent);
          newSearchParams.delete('view');
          newSearchParams.delete('right');
        }
        setSearchParams(newSearchParams, { replace: true });
      };
      
      const handleSplitViewClick = () => {
        const paneContent = pageToPaneMap[activePage] || 'details';
        if (pane === 'right') return;

        const newSearchParams = new URLSearchParams(location.search);
        if (bodyState === BODY_STATES.SPLIT_VIEW) {
            // from split to overlay
            newSearchParams.set('sidePane', sidePaneContent);
            newSearchParams.delete('view');
            newSearchParams.delete('right');
        } else {
            // from normal/overlay to split
            newSearchParams.set('view', 'split');
            newSearchParams.set('right', bodyState === BODY_STATES.SIDE_PANE ? sidePaneContent : paneContent);
            newSearchParams.delete('sidePane');
        }
        setSearchParams(newSearchParams, { replace: true });
      }

      const handleSwitchPanes = () => {
        if (bodyState !== BODY_STATES.SPLIT_VIEW) return;
        const newSidePaneContent = pageToPaneMap[currentActivePage];
        const newActivePage = Object.entries(pageToPaneMap).find(
          ([, value]) => value === sidePaneContent
        )?.[0] as ActivePage | undefined;

        if (newActivePage && newSidePaneContent) {
          navigate(`/${newActivePage}?view=split&right=${newSidePaneContent}`, { replace: true });
        }
      };

      const handleClosePane = () => {
        if (bodyState !== BODY_STATES.SPLIT_VIEW) return;
        if (pane === 'right') {
          setSearchParams({}, { replace: true });
        } else if (pane === 'main') {
          const pageToBecomeActive = Object.entries(pageToPaneMap).find(
            ([, value]) => value === sidePaneContent
          )?.[0] as ActivePage | undefined;
          
          if (pageToBecomeActive) {
            navigate(`/${pageToBecomeActive}`, { replace: true });
          } else {
            setSearchParams({}, { replace: true });
          }
        }
      }

      const handleNormalViewClick = () => {
        if (isFullscreen) {
          toggleFullscreen();
        }
        if (targetPage && targetPage !== currentActivePage) {
          navigate(`/${targetPage}`, { replace: true });
        }
          setSearchParams({}, { replace: true });
      }

      const buttons = [
        {
          id: 'normal',
          onClick: handleNormalViewClick,
          active: bodyState === BODY_STATES.NORMAL,
          title: "Normal View",
          icon: <Columns className="w-4 h-4" />
        },
        {
          id: 'side-pane',
          onClick: handleSidePaneClick,
          active: bodyState === BODY_STATES.SIDE_PANE,
          title: "Side Pane View",
          icon: <PanelRightOpen className="w-4 h-4" />
        },
        {
          id: 'split-view',
          onClick: handleSplitViewClick,
          active: bodyState === BODY_STATES.SPLIT_VIEW,
          title: bodyState === BODY_STATES.SPLIT_VIEW ? 'Switch to Overlay View' : 'Switch to Split View',
          icon: bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-4 h-4" /> : <SplitSquareHorizontal className="w-4 h-4" />
        },
        {
          id: 'fullscreen',
          onClick: () => {
            if (targetPage && targetPage !== currentActivePage ) {
              navigate(`/${targetPage}`);
              setTimeout(() => toggleFullscreen(pane), 50);
            } else {
              toggleFullscreen(pane);
            }
          },
          active: isThisPaneFullscreen,
          title: "Toggle Fullscreen",
          icon: isThisPaneFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />
        }
      ];

      if (bodyState === BODY_STATES.SPLIT_VIEW) {
        buttons.push({
          id: 'switch',
          onClick: handleSwitchPanes,
          active: false,
          title: "Switch Panes",
          icon: <ArrowLeftRight className="w-4 h-4" />
        });
        buttons.push({
          id: 'close',
          onClick: handleClosePane,
          active: false,
          title: "Close Pane",
          icon: <X className="w-4 h-4 text-muted-foreground group-hover:text-destructive" />
        });
      }

      return (
        <div
          onMouseEnter={() => setIsExpanded(true)}
          onMouseLeave={() => setIsExpanded(false)}
          className="flex items-center gap-0 p-1 bg-card rounded-full border border-border"
        >
            <button
                className='h-8 w-8 flex-shrink-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors'
                title="View Modes"
                onClick={() => setIsExpanded(!isExpanded)}
            >
                <Layers className="w-4 h-4" />
            </button>
          
          {buttons.map((btn, index) => (
            <button
              key={btn.id}
              ref={el => buttonRefs.current[index] = el}
              onClick={btn.onClick}
              className={cn(
                'h-8 w-0 flex items-center justify-center rounded-full hover:bg-accent transition-colors group opacity-0',
                btn.active && 'bg-accent text-accent-foreground',
                btn.id === 'close' && 'hover:bg-destructive/20'
              )}
              style={{ pointerEvents: 'none', marginLeft: 0, overflow: 'hidden' }}
              title={btn.title}
            >
              {btn.icon}
            </button>
          ))}
        </div>
      )
    }
  src/App.tsx: >-
    import React, { useEffect, useMemo, useCallback } from "react";

    import {
      createBrowserRouter,
      RouterProvider,
      Outlet,
      Navigate,
      useNavigate,
      useLocation,
      useParams,
      useSearchParams,
    } from "react-router-dom";


    import { AppShell } from "./components/layout/AppShell";

    import { AppShellProvider, useAppShell } from "./context/AppShellContext";

    import { useAppStore } from "./store/appStore";

    import { useAuthStore } from "./store/authStore";

    import "./index.css";


    // Import library components

    import { EnhancedSidebar } from "./components/layout/EnhancedSidebar";

    import { MainContent } from "./components/layout/MainContent";

    import { RightPane } from "./components/layout/RightPane";

    import { TopBar } from "./components/layout/TopBar";

    import { CommandPalette } from "./components/global/CommandPalette";

    import { ToasterProvider } from "./components/ui/toast";


    // --- Page/Content Components for Pages and Panes ---

    import { DashboardContent } from "./pages/Dashboard";

    import { SettingsPage } from "./pages/Settings";

    import { SettingsContent } from "./features/settings/SettingsContent";

    import { ToasterDemo } from "./pages/ToasterDemo";

    import { NotificationsPage } from "./pages/Notifications";

    import DataDemoPage from "./pages/DataDemo";

    import { DataDetailPanel } from
    "./pages/DataDemo/components/DataDetailPanel";

    import { mockDataItems } from "./pages/DataDemo/data/mockData";

    import { LoginPage } from "./components/auth/LoginPage";


    // --- Icons ---

    import {
      Search,
      Filter,
      Plus,
      ChevronRight,
      Rocket,
      LayoutDashboard,
      Settings,
      Component,
      Bell,
      SlidersHorizontal,
      ChevronsLeftRight,
      Layers,
      SplitSquareHorizontal,
      Database,
    } from "lucide-react";


    // --- Utils & Hooks ---

    import { cn, BODY_STATES } from "./lib/utils";

    import { useUrlStateSync } from "./hooks/useUrlStateSync.hook";


    // Wrapper for LoginPage to provide auth handlers

    function LoginPageWrapper() {
      const { login, forgotPassword } = useAuthStore();
      const navigate = useNavigate();
      const location = useLocation();
      const from = location.state?.from?.pathname + location.state?.from?.search || "/";

      const handleLogin = async (email: string, password: string) => {
        try {
          await login(email, password);
          navigate(from, { replace: true });
        } catch (error) {
          console.error("Login failed:", error);
          // In a real app, you'd show an error message to the user
        }
      };

      const handleForgotPassword = async (email: string) => {
        try {
          await forgotPassword(email);
        } catch (error) {
          console.error("Forgot password failed:", error);
        }
      };

      const handleSignUp = () => {
        // In a real app, navigate to sign up page
        console.log("Navigate to sign up page");
      };

      return (
        <LoginPage
          onLogin={handleLogin}
          onForgotPassword={handleForgotPassword}
          onSignUp={handleSignUp}
        />
      );
    }


    // Checks for authentication and redirects to login if needed

    function ProtectedRoute() {
      const { isAuthenticated } = useAuthStore();
      const location = useLocation();
      if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
      }
      return <Outlet />;
    }


    // A root component to apply global styles and effects

    function Root() {
      const isDarkMode = useAppStore((state) => state.isDarkMode);

      useEffect(() => {
        document.documentElement.classList.toggle("dark", isDarkMode);
      }, [isDarkMode]);

      return <Outlet />;
    }


    // The main layout for authenticated parts of the application

    function ProtectedLayout() {

      return (
        <div className="h-screen w-screen overflow-hidden bg-background">
          <AppShellProvider
            appName="Jeli App"
            appLogo={
              <div className="p-2 bg-primary/20 rounded-lg">
                <Rocket className="w-5 h-5 text-primary" />
              </div>
            }
          >
            <ComposedApp />
          </AppShellProvider>
        </div>
      );
    }


    // Content for the Top Bar (will be fully refactored in Part 2)

    function AppTopBar() {
      const { searchTerm, setSearchTerm } = useAppStore();
      const [isSearchFocused, setIsSearchFocused] = React.useState(false);
      const location = useLocation();
      const activePage = location.pathname.split('/').filter(Boolean).pop()?.replace('-', ' ') || 'dashboard';

      return (
        <div className="flex items-center gap-3 flex-1">
          <div
            className={cn(
              "hidden md:flex items-center gap-2 text-sm transition-opacity",
              {
                "opacity-0 pointer-events-none":
                  isSearchFocused && activePage === "dashboard",
              },
            )}
          >
            <a
              href="#"
              className="text-muted-foreground hover:text-foreground transition-colors"
            >
              Home
            </a>
            <ChevronRight className="w-4 h-4 text-muted-foreground" />
            <span className="font-medium text-foreground capitalize">
              {activePage}
            </span>
          </div>

          <div className="flex-1" />

          {/* Page-specific: Dashboard search and actions */}
          {activePage === "dashboard" && (
            <div className="flex items-center gap-2 flex-1 justify-end">
              <div
                className={cn(
                  "relative transition-all duration-300 ease-in-out",
                  isSearchFocused ? "flex-1 max-w-lg" : "w-auto",
                )}
              >
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4 pointer-events-none" />
                <input
                  type="text"
                  placeholder="Search..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  onFocus={() => setIsSearchFocused(true)}
                  onBlur={() => setIsSearchFocused(false)}
                  className={cn(
                    "pl-9 pr-4 py-2 h-10 border-none rounded-lg bg-card focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all duration-300 ease-in-out w-full",
                    isSearchFocused ? "bg-background" : "w-48",
                  )}
                />
              </div>
              <button className="h-10 w-10 flex-shrink-0 flex items-center justify-center hover:bg-accent rounded-full transition-colors">
                <Filter className="w-5 h-5" />
              </button>
              <button className="bg-primary text-primary-foreground px-4 py-2 rounded-full hover:bg-primary/90 transition-colors flex items-center gap-2 h-10 flex-shrink-0">
                <Plus className="w-5 h-5" />
                <span
                  className={cn(isSearchFocused ? "hidden sm:inline" : "inline")}
                >
                  New Project
                </span>
              </button>
            </div>
          )}
        </div>
      );
    }


    // The main App component that composes the shell

    function ComposedApp() {
      // --- State from Context & Router ---
      const { bodyState, sidePaneContent } = useAppShell();
      const navigate = useNavigate();
      const [searchParams, setSearchParams] = useSearchParams();
      const { itemId } = useParams<{ itemId: string }>();

      // --- Sync URL with App Shell State ---
      useUrlStateSync();

      // --- Content Mapping for Side/Right Panes ---
      const contentMap = useMemo(() => ({
        main: {
          title: "Dashboard",
          icon: LayoutDashboard,
          page: "dashboard",
          content: <DashboardContent isInSidePane />,
        },
        settings: {
          title: "Settings",
          icon: Settings,
          page: "settings",
          content: <div className="p-6"><SettingsContent /></div>
        },
        toaster: {
          title: "Toaster Demo",
          icon: Component,
          page: "toaster",
          content: <ToasterDemo isInSidePane />,
        },
        notifications: {
          title: "Notifications",
          icon: Bell,
          page: "notifications",
          content: <NotificationsPage isInSidePane />,
        },
        dataDemo: {
          title: "Data Showcase",
          icon: Database,
          page: "data-demo",
          content: <DataDemoPage />,
        },
        details: {
          title: "Details Panel",
          icon: SlidersHorizontal,
          content: (
            <div className="p-6">
              <p className="text-muted-foreground">
                This is the side pane. It can be used to display contextual
                information, forms, or actions related to the main content.
              </p>
            </div>
          ),
        },
      }), []);

      // --- Derived State for Content ---
      const selectedItem = useMemo(() => {
        if (!itemId) return null
        return mockDataItems.find(item => item.id === itemId) ?? null
      }, [itemId]);

      const { currentContent, rightPaneContent } = useMemo(() => {
        if (sidePaneContent === 'dataItem' && selectedItem) {
          return {
            currentContent: { title: "Item Details", icon: Database, page: `data-demo/${itemId}` },
            rightPaneContent: <DataDetailPanel item={selectedItem} onClose={() => navigate('/data-demo')} />,
          };
        }
        const mappedContent = contentMap[sidePaneContent as keyof typeof contentMap] || contentMap.details;
        return {
          currentContent: mappedContent,
          rightPaneContent: mappedContent.content,
        };
      }, [sidePaneContent, selectedItem, navigate, contentMap, itemId]);

      const CurrentIcon = currentContent.icon;

      // --- Callbacks for Right Pane Actions ---
      const handleMaximize = useCallback(() => {
        if ("page" in currentContent && currentContent.page) {
          navigate(`/${currentContent.page}`, { replace: true });
        } else {
          setSearchParams({}, { replace: true });
        }
      }, [currentContent, navigate, setSearchParams]);

      const handleCloseSidePane = useCallback(() => {
        if (itemId) {
          navigate('/data-demo');
        } else {
          setSearchParams(prev => {
            const newParams = new URLSearchParams(prev);
            newParams.delete('sidePane');
            newParams.delete('right');
            newParams.delete('view');
            return newParams;
          }, { replace: true });
        }
      }, [setSearchParams, itemId, navigate]);

      const handleToggleSplitView = useCallback(() => {
        if (bodyState === BODY_STATES.SIDE_PANE) {
          setSearchParams(prev => {
            const newParams = new URLSearchParams(prev);
            const currentPane = newParams.get('sidePane');
            if (currentPane) {
              newParams.set('view', 'split');
              newParams.set('right', currentPane);
              newParams.delete('sidePane');
            }
            return newParams;
          }, { replace: true });
        } else if (bodyState === BODY_STATES.SPLIT_VIEW) {
          setSearchParams(prev => {
            return { sidePane: prev.get('right') || 'details' }
          }, { replace: true });
        }
      }, [bodyState, setSearchParams]);

      // --- Right Pane Header UI ---
      const rightPaneHeader = useMemo(() => (
        <>
          {bodyState !== BODY_STATES.SPLIT_VIEW ? (
            <div className="flex items-center gap-2">
              <CurrentIcon className="w-5 h-5" />
              <h2 className="text-lg font-semibold whitespace-nowrap">
                {currentContent.title}
              </h2>
            </div>
          ) : <div />} {/* Placeholder to make justify-between work */}
          <div className="flex items-center">
            {(bodyState === BODY_STATES.SIDE_PANE || bodyState === BODY_STATES.SPLIT_VIEW) && (
              <button onClick={handleToggleSplitView} className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors" title={bodyState === BODY_STATES.SIDE_PANE ? "Switch to Split View" : "Switch to Overlay View"}>
                {bodyState === BODY_STATES.SPLIT_VIEW ? <Layers className="w-5 h-5" /> : <SplitSquareHorizontal className="w-5 h-5" />}
              </button>
            )}
            {bodyState !== BODY_STATES.SPLIT_VIEW && "page" in currentContent && currentContent.page && (
              <button onClick={handleMaximize} className="h-10 w-10 flex items-center justify-center hover:bg-accent rounded-full transition-colors mr-2" title="Move to Main View">
                <ChevronsLeftRight className="w-5 h-5" />
              </button>
            )}
          </div>
        </>
      ), [bodyState, currentContent, CurrentIcon, handleToggleSplitView, handleMaximize]);

      return (
        <AppShell
          sidebar={<EnhancedSidebar />}
          onOverlayClick={handleCloseSidePane}
          topBar={
            <TopBar>
              <AppTopBar />
            </TopBar>
          }
          mainContent={
            <MainContent>
              <Outlet />
            </MainContent>
          }
          rightPane={
            <RightPane onClose={handleCloseSidePane} header={rightPaneHeader}>
              {rightPaneContent}
            </RightPane>
          }
          commandPalette={<CommandPalette />}
        />
      );
    }


    function App() {
      const router = createBrowserRouter([
        {
          element: <Root />,
          children: [
            {
              path: "/login",
              element: <LoginPageWrapper />,
            },
            {
              path: "/",
              element: <ProtectedRoute />,
              children: [
                {
                  path: "/",
                  element: <ProtectedLayout />,
                  children: [
                    { index: true, element: <Navigate to="/dashboard" replace /> },
                    { path: "dashboard", element: <DashboardContent /> },
                    { path: "settings", element: <SettingsPage /> },
                    { path: "toaster", element: <ToasterDemo /> },
                    { path: "notifications", element: <NotificationsPage /> },
                    { path: "data-demo", element: <DataDemoPage /> },
                    { path: "data-demo/:itemId", element: <DataDemoPage /> },
                  ],
                },
              ],
            },
          ],
        },
      ]);

      return (
        <ToasterProvider>
          <RouterProvider router={router} />
        </ToasterProvider>
      );
    }


    export default App;
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-10-14T02:45:08.298Z'
status: committed
id: 271
